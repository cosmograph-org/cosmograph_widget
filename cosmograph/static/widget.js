var R_ = "http://www.w3.org/1999/xhtml";
const _2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: R_,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function ay(e) {
  var t = e += "", i = t.indexOf(":");
  return i >= 0 && (t = e.slice(0, i)) !== "xmlns" && (e = e.slice(i + 1)), _2.hasOwnProperty(t) ? { space: _2[t], local: e } : e;
}
function pF(e) {
  return function() {
    var t = this.ownerDocument, i = this.namespaceURI;
    return i === R_ && t.documentElement.namespaceURI === R_ ? t.createElement(e) : t.createElementNS(i, e);
  };
}
function mF(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function z3(e) {
  var t = ay(e);
  return (t.local ? mF : pF)(t);
}
function gF() {
}
function Jb(e) {
  return e == null ? gF : function() {
    return this.querySelector(e);
  };
}
function yF(e) {
  typeof e != "function" && (e = Jb(e));
  for (var t = this._groups, i = t.length, r = new Array(i), n = 0; n < i; ++n)
    for (var s = t[n], a = s.length, o = r[n] = new Array(a), c, l, d = 0; d < a; ++d)
      (c = s[d]) && (l = e.call(c, c.__data__, d, s)) && ("__data__" in c && (l.__data__ = c.__data__), o[d] = l);
  return new is(r, this._parents);
}
function vF(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function _F() {
  return [];
}
function U3(e) {
  return e == null ? _F : function() {
    return this.querySelectorAll(e);
  };
}
function bF(e) {
  return function() {
    return vF(e.apply(this, arguments));
  };
}
function xF(e) {
  typeof e == "function" ? e = bF(e) : e = U3(e);
  for (var t = this._groups, i = t.length, r = [], n = [], s = 0; s < i; ++s)
    for (var a = t[s], o = a.length, c, l = 0; l < o; ++l)
      (c = a[l]) && (r.push(e.call(c, c.__data__, l, a)), n.push(c));
  return new is(r, n);
}
function V3(e) {
  return function() {
    return this.matches(e);
  };
}
function j3(e) {
  return function(t) {
    return t.matches(e);
  };
}
var wF = Array.prototype.find;
function SF(e) {
  return function() {
    return wF.call(this.children, e);
  };
}
function IF() {
  return this.firstElementChild;
}
function AF(e) {
  return this.select(e == null ? IF : SF(typeof e == "function" ? e : j3(e)));
}
var TF = Array.prototype.filter;
function EF() {
  return Array.from(this.children);
}
function kF(e) {
  return function() {
    return TF.call(this.children, e);
  };
}
function CF(e) {
  return this.selectAll(e == null ? EF : kF(typeof e == "function" ? e : j3(e)));
}
function OF(e) {
  typeof e != "function" && (e = V3(e));
  for (var t = this._groups, i = t.length, r = new Array(i), n = 0; n < i; ++n)
    for (var s = t[n], a = s.length, o = r[n] = [], c, l = 0; l < a; ++l)
      (c = s[l]) && e.call(c, c.__data__, l, s) && o.push(c);
  return new is(r, this._parents);
}
function G3(e) {
  return new Array(e.length);
}
function DF() {
  return new is(this._enter || this._groups.map(G3), this._parents);
}
function Ig(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Ig.prototype = {
  constructor: Ig,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function NF(e) {
  return function() {
    return e;
  };
}
function LF(e, t, i, r, n, s) {
  for (var a = 0, o, c = t.length, l = s.length; a < l; ++a)
    (o = t[a]) ? (o.__data__ = s[a], r[a] = o) : i[a] = new Ig(e, s[a]);
  for (; a < c; ++a)
    (o = t[a]) && (n[a] = o);
}
function FF(e, t, i, r, n, s, a) {
  var o, c, l = /* @__PURE__ */ new Map(), d = t.length, u = s.length, h = new Array(d), p;
  for (o = 0; o < d; ++o)
    (c = t[o]) && (h[o] = p = a.call(c, c.__data__, o, t) + "", l.has(p) ? n[o] = c : l.set(p, c));
  for (o = 0; o < u; ++o)
    p = a.call(e, s[o], o, s) + "", (c = l.get(p)) ? (r[o] = c, c.__data__ = s[o], l.delete(p)) : i[o] = new Ig(e, s[o]);
  for (o = 0; o < d; ++o)
    (c = t[o]) && l.get(h[o]) === c && (n[o] = c);
}
function BF(e) {
  return e.__data__;
}
function RF(e, t) {
  if (!arguments.length)
    return Array.from(this, BF);
  var i = t ? FF : LF, r = this._parents, n = this._groups;
  typeof e != "function" && (e = NF(e));
  for (var s = n.length, a = new Array(s), o = new Array(s), c = new Array(s), l = 0; l < s; ++l) {
    var d = r[l], u = n[l], h = u.length, p = MF(e.call(d, d && d.__data__, l, r)), m = p.length, w = o[l] = new Array(m), C = a[l] = new Array(m), F = c[l] = new Array(h);
    i(d, u, w, C, F, p, t);
    for (var W = 0, et = 0, E, Z; W < m; ++W)
      if (E = w[W]) {
        for (W >= et && (et = W + 1); !(Z = C[et]) && ++et < m; )
          ;
        E._next = Z || null;
      }
  }
  return a = new is(a, r), a._enter = o, a._exit = c, a;
}
function MF(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function PF() {
  return new is(this._exit || this._groups.map(G3), this._parents);
}
function $F(e, t, i) {
  var r = this.enter(), n = this, s = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (n = t(n), n && (n = n.selection())), i == null ? s.remove() : i(s), r && n ? r.merge(n).order() : n;
}
function zF(e) {
  for (var t = e.selection ? e.selection() : e, i = this._groups, r = t._groups, n = i.length, s = r.length, a = Math.min(n, s), o = new Array(n), c = 0; c < a; ++c)
    for (var l = i[c], d = r[c], u = l.length, h = o[c] = new Array(u), p, m = 0; m < u; ++m)
      (p = l[m] || d[m]) && (h[m] = p);
  for (; c < n; ++c)
    o[c] = i[c];
  return new is(o, this._parents);
}
function UF() {
  for (var e = this._groups, t = -1, i = e.length; ++t < i; )
    for (var r = e[t], n = r.length - 1, s = r[n], a; --n >= 0; )
      (a = r[n]) && (s && a.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(a, s), s = a);
  return this;
}
function VF(e) {
  e || (e = jF);
  function t(u, h) {
    return u && h ? e(u.__data__, h.__data__) : !u - !h;
  }
  for (var i = this._groups, r = i.length, n = new Array(r), s = 0; s < r; ++s) {
    for (var a = i[s], o = a.length, c = n[s] = new Array(o), l, d = 0; d < o; ++d)
      (l = a[d]) && (c[d] = l);
    c.sort(t);
  }
  return new is(n, this._parents).order();
}
function jF(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function GF() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function HF() {
  return Array.from(this);
}
function WF() {
  for (var e = this._groups, t = 0, i = e.length; t < i; ++t)
    for (var r = e[t], n = 0, s = r.length; n < s; ++n) {
      var a = r[n];
      if (a)
        return a;
    }
  return null;
}
function YF() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function qF() {
  return !this.node();
}
function ZF(e) {
  for (var t = this._groups, i = 0, r = t.length; i < r; ++i)
    for (var n = t[i], s = 0, a = n.length, o; s < a; ++s)
      (o = n[s]) && e.call(o, o.__data__, s, n);
  return this;
}
function XF(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function KF(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function JF(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function QF(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function tB(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.removeAttribute(e) : this.setAttribute(e, i);
  };
}
function eB(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, i);
  };
}
function iB(e, t) {
  var i = ay(e);
  if (arguments.length < 2) {
    var r = this.node();
    return i.local ? r.getAttributeNS(i.space, i.local) : r.getAttribute(i);
  }
  return this.each((t == null ? i.local ? KF : XF : typeof t == "function" ? i.local ? eB : tB : i.local ? QF : JF)(i, t));
}
function H3(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function rB(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function nB(e, t, i) {
  return function() {
    this.style.setProperty(e, t, i);
  };
}
function sB(e, t, i) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, i);
  };
}
function aB(e, t, i) {
  return arguments.length > 1 ? this.each((t == null ? rB : typeof t == "function" ? sB : nB)(e, t, i ?? "")) : Su(this.node(), e);
}
function Su(e, t) {
  return e.style.getPropertyValue(t) || H3(e).getComputedStyle(e, null).getPropertyValue(t);
}
function oB(e) {
  return function() {
    delete this[e];
  };
}
function cB(e, t) {
  return function() {
    this[e] = t;
  };
}
function lB(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    i == null ? delete this[e] : this[e] = i;
  };
}
function dB(e, t) {
  return arguments.length > 1 ? this.each((t == null ? oB : typeof t == "function" ? lB : cB)(e, t)) : this.node()[e];
}
function W3(e) {
  return e.trim().split(/^|\s+/);
}
function Qb(e) {
  return e.classList || new Y3(e);
}
function Y3(e) {
  this._node = e, this._names = W3(e.getAttribute("class") || "");
}
Y3.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function q3(e, t) {
  for (var i = Qb(e), r = -1, n = t.length; ++r < n; )
    i.add(t[r]);
}
function Z3(e, t) {
  for (var i = Qb(e), r = -1, n = t.length; ++r < n; )
    i.remove(t[r]);
}
function uB(e) {
  return function() {
    q3(this, e);
  };
}
function hB(e) {
  return function() {
    Z3(this, e);
  };
}
function fB(e, t) {
  return function() {
    (t.apply(this, arguments) ? q3 : Z3)(this, e);
  };
}
function pB(e, t) {
  var i = W3(e + "");
  if (arguments.length < 2) {
    for (var r = Qb(this.node()), n = -1, s = i.length; ++n < s; )
      if (!r.contains(i[n]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? fB : t ? uB : hB)(i, t));
}
function mB() {
  this.textContent = "";
}
function gB(e) {
  return function() {
    this.textContent = e;
  };
}
function yB(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function vB(e) {
  return arguments.length ? this.each(e == null ? mB : (typeof e == "function" ? yB : gB)(e)) : this.node().textContent;
}
function _B() {
  this.innerHTML = "";
}
function bB(e) {
  return function() {
    this.innerHTML = e;
  };
}
function xB(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function wB(e) {
  return arguments.length ? this.each(e == null ? _B : (typeof e == "function" ? xB : bB)(e)) : this.node().innerHTML;
}
function SB() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function IB() {
  return this.each(SB);
}
function AB() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function TB() {
  return this.each(AB);
}
function EB(e) {
  var t = typeof e == "function" ? e : z3(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function kB() {
  return null;
}
function CB(e, t) {
  var i = typeof e == "function" ? e : z3(e), r = t == null ? kB : typeof t == "function" ? t : Jb(t);
  return this.select(function() {
    return this.insertBefore(i.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function OB() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function DB() {
  return this.each(OB);
}
function NB() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function LB() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function FB(e) {
  return this.select(e ? LB : NB);
}
function BB(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function RB(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function MB(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var i = "", r = t.indexOf(".");
    return r >= 0 && (i = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: i };
  });
}
function PB(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var i = 0, r = -1, n = t.length, s; i < n; ++i)
        s = t[i], (!e.type || s.type === e.type) && s.name === e.name ? this.removeEventListener(s.type, s.listener, s.options) : t[++r] = s;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function $B(e, t, i) {
  return function() {
    var r = this.__on, n, s = RB(t);
    if (r) {
      for (var a = 0, o = r.length; a < o; ++a)
        if ((n = r[a]).type === e.type && n.name === e.name) {
          this.removeEventListener(n.type, n.listener, n.options), this.addEventListener(n.type, n.listener = s, n.options = i), n.value = t;
          return;
        }
    }
    this.addEventListener(e.type, s, i), n = { type: e.type, name: e.name, value: t, listener: s, options: i }, r ? r.push(n) : this.__on = [n];
  };
}
function zB(e, t, i) {
  var r = MB(e + ""), n, s = r.length, a;
  if (arguments.length < 2) {
    var o = this.node().__on;
    if (o) {
      for (var c = 0, l = o.length, d; c < l; ++c)
        for (n = 0, d = o[c]; n < s; ++n)
          if ((a = r[n]).type === d.type && a.name === d.name)
            return d.value;
    }
    return;
  }
  for (o = t ? $B : PB, n = 0; n < s; ++n)
    this.each(o(r[n], t, i));
  return this;
}
function X3(e, t, i) {
  var r = H3(e), n = r.CustomEvent;
  typeof n == "function" ? n = new n(t, i) : (n = r.document.createEvent("Event"), i ? (n.initEvent(t, i.bubbles, i.cancelable), n.detail = i.detail) : n.initEvent(t, !1, !1)), e.dispatchEvent(n);
}
function UB(e, t) {
  return function() {
    return X3(this, e, t);
  };
}
function VB(e, t) {
  return function() {
    return X3(this, e, t.apply(this, arguments));
  };
}
function jB(e, t) {
  return this.each((typeof t == "function" ? VB : UB)(e, t));
}
function* GB() {
  for (var e = this._groups, t = 0, i = e.length; t < i; ++t)
    for (var r = e[t], n = 0, s = r.length, a; n < s; ++n)
      (a = r[n]) && (yield a);
}
var K3 = [null];
function is(e, t) {
  this._groups = e, this._parents = t;
}
function pp() {
  return new is([[document.documentElement]], K3);
}
function HB() {
  return this;
}
is.prototype = pp.prototype = {
  constructor: is,
  select: yF,
  selectAll: xF,
  selectChild: AF,
  selectChildren: CF,
  filter: OF,
  data: RF,
  enter: DF,
  exit: PF,
  join: $F,
  merge: zF,
  selection: HB,
  order: UF,
  sort: VF,
  call: GF,
  nodes: HF,
  node: WF,
  size: YF,
  empty: qF,
  each: ZF,
  attr: iB,
  style: aB,
  property: dB,
  classed: pB,
  text: vB,
  html: wB,
  raise: IB,
  lower: TB,
  append: EB,
  insert: CB,
  remove: DB,
  clone: FB,
  datum: BB,
  on: zB,
  dispatch: jB,
  [Symbol.iterator]: GB
};
function wa(e) {
  return typeof e == "string" ? new is([[document.querySelector(e)]], [document.documentElement]) : new is([[e]], K3);
}
function WB(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function cl(e, t) {
  if (e = WB(e), t === void 0 && (t = e.currentTarget), t) {
    var i = t.ownerSVGElement || t;
    if (i.createSVGPoint) {
      var r = i.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var n = t.getBoundingClientRect();
      return [e.clientX - n.left - t.clientLeft, e.clientY - n.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
var YB = { value: () => {
} };
function t1() {
  for (var e = 0, t = arguments.length, i = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in i || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    i[r] = [];
  }
  return new Wm(i);
}
function Wm(e) {
  this._ = e;
}
function qB(e, t) {
  return e.trim().split(/^|\s+/).map(function(i) {
    var r = "", n = i.indexOf(".");
    if (n >= 0 && (r = i.slice(n + 1), i = i.slice(0, n)), i && !t.hasOwnProperty(i))
      throw new Error("unknown type: " + i);
    return { type: i, name: r };
  });
}
Wm.prototype = t1.prototype = {
  constructor: Wm,
  on: function(e, t) {
    var i = this._, r = qB(e + "", i), n, s = -1, a = r.length;
    if (arguments.length < 2) {
      for (; ++s < a; )
        if ((n = (e = r[s]).type) && (n = ZB(i[n], e.name)))
          return n;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++s < a; )
      if (n = (e = r[s]).type)
        i[n] = b2(i[n], e.name, t);
      else if (t == null)
        for (n in i)
          i[n] = b2(i[n], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var i in t)
      e[i] = t[i].slice();
    return new Wm(e);
  },
  call: function(e, t) {
    if ((n = arguments.length - 2) > 0)
      for (var i = new Array(n), r = 0, n, s; r < n; ++r)
        i[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (s = this._[e], r = 0, n = s.length; r < n; ++r)
      s[r].value.apply(t, i);
  },
  apply: function(e, t, i) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], n = 0, s = r.length; n < s; ++n)
      r[n].value.apply(t, i);
  }
};
function ZB(e, t) {
  for (var i = 0, r = e.length, n; i < r; ++i)
    if ((n = e[i]).name === t)
      return n.value;
}
function b2(e, t, i) {
  for (var r = 0, n = e.length; r < n; ++r)
    if (e[r].name === t) {
      e[r] = YB, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return i != null && e.push({ name: t, value: i }), e;
}
var Iu = 0, Kh = 0, Lh = 0, J3 = 1e3, Ag, Jh, Tg = 0, Rl = 0, oy = 0, Ef = typeof performance == "object" && performance.now ? performance : Date, Q3 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function e1() {
  return Rl || (Q3(XB), Rl = Ef.now() + oy);
}
function XB() {
  Rl = 0;
}
function Eg() {
  this._call = this._time = this._next = null;
}
Eg.prototype = tT.prototype = {
  constructor: Eg,
  restart: function(e, t, i) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    i = (i == null ? e1() : +i) + (t == null ? 0 : +t), !this._next && Jh !== this && (Jh ? Jh._next = this : Ag = this, Jh = this), this._call = e, this._time = i, M_();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, M_());
  }
};
function tT(e, t, i) {
  var r = new Eg();
  return r.restart(e, t, i), r;
}
function KB() {
  e1(), ++Iu;
  for (var e = Ag, t; e; )
    (t = Rl - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Iu;
}
function x2() {
  Rl = (Tg = Ef.now()) + oy, Iu = Kh = 0;
  try {
    KB();
  } finally {
    Iu = 0, QB(), Rl = 0;
  }
}
function JB() {
  var e = Ef.now(), t = e - Tg;
  t > J3 && (oy -= t, Tg = e);
}
function QB() {
  for (var e, t = Ag, i, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (i = t._next, t._next = null, t = e ? e._next = i : Ag = i);
  Jh = e, M_(r);
}
function M_(e) {
  if (!Iu) {
    Kh && (Kh = clearTimeout(Kh));
    var t = e - Rl;
    t > 24 ? (e < 1 / 0 && (Kh = setTimeout(x2, e - Ef.now() - oy)), Lh && (Lh = clearInterval(Lh))) : (Lh || (Tg = Ef.now(), Lh = setInterval(JB, J3)), Iu = 1, Q3(x2));
  }
}
function w2(e, t, i) {
  var r = new Eg();
  return t = t == null ? 0 : +t, r.restart((n) => {
    r.stop(), e(n + t);
  }, t, i), r;
}
var tR = t1("start", "end", "cancel", "interrupt"), eR = [], eT = 0, S2 = 1, P_ = 2, Ym = 3, I2 = 4, $_ = 5, qm = 6;
function cy(e, t, i, r, n, s) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (i in a)
    return;
  iR(e, i, {
    name: t,
    index: r,
    // For context during callback.
    group: n,
    // For context during callback.
    on: tR,
    tween: eR,
    time: s.time,
    delay: s.delay,
    duration: s.duration,
    ease: s.ease,
    timer: null,
    state: eT
  });
}
function i1(e, t) {
  var i = na(e, t);
  if (i.state > eT)
    throw new Error("too late; already scheduled");
  return i;
}
function Ua(e, t) {
  var i = na(e, t);
  if (i.state > Ym)
    throw new Error("too late; already running");
  return i;
}
function na(e, t) {
  var i = e.__transition;
  if (!i || !(i = i[t]))
    throw new Error("transition not found");
  return i;
}
function iR(e, t, i) {
  var r = e.__transition, n;
  r[t] = i, i.timer = tT(s, 0, i.time);
  function s(l) {
    i.state = S2, i.timer.restart(a, i.delay, i.time), i.delay <= l && a(l - i.delay);
  }
  function a(l) {
    var d, u, h, p;
    if (i.state !== S2)
      return c();
    for (d in r)
      if (p = r[d], p.name === i.name) {
        if (p.state === Ym)
          return w2(a);
        p.state === I2 ? (p.state = qm, p.timer.stop(), p.on.call("interrupt", e, e.__data__, p.index, p.group), delete r[d]) : +d < t && (p.state = qm, p.timer.stop(), p.on.call("cancel", e, e.__data__, p.index, p.group), delete r[d]);
      }
    if (w2(function() {
      i.state === Ym && (i.state = I2, i.timer.restart(o, i.delay, i.time), o(l));
    }), i.state = P_, i.on.call("start", e, e.__data__, i.index, i.group), i.state === P_) {
      for (i.state = Ym, n = new Array(h = i.tween.length), d = 0, u = -1; d < h; ++d)
        (p = i.tween[d].value.call(e, e.__data__, i.index, i.group)) && (n[++u] = p);
      n.length = u + 1;
    }
  }
  function o(l) {
    for (var d = l < i.duration ? i.ease.call(null, l / i.duration) : (i.timer.restart(c), i.state = $_, 1), u = -1, h = n.length; ++u < h; )
      n[u].call(e, d);
    i.state === $_ && (i.on.call("end", e, e.__data__, i.index, i.group), c());
  }
  function c() {
    i.state = qm, i.timer.stop(), delete r[t];
    for (var l in r)
      return;
    delete e.__transition;
  }
}
function Zm(e, t) {
  var i = e.__transition, r, n, s = !0, a;
  if (i) {
    t = t == null ? null : t + "";
    for (a in i) {
      if ((r = i[a]).name !== t) {
        s = !1;
        continue;
      }
      n = r.state > P_ && r.state < $_, r.state = qm, r.timer.stop(), r.on.call(n ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete i[a];
    }
    s && delete e.__transition;
  }
}
function rR(e) {
  return this.each(function() {
    Zm(this, e);
  });
}
function r1(e, t, i) {
  e.prototype = t.prototype = i, i.constructor = e;
}
function iT(e, t) {
  var i = Object.create(e.prototype);
  for (var r in t)
    i[r] = t[r];
  return i;
}
function mp() {
}
var kf = 0.7, kg = 1 / kf, cu = "\\s*([+-]?\\d+)\\s*", Cf = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ca = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", nR = /^#([0-9a-f]{3,8})$/, sR = new RegExp(`^rgb\\(${cu},${cu},${cu}\\)$`), aR = new RegExp(`^rgb\\(${Ca},${Ca},${Ca}\\)$`), oR = new RegExp(`^rgba\\(${cu},${cu},${cu},${Cf}\\)$`), cR = new RegExp(`^rgba\\(${Ca},${Ca},${Ca},${Cf}\\)$`), lR = new RegExp(`^hsl\\(${Cf},${Ca},${Ca}\\)$`), dR = new RegExp(`^hsla\\(${Cf},${Ca},${Ca},${Cf}\\)$`), A2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
r1(mp, So, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: T2,
  // Deprecated! Use color.formatHex.
  formatHex: T2,
  formatHex8: uR,
  formatHsl: hR,
  formatRgb: E2,
  toString: E2
});
function T2() {
  return this.rgb().formatHex();
}
function uR() {
  return this.rgb().formatHex8();
}
function hR() {
  return rT(this).formatHsl();
}
function E2() {
  return this.rgb().formatRgb();
}
function So(e) {
  var t, i;
  return e = (e + "").trim().toLowerCase(), (t = nR.exec(e)) ? (i = t[1].length, t = parseInt(t[1], 16), i === 6 ? k2(t) : i === 3 ? new zn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : i === 8 ? Em(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : i === 4 ? Em(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = sR.exec(e)) ? new zn(t[1], t[2], t[3], 1) : (t = aR.exec(e)) ? new zn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = oR.exec(e)) ? Em(t[1], t[2], t[3], t[4]) : (t = cR.exec(e)) ? Em(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = lR.exec(e)) ? D2(t[1], t[2] / 100, t[3] / 100, 1) : (t = dR.exec(e)) ? D2(t[1], t[2] / 100, t[3] / 100, t[4]) : A2.hasOwnProperty(e) ? k2(A2[e]) : e === "transparent" ? new zn(NaN, NaN, NaN, 0) : null;
}
function k2(e) {
  return new zn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Em(e, t, i, r) {
  return r <= 0 && (e = t = i = NaN), new zn(e, t, i, r);
}
function fR(e) {
  return e instanceof mp || (e = So(e)), e ? (e = e.rgb(), new zn(e.r, e.g, e.b, e.opacity)) : new zn();
}
function z_(e, t, i, r) {
  return arguments.length === 1 ? fR(e) : new zn(e, t, i, r ?? 1);
}
function zn(e, t, i, r) {
  this.r = +e, this.g = +t, this.b = +i, this.opacity = +r;
}
r1(zn, z_, iT(mp, {
  brighter(e) {
    return e = e == null ? kg : Math.pow(kg, e), new zn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? kf : Math.pow(kf, e), new zn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new zn(Ll(this.r), Ll(this.g), Ll(this.b), Cg(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: C2,
  // Deprecated! Use color.formatHex.
  formatHex: C2,
  formatHex8: pR,
  formatRgb: O2,
  toString: O2
}));
function C2() {
  return `#${Cl(this.r)}${Cl(this.g)}${Cl(this.b)}`;
}
function pR() {
  return `#${Cl(this.r)}${Cl(this.g)}${Cl(this.b)}${Cl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function O2() {
  const e = Cg(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ll(this.r)}, ${Ll(this.g)}, ${Ll(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Cg(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ll(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Cl(e) {
  return e = Ll(e), (e < 16 ? "0" : "") + e.toString(16);
}
function D2(e, t, i, r) {
  return r <= 0 ? e = t = i = NaN : i <= 0 || i >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new zs(e, t, i, r);
}
function rT(e) {
  if (e instanceof zs)
    return new zs(e.h, e.s, e.l, e.opacity);
  if (e instanceof mp || (e = So(e)), !e)
    return new zs();
  if (e instanceof zs)
    return e;
  e = e.rgb();
  var t = e.r / 255, i = e.g / 255, r = e.b / 255, n = Math.min(t, i, r), s = Math.max(t, i, r), a = NaN, o = s - n, c = (s + n) / 2;
  return o ? (t === s ? a = (i - r) / o + (i < r) * 6 : i === s ? a = (r - t) / o + 2 : a = (t - i) / o + 4, o /= c < 0.5 ? s + n : 2 - s - n, a *= 60) : o = c > 0 && c < 1 ? 0 : a, new zs(a, o, c, e.opacity);
}
function mR(e, t, i, r) {
  return arguments.length === 1 ? rT(e) : new zs(e, t, i, r ?? 1);
}
function zs(e, t, i, r) {
  this.h = +e, this.s = +t, this.l = +i, this.opacity = +r;
}
r1(zs, mR, iT(mp, {
  brighter(e) {
    return e = e == null ? kg : Math.pow(kg, e), new zs(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? kf : Math.pow(kf, e), new zs(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, i = this.l, r = i + (i < 0.5 ? i : 1 - i) * t, n = 2 * i - r;
    return new zn(
      Wv(e >= 240 ? e - 240 : e + 120, n, r),
      Wv(e, n, r),
      Wv(e < 120 ? e + 240 : e - 120, n, r),
      this.opacity
    );
  },
  clamp() {
    return new zs(N2(this.h), km(this.s), km(this.l), Cg(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Cg(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${N2(this.h)}, ${km(this.s) * 100}%, ${km(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function N2(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function km(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Wv(e, t, i) {
  return (e < 60 ? t + (i - t) * e / 60 : e < 180 ? i : e < 240 ? t + (i - t) * (240 - e) / 60 : t) * 255;
}
const n1 = (e) => () => e;
function gR(e, t) {
  return function(i) {
    return e + i * t;
  };
}
function yR(e, t, i) {
  return e = Math.pow(e, i), t = Math.pow(t, i) - e, i = 1 / i, function(r) {
    return Math.pow(e + r * t, i);
  };
}
function vR(e) {
  return (e = +e) == 1 ? nT : function(t, i) {
    return i - t ? yR(t, i, e) : n1(isNaN(t) ? i : t);
  };
}
function nT(e, t) {
  var i = t - e;
  return i ? gR(e, i) : n1(isNaN(e) ? t : e);
}
const Og = function e(t) {
  var i = vR(t);
  function r(n, s) {
    var a = i((n = z_(n)).r, (s = z_(s)).r), o = i(n.g, s.g), c = i(n.b, s.b), l = nT(n.opacity, s.opacity);
    return function(d) {
      return n.r = a(d), n.g = o(d), n.b = c(d), n.opacity = l(d), n + "";
    };
  }
  return r.gamma = e, r;
}(1);
function _R(e, t) {
  t || (t = []);
  var i = e ? Math.min(t.length, e.length) : 0, r = t.slice(), n;
  return function(s) {
    for (n = 0; n < i; ++n)
      r[n] = e[n] * (1 - s) + t[n] * s;
    return r;
  };
}
function bR(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function xR(e, t) {
  var i = t ? t.length : 0, r = e ? Math.min(i, e.length) : 0, n = new Array(r), s = new Array(i), a;
  for (a = 0; a < r; ++a)
    n[a] = s1(e[a], t[a]);
  for (; a < i; ++a)
    s[a] = t[a];
  return function(o) {
    for (a = 0; a < r; ++a)
      s[a] = n[a](o);
    return s;
  };
}
function wR(e, t) {
  var i = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return i.setTime(e * (1 - r) + t * r), i;
  };
}
function Ps(e, t) {
  return e = +e, t = +t, function(i) {
    return e * (1 - i) + t * i;
  };
}
function SR(e, t) {
  var i = {}, r = {}, n;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (n in t)
    n in e ? i[n] = s1(e[n], t[n]) : r[n] = t[n];
  return function(s) {
    for (n in i)
      r[n] = i[n](s);
    return r;
  };
}
var U_ = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Yv = new RegExp(U_.source, "g");
function IR(e) {
  return function() {
    return e;
  };
}
function AR(e) {
  return function(t) {
    return e(t) + "";
  };
}
function sT(e, t) {
  var i = U_.lastIndex = Yv.lastIndex = 0, r, n, s, a = -1, o = [], c = [];
  for (e = e + "", t = t + ""; (r = U_.exec(e)) && (n = Yv.exec(t)); )
    (s = n.index) > i && (s = t.slice(i, s), o[a] ? o[a] += s : o[++a] = s), (r = r[0]) === (n = n[0]) ? o[a] ? o[a] += n : o[++a] = n : (o[++a] = null, c.push({ i: a, x: Ps(r, n) })), i = Yv.lastIndex;
  return i < t.length && (s = t.slice(i), o[a] ? o[a] += s : o[++a] = s), o.length < 2 ? c[0] ? AR(c[0].x) : IR(t) : (t = c.length, function(l) {
    for (var d = 0, u; d < t; ++d)
      o[(u = c[d]).i] = u.x(l);
    return o.join("");
  });
}
function s1(e, t) {
  var i = typeof t, r;
  return t == null || i === "boolean" ? n1(t) : (i === "number" ? Ps : i === "string" ? (r = So(t)) ? (t = r, Og) : sT : t instanceof So ? Og : t instanceof Date ? wR : bR(t) ? _R : Array.isArray(t) ? xR : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? SR : Ps)(e, t);
}
function TR(e, t) {
  return e = +e, t = +t, function(i) {
    return Math.round(e * (1 - i) + t * i);
  };
}
var L2 = 180 / Math.PI, V_ = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function aT(e, t, i, r, n, s) {
  var a, o, c;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (c = e * i + t * r) && (i -= e * c, r -= t * c), (o = Math.sqrt(i * i + r * r)) && (i /= o, r /= o, c /= o), e * r < t * i && (e = -e, t = -t, c = -c, a = -a), {
    translateX: n,
    translateY: s,
    rotate: Math.atan2(t, e) * L2,
    skewX: Math.atan(c) * L2,
    scaleX: a,
    scaleY: o
  };
}
var Cm;
function ER(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? V_ : aT(t.a, t.b, t.c, t.d, t.e, t.f);
}
function kR(e) {
  return e == null || (Cm || (Cm = document.createElementNS("http://www.w3.org/2000/svg", "g")), Cm.setAttribute("transform", e), !(e = Cm.transform.baseVal.consolidate())) ? V_ : (e = e.matrix, aT(e.a, e.b, e.c, e.d, e.e, e.f));
}
function oT(e, t, i, r) {
  function n(l) {
    return l.length ? l.pop() + " " : "";
  }
  function s(l, d, u, h, p, m) {
    if (l !== u || d !== h) {
      var w = p.push("translate(", null, t, null, i);
      m.push({ i: w - 4, x: Ps(l, u) }, { i: w - 2, x: Ps(d, h) });
    } else
      (u || h) && p.push("translate(" + u + t + h + i);
  }
  function a(l, d, u, h) {
    l !== d ? (l - d > 180 ? d += 360 : d - l > 180 && (l += 360), h.push({ i: u.push(n(u) + "rotate(", null, r) - 2, x: Ps(l, d) })) : d && u.push(n(u) + "rotate(" + d + r);
  }
  function o(l, d, u, h) {
    l !== d ? h.push({ i: u.push(n(u) + "skewX(", null, r) - 2, x: Ps(l, d) }) : d && u.push(n(u) + "skewX(" + d + r);
  }
  function c(l, d, u, h, p, m) {
    if (l !== u || d !== h) {
      var w = p.push(n(p) + "scale(", null, ",", null, ")");
      m.push({ i: w - 4, x: Ps(l, u) }, { i: w - 2, x: Ps(d, h) });
    } else
      (u !== 1 || h !== 1) && p.push(n(p) + "scale(" + u + "," + h + ")");
  }
  return function(l, d) {
    var u = [], h = [];
    return l = e(l), d = e(d), s(l.translateX, l.translateY, d.translateX, d.translateY, u, h), a(l.rotate, d.rotate, u, h), o(l.skewX, d.skewX, u, h), c(l.scaleX, l.scaleY, d.scaleX, d.scaleY, u, h), l = d = null, function(p) {
      for (var m = -1, w = h.length, C; ++m < w; )
        u[(C = h[m]).i] = C.x(p);
      return u.join("");
    };
  };
}
var CR = oT(ER, "px, ", "px)", "deg)"), OR = oT(kR, ", ", ")", ")"), DR = 1e-12;
function F2(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function NR(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function LR(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const FR = function e(t, i, r) {
  function n(s, a) {
    var o = s[0], c = s[1], l = s[2], d = a[0], u = a[1], h = a[2], p = d - o, m = u - c, w = p * p + m * m, C, F;
    if (w < DR)
      F = Math.log(h / l) / t, C = function(bt) {
        return [
          o + bt * p,
          c + bt * m,
          l * Math.exp(t * bt * F)
        ];
      };
    else {
      var W = Math.sqrt(w), et = (h * h - l * l + r * w) / (2 * l * i * W), E = (h * h - l * l - r * w) / (2 * h * i * W), Z = Math.log(Math.sqrt(et * et + 1) - et), yt = Math.log(Math.sqrt(E * E + 1) - E);
      F = (yt - Z) / t, C = function(bt) {
        var Ct = bt * F, Mt = F2(Z), Me = l / (i * W) * (Mt * LR(t * Ct + Z) - NR(Z));
        return [
          o + Me * p,
          c + Me * m,
          l * Mt / F2(t * Ct + Z)
        ];
      };
    }
    return C.duration = F * 1e3 * t / Math.SQRT2, C;
  }
  return n.rho = function(s) {
    var a = Math.max(1e-3, +s), o = a * a, c = o * o;
    return e(a, o, c);
  }, n;
}(Math.SQRT2, 2, 4);
function BR(e, t) {
  var i, r;
  return function() {
    var n = Ua(this, e), s = n.tween;
    if (s !== i) {
      r = i = s;
      for (var a = 0, o = r.length; a < o; ++a)
        if (r[a].name === t) {
          r = r.slice(), r.splice(a, 1);
          break;
        }
    }
    n.tween = r;
  };
}
function RR(e, t, i) {
  var r, n;
  if (typeof i != "function")
    throw new Error();
  return function() {
    var s = Ua(this, e), a = s.tween;
    if (a !== r) {
      n = (r = a).slice();
      for (var o = { name: t, value: i }, c = 0, l = n.length; c < l; ++c)
        if (n[c].name === t) {
          n[c] = o;
          break;
        }
      c === l && n.push(o);
    }
    s.tween = n;
  };
}
function MR(e, t) {
  var i = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = na(this.node(), i).tween, n = 0, s = r.length, a; n < s; ++n)
      if ((a = r[n]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? BR : RR)(i, e, t));
}
function a1(e, t, i) {
  var r = e._id;
  return e.each(function() {
    var n = Ua(this, r);
    (n.value || (n.value = {}))[t] = i.apply(this, arguments);
  }), function(n) {
    return na(n, r).value[t];
  };
}
function cT(e, t) {
  var i;
  return (typeof t == "number" ? Ps : t instanceof So ? Og : (i = So(t)) ? (t = i, Og) : sT)(e, t);
}
function PR(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function $R(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function zR(e, t, i) {
  var r, n = i + "", s;
  return function() {
    var a = this.getAttribute(e);
    return a === n ? null : a === r ? s : s = t(r = a, i);
  };
}
function UR(e, t, i) {
  var r, n = i + "", s;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === n ? null : a === r ? s : s = t(r = a, i);
  };
}
function VR(e, t, i) {
  var r, n, s;
  return function() {
    var a, o = i(this), c;
    return o == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), c = o + "", a === c ? null : a === r && c === n ? s : (n = c, s = t(r = a, o)));
  };
}
function jR(e, t, i) {
  var r, n, s;
  return function() {
    var a, o = i(this), c;
    return o == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), c = o + "", a === c ? null : a === r && c === n ? s : (n = c, s = t(r = a, o)));
  };
}
function GR(e, t) {
  var i = ay(e), r = i === "transform" ? OR : cT;
  return this.attrTween(e, typeof t == "function" ? (i.local ? jR : VR)(i, r, a1(this, "attr." + e, t)) : t == null ? (i.local ? $R : PR)(i) : (i.local ? UR : zR)(i, r, t));
}
function HR(e, t) {
  return function(i) {
    this.setAttribute(e, t.call(this, i));
  };
}
function WR(e, t) {
  return function(i) {
    this.setAttributeNS(e.space, e.local, t.call(this, i));
  };
}
function YR(e, t) {
  var i, r;
  function n() {
    var s = t.apply(this, arguments);
    return s !== r && (i = (r = s) && WR(e, s)), i;
  }
  return n._value = t, n;
}
function qR(e, t) {
  var i, r;
  function n() {
    var s = t.apply(this, arguments);
    return s !== r && (i = (r = s) && HR(e, s)), i;
  }
  return n._value = t, n;
}
function ZR(e, t) {
  var i = "attr." + e;
  if (arguments.length < 2)
    return (i = this.tween(i)) && i._value;
  if (t == null)
    return this.tween(i, null);
  if (typeof t != "function")
    throw new Error();
  var r = ay(e);
  return this.tween(i, (r.local ? YR : qR)(r, t));
}
function XR(e, t) {
  return function() {
    i1(this, e).delay = +t.apply(this, arguments);
  };
}
function KR(e, t) {
  return t = +t, function() {
    i1(this, e).delay = t;
  };
}
function JR(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? XR : KR)(t, e)) : na(this.node(), t).delay;
}
function QR(e, t) {
  return function() {
    Ua(this, e).duration = +t.apply(this, arguments);
  };
}
function tM(e, t) {
  return t = +t, function() {
    Ua(this, e).duration = t;
  };
}
function eM(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? QR : tM)(t, e)) : na(this.node(), t).duration;
}
function iM(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Ua(this, e).ease = t;
  };
}
function rM(e) {
  var t = this._id;
  return arguments.length ? this.each(iM(t, e)) : na(this.node(), t).ease;
}
function nM(e, t) {
  return function() {
    var i = t.apply(this, arguments);
    if (typeof i != "function")
      throw new Error();
    Ua(this, e).ease = i;
  };
}
function sM(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(nM(this._id, e));
}
function aM(e) {
  typeof e != "function" && (e = V3(e));
  for (var t = this._groups, i = t.length, r = new Array(i), n = 0; n < i; ++n)
    for (var s = t[n], a = s.length, o = r[n] = [], c, l = 0; l < a; ++l)
      (c = s[l]) && e.call(c, c.__data__, l, s) && o.push(c);
  return new Io(r, this._parents, this._name, this._id);
}
function oM(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, i = e._groups, r = t.length, n = i.length, s = Math.min(r, n), a = new Array(r), o = 0; o < s; ++o)
    for (var c = t[o], l = i[o], d = c.length, u = a[o] = new Array(d), h, p = 0; p < d; ++p)
      (h = c[p] || l[p]) && (u[p] = h);
  for (; o < r; ++o)
    a[o] = t[o];
  return new Io(a, this._parents, this._name, this._id);
}
function cM(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    return i >= 0 && (t = t.slice(0, i)), !t || t === "start";
  });
}
function lM(e, t, i) {
  var r, n, s = cM(t) ? i1 : Ua;
  return function() {
    var a = s(this, e), o = a.on;
    o !== r && (n = (r = o).copy()).on(t, i), a.on = n;
  };
}
function dM(e, t) {
  var i = this._id;
  return arguments.length < 2 ? na(this.node(), i).on.on(e) : this.each(lM(i, e, t));
}
function uM(e) {
  return function() {
    var t = this.parentNode;
    for (var i in this.__transition)
      if (+i !== e)
        return;
    t && t.removeChild(this);
  };
}
function hM() {
  return this.on("end.remove", uM(this._id));
}
function fM(e) {
  var t = this._name, i = this._id;
  typeof e != "function" && (e = Jb(e));
  for (var r = this._groups, n = r.length, s = new Array(n), a = 0; a < n; ++a)
    for (var o = r[a], c = o.length, l = s[a] = new Array(c), d, u, h = 0; h < c; ++h)
      (d = o[h]) && (u = e.call(d, d.__data__, h, o)) && ("__data__" in d && (u.__data__ = d.__data__), l[h] = u, cy(l[h], t, i, h, l, na(d, i)));
  return new Io(s, this._parents, t, i);
}
function pM(e) {
  var t = this._name, i = this._id;
  typeof e != "function" && (e = U3(e));
  for (var r = this._groups, n = r.length, s = [], a = [], o = 0; o < n; ++o)
    for (var c = r[o], l = c.length, d, u = 0; u < l; ++u)
      if (d = c[u]) {
        for (var h = e.call(d, d.__data__, u, c), p, m = na(d, i), w = 0, C = h.length; w < C; ++w)
          (p = h[w]) && cy(p, t, i, w, h, m);
        s.push(h), a.push(d);
      }
  return new Io(s, a, t, i);
}
var mM = pp.prototype.constructor;
function gM() {
  return new mM(this._groups, this._parents);
}
function yM(e, t) {
  var i, r, n;
  return function() {
    var s = Su(this, e), a = (this.style.removeProperty(e), Su(this, e));
    return s === a ? null : s === i && a === r ? n : n = t(i = s, r = a);
  };
}
function lT(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function vM(e, t, i) {
  var r, n = i + "", s;
  return function() {
    var a = Su(this, e);
    return a === n ? null : a === r ? s : s = t(r = a, i);
  };
}
function _M(e, t, i) {
  var r, n, s;
  return function() {
    var a = Su(this, e), o = i(this), c = o + "";
    return o == null && (c = o = (this.style.removeProperty(e), Su(this, e))), a === c ? null : a === r && c === n ? s : (n = c, s = t(r = a, o));
  };
}
function bM(e, t) {
  var i, r, n, s = "style." + t, a = "end." + s, o;
  return function() {
    var c = Ua(this, e), l = c.on, d = c.value[s] == null ? o || (o = lT(t)) : void 0;
    (l !== i || n !== d) && (r = (i = l).copy()).on(a, n = d), c.on = r;
  };
}
function xM(e, t, i) {
  var r = (e += "") == "transform" ? CR : cT;
  return t == null ? this.styleTween(e, yM(e, r)).on("end.style." + e, lT(e)) : typeof t == "function" ? this.styleTween(e, _M(e, r, a1(this, "style." + e, t))).each(bM(this._id, e)) : this.styleTween(e, vM(e, r, t), i).on("end.style." + e, null);
}
function wM(e, t, i) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), i);
  };
}
function SM(e, t, i) {
  var r, n;
  function s() {
    var a = t.apply(this, arguments);
    return a !== n && (r = (n = a) && wM(e, a, i)), r;
  }
  return s._value = t, s;
}
function IM(e, t, i) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, SM(e, t, i ?? ""));
}
function AM(e) {
  return function() {
    this.textContent = e;
  };
}
function TM(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function EM(e) {
  return this.tween("text", typeof e == "function" ? TM(a1(this, "text", e)) : AM(e == null ? "" : e + ""));
}
function kM(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function CM(e) {
  var t, i;
  function r() {
    var n = e.apply(this, arguments);
    return n !== i && (t = (i = n) && kM(n)), t;
  }
  return r._value = e, r;
}
function OM(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, CM(e));
}
function DM() {
  for (var e = this._name, t = this._id, i = dT(), r = this._groups, n = r.length, s = 0; s < n; ++s)
    for (var a = r[s], o = a.length, c, l = 0; l < o; ++l)
      if (c = a[l]) {
        var d = na(c, t);
        cy(c, e, i, l, a, {
          time: d.time + d.delay + d.duration,
          delay: 0,
          duration: d.duration,
          ease: d.ease
        });
      }
  return new Io(r, this._parents, e, i);
}
function NM() {
  var e, t, i = this, r = i._id, n = i.size();
  return new Promise(function(s, a) {
    var o = { value: a }, c = { value: function() {
      --n === 0 && s();
    } };
    i.each(function() {
      var l = Ua(this, r), d = l.on;
      d !== e && (t = (e = d).copy(), t._.cancel.push(o), t._.interrupt.push(o), t._.end.push(c)), l.on = t;
    }), n === 0 && s();
  });
}
var LM = 0;
function Io(e, t, i, r) {
  this._groups = e, this._parents = t, this._name = i, this._id = r;
}
function dT() {
  return ++LM;
}
var to = pp.prototype;
Io.prototype = {
  constructor: Io,
  select: fM,
  selectAll: pM,
  selectChild: to.selectChild,
  selectChildren: to.selectChildren,
  filter: aM,
  merge: oM,
  selection: gM,
  transition: DM,
  call: to.call,
  nodes: to.nodes,
  node: to.node,
  size: to.size,
  empty: to.empty,
  each: to.each,
  on: dM,
  attr: GR,
  attrTween: ZR,
  style: xM,
  styleTween: IM,
  text: EM,
  textTween: OM,
  remove: hM,
  tween: MR,
  delay: JR,
  duration: eM,
  ease: rM,
  easeVarying: sM,
  end: NM,
  [Symbol.iterator]: to[Symbol.iterator]
};
function FM(e) {
  return e * e;
}
function BM(e) {
  return e * (2 - e);
}
function RM(e) {
  return ((e *= 2) <= 1 ? e * e : --e * (2 - e) + 1) / 2;
}
function MM(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var PM = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: MM
};
function $M(e, t) {
  for (var i; !(i = e.__transition) || !(i = i[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return i;
}
function zM(e) {
  var t, i;
  e instanceof Io ? (t = e._id, e = e._name) : (t = dT(), (i = PM).time = e1(), e = e == null ? null : e + "");
  for (var r = this._groups, n = r.length, s = 0; s < n; ++s)
    for (var a = r[s], o = a.length, c, l = 0; l < o; ++l)
      (c = a[l]) && cy(c, e, t, l, a, i || $M(c, t));
  return new Io(r, this._parents, e, t);
}
pp.prototype.interrupt = rR;
pp.prototype.transition = zM;
var $c = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function o1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function UM(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var i = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    i.prototype = t.prototype;
  } else
    i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var n = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(i, r, n.get ? n : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), i;
}
var uT = { exports: {} };
(function(e, t) {
  (function(i, r) {
    e.exports = r();
  })($c, function() {
    var i = function(f) {
      return f instanceof Uint8Array || f instanceof Uint16Array || f instanceof Uint32Array || f instanceof Int8Array || f instanceof Int16Array || f instanceof Int32Array || f instanceof Float32Array || f instanceof Float64Array || f instanceof Uint8ClampedArray;
    }, r = function(f, y) {
      for (var T = Object.keys(y), G = 0; G < T.length; ++G)
        f[T[G]] = y[T[G]];
      return f;
    }, n = `
`;
    function s(f) {
      return typeof atob < "u" ? atob(f) : "base64:" + f;
    }
    function a(f) {
      var y = new Error("(regl) " + f);
      throw console.error(y), y;
    }
    function o(f, y) {
      f || a(y);
    }
    function c(f) {
      return f ? ": " + f : "";
    }
    function l(f, y, T) {
      f in y || a("unknown parameter (" + f + ")" + c(T) + ". possible values: " + Object.keys(y).join());
    }
    function d(f, y) {
      i(f) || a(
        "invalid parameter type" + c(y) + ". must be a typed array"
      );
    }
    function u(f, y) {
      switch (y) {
        case "number":
          return typeof f == "number";
        case "object":
          return typeof f == "object";
        case "string":
          return typeof f == "string";
        case "boolean":
          return typeof f == "boolean";
        case "function":
          return typeof f == "function";
        case "undefined":
          return typeof f > "u";
        case "symbol":
          return typeof f == "symbol";
      }
    }
    function h(f, y, T) {
      u(f, y) || a(
        "invalid parameter type" + c(T) + ". expected " + y + ", got " + typeof f
      );
    }
    function p(f, y) {
      f >= 0 && (f | 0) === f || a("invalid parameter type, (" + f + ")" + c(y) + ". must be a nonnegative integer");
    }
    function m(f, y, T) {
      y.indexOf(f) < 0 && a("invalid value" + c(T) + ". must be one of: " + y);
    }
    var w = [
      "gl",
      "canvas",
      "container",
      "attributes",
      "pixelRatio",
      "extensions",
      "optionalExtensions",
      "profile",
      "onDone"
    ];
    function C(f) {
      Object.keys(f).forEach(function(y) {
        w.indexOf(y) < 0 && a('invalid regl constructor argument "' + y + '". must be one of ' + w);
      });
    }
    function F(f, y) {
      for (f = f + ""; f.length < y; )
        f = " " + f;
      return f;
    }
    function W() {
      this.name = "unknown", this.lines = [], this.index = {}, this.hasErrors = !1;
    }
    function et(f, y) {
      this.number = f, this.line = y, this.errors = [];
    }
    function E(f, y, T) {
      this.file = f, this.line = y, this.message = T;
    }
    function Z() {
      var f = new Error(), y = (f.stack || f).toString(), T = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(y);
      if (T)
        return T[1];
      var G = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(y);
      return G ? G[1] : "unknown";
    }
    function yt() {
      var f = new Error(), y = (f.stack || f).toString(), T = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(y);
      if (T)
        return T[1];
      var G = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(y);
      return G ? G[1] : "unknown";
    }
    function bt(f, y) {
      var T = f.split(`
`), G = 1, tt = 0, j = {
        unknown: new W(),
        0: new W()
      };
      j.unknown.name = j[0].name = y || Z(), j.unknown.lines.push(new et(0, ""));
      for (var q = 0; q < T.length; ++q) {
        var lt = T[q], ct = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(lt);
        if (ct)
          switch (ct[1]) {
            case "line":
              var pt = /(\d+)(\s+\d+)?/.exec(ct[2]);
              pt && (G = pt[1] | 0, pt[2] && (tt = pt[2] | 0, tt in j || (j[tt] = new W())));
              break;
            case "define":
              var gt = /SHADER_NAME(_B64)?\s+(.*)$/.exec(ct[2]);
              gt && (j[tt].name = gt[1] ? s(gt[2]) : gt[2]);
              break;
          }
        j[tt].lines.push(new et(G++, lt));
      }
      return Object.keys(j).forEach(function(mt) {
        var xt = j[mt];
        xt.lines.forEach(function(dt) {
          xt.index[dt.number] = dt;
        });
      }), j;
    }
    function Ct(f) {
      var y = [];
      return f.split(`
`).forEach(function(T) {
        if (!(T.length < 5)) {
          var G = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(T);
          G ? y.push(new E(
            G[1] | 0,
            G[2] | 0,
            G[3].trim()
          )) : T.length > 0 && y.push(new E("unknown", 0, T));
        }
      }), y;
    }
    function Mt(f, y) {
      y.forEach(function(T) {
        var G = f[T.file];
        if (G) {
          var tt = G.index[T.line];
          if (tt) {
            tt.errors.push(T), G.hasErrors = !0;
            return;
          }
        }
        f.unknown.hasErrors = !0, f.unknown.lines[0].errors.push(T);
      });
    }
    function Me(f, y, T, G, tt) {
      if (!f.getShaderParameter(y, f.COMPILE_STATUS)) {
        var j = f.getShaderInfoLog(y), q = G === f.FRAGMENT_SHADER ? "fragment" : "vertex";
        vt(T, "string", q + " shader source must be a string", tt);
        var lt = bt(T, tt), ct = Ct(j);
        Mt(lt, ct), Object.keys(lt).forEach(function(pt) {
          var gt = lt[pt];
          if (!gt.hasErrors)
            return;
          var mt = [""], xt = [""];
          function dt(ft, R) {
            mt.push(ft), xt.push(R || "");
          }
          dt("file number " + pt + ": " + gt.name + `
`, "color:red;text-decoration:underline;font-weight:bold"), gt.lines.forEach(function(ft) {
            if (ft.errors.length > 0) {
              dt(F(ft.number, 4) + "|  ", "background-color:yellow; font-weight:bold"), dt(ft.line + n, "color:red; background-color:yellow; font-weight:bold");
              var R = 0;
              ft.errors.forEach(function(Y) {
                var ht = Y.message, Lt = /^\s*'(.*)'\s*:\s*(.*)$/.exec(ht);
                if (Lt) {
                  var st = Lt[1];
                  switch (ht = Lt[2], st) {
                    case "assign":
                      st = "=";
                      break;
                  }
                  R = Math.max(ft.line.indexOf(st, R), 0);
                } else
                  R = 0;
                dt(F("| ", 6)), dt(F("^^^", R + 3) + n, "font-weight:bold"), dt(F("| ", 6)), dt(ht + n, "font-weight:bold");
              }), dt(F("| ", 6) + n);
            } else
              dt(F(ft.number, 4) + "|  "), dt(ft.line + n, "color:red");
          }), typeof document < "u" && !window.chrome ? (xt[0] = mt.join("%c"), console.log.apply(console, xt)) : console.log(mt.join(""));
        }), o.raise("Error compiling " + q + " shader, " + lt[0].name);
      }
    }
    function kt(f, y, T, G, tt) {
      if (!f.getProgramParameter(y, f.LINK_STATUS)) {
        var j = f.getProgramInfoLog(y), q = bt(T, tt), lt = bt(G, tt), ct = 'Error linking program with vertex shader, "' + lt[0].name + '", and fragment shader "' + q[0].name + '"';
        typeof document < "u" ? console.log(
          "%c" + ct + n + "%c" + j,
          "color:red;text-decoration:underline;font-weight:bold",
          "color:red"
        ) : console.log(ct + n + j), o.raise(ct);
      }
    }
    function le(f) {
      f._commandRef = Z();
    }
    function ye(f, y, T, G) {
      le(f);
      function tt(ct) {
        return ct ? G.id(ct) : 0;
      }
      f._fragId = tt(f.static.frag), f._vertId = tt(f.static.vert);
      function j(ct, pt) {
        Object.keys(pt).forEach(function(gt) {
          ct[G.id(gt)] = !0;
        });
      }
      var q = f._uniformSet = {};
      j(q, y.static), j(q, y.dynamic);
      var lt = f._attributeSet = {};
      j(lt, T.static), j(lt, T.dynamic), f._hasCount = "count" in f.static || "count" in f.dynamic || "elements" in f.static || "elements" in f.dynamic;
    }
    function V(f, y) {
      var T = yt();
      a(f + " in command " + (y || Z()) + (T === "unknown" ? "" : " called from " + T));
    }
    function Bt(f, y, T) {
      f || V(y, T || Z());
    }
    function at(f, y, T, G) {
      f in y || V(
        "unknown parameter (" + f + ")" + c(T) + ". possible values: " + Object.keys(y).join(),
        G || Z()
      );
    }
    function vt(f, y, T, G) {
      u(f, y) || V(
        "invalid parameter type" + c(T) + ". expected " + y + ", got " + typeof f,
        G || Z()
      );
    }
    function oe(f) {
      f();
    }
    function Yt(f, y, T) {
      f.texture ? m(
        f.texture._texture.internalformat,
        y,
        "unsupported texture format for attachment"
      ) : m(
        f.renderbuffer._renderbuffer.format,
        T,
        "unsupported renderbuffer format for attachment"
      );
    }
    var pe = 33071, ei = 9728, ii = 9984, cr = 9985, Oi = 9986, Ri = 9987, Zi = 5120, hr = 5121, br = 5122, qt = 5123, Ze = 5124, ai = 5125, It = 5126, Er = 32819, Di = 32820, Gr = 33635, Hr = 34042, Zn = 36193, Wr = {};
    Wr[Zi] = Wr[hr] = 1, Wr[br] = Wr[qt] = Wr[Zn] = Wr[Gr] = Wr[Er] = Wr[Di] = 2, Wr[Ze] = Wr[ai] = Wr[It] = Wr[Hr] = 4;
    function fh(f, y) {
      return f === Di || f === Er || f === Gr ? 2 : f === Hr ? 4 : Wr[f] * y;
    }
    function Ql(f) {
      return !(f & f - 1) && !!f;
    }
    function Hy(f, y, T) {
      var G, tt = y.width, j = y.height, q = y.channels;
      o(
        tt > 0 && tt <= T.maxTextureSize && j > 0 && j <= T.maxTextureSize,
        "invalid texture shape"
      ), (f.wrapS !== pe || f.wrapT !== pe) && o(
        Ql(tt) && Ql(j),
        "incompatible wrap mode for texture, both width and height must be power of 2"
      ), y.mipmask === 1 ? tt !== 1 && j !== 1 && o(
        f.minFilter !== ii && f.minFilter !== Oi && f.minFilter !== cr && f.minFilter !== Ri,
        "min filter requires mipmap"
      ) : (o(
        Ql(tt) && Ql(j),
        "texture must be a square power of 2 to support mipmapping"
      ), o(
        y.mipmask === (tt << 1) - 1,
        "missing or incomplete mipmap data"
      )), y.type === It && (T.extensions.indexOf("oes_texture_float_linear") < 0 && o(
        f.minFilter === ei && f.magFilter === ei,
        "filter not supported, must enable oes_texture_float_linear"
      ), o(
        !f.genMipmaps,
        "mipmap generation not supported with float textures"
      ));
      var lt = y.images;
      for (G = 0; G < 16; ++G)
        if (lt[G]) {
          var ct = tt >> G, pt = j >> G;
          o(y.mipmask & 1 << G, "missing mipmap data");
          var gt = lt[G];
          if (o(
            gt.width === ct && gt.height === pt,
            "invalid shape for mip images"
          ), o(
            gt.format === y.format && gt.internalformat === y.internalformat && gt.type === y.type,
            "incompatible type for mip image"
          ), !gt.compressed)
            if (gt.data) {
              var mt = Math.ceil(fh(gt.type, q) * ct / gt.unpackAlignment) * gt.unpackAlignment;
              o(
                gt.data.byteLength === mt * pt,
                "invalid data for image, buffer size is inconsistent with image format"
              );
            } else
              gt.element || gt.copy;
        } else
          f.genMipmaps || o((y.mipmask & 1 << G) === 0, "extra mipmap data");
      y.compressed && o(
        !f.genMipmaps,
        "mipmap generation for compressed images not supported"
      );
    }
    function Wy(f, y, T, G) {
      var tt = f.width, j = f.height, q = f.channels;
      o(
        tt > 0 && tt <= G.maxTextureSize && j > 0 && j <= G.maxTextureSize,
        "invalid texture shape"
      ), o(
        tt === j,
        "cube map must be square"
      ), o(
        y.wrapS === pe && y.wrapT === pe,
        "wrap mode not supported by cube map"
      );
      for (var lt = 0; lt < T.length; ++lt) {
        var ct = T[lt];
        o(
          ct.width === tt && ct.height === j,
          "inconsistent cube map face shape"
        ), y.genMipmaps && (o(
          !ct.compressed,
          "can not generate mipmap for compressed textures"
        ), o(
          ct.mipmask === 1,
          "can not specify mipmaps and generate mipmaps"
        ));
        for (var pt = ct.images, gt = 0; gt < 16; ++gt) {
          var mt = pt[gt];
          if (mt) {
            var xt = tt >> gt, dt = j >> gt;
            o(ct.mipmask & 1 << gt, "missing mipmap data"), o(
              mt.width === xt && mt.height === dt,
              "invalid shape for mip images"
            ), o(
              mt.format === f.format && mt.internalformat === f.internalformat && mt.type === f.type,
              "incompatible type for mip image"
            ), mt.compressed || (mt.data ? o(
              mt.data.byteLength === xt * dt * Math.max(fh(mt.type, q), mt.unpackAlignment),
              "invalid data for image, buffer size is inconsistent with image format"
            ) : mt.element || mt.copy);
          }
        }
      }
    }
    var _ = r(o, {
      optional: oe,
      raise: a,
      commandRaise: V,
      command: Bt,
      parameter: l,
      commandParameter: at,
      constructor: C,
      type: h,
      commandType: vt,
      isTypedArray: d,
      nni: p,
      oneOf: m,
      shaderError: Me,
      linkError: kt,
      callSite: yt,
      saveCommandRef: le,
      saveDrawInfo: ye,
      framebufferFormat: Yt,
      guessCommand: Z,
      texture2D: Hy,
      textureCube: Wy
    }), Vp = 0, Yy = 0, jp = 5, jt = 6;
    function Wt(f, y) {
      this.id = Vp++, this.type = f, this.data = y;
    }
    function ot(f) {
      return f.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    }
    function X(f) {
      if (f.length === 0)
        return [];
      var y = f.charAt(0), T = f.charAt(f.length - 1);
      if (f.length > 1 && y === T && (y === '"' || y === "'"))
        return ['"' + ot(f.substr(1, f.length - 2)) + '"'];
      var G = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(f);
      if (G)
        return X(f.substr(0, G.index)).concat(X(G[1])).concat(X(f.substr(G.index + G[0].length)));
      var tt = f.split(".");
      if (tt.length === 1)
        return ['"' + ot(f) + '"'];
      for (var j = [], q = 0; q < tt.length; ++q)
        j = j.concat(X(tt[q]));
      return j;
    }
    function Pe(f) {
      return "[" + X(f).join("][") + "]";
    }
    function te(f, y) {
      return new Wt(f, Pe(y + ""));
    }
    function ee(f) {
      return typeof f == "function" && !f._reglType || f instanceof Wt;
    }
    function Ui(f, y) {
      if (typeof f == "function")
        return new Wt(Yy, f);
      if (typeof f == "number" || typeof f == "boolean")
        return new Wt(jp, f);
      if (Array.isArray(f))
        return new Wt(jt, f.map(function(T, G) {
          return Ui(T, y + "[" + G + "]");
        }));
      if (f instanceof Wt)
        return f;
      _(!1, "invalid option type in uniform " + y);
    }
    var Ii = {
      DynamicVariable: Wt,
      define: te,
      isDynamic: ee,
      unbox: Ui,
      accessor: Pe
    }, xr = {
      next: typeof requestAnimationFrame == "function" ? function(f) {
        return requestAnimationFrame(f);
      } : function(f) {
        return setTimeout(f, 16);
      },
      cancel: typeof cancelAnimationFrame == "function" ? function(f) {
        return cancelAnimationFrame(f);
      } : clearTimeout
    }, fr = typeof performance < "u" && performance.now ? function() {
      return performance.now();
    } : function() {
      return +/* @__PURE__ */ new Date();
    };
    function pn() {
      var f = { "": 0 }, y = [""];
      return {
        id: function(T) {
          var G = f[T];
          return G || (G = f[T] = y.length, y.push(T), G);
        },
        str: function(T) {
          return y[T];
        }
      };
    }
    function lr(f, y, T) {
      var G = document.createElement("canvas");
      r(G.style, {
        border: 0,
        margin: 0,
        padding: 0,
        top: 0,
        left: 0,
        width: "100%",
        height: "100%"
      }), f.appendChild(G), f === document.body && (G.style.position = "absolute", r(f.style, {
        margin: 0,
        padding: 0
      }));
      function tt() {
        var lt = window.innerWidth, ct = window.innerHeight;
        if (f !== document.body) {
          var pt = G.getBoundingClientRect();
          lt = pt.right - pt.left, ct = pt.bottom - pt.top;
        }
        G.width = T * lt, G.height = T * ct;
      }
      var j;
      f !== document.body && typeof ResizeObserver == "function" ? (j = new ResizeObserver(function() {
        setTimeout(tt);
      }), j.observe(f)) : window.addEventListener("resize", tt, !1);
      function q() {
        j ? j.disconnect() : window.removeEventListener("resize", tt), f.removeChild(G);
      }
      return tt(), {
        canvas: G,
        onDestroy: q
      };
    }
    function Vi(f, y) {
      function T(G) {
        try {
          return f.getContext(G, y);
        } catch {
          return null;
        }
      }
      return T("webgl") || T("experimental-webgl") || T("webgl-experimental");
    }
    function Mr(f) {
      return typeof f.nodeName == "string" && typeof f.appendChild == "function" && typeof f.getBoundingClientRect == "function";
    }
    function xn(f) {
      return typeof f.drawArrays == "function" || typeof f.drawElements == "function";
    }
    function ks(f) {
      return typeof f == "string" ? f.split() : (_(Array.isArray(f), "invalid extension array"), f);
    }
    function Ya(f) {
      return typeof f == "string" ? (_(typeof document < "u", "not supported outside of DOM"), document.querySelector(f)) : f;
    }
    function Wc(f) {
      var y = f || {}, T, G, tt, j, q = {}, lt = [], ct = [], pt = typeof window > "u" ? 1 : window.devicePixelRatio, gt = !1, mt = function(ft) {
        ft && _.raise(ft);
      }, xt = function() {
      };
      if (typeof y == "string" ? (_(
        typeof document < "u",
        "selector queries only supported in DOM enviroments"
      ), T = document.querySelector(y), _(T, "invalid query string for element")) : typeof y == "object" ? Mr(y) ? T = y : xn(y) ? (j = y, tt = j.canvas) : (_.constructor(y), "gl" in y ? j = y.gl : "canvas" in y ? tt = Ya(y.canvas) : "container" in y && (G = Ya(y.container)), "attributes" in y && (q = y.attributes, _.type(q, "object", "invalid context attributes")), "extensions" in y && (lt = ks(y.extensions)), "optionalExtensions" in y && (ct = ks(y.optionalExtensions)), "onDone" in y && (_.type(
        y.onDone,
        "function",
        "invalid or missing onDone callback"
      ), mt = y.onDone), "profile" in y && (gt = !!y.profile), "pixelRatio" in y && (pt = +y.pixelRatio, _(pt > 0, "invalid pixel ratio"))) : _.raise("invalid arguments to regl"), T && (T.nodeName.toLowerCase() === "canvas" ? tt = T : G = T), !j) {
        if (!tt) {
          _(
            typeof document < "u",
            "must manually specify webgl context outside of DOM environments"
          );
          var dt = lr(G || document.body, mt, pt);
          if (!dt)
            return null;
          tt = dt.canvas, xt = dt.onDestroy;
        }
        q.premultipliedAlpha === void 0 && (q.premultipliedAlpha = !0), j = Vi(tt, q);
      }
      return j ? {
        gl: j,
        canvas: tt,
        container: G,
        extensions: lt,
        optionalExtensions: ct,
        pixelRatio: pt,
        profile: gt,
        onDone: mt,
        onDestroy: xt
      } : (xt(), mt("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"), null);
    }
    function Yo(f, y) {
      var T = {};
      function G(q) {
        _.type(q, "string", "extension name must be string");
        var lt = q.toLowerCase(), ct;
        try {
          ct = T[lt] = f.getExtension(lt);
        } catch {
        }
        return !!ct;
      }
      for (var tt = 0; tt < y.extensions.length; ++tt) {
        var j = y.extensions[tt];
        if (!G(j))
          return y.onDestroy(), y.onDone('"' + j + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser'), null;
      }
      return y.optionalExtensions.forEach(G), {
        extensions: T,
        restore: function() {
          Object.keys(T).forEach(function(q) {
            if (T[q] && !G(q))
              throw new Error("(regl): error restoring extension " + q);
          });
        }
      };
    }
    function Xi(f, y) {
      for (var T = Array(f), G = 0; G < f; ++G)
        T[G] = y(G);
      return T;
    }
    var Yc = 5120, on = 5121, Pr = 5122, qy = 5123, ph = 5124, Gp = 5125, Zy = 5126;
    function Hp(f) {
      for (var y = 16; y <= 1 << 28; y *= 16)
        if (f <= y)
          return y;
      return 0;
    }
    function Wp(f) {
      var y, T;
      return y = (f > 65535) << 4, f >>>= y, T = (f > 255) << 3, f >>>= T, y |= T, T = (f > 15) << 2, f >>>= T, y |= T, T = (f > 3) << 1, f >>>= T, y |= T, y | f >> 1;
    }
    function Yp() {
      var f = Xi(8, function() {
        return [];
      });
      function y(j) {
        var q = Hp(j), lt = f[Wp(q) >> 2];
        return lt.length > 0 ? lt.pop() : new ArrayBuffer(q);
      }
      function T(j) {
        f[Wp(j.byteLength) >> 2].push(j);
      }
      function G(j, q) {
        var lt = null;
        switch (j) {
          case Yc:
            lt = new Int8Array(y(q), 0, q);
            break;
          case on:
            lt = new Uint8Array(y(q), 0, q);
            break;
          case Pr:
            lt = new Int16Array(y(2 * q), 0, q);
            break;
          case qy:
            lt = new Uint16Array(y(2 * q), 0, q);
            break;
          case ph:
            lt = new Int32Array(y(4 * q), 0, q);
            break;
          case Gp:
            lt = new Uint32Array(y(4 * q), 0, q);
            break;
          case Zy:
            lt = new Float32Array(y(4 * q), 0, q);
            break;
          default:
            return null;
        }
        return lt.length !== q ? lt.subarray(0, q) : lt;
      }
      function tt(j) {
        T(j.buffer);
      }
      return {
        alloc: y,
        free: T,
        allocType: G,
        freeType: tt
      };
    }
    var nr = Yp();
    nr.zero = Yp();
    var Gt = 3408, si = 3410, xi = 3411, kr = 3412, oi = 3413, We = 3414, Ai = 3415, ji = 33901, $r = 33902, Yr = 3379, qr = 3386, qa = 34921, ns = 36347, qo = 36348, td = 35661, Za = 35660, Xa = 34930, mh = 36349, Cs = 34076, qp = 34024, UN = 7936, VN = 7937, jN = 7938, GN = 35724, HN = 34047, WN = 36063, YN = 34852, Zp = 3553, Cw = 34067, qN = 34069, ZN = 33984, gh = 6408, Xy = 5126, Ow = 5121, Ky = 36160, XN = 36053, KN = 36064, JN = 16384, QN = function(f, y) {
      var T = 1;
      y.ext_texture_filter_anisotropic && (T = f.getParameter(HN));
      var G = 1, tt = 1;
      y.webgl_draw_buffers && (G = f.getParameter(YN), tt = f.getParameter(WN));
      var j = !!y.oes_texture_float;
      if (j) {
        var q = f.createTexture();
        f.bindTexture(Zp, q), f.texImage2D(Zp, 0, gh, 1, 1, 0, gh, Xy, null);
        var lt = f.createFramebuffer();
        if (f.bindFramebuffer(Ky, lt), f.framebufferTexture2D(Ky, KN, Zp, q, 0), f.bindTexture(Zp, null), f.checkFramebufferStatus(Ky) !== XN)
          j = !1;
        else {
          f.viewport(0, 0, 1, 1), f.clearColor(1, 0, 0, 1), f.clear(JN);
          var ct = nr.allocType(Xy, 4);
          f.readPixels(0, 0, 1, 1, gh, Xy, ct), f.getError() ? j = !1 : (f.deleteFramebuffer(lt), f.deleteTexture(q), j = ct[0] === 1), nr.freeType(ct);
        }
      }
      var pt = typeof navigator < "u" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent)), gt = !0;
      if (!pt) {
        var mt = f.createTexture(), xt = nr.allocType(Ow, 36);
        f.activeTexture(ZN), f.bindTexture(Cw, mt), f.texImage2D(qN, 0, gh, 3, 3, 0, gh, Ow, xt), nr.freeType(xt), f.bindTexture(Cw, null), f.deleteTexture(mt), gt = !f.getError();
      }
      return {
        // drawing buffer bit depth
        colorBits: [
          f.getParameter(si),
          f.getParameter(xi),
          f.getParameter(kr),
          f.getParameter(oi)
        ],
        depthBits: f.getParameter(We),
        stencilBits: f.getParameter(Ai),
        subpixelBits: f.getParameter(Gt),
        // supported extensions
        extensions: Object.keys(y).filter(function(dt) {
          return !!y[dt];
        }),
        // max aniso samples
        maxAnisotropic: T,
        // max draw buffers
        maxDrawbuffers: G,
        maxColorAttachments: tt,
        // point and line size ranges
        pointSizeDims: f.getParameter(ji),
        lineWidthDims: f.getParameter($r),
        maxViewportDims: f.getParameter(qr),
        maxCombinedTextureUnits: f.getParameter(td),
        maxCubeMapSize: f.getParameter(Cs),
        maxRenderbufferSize: f.getParameter(qp),
        maxTextureUnits: f.getParameter(Xa),
        maxTextureSize: f.getParameter(Yr),
        maxAttributes: f.getParameter(qa),
        maxVertexUniforms: f.getParameter(ns),
        maxVertexTextureUnits: f.getParameter(Za),
        maxVaryingVectors: f.getParameter(qo),
        maxFragmentUniforms: f.getParameter(mh),
        // vendor info
        glsl: f.getParameter(GN),
        renderer: f.getParameter(VN),
        vendor: f.getParameter(UN),
        version: f.getParameter(jN),
        // quirks
        readFloat: j,
        npotTextureCube: gt
      };
    };
    function Os(f) {
      return !!f && typeof f == "object" && Array.isArray(f.shape) && Array.isArray(f.stride) && typeof f.offset == "number" && f.shape.length === f.stride.length && (Array.isArray(f.data) || i(f.data));
    }
    var Xn = function(f) {
      return Object.keys(f).map(function(y) {
        return f[y];
      });
    }, Xp = {
      shape: rL,
      flatten: iL
    };
    function tL(f, y, T) {
      for (var G = 0; G < y; ++G)
        T[G] = f[G];
    }
    function eL(f, y, T, G) {
      for (var tt = 0, j = 0; j < y; ++j)
        for (var q = f[j], lt = 0; lt < T; ++lt)
          G[tt++] = q[lt];
    }
    function Dw(f, y, T, G, tt, j) {
      for (var q = j, lt = 0; lt < y; ++lt)
        for (var ct = f[lt], pt = 0; pt < T; ++pt)
          for (var gt = ct[pt], mt = 0; mt < G; ++mt)
            tt[q++] = gt[mt];
    }
    function Nw(f, y, T, G, tt) {
      for (var j = 1, q = T + 1; q < y.length; ++q)
        j *= y[q];
      var lt = y[T];
      if (y.length - T === 4) {
        var ct = y[T + 1], pt = y[T + 2], gt = y[T + 3];
        for (q = 0; q < lt; ++q)
          Dw(f[q], ct, pt, gt, G, tt), tt += j;
      } else
        for (q = 0; q < lt; ++q)
          Nw(f[q], y, T + 1, G, tt), tt += j;
    }
    function iL(f, y, T, G) {
      var tt = 1;
      if (y.length)
        for (var j = 0; j < y.length; ++j)
          tt *= y[j];
      else
        tt = 0;
      var q = G || nr.allocType(T, tt);
      switch (y.length) {
        case 0:
          break;
        case 1:
          tL(f, y[0], q);
          break;
        case 2:
          eL(f, y[0], y[1], q);
          break;
        case 3:
          Dw(f, y[0], y[1], y[2], q, 0);
          break;
        default:
          Nw(f, y, 0, q, 0);
      }
      return q;
    }
    function rL(f) {
      for (var y = [], T = f; T.length; T = T[0])
        y.push(T.length);
      return y;
    }
    var Jy = {
      "[object Int8Array]": 5120,
      "[object Int16Array]": 5122,
      "[object Int32Array]": 5124,
      "[object Uint8Array]": 5121,
      "[object Uint8ClampedArray]": 5121,
      "[object Uint16Array]": 5123,
      "[object Uint32Array]": 5125,
      "[object Float32Array]": 5126,
      "[object Float64Array]": 5121,
      "[object ArrayBuffer]": 5121
    }, nL = 5120, sL = 5122, aL = 5124, oL = 5121, cL = 5123, lL = 5125, dL = 5126, uL = 5126, qc = {
      int8: nL,
      int16: sL,
      int32: aL,
      uint8: oL,
      uint16: cL,
      uint32: lL,
      float: dL,
      float32: uL
    }, hL = 35048, fL = 35040, Kp = {
      dynamic: hL,
      stream: fL,
      static: 35044
    }, Qy = Xp.flatten, Lw = Xp.shape, Fw = 35044, pL = 35040, tv = 5121, ev = 5126, Zo = [];
    Zo[5120] = 1, Zo[5122] = 2, Zo[5124] = 4, Zo[5121] = 1, Zo[5123] = 2, Zo[5125] = 4, Zo[5126] = 4;
    function Jp(f) {
      return Jy[Object.prototype.toString.call(f)] | 0;
    }
    function Bw(f, y) {
      for (var T = 0; T < y.length; ++T)
        f[T] = y[T];
    }
    function Rw(f, y, T, G, tt, j, q) {
      for (var lt = 0, ct = 0; ct < T; ++ct)
        for (var pt = 0; pt < G; ++pt)
          f[lt++] = y[tt * ct + j * pt + q];
    }
    function mL(f, y, T, G) {
      var tt = 0, j = {};
      function q(R) {
        this.id = tt++, this.buffer = f.createBuffer(), this.type = R, this.usage = Fw, this.byteLength = 0, this.dimension = 1, this.dtype = tv, this.persistentData = null, T.profile && (this.stats = { size: 0 });
      }
      q.prototype.bind = function() {
        f.bindBuffer(this.type, this.buffer);
      }, q.prototype.destroy = function() {
        xt(this);
      };
      var lt = [];
      function ct(R, Y) {
        var ht = lt.pop();
        return ht || (ht = new q(R)), ht.bind(), mt(ht, Y, pL, 0, 1, !1), ht;
      }
      function pt(R) {
        lt.push(R);
      }
      function gt(R, Y, ht) {
        R.byteLength = Y.byteLength, f.bufferData(R.type, Y, ht);
      }
      function mt(R, Y, ht, Lt, st, Ot) {
        var Tt;
        if (R.usage = ht, Array.isArray(Y)) {
          if (R.dtype = Lt || ev, Y.length > 0) {
            var Jt;
            if (Array.isArray(Y[0])) {
              Tt = Lw(Y);
              for (var it = 1, Q = 1; Q < Tt.length; ++Q)
                it *= Tt[Q];
              R.dimension = it, Jt = Qy(Y, Tt, R.dtype), gt(R, Jt, ht), Ot ? R.persistentData = Jt : nr.freeType(Jt);
            } else if (typeof Y[0] == "number") {
              R.dimension = st;
              var zt = nr.allocType(R.dtype, Y.length);
              Bw(zt, Y), gt(R, zt, ht), Ot ? R.persistentData = zt : nr.freeType(zt);
            } else
              i(Y[0]) ? (R.dimension = Y[0].length, R.dtype = Lt || Jp(Y[0]) || ev, Jt = Qy(
                Y,
                [Y.length, Y[0].length],
                R.dtype
              ), gt(R, Jt, ht), Ot ? R.persistentData = Jt : nr.freeType(Jt)) : _.raise("invalid buffer data");
          }
        } else if (i(Y))
          R.dtype = Lt || Jp(Y), R.dimension = st, gt(R, Y, ht), Ot && (R.persistentData = new Uint8Array(new Uint8Array(Y.buffer)));
        else if (Os(Y)) {
          Tt = Y.shape;
          var wt = Y.stride, ut = Y.offset, St = 0, At = 0, he = 0, ce = 0;
          Tt.length === 1 ? (St = Tt[0], At = 1, he = wt[0], ce = 0) : Tt.length === 2 ? (St = Tt[0], At = Tt[1], he = wt[0], ce = wt[1]) : _.raise("invalid shape"), R.dtype = Lt || Jp(Y.data) || ev, R.dimension = At;
          var Et = nr.allocType(R.dtype, St * At);
          Rw(
            Et,
            Y.data,
            St,
            At,
            he,
            ce,
            ut
          ), gt(R, Et, ht), Ot ? R.persistentData = Et : nr.freeType(Et);
        } else
          Y instanceof ArrayBuffer ? (R.dtype = tv, R.dimension = st, gt(R, Y, ht), Ot && (R.persistentData = new Uint8Array(new Uint8Array(Y)))) : _.raise("invalid buffer data");
      }
      function xt(R) {
        y.bufferCount--, G(R);
        var Y = R.buffer;
        _(Y, "buffer must not be deleted already"), f.deleteBuffer(Y), R.buffer = null, delete j[R.id];
      }
      function dt(R, Y, ht, Lt) {
        y.bufferCount++;
        var st = new q(Y);
        j[st.id] = st;
        function Ot(it) {
          var Q = Fw, zt = null, wt = 0, ut = 0, St = 1;
          return Array.isArray(it) || i(it) || Os(it) || it instanceof ArrayBuffer ? zt = it : typeof it == "number" ? wt = it | 0 : it && (_.type(
            it,
            "object",
            "buffer arguments must be an object, a number or an array"
          ), "data" in it && (_(
            zt === null || Array.isArray(zt) || i(zt) || Os(zt),
            "invalid data for buffer"
          ), zt = it.data), "usage" in it && (_.parameter(it.usage, Kp, "invalid buffer usage"), Q = Kp[it.usage]), "type" in it && (_.parameter(it.type, qc, "invalid buffer type"), ut = qc[it.type]), "dimension" in it && (_.type(it.dimension, "number", "invalid dimension"), St = it.dimension | 0), "length" in it && (_.nni(wt, "buffer length must be a nonnegative integer"), wt = it.length | 0)), st.bind(), zt ? mt(st, zt, Q, ut, St, Lt) : (wt && f.bufferData(st.type, wt, Q), st.dtype = ut || tv, st.usage = Q, st.dimension = St, st.byteLength = wt), T.profile && (st.stats.size = st.byteLength * Zo[st.dtype]), Ot;
        }
        function Tt(it, Q) {
          _(
            Q + it.byteLength <= st.byteLength,
            "invalid buffer subdata call, buffer is too small.  Can't write data of size " + it.byteLength + " starting from offset " + Q + " to a buffer of size " + st.byteLength
          ), f.bufferSubData(st.type, Q, it);
        }
        function Jt(it, Q) {
          var zt = (Q || 0) | 0, wt;
          if (st.bind(), i(it) || it instanceof ArrayBuffer)
            Tt(it, zt);
          else if (Array.isArray(it)) {
            if (it.length > 0)
              if (typeof it[0] == "number") {
                var ut = nr.allocType(st.dtype, it.length);
                Bw(ut, it), Tt(ut, zt), nr.freeType(ut);
              } else if (Array.isArray(it[0]) || i(it[0])) {
                wt = Lw(it);
                var St = Qy(it, wt, st.dtype);
                Tt(St, zt), nr.freeType(St);
              } else
                _.raise("invalid buffer data");
          } else if (Os(it)) {
            wt = it.shape;
            var At = it.stride, he = 0, ce = 0, Et = 0, Nt = 0;
            wt.length === 1 ? (he = wt[0], ce = 1, Et = At[0], Nt = 0) : wt.length === 2 ? (he = wt[0], ce = wt[1], Et = At[0], Nt = At[1]) : _.raise("invalid shape");
            var ne = Array.isArray(it.data) ? st.dtype : Jp(it.data), fe = nr.allocType(ne, he * ce);
            Rw(
              fe,
              it.data,
              he,
              ce,
              Et,
              Nt,
              it.offset
            ), Tt(fe, zt), nr.freeType(fe);
          } else
            _.raise("invalid data for buffer subdata");
          return Ot;
        }
        return ht || Ot(R), Ot._reglType = "buffer", Ot._buffer = st, Ot.subdata = Jt, T.profile && (Ot.stats = st.stats), Ot.destroy = function() {
          xt(st);
        }, Ot;
      }
      function ft() {
        Xn(j).forEach(function(R) {
          R.buffer = f.createBuffer(), f.bindBuffer(R.type, R.buffer), f.bufferData(
            R.type,
            R.persistentData || R.byteLength,
            R.usage
          );
        });
      }
      return T.profile && (y.getTotalBufferSize = function() {
        var R = 0;
        return Object.keys(j).forEach(function(Y) {
          R += j[Y].stats.size;
        }), R;
      }), {
        create: dt,
        createStream: ct,
        destroyStream: pt,
        clear: function() {
          Xn(j).forEach(xt), lt.forEach(xt);
        },
        getBuffer: function(R) {
          return R && R._buffer instanceof q ? R._buffer : null;
        },
        restore: ft,
        _initBuffer: mt
      };
    }
    var gL = 0, yL = 0, vL = 1, _L = 1, bL = 4, xL = 4, Xo = {
      points: gL,
      point: yL,
      lines: vL,
      line: _L,
      triangles: bL,
      triangle: xL,
      "line loop": 2,
      "line strip": 3,
      "triangle strip": 5,
      "triangle fan": 6
    }, wL = 0, SL = 1, yh = 4, IL = 5120, ed = 5121, Mw = 5122, id = 5123, Pw = 5124, Zc = 5125, iv = 34963, AL = 35040, TL = 35044;
    function EL(f, y, T, G) {
      var tt = {}, j = 0, q = {
        uint8: ed,
        uint16: id
      };
      y.oes_element_index_uint && (q.uint32 = Zc);
      function lt(ft) {
        this.id = j++, tt[this.id] = this, this.buffer = ft, this.primType = yh, this.vertCount = 0, this.type = 0;
      }
      lt.prototype.bind = function() {
        this.buffer.bind();
      };
      var ct = [];
      function pt(ft) {
        var R = ct.pop();
        return R || (R = new lt(T.create(
          null,
          iv,
          !0,
          !1
        )._buffer)), mt(R, ft, AL, -1, -1, 0, 0), R;
      }
      function gt(ft) {
        ct.push(ft);
      }
      function mt(ft, R, Y, ht, Lt, st, Ot) {
        ft.buffer.bind();
        var Tt;
        if (R) {
          var Jt = Ot;
          !Ot && (!i(R) || Os(R) && !i(R.data)) && (Jt = y.oes_element_index_uint ? Zc : id), T._initBuffer(
            ft.buffer,
            R,
            Y,
            Jt,
            3
          );
        } else
          f.bufferData(iv, st, Y), ft.buffer.dtype = Tt || ed, ft.buffer.usage = Y, ft.buffer.dimension = 3, ft.buffer.byteLength = st;
        if (Tt = Ot, !Ot) {
          switch (ft.buffer.dtype) {
            case ed:
            case IL:
              Tt = ed;
              break;
            case id:
            case Mw:
              Tt = id;
              break;
            case Zc:
            case Pw:
              Tt = Zc;
              break;
            default:
              _.raise("unsupported type for element array");
          }
          ft.buffer.dtype = Tt;
        }
        ft.type = Tt, _(
          Tt !== Zc || !!y.oes_element_index_uint,
          "32 bit element buffers not supported, enable oes_element_index_uint first"
        );
        var it = Lt;
        it < 0 && (it = ft.buffer.byteLength, Tt === id ? it >>= 1 : Tt === Zc && (it >>= 2)), ft.vertCount = it;
        var Q = ht;
        if (ht < 0) {
          Q = yh;
          var zt = ft.buffer.dimension;
          zt === 1 && (Q = wL), zt === 2 && (Q = SL), zt === 3 && (Q = yh);
        }
        ft.primType = Q;
      }
      function xt(ft) {
        G.elementsCount--, _(ft.buffer !== null, "must not double destroy elements"), delete tt[ft.id], ft.buffer.destroy(), ft.buffer = null;
      }
      function dt(ft, R) {
        var Y = T.create(null, iv, !0), ht = new lt(Y._buffer);
        G.elementsCount++;
        function Lt(st) {
          if (!st)
            Y(), ht.primType = yh, ht.vertCount = 0, ht.type = ed;
          else if (typeof st == "number")
            Y(st), ht.primType = yh, ht.vertCount = st | 0, ht.type = ed;
          else {
            var Ot = null, Tt = TL, Jt = -1, it = -1, Q = 0, zt = 0;
            Array.isArray(st) || i(st) || Os(st) ? Ot = st : (_.type(st, "object", "invalid arguments for elements"), "data" in st && (Ot = st.data, _(
              Array.isArray(Ot) || i(Ot) || Os(Ot),
              "invalid data for element buffer"
            )), "usage" in st && (_.parameter(
              st.usage,
              Kp,
              "invalid element buffer usage"
            ), Tt = Kp[st.usage]), "primitive" in st && (_.parameter(
              st.primitive,
              Xo,
              "invalid element buffer primitive"
            ), Jt = Xo[st.primitive]), "count" in st && (_(
              typeof st.count == "number" && st.count >= 0,
              "invalid vertex count for elements"
            ), it = st.count | 0), "type" in st && (_.parameter(
              st.type,
              q,
              "invalid buffer type"
            ), zt = q[st.type]), "length" in st ? Q = st.length | 0 : (Q = it, zt === id || zt === Mw ? Q *= 2 : (zt === Zc || zt === Pw) && (Q *= 4))), mt(
              ht,
              Ot,
              Tt,
              Jt,
              it,
              Q,
              zt
            );
          }
          return Lt;
        }
        return Lt(ft), Lt._reglType = "elements", Lt._elements = ht, Lt.subdata = function(st, Ot) {
          return Y.subdata(st, Ot), Lt;
        }, Lt.destroy = function() {
          xt(ht);
        }, Lt;
      }
      return {
        create: dt,
        createStream: pt,
        destroyStream: gt,
        getElements: function(ft) {
          return typeof ft == "function" && ft._elements instanceof lt ? ft._elements : null;
        },
        clear: function() {
          Xn(tt).forEach(xt);
        }
      };
    }
    var $w = new Float32Array(1), kL = new Uint32Array($w.buffer), CL = 5123;
    function zw(f) {
      for (var y = nr.allocType(CL, f.length), T = 0; T < f.length; ++T)
        if (isNaN(f[T]))
          y[T] = 65535;
        else if (f[T] === 1 / 0)
          y[T] = 31744;
        else if (f[T] === -1 / 0)
          y[T] = 64512;
        else {
          $w[0] = f[T];
          var G = kL[0], tt = G >>> 31 << 15, j = (G << 1 >>> 24) - 127, q = G >> 13 & 1023;
          if (j < -24)
            y[T] = tt;
          else if (j < -14) {
            var lt = -14 - j;
            y[T] = tt + (q + 1024 >> lt);
          } else
            j > 15 ? y[T] = tt + 31744 : y[T] = tt + (j + 15 << 10) + q;
        }
      return y;
    }
    function Ji(f) {
      return Array.isArray(f) || i(f);
    }
    var Uw = function(f) {
      return !(f & f - 1) && !!f;
    }, OL = 34467, oa = 3553, rv = 34067, Qp = 34069, Xc = 6408, nv = 6406, tm = 6407, vh = 6409, em = 6410, Vw = 32854, sv = 32855, jw = 36194, DL = 32819, NL = 32820, LL = 33635, FL = 34042, av = 6402, im = 34041, ov = 35904, cv = 35906, rd = 36193, lv = 33776, dv = 33777, uv = 33778, hv = 33779, Gw = 35986, Hw = 35987, Ww = 34798, Yw = 35840, qw = 35841, Zw = 35842, Xw = 35843, Kw = 36196, nd = 5121, fv = 5123, pv = 5125, _h = 5126, BL = 10242, RL = 10243, ML = 10497, mv = 33071, PL = 33648, $L = 10240, zL = 10241, gv = 9728, UL = 9729, yv = 9984, Jw = 9985, Qw = 9986, vv = 9987, VL = 33170, rm = 4352, jL = 4353, GL = 4354, HL = 34046, WL = 3317, YL = 37440, qL = 37441, ZL = 37443, tS = 37444, bh = 33984, XL = [
      yv,
      Qw,
      Jw,
      vv
    ], nm = [
      0,
      vh,
      em,
      tm,
      Xc
    ], ss = {};
    ss[vh] = ss[nv] = ss[av] = 1, ss[im] = ss[em] = 2, ss[tm] = ss[ov] = 3, ss[Xc] = ss[cv] = 4;
    function sd(f) {
      return "[object " + f + "]";
    }
    var eS = sd("HTMLCanvasElement"), iS = sd("OffscreenCanvas"), rS = sd("CanvasRenderingContext2D"), nS = sd("ImageBitmap"), sS = sd("HTMLImageElement"), aS = sd("HTMLVideoElement"), KL = Object.keys(Jy).concat([
      eS,
      iS,
      rS,
      nS,
      sS,
      aS
    ]), ad = [];
    ad[nd] = 1, ad[_h] = 4, ad[rd] = 2, ad[fv] = 2, ad[pv] = 4;
    var en = [];
    en[Vw] = 2, en[sv] = 2, en[jw] = 2, en[im] = 4, en[lv] = 0.5, en[dv] = 0.5, en[uv] = 1, en[hv] = 1, en[Gw] = 0.5, en[Hw] = 1, en[Ww] = 1, en[Yw] = 0.5, en[qw] = 0.25, en[Zw] = 0.5, en[Xw] = 0.25, en[Kw] = 0.5;
    function oS(f) {
      return Array.isArray(f) && (f.length === 0 || typeof f[0] == "number");
    }
    function cS(f) {
      if (!Array.isArray(f))
        return !1;
      var y = f.length;
      return !(y === 0 || !Ji(f[0]));
    }
    function Kc(f) {
      return Object.prototype.toString.call(f);
    }
    function lS(f) {
      return Kc(f) === eS;
    }
    function dS(f) {
      return Kc(f) === iS;
    }
    function JL(f) {
      return Kc(f) === rS;
    }
    function QL(f) {
      return Kc(f) === nS;
    }
    function t6(f) {
      return Kc(f) === sS;
    }
    function e6(f) {
      return Kc(f) === aS;
    }
    function _v(f) {
      if (!f)
        return !1;
      var y = Kc(f);
      return KL.indexOf(y) >= 0 ? !0 : oS(f) || cS(f) || Os(f);
    }
    function uS(f) {
      return Jy[Object.prototype.toString.call(f)] | 0;
    }
    function i6(f, y) {
      var T = y.length;
      switch (f.type) {
        case nd:
        case fv:
        case pv:
        case _h:
          var G = nr.allocType(f.type, T);
          G.set(y), f.data = G;
          break;
        case rd:
          f.data = zw(y);
          break;
        default:
          _.raise("unsupported texture type, must specify a typed array");
      }
    }
    function hS(f, y) {
      return nr.allocType(
        f.type === rd ? _h : f.type,
        y
      );
    }
    function fS(f, y) {
      f.type === rd ? (f.data = zw(y), nr.freeType(y)) : f.data = y;
    }
    function r6(f, y, T, G, tt, j) {
      for (var q = f.width, lt = f.height, ct = f.channels, pt = q * lt * ct, gt = hS(f, pt), mt = 0, xt = 0; xt < lt; ++xt)
        for (var dt = 0; dt < q; ++dt)
          for (var ft = 0; ft < ct; ++ft)
            gt[mt++] = y[T * dt + G * xt + tt * ft + j];
      fS(f, gt);
    }
    function sm(f, y, T, G, tt, j) {
      var q;
      if (typeof en[f] < "u" ? q = en[f] : q = ss[f] * ad[y], j && (q *= 6), tt) {
        for (var lt = 0, ct = T; ct >= 1; )
          lt += q * ct * ct, ct /= 2;
        return lt;
      } else
        return q * T * G;
    }
    function n6(f, y, T, G, tt, j, q) {
      var lt = {
        "don't care": rm,
        "dont care": rm,
        nice: GL,
        fast: jL
      }, ct = {
        repeat: ML,
        clamp: mv,
        mirror: PL
      }, pt = {
        nearest: gv,
        linear: UL
      }, gt = r({
        mipmap: vv,
        "nearest mipmap nearest": yv,
        "linear mipmap nearest": Jw,
        "nearest mipmap linear": Qw,
        "linear mipmap linear": vv
      }, pt), mt = {
        none: 0,
        browser: tS
      }, xt = {
        uint8: nd,
        rgba4: DL,
        rgb565: LL,
        "rgb5 a1": NL
      }, dt = {
        alpha: nv,
        luminance: vh,
        "luminance alpha": em,
        rgb: tm,
        rgba: Xc,
        rgba4: Vw,
        "rgb5 a1": sv,
        rgb565: jw
      }, ft = {};
      y.ext_srgb && (dt.srgb = ov, dt.srgba = cv), y.oes_texture_float && (xt.float32 = xt.float = _h), y.oes_texture_half_float && (xt.float16 = xt["half float"] = rd), y.webgl_depth_texture && (r(dt, {
        depth: av,
        "depth stencil": im
      }), r(xt, {
        uint16: fv,
        uint32: pv,
        "depth stencil": FL
      })), y.webgl_compressed_texture_s3tc && r(ft, {
        "rgb s3tc dxt1": lv,
        "rgba s3tc dxt1": dv,
        "rgba s3tc dxt3": uv,
        "rgba s3tc dxt5": hv
      }), y.webgl_compressed_texture_atc && r(ft, {
        "rgb atc": Gw,
        "rgba atc explicit alpha": Hw,
        "rgba atc interpolated alpha": Ww
      }), y.webgl_compressed_texture_pvrtc && r(ft, {
        "rgb pvrtc 4bppv1": Yw,
        "rgb pvrtc 2bppv1": qw,
        "rgba pvrtc 4bppv1": Zw,
        "rgba pvrtc 2bppv1": Xw
      }), y.webgl_compressed_texture_etc1 && (ft["rgb etc1"] = Kw);
      var R = Array.prototype.slice.call(
        f.getParameter(OL)
      );
      Object.keys(ft).forEach(function(I) {
        var H = ft[I];
        R.indexOf(H) >= 0 && (dt[I] = H);
      });
      var Y = Object.keys(dt);
      T.textureFormats = Y;
      var ht = [];
      Object.keys(dt).forEach(function(I) {
        var H = dt[I];
        ht[H] = I;
      });
      var Lt = [];
      Object.keys(xt).forEach(function(I) {
        var H = xt[I];
        Lt[H] = I;
      });
      var st = [];
      Object.keys(pt).forEach(function(I) {
        var H = pt[I];
        st[H] = I;
      });
      var Ot = [];
      Object.keys(gt).forEach(function(I) {
        var H = gt[I];
        Ot[H] = I;
      });
      var Tt = [];
      Object.keys(ct).forEach(function(I) {
        var H = ct[I];
        Tt[H] = I;
      });
      var Jt = Y.reduce(function(I, H) {
        var U = dt[H];
        return U === vh || U === nv || U === vh || U === em || U === av || U === im || y.ext_srgb && (U === ov || U === cv) ? I[U] = U : U === sv || H.indexOf("rgba") >= 0 ? I[U] = Xc : I[U] = tm, I;
      }, {});
      function it() {
        this.internalformat = Xc, this.format = Xc, this.type = nd, this.compressed = !1, this.premultiplyAlpha = !1, this.flipY = !1, this.unpackAlignment = 1, this.colorSpace = tS, this.width = 0, this.height = 0, this.channels = 0;
      }
      function Q(I, H) {
        I.internalformat = H.internalformat, I.format = H.format, I.type = H.type, I.compressed = H.compressed, I.premultiplyAlpha = H.premultiplyAlpha, I.flipY = H.flipY, I.unpackAlignment = H.unpackAlignment, I.colorSpace = H.colorSpace, I.width = H.width, I.height = H.height, I.channels = H.channels;
      }
      function zt(I, H) {
        if (!(typeof H != "object" || !H)) {
          if ("premultiplyAlpha" in H && (_.type(
            H.premultiplyAlpha,
            "boolean",
            "invalid premultiplyAlpha"
          ), I.premultiplyAlpha = H.premultiplyAlpha), "flipY" in H && (_.type(
            H.flipY,
            "boolean",
            "invalid texture flip"
          ), I.flipY = H.flipY), "alignment" in H && (_.oneOf(
            H.alignment,
            [1, 2, 4, 8],
            "invalid texture unpack alignment"
          ), I.unpackAlignment = H.alignment), "colorSpace" in H && (_.parameter(
            H.colorSpace,
            mt,
            "invalid colorSpace"
          ), I.colorSpace = mt[H.colorSpace]), "type" in H) {
            var U = H.type;
            _(
              y.oes_texture_float || !(U === "float" || U === "float32"),
              "you must enable the OES_texture_float extension in order to use floating point textures."
            ), _(
              y.oes_texture_half_float || !(U === "half float" || U === "float16"),
              "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."
            ), _(
              y.webgl_depth_texture || !(U === "uint16" || U === "uint32" || U === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            ), _.parameter(
              U,
              xt,
              "invalid texture type"
            ), I.type = xt[U];
          }
          var $t = I.width, Ue = I.height, b = I.channels, g = !1;
          "shape" in H ? (_(
            Array.isArray(H.shape) && H.shape.length >= 2,
            "shape must be an array"
          ), $t = H.shape[0], Ue = H.shape[1], H.shape.length === 3 && (b = H.shape[2], _(b > 0 && b <= 4, "invalid number of channels"), g = !0), _($t >= 0 && $t <= T.maxTextureSize, "invalid width"), _(Ue >= 0 && Ue <= T.maxTextureSize, "invalid height")) : ("radius" in H && ($t = Ue = H.radius, _($t >= 0 && $t <= T.maxTextureSize, "invalid radius")), "width" in H && ($t = H.width, _($t >= 0 && $t <= T.maxTextureSize, "invalid width")), "height" in H && (Ue = H.height, _(Ue >= 0 && Ue <= T.maxTextureSize, "invalid height")), "channels" in H && (b = H.channels, _(b > 0 && b <= 4, "invalid number of channels"), g = !0)), I.width = $t | 0, I.height = Ue | 0, I.channels = b | 0;
          var k = !1;
          if ("format" in H) {
            var B = H.format;
            _(
              y.webgl_depth_texture || !(B === "depth" || B === "depth stencil"),
              "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."
            ), _.parameter(
              B,
              dt,
              "invalid texture format"
            );
            var P = I.internalformat = dt[B];
            I.format = Jt[P], B in xt && ("type" in H || (I.type = xt[B])), B in ft && (I.compressed = !0), k = !0;
          }
          !g && k ? I.channels = ss[I.format] : g && !k ? I.channels !== nm[I.format] && (I.format = I.internalformat = nm[I.channels]) : k && g && _(
            I.channels === ss[I.format],
            "number of channels inconsistent with specified format"
          );
        }
      }
      function wt(I) {
        f.pixelStorei(YL, I.flipY), f.pixelStorei(qL, I.premultiplyAlpha), f.pixelStorei(ZL, I.colorSpace), f.pixelStorei(WL, I.unpackAlignment);
      }
      function ut() {
        it.call(this), this.xOffset = 0, this.yOffset = 0, this.data = null, this.needsFree = !1, this.element = null, this.needsCopy = !1;
      }
      function St(I, H) {
        var U = null;
        if (_v(H) ? U = H : H && (_.type(H, "object", "invalid pixel data type"), zt(I, H), "x" in H && (I.xOffset = H.x | 0), "y" in H && (I.yOffset = H.y | 0), _v(H.data) && (U = H.data)), _(
          !I.compressed || U instanceof Uint8Array,
          "compressed texture data must be stored in a uint8array"
        ), H.copy) {
          _(!U, "can not specify copy and data field for the same texture");
          var $t = tt.viewportWidth, Ue = tt.viewportHeight;
          I.width = I.width || $t - I.xOffset, I.height = I.height || Ue - I.yOffset, I.needsCopy = !0, _(
            I.xOffset >= 0 && I.xOffset < $t && I.yOffset >= 0 && I.yOffset < Ue && I.width > 0 && I.width <= $t && I.height > 0 && I.height <= Ue,
            "copy texture read out of bounds"
          );
        } else if (!U)
          I.width = I.width || 1, I.height = I.height || 1, I.channels = I.channels || 4;
        else if (i(U))
          I.channels = I.channels || 4, I.data = U, !("type" in H) && I.type === nd && (I.type = uS(U));
        else if (oS(U))
          I.channels = I.channels || 4, i6(I, U), I.alignment = 1, I.needsFree = !0;
        else if (Os(U)) {
          var b = U.data;
          !Array.isArray(b) && I.type === nd && (I.type = uS(b));
          var g = U.shape, k = U.stride, B, P, N, D, L, x;
          g.length === 3 ? (N = g[2], x = k[2]) : (_(g.length === 2, "invalid ndarray pixel data, must be 2 or 3D"), N = 1, x = 1), B = g[0], P = g[1], D = k[0], L = k[1], I.alignment = 1, I.width = B, I.height = P, I.channels = N, I.format = I.internalformat = nm[N], I.needsFree = !0, r6(I, b, D, L, x, U.offset);
        } else if (lS(U) || dS(U) || JL(U))
          lS(U) || dS(U) ? I.element = U : I.element = U.canvas, I.width = I.element.width, I.height = I.element.height, I.channels = 4;
        else if (QL(U))
          I.element = U, I.width = U.width, I.height = U.height, I.channels = 4;
        else if (t6(U))
          I.element = U, I.width = U.naturalWidth, I.height = U.naturalHeight, I.channels = 4;
        else if (e6(U))
          I.element = U, I.width = U.videoWidth, I.height = U.videoHeight, I.channels = 4;
        else if (cS(U)) {
          var A = I.width || U[0].length, S = I.height || U.length, z = I.channels;
          Ji(U[0][0]) ? z = z || U[0][0].length : z = z || 1;
          for (var $ = Xp.shape(U), J = 1, rt = 0; rt < $.length; ++rt)
            J *= $[rt];
          var _t = hS(I, J);
          Xp.flatten(U, $, "", _t), fS(I, _t), I.alignment = 1, I.width = A, I.height = S, I.channels = z, I.format = I.internalformat = nm[z], I.needsFree = !0;
        }
        I.type === _h ? _(
          T.extensions.indexOf("oes_texture_float") >= 0,
          "oes_texture_float extension not enabled"
        ) : I.type === rd && _(
          T.extensions.indexOf("oes_texture_half_float") >= 0,
          "oes_texture_half_float extension not enabled"
        );
      }
      function At(I, H, U) {
        var $t = I.element, Ue = I.data, b = I.internalformat, g = I.format, k = I.type, B = I.width, P = I.height;
        wt(I), $t ? f.texImage2D(H, U, g, g, k, $t) : I.compressed ? f.compressedTexImage2D(H, U, b, B, P, 0, Ue) : I.needsCopy ? (G(), f.copyTexImage2D(
          H,
          U,
          g,
          I.xOffset,
          I.yOffset,
          B,
          P,
          0
        )) : f.texImage2D(H, U, g, B, P, 0, g, k, Ue || null);
      }
      function he(I, H, U, $t, Ue) {
        var b = I.element, g = I.data, k = I.internalformat, B = I.format, P = I.type, N = I.width, D = I.height;
        wt(I), b ? f.texSubImage2D(
          H,
          Ue,
          U,
          $t,
          B,
          P,
          b
        ) : I.compressed ? f.compressedTexSubImage2D(
          H,
          Ue,
          U,
          $t,
          k,
          N,
          D,
          g
        ) : I.needsCopy ? (G(), f.copyTexSubImage2D(
          H,
          Ue,
          U,
          $t,
          I.xOffset,
          I.yOffset,
          N,
          D
        )) : f.texSubImage2D(
          H,
          Ue,
          U,
          $t,
          N,
          D,
          B,
          P,
          g
        );
      }
      var ce = [];
      function Et() {
        return ce.pop() || new ut();
      }
      function Nt(I) {
        I.needsFree && nr.freeType(I.data), ut.call(I), ce.push(I);
      }
      function ne() {
        it.call(this), this.genMipmaps = !1, this.mipmapHint = rm, this.mipmask = 0, this.images = Array(16);
      }
      function fe(I, H, U) {
        var $t = I.images[0] = Et();
        I.mipmask = 1, $t.width = I.width = H, $t.height = I.height = U, $t.channels = I.channels = 4;
      }
      function je(I, H) {
        var U = null;
        if (_v(H))
          U = I.images[0] = Et(), Q(U, I), St(U, H), I.mipmask = 1;
        else if (zt(I, H), Array.isArray(H.mipmap))
          for (var $t = H.mipmap, Ue = 0; Ue < $t.length; ++Ue)
            U = I.images[Ue] = Et(), Q(U, I), U.width >>= Ue, U.height >>= Ue, St(U, $t[Ue]), I.mipmask |= 1 << Ue;
        else
          U = I.images[0] = Et(), Q(U, I), St(U, H), I.mipmask = 1;
        Q(I, I.images[0]), I.compressed && (I.internalformat === lv || I.internalformat === dv || I.internalformat === uv || I.internalformat === hv) && _(
          I.width % 4 === 0 && I.height % 4 === 0,
          "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4"
        );
      }
      function Qi(I, H) {
        for (var U = I.images, $t = 0; $t < U.length; ++$t) {
          if (!U[$t])
            return;
          At(U[$t], H, $t);
        }
      }
      var sr = [];
      function Ye() {
        var I = sr.pop() || new ne();
        it.call(I), I.mipmask = 0;
        for (var H = 0; H < 16; ++H)
          I.images[H] = null;
        return I;
      }
      function Cr(I) {
        for (var H = I.images, U = 0; U < H.length; ++U)
          H[U] && Nt(H[U]), H[U] = null;
        sr.push(I);
      }
      function Gi() {
        this.minFilter = gv, this.magFilter = gv, this.wrapS = mv, this.wrapT = mv, this.anisotropic = 1, this.genMipmaps = !1, this.mipmapHint = rm;
      }
      function Sr(I, H) {
        if ("min" in H) {
          var U = H.min;
          _.parameter(U, gt), I.minFilter = gt[U], XL.indexOf(I.minFilter) >= 0 && !("faces" in H) && (I.genMipmaps = !0);
        }
        if ("mag" in H) {
          var $t = H.mag;
          _.parameter($t, pt), I.magFilter = pt[$t];
        }
        var Ue = I.wrapS, b = I.wrapT;
        if ("wrap" in H) {
          var g = H.wrap;
          typeof g == "string" ? (_.parameter(g, ct), Ue = b = ct[g]) : Array.isArray(g) && (_.parameter(g[0], ct), _.parameter(g[1], ct), Ue = ct[g[0]], b = ct[g[1]]);
        } else {
          if ("wrapS" in H) {
            var k = H.wrapS;
            _.parameter(k, ct), Ue = ct[k];
          }
          if ("wrapT" in H) {
            var B = H.wrapT;
            _.parameter(B, ct), b = ct[B];
          }
        }
        if (I.wrapS = Ue, I.wrapT = b, "anisotropic" in H) {
          var P = H.anisotropic;
          _(
            typeof P == "number" && P >= 1 && P <= T.maxAnisotropic,
            "aniso samples must be between 1 and "
          ), I.anisotropic = H.anisotropic;
        }
        if ("mipmap" in H) {
          var N = !1;
          switch (typeof H.mipmap) {
            case "string":
              _.parameter(
                H.mipmap,
                lt,
                "invalid mipmap hint"
              ), I.mipmapHint = lt[H.mipmap], I.genMipmaps = !0, N = !0;
              break;
            case "boolean":
              N = I.genMipmaps = H.mipmap;
              break;
            case "object":
              _(Array.isArray(H.mipmap), "invalid mipmap type"), I.genMipmaps = !1, N = !0;
              break;
            default:
              _.raise("invalid mipmap type");
          }
          N && !("min" in H) && (I.minFilter = yv);
        }
      }
      function Or(I, H) {
        f.texParameteri(H, zL, I.minFilter), f.texParameteri(H, $L, I.magFilter), f.texParameteri(H, BL, I.wrapS), f.texParameteri(H, RL, I.wrapT), y.ext_texture_filter_anisotropic && f.texParameteri(H, HL, I.anisotropic), I.genMipmaps && (f.hint(VL, I.mipmapHint), f.generateMipmap(H));
      }
      var Dr = 0, Zr = {}, rn = T.maxTextureUnits, pr = Array(rn).map(function() {
        return null;
      });
      function we(I) {
        it.call(this), this.mipmask = 0, this.internalformat = Xc, this.id = Dr++, this.refCount = 1, this.target = I, this.texture = f.createTexture(), this.unit = -1, this.bindCount = 0, this.texInfo = new Gi(), q.profile && (this.stats = { size: 0 });
      }
      function nn(I) {
        f.activeTexture(bh), f.bindTexture(I.target, I.texture);
      }
      function hi() {
        var I = pr[0];
        I ? f.bindTexture(I.target, I.texture) : f.bindTexture(oa, null);
      }
      function ie(I) {
        var H = I.texture;
        _(H, "must not double destroy texture");
        var U = I.unit, $t = I.target;
        U >= 0 && (f.activeTexture(bh + U), f.bindTexture($t, null), pr[U] = null), f.deleteTexture(H), I.texture = null, I.params = null, I.pixels = null, I.refCount = 0, delete Zr[I.id], j.textureCount--;
      }
      r(we.prototype, {
        bind: function() {
          var I = this;
          I.bindCount += 1;
          var H = I.unit;
          if (H < 0) {
            for (var U = 0; U < rn; ++U) {
              var $t = pr[U];
              if ($t) {
                if ($t.bindCount > 0)
                  continue;
                $t.unit = -1;
              }
              pr[U] = I, H = U;
              break;
            }
            H >= rn && _.raise("insufficient number of texture units"), q.profile && j.maxTextureUnits < H + 1 && (j.maxTextureUnits = H + 1), I.unit = H, f.activeTexture(bh + H), f.bindTexture(I.target, I.texture);
          }
          return H;
        },
        unbind: function() {
          this.bindCount -= 1;
        },
        decRef: function() {
          --this.refCount <= 0 && ie(this);
        }
      });
      function Ge(I, H) {
        var U = new we(oa);
        Zr[U.id] = U, j.textureCount++;
        function $t(g, k) {
          var B = U.texInfo;
          Gi.call(B);
          var P = Ye();
          return typeof g == "number" ? typeof k == "number" ? fe(P, g | 0, k | 0) : fe(P, g | 0, g | 0) : g ? (_.type(g, "object", "invalid arguments to regl.texture"), Sr(B, g), je(P, g)) : fe(P, 1, 1), B.genMipmaps && (P.mipmask = (P.width << 1) - 1), U.mipmask = P.mipmask, Q(U, P), _.texture2D(B, P, T), U.internalformat = P.internalformat, $t.width = P.width, $t.height = P.height, nn(U), Qi(P, oa), Or(B, oa), hi(), Cr(P), q.profile && (U.stats.size = sm(
            U.internalformat,
            U.type,
            P.width,
            P.height,
            B.genMipmaps,
            !1
          )), $t.format = ht[U.internalformat], $t.type = Lt[U.type], $t.mag = st[B.magFilter], $t.min = Ot[B.minFilter], $t.wrapS = Tt[B.wrapS], $t.wrapT = Tt[B.wrapT], $t;
        }
        function Ue(g, k, B, P) {
          _(!!g, "must specify image data");
          var N = k | 0, D = B | 0, L = P | 0, x = Et();
          return Q(x, U), x.width = 0, x.height = 0, St(x, g), x.width = x.width || (U.width >> L) - N, x.height = x.height || (U.height >> L) - D, _(
            U.type === x.type && U.format === x.format && U.internalformat === x.internalformat,
            "incompatible format for texture.subimage"
          ), _(
            N >= 0 && D >= 0 && N + x.width <= U.width && D + x.height <= U.height,
            "texture.subimage write out of bounds"
          ), _(
            U.mipmask & 1 << L,
            "missing mipmap data"
          ), _(
            x.data || x.element || x.needsCopy,
            "missing image data"
          ), nn(U), he(x, oa, N, D, L), hi(), Nt(x), $t;
        }
        function b(g, k) {
          var B = g | 0, P = k | 0 || B;
          if (B === U.width && P === U.height)
            return $t;
          $t.width = U.width = B, $t.height = U.height = P, nn(U);
          for (var N = 0; U.mipmask >> N; ++N) {
            var D = B >> N, L = P >> N;
            if (!D || !L)
              break;
            f.texImage2D(
              oa,
              N,
              U.format,
              D,
              L,
              0,
              U.format,
              U.type,
              null
            );
          }
          return hi(), q.profile && (U.stats.size = sm(
            U.internalformat,
            U.type,
            B,
            P,
            !1,
            !1
          )), $t;
        }
        return $t(I, H), $t.subimage = Ue, $t.resize = b, $t._reglType = "texture2d", $t._texture = U, q.profile && ($t.stats = U.stats), $t.destroy = function() {
          U.decRef();
        }, $t;
      }
      function ri(I, H, U, $t, Ue, b) {
        var g = new we(rv);
        Zr[g.id] = g, j.cubeCount++;
        var k = new Array(6);
        function B(D, L, x, A, S, z) {
          var $, J = g.texInfo;
          for (Gi.call(J), $ = 0; $ < 6; ++$)
            k[$] = Ye();
          if (typeof D == "number" || !D) {
            var rt = D | 0 || 1;
            for ($ = 0; $ < 6; ++$)
              fe(k[$], rt, rt);
          } else if (typeof D == "object")
            if (L)
              je(k[0], D), je(k[1], L), je(k[2], x), je(k[3], A), je(k[4], S), je(k[5], z);
            else if (Sr(J, D), zt(g, D), "faces" in D) {
              var _t = D.faces;
              for (_(
                Array.isArray(_t) && _t.length === 6,
                "cube faces must be a length 6 array"
              ), $ = 0; $ < 6; ++$)
                _(
                  typeof _t[$] == "object" && !!_t[$],
                  "invalid input for cube map face"
                ), Q(k[$], g), je(k[$], _t[$]);
            } else
              for ($ = 0; $ < 6; ++$)
                je(k[$], D);
          else
            _.raise("invalid arguments to cube map");
          for (Q(g, k[0]), _.optional(function() {
            T.npotTextureCube || _(Uw(g.width) && Uw(g.height), "your browser does not support non power or two texture dimensions");
          }), J.genMipmaps ? g.mipmask = (k[0].width << 1) - 1 : g.mipmask = k[0].mipmask, _.textureCube(g, J, k, T), g.internalformat = k[0].internalformat, B.width = k[0].width, B.height = k[0].height, nn(g), $ = 0; $ < 6; ++$)
            Qi(k[$], Qp + $);
          for (Or(J, rv), hi(), q.profile && (g.stats.size = sm(
            g.internalformat,
            g.type,
            B.width,
            B.height,
            J.genMipmaps,
            !0
          )), B.format = ht[g.internalformat], B.type = Lt[g.type], B.mag = st[J.magFilter], B.min = Ot[J.minFilter], B.wrapS = Tt[J.wrapS], B.wrapT = Tt[J.wrapT], $ = 0; $ < 6; ++$)
            Cr(k[$]);
          return B;
        }
        function P(D, L, x, A, S) {
          _(!!L, "must specify image data"), _(typeof D == "number" && D === (D | 0) && D >= 0 && D < 6, "invalid face");
          var z = x | 0, $ = A | 0, J = S | 0, rt = Et();
          return Q(rt, g), rt.width = 0, rt.height = 0, St(rt, L), rt.width = rt.width || (g.width >> J) - z, rt.height = rt.height || (g.height >> J) - $, _(
            g.type === rt.type && g.format === rt.format && g.internalformat === rt.internalformat,
            "incompatible format for texture.subimage"
          ), _(
            z >= 0 && $ >= 0 && z + rt.width <= g.width && $ + rt.height <= g.height,
            "texture.subimage write out of bounds"
          ), _(
            g.mipmask & 1 << J,
            "missing mipmap data"
          ), _(
            rt.data || rt.element || rt.needsCopy,
            "missing image data"
          ), nn(g), he(rt, Qp + D, z, $, J), hi(), Nt(rt), B;
        }
        function N(D) {
          var L = D | 0;
          if (L !== g.width) {
            B.width = g.width = L, B.height = g.height = L, nn(g);
            for (var x = 0; x < 6; ++x)
              for (var A = 0; g.mipmask >> A; ++A)
                f.texImage2D(
                  Qp + x,
                  A,
                  g.format,
                  L >> A,
                  L >> A,
                  0,
                  g.format,
                  g.type,
                  null
                );
            return hi(), q.profile && (g.stats.size = sm(
              g.internalformat,
              g.type,
              B.width,
              B.height,
              !1,
              !0
            )), B;
          }
        }
        return B(I, H, U, $t, Ue, b), B.subimage = P, B.resize = N, B._reglType = "textureCube", B._texture = g, q.profile && (B.stats = g.stats), B.destroy = function() {
          g.decRef();
        }, B;
      }
      function mr() {
        for (var I = 0; I < rn; ++I)
          f.activeTexture(bh + I), f.bindTexture(oa, null), pr[I] = null;
        Xn(Zr).forEach(ie), j.cubeCount = 0, j.textureCount = 0;
      }
      q.profile && (j.getTotalTextureSize = function() {
        var I = 0;
        return Object.keys(Zr).forEach(function(H) {
          I += Zr[H].stats.size;
        }), I;
      });
      function la() {
        for (var I = 0; I < rn; ++I) {
          var H = pr[I];
          H && (H.bindCount = 0, H.unit = -1, pr[I] = null);
        }
        Xn(Zr).forEach(function(U) {
          U.texture = f.createTexture(), f.bindTexture(U.target, U.texture);
          for (var $t = 0; $t < 32; ++$t)
            if (U.mipmask & 1 << $t)
              if (U.target === oa)
                f.texImage2D(
                  oa,
                  $t,
                  U.internalformat,
                  U.width >> $t,
                  U.height >> $t,
                  0,
                  U.internalformat,
                  U.type,
                  null
                );
              else
                for (var Ue = 0; Ue < 6; ++Ue)
                  f.texImage2D(
                    Qp + Ue,
                    $t,
                    U.internalformat,
                    U.width >> $t,
                    U.height >> $t,
                    0,
                    U.internalformat,
                    U.type,
                    null
                  );
          Or(U.texInfo, U.target);
        });
      }
      function nl() {
        for (var I = 0; I < rn; ++I) {
          var H = pr[I];
          H && (H.bindCount = 0, H.unit = -1, pr[I] = null), f.activeTexture(bh + I), f.bindTexture(oa, null), f.bindTexture(rv, null);
        }
      }
      return {
        create2D: Ge,
        createCube: ri,
        clear: mr,
        getTexture: function(I) {
          return null;
        },
        restore: la,
        refresh: nl
      };
    }
    var Ko = 36161, am = 32854, pS = 32855, mS = 36194, gS = 33189, yS = 36168, vS = 34041, _S = 35907, bS = 34836, xS = 34842, wS = 34843, Ds = [];
    Ds[am] = 2, Ds[pS] = 2, Ds[mS] = 2, Ds[gS] = 2, Ds[yS] = 1, Ds[vS] = 4, Ds[_S] = 4, Ds[bS] = 16, Ds[xS] = 8, Ds[wS] = 6;
    function SS(f, y, T) {
      return Ds[f] * y * T;
    }
    var s6 = function(f, y, T, G, tt) {
      var j = {
        rgba4: am,
        rgb565: mS,
        "rgb5 a1": pS,
        depth: gS,
        stencil: yS,
        "depth stencil": vS
      };
      y.ext_srgb && (j.srgba = _S), y.ext_color_buffer_half_float && (j.rgba16f = xS, j.rgb16f = wS), y.webgl_color_buffer_float && (j.rgba32f = bS);
      var q = [];
      Object.keys(j).forEach(function(dt) {
        var ft = j[dt];
        q[ft] = dt;
      });
      var lt = 0, ct = {};
      function pt(dt) {
        this.id = lt++, this.refCount = 1, this.renderbuffer = dt, this.format = am, this.width = 0, this.height = 0, tt.profile && (this.stats = { size: 0 });
      }
      pt.prototype.decRef = function() {
        --this.refCount <= 0 && gt(this);
      };
      function gt(dt) {
        var ft = dt.renderbuffer;
        _(ft, "must not double destroy renderbuffer"), f.bindRenderbuffer(Ko, null), f.deleteRenderbuffer(ft), dt.renderbuffer = null, dt.refCount = 0, delete ct[dt.id], G.renderbufferCount--;
      }
      function mt(dt, ft) {
        var R = new pt(f.createRenderbuffer());
        ct[R.id] = R, G.renderbufferCount++;
        function Y(Lt, st) {
          var Ot = 0, Tt = 0, Jt = am;
          if (typeof Lt == "object" && Lt) {
            var it = Lt;
            if ("shape" in it) {
              var Q = it.shape;
              _(
                Array.isArray(Q) && Q.length >= 2,
                "invalid renderbuffer shape"
              ), Ot = Q[0] | 0, Tt = Q[1] | 0;
            } else
              "radius" in it && (Ot = Tt = it.radius | 0), "width" in it && (Ot = it.width | 0), "height" in it && (Tt = it.height | 0);
            "format" in it && (_.parameter(
              it.format,
              j,
              "invalid renderbuffer format"
            ), Jt = j[it.format]);
          } else
            typeof Lt == "number" ? (Ot = Lt | 0, typeof st == "number" ? Tt = st | 0 : Tt = Ot) : Lt ? _.raise("invalid arguments to renderbuffer constructor") : Ot = Tt = 1;
          if (_(
            Ot > 0 && Tt > 0 && Ot <= T.maxRenderbufferSize && Tt <= T.maxRenderbufferSize,
            "invalid renderbuffer size"
          ), !(Ot === R.width && Tt === R.height && Jt === R.format))
            return Y.width = R.width = Ot, Y.height = R.height = Tt, R.format = Jt, f.bindRenderbuffer(Ko, R.renderbuffer), f.renderbufferStorage(Ko, Jt, Ot, Tt), _(
              f.getError() === 0,
              "invalid render buffer format"
            ), tt.profile && (R.stats.size = SS(R.format, R.width, R.height)), Y.format = q[R.format], Y;
        }
        function ht(Lt, st) {
          var Ot = Lt | 0, Tt = st | 0 || Ot;
          return Ot === R.width && Tt === R.height || (_(
            Ot > 0 && Tt > 0 && Ot <= T.maxRenderbufferSize && Tt <= T.maxRenderbufferSize,
            "invalid renderbuffer size"
          ), Y.width = R.width = Ot, Y.height = R.height = Tt, f.bindRenderbuffer(Ko, R.renderbuffer), f.renderbufferStorage(Ko, R.format, Ot, Tt), _(
            f.getError() === 0,
            "invalid render buffer format"
          ), tt.profile && (R.stats.size = SS(
            R.format,
            R.width,
            R.height
          ))), Y;
        }
        return Y(dt, ft), Y.resize = ht, Y._reglType = "renderbuffer", Y._renderbuffer = R, tt.profile && (Y.stats = R.stats), Y.destroy = function() {
          R.decRef();
        }, Y;
      }
      tt.profile && (G.getTotalRenderbufferSize = function() {
        var dt = 0;
        return Object.keys(ct).forEach(function(ft) {
          dt += ct[ft].stats.size;
        }), dt;
      });
      function xt() {
        Xn(ct).forEach(function(dt) {
          dt.renderbuffer = f.createRenderbuffer(), f.bindRenderbuffer(Ko, dt.renderbuffer), f.renderbufferStorage(Ko, dt.format, dt.width, dt.height);
        }), f.bindRenderbuffer(Ko, null);
      }
      return {
        create: mt,
        clear: function() {
          Xn(ct).forEach(gt);
        },
        restore: xt
      };
    }, Ka = 36160, bv = 36161, Jc = 3553, om = 34069, IS = 36064, AS = 36096, TS = 36128, ES = 33306, kS = 36053, a6 = 36054, o6 = 36055, c6 = 36057, l6 = 36061, d6 = 36193, u6 = 5121, h6 = 5126, CS = 6407, OS = 6408, f6 = 6402, p6 = [
      CS,
      OS
    ], xv = [];
    xv[OS] = 4, xv[CS] = 3;
    var cm = [];
    cm[u6] = 1, cm[h6] = 4, cm[d6] = 2;
    var m6 = 32854, g6 = 32855, y6 = 36194, v6 = 33189, _6 = 36168, DS = 34041, b6 = 35907, x6 = 34836, w6 = 34842, S6 = 34843, I6 = [
      m6,
      g6,
      y6,
      b6,
      w6,
      S6,
      x6
    ], od = {};
    od[kS] = "complete", od[a6] = "incomplete attachment", od[c6] = "incomplete dimensions", od[o6] = "incomplete, missing attachment", od[l6] = "unsupported";
    function A6(f, y, T, G, tt, j) {
      var q = {
        cur: null,
        next: null,
        dirty: !1,
        setFBO: null
      }, lt = ["rgba"], ct = ["rgba4", "rgb565", "rgb5 a1"];
      y.ext_srgb && ct.push("srgba"), y.ext_color_buffer_half_float && ct.push("rgba16f", "rgb16f"), y.webgl_color_buffer_float && ct.push("rgba32f");
      var pt = ["uint8"];
      y.oes_texture_half_float && pt.push("half float", "float16"), y.oes_texture_float && pt.push("float", "float32");
      function gt(ut, St, At) {
        this.target = ut, this.texture = St, this.renderbuffer = At;
        var he = 0, ce = 0;
        St ? (he = St.width, ce = St.height) : At && (he = At.width, ce = At.height), this.width = he, this.height = ce;
      }
      function mt(ut) {
        ut && (ut.texture && ut.texture._texture.decRef(), ut.renderbuffer && ut.renderbuffer._renderbuffer.decRef());
      }
      function xt(ut, St, At) {
        if (ut)
          if (ut.texture) {
            var he = ut.texture._texture, ce = Math.max(1, he.width), Et = Math.max(1, he.height);
            _(
              ce === St && Et === At,
              "inconsistent width/height for supplied texture"
            ), he.refCount += 1;
          } else {
            var Nt = ut.renderbuffer._renderbuffer;
            _(
              Nt.width === St && Nt.height === At,
              "inconsistent width/height for renderbuffer"
            ), Nt.refCount += 1;
          }
      }
      function dt(ut, St) {
        St && (St.texture ? f.framebufferTexture2D(
          Ka,
          ut,
          St.target,
          St.texture._texture.texture,
          0
        ) : f.framebufferRenderbuffer(
          Ka,
          ut,
          bv,
          St.renderbuffer._renderbuffer.renderbuffer
        ));
      }
      function ft(ut) {
        var St = Jc, At = null, he = null, ce = ut;
        typeof ut == "object" && (ce = ut.data, "target" in ut && (St = ut.target | 0)), _.type(ce, "function", "invalid attachment data");
        var Et = ce._reglType;
        return Et === "texture2d" ? (At = ce, _(St === Jc)) : Et === "textureCube" ? (At = ce, _(
          St >= om && St < om + 6,
          "invalid cube map target"
        )) : Et === "renderbuffer" ? (he = ce, St = bv) : _.raise("invalid regl object for attachment"), new gt(St, At, he);
      }
      function R(ut, St, At, he, ce) {
        if (At) {
          var Et = G.create2D({
            width: ut,
            height: St,
            format: he,
            type: ce
          });
          return Et._texture.refCount = 0, new gt(Jc, Et, null);
        } else {
          var Nt = tt.create({
            width: ut,
            height: St,
            format: he
          });
          return Nt._renderbuffer.refCount = 0, new gt(bv, null, Nt);
        }
      }
      function Y(ut) {
        return ut && (ut.texture || ut.renderbuffer);
      }
      function ht(ut, St, At) {
        ut && (ut.texture ? ut.texture.resize(St, At) : ut.renderbuffer && ut.renderbuffer.resize(St, At), ut.width = St, ut.height = At);
      }
      var Lt = 0, st = {};
      function Ot() {
        this.id = Lt++, st[this.id] = this, this.framebuffer = f.createFramebuffer(), this.width = 0, this.height = 0, this.colorAttachments = [], this.depthAttachment = null, this.stencilAttachment = null, this.depthStencilAttachment = null;
      }
      function Tt(ut) {
        ut.colorAttachments.forEach(mt), mt(ut.depthAttachment), mt(ut.stencilAttachment), mt(ut.depthStencilAttachment);
      }
      function Jt(ut) {
        var St = ut.framebuffer;
        _(St, "must not double destroy framebuffer"), f.deleteFramebuffer(St), ut.framebuffer = null, j.framebufferCount--, delete st[ut.id];
      }
      function it(ut) {
        var St;
        f.bindFramebuffer(Ka, ut.framebuffer);
        var At = ut.colorAttachments;
        for (St = 0; St < At.length; ++St)
          dt(IS + St, At[St]);
        for (St = At.length; St < T.maxColorAttachments; ++St)
          f.framebufferTexture2D(
            Ka,
            IS + St,
            Jc,
            null,
            0
          );
        f.framebufferTexture2D(
          Ka,
          ES,
          Jc,
          null,
          0
        ), f.framebufferTexture2D(
          Ka,
          AS,
          Jc,
          null,
          0
        ), f.framebufferTexture2D(
          Ka,
          TS,
          Jc,
          null,
          0
        ), dt(AS, ut.depthAttachment), dt(TS, ut.stencilAttachment), dt(ES, ut.depthStencilAttachment);
        var he = f.checkFramebufferStatus(Ka);
        !f.isContextLost() && he !== kS && _.raise("framebuffer configuration not supported, status = " + od[he]), f.bindFramebuffer(Ka, q.next ? q.next.framebuffer : null), q.cur = q.next, f.getError();
      }
      function Q(ut, St) {
        var At = new Ot();
        j.framebufferCount++;
        function he(Et, Nt) {
          var ne;
          _(
            q.next !== At,
            "can not update framebuffer which is currently in use"
          );
          var fe = 0, je = 0, Qi = !0, sr = !0, Ye = null, Cr = !0, Gi = "rgba", Sr = "uint8", Or = 1, Dr = null, Zr = null, rn = null, pr = !1;
          if (typeof Et == "number")
            fe = Et | 0, je = Nt | 0 || fe;
          else if (!Et)
            fe = je = 1;
          else {
            _.type(Et, "object", "invalid arguments for framebuffer");
            var we = Et;
            if ("shape" in we) {
              var nn = we.shape;
              _(
                Array.isArray(nn) && nn.length >= 2,
                "invalid shape for framebuffer"
              ), fe = nn[0], je = nn[1];
            } else
              "radius" in we && (fe = je = we.radius), "width" in we && (fe = we.width), "height" in we && (je = we.height);
            ("color" in we || "colors" in we) && (Ye = we.color || we.colors, Array.isArray(Ye) && _(
              Ye.length === 1 || y.webgl_draw_buffers,
              "multiple render targets not supported"
            )), Ye || ("colorCount" in we && (Or = we.colorCount | 0, _(Or > 0, "invalid color buffer count")), "colorTexture" in we && (Cr = !!we.colorTexture, Gi = "rgba4"), "colorType" in we && (Sr = we.colorType, Cr ? (_(
              y.oes_texture_float || !(Sr === "float" || Sr === "float32"),
              "you must enable OES_texture_float in order to use floating point framebuffer objects"
            ), _(
              y.oes_texture_half_float || !(Sr === "half float" || Sr === "float16"),
              "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects"
            )) : Sr === "half float" || Sr === "float16" ? (_(
              y.ext_color_buffer_half_float,
              "you must enable EXT_color_buffer_half_float to use 16-bit render buffers"
            ), Gi = "rgba16f") : (Sr === "float" || Sr === "float32") && (_(
              y.webgl_color_buffer_float,
              "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"
            ), Gi = "rgba32f"), _.oneOf(Sr, pt, "invalid color type")), "colorFormat" in we && (Gi = we.colorFormat, lt.indexOf(Gi) >= 0 ? Cr = !0 : ct.indexOf(Gi) >= 0 ? Cr = !1 : _.optional(function() {
              Cr ? _.oneOf(
                we.colorFormat,
                lt,
                "invalid color format for texture"
              ) : _.oneOf(
                we.colorFormat,
                ct,
                "invalid color format for renderbuffer"
              );
            }))), ("depthTexture" in we || "depthStencilTexture" in we) && (pr = !!(we.depthTexture || we.depthStencilTexture), _(
              !pr || y.webgl_depth_texture,
              "webgl_depth_texture extension not supported"
            )), "depth" in we && (typeof we.depth == "boolean" ? Qi = we.depth : (Dr = we.depth, sr = !1)), "stencil" in we && (typeof we.stencil == "boolean" ? sr = we.stencil : (Zr = we.stencil, Qi = !1)), "depthStencil" in we && (typeof we.depthStencil == "boolean" ? Qi = sr = we.depthStencil : (rn = we.depthStencil, Qi = !1, sr = !1));
          }
          var hi = null, ie = null, Ge = null, ri = null;
          if (Array.isArray(Ye))
            hi = Ye.map(ft);
          else if (Ye)
            hi = [ft(Ye)];
          else
            for (hi = new Array(Or), ne = 0; ne < Or; ++ne)
              hi[ne] = R(
                fe,
                je,
                Cr,
                Gi,
                Sr
              );
          _(
            y.webgl_draw_buffers || hi.length <= 1,
            "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."
          ), _(
            hi.length <= T.maxColorAttachments,
            "too many color attachments, not supported"
          ), fe = fe || hi[0].width, je = je || hi[0].height, Dr ? ie = ft(Dr) : Qi && !sr && (ie = R(
            fe,
            je,
            pr,
            "depth",
            "uint32"
          )), Zr ? Ge = ft(Zr) : sr && !Qi && (Ge = R(
            fe,
            je,
            !1,
            "stencil",
            "uint8"
          )), rn ? ri = ft(rn) : !Dr && !Zr && sr && Qi && (ri = R(
            fe,
            je,
            pr,
            "depth stencil",
            "depth stencil"
          )), _(
            !!Dr + !!Zr + !!rn <= 1,
            "invalid framebuffer configuration, can specify exactly one depth/stencil attachment"
          );
          var mr = null;
          for (ne = 0; ne < hi.length; ++ne)
            if (xt(hi[ne], fe, je), _(
              !hi[ne] || hi[ne].texture && p6.indexOf(hi[ne].texture._texture.format) >= 0 || hi[ne].renderbuffer && I6.indexOf(hi[ne].renderbuffer._renderbuffer.format) >= 0,
              "framebuffer color attachment " + ne + " is invalid"
            ), hi[ne] && hi[ne].texture) {
              var la = xv[hi[ne].texture._texture.format] * cm[hi[ne].texture._texture.type];
              mr === null ? mr = la : _(
                mr === la,
                "all color attachments much have the same number of bits per pixel."
              );
            }
          return xt(ie, fe, je), _(
            !ie || ie.texture && ie.texture._texture.format === f6 || ie.renderbuffer && ie.renderbuffer._renderbuffer.format === v6,
            "invalid depth attachment for framebuffer object"
          ), xt(Ge, fe, je), _(
            !Ge || Ge.renderbuffer && Ge.renderbuffer._renderbuffer.format === _6,
            "invalid stencil attachment for framebuffer object"
          ), xt(ri, fe, je), _(
            !ri || ri.texture && ri.texture._texture.format === DS || ri.renderbuffer && ri.renderbuffer._renderbuffer.format === DS,
            "invalid depth-stencil attachment for framebuffer object"
          ), Tt(At), At.width = fe, At.height = je, At.colorAttachments = hi, At.depthAttachment = ie, At.stencilAttachment = Ge, At.depthStencilAttachment = ri, he.color = hi.map(Y), he.depth = Y(ie), he.stencil = Y(Ge), he.depthStencil = Y(ri), he.width = At.width, he.height = At.height, it(At), he;
        }
        function ce(Et, Nt) {
          _(
            q.next !== At,
            "can not resize a framebuffer which is currently in use"
          );
          var ne = Math.max(Et | 0, 1), fe = Math.max(Nt | 0 || ne, 1);
          if (ne === At.width && fe === At.height)
            return he;
          for (var je = At.colorAttachments, Qi = 0; Qi < je.length; ++Qi)
            ht(je[Qi], ne, fe);
          return ht(At.depthAttachment, ne, fe), ht(At.stencilAttachment, ne, fe), ht(At.depthStencilAttachment, ne, fe), At.width = he.width = ne, At.height = he.height = fe, it(At), he;
        }
        return he(ut, St), r(he, {
          resize: ce,
          _reglType: "framebuffer",
          _framebuffer: At,
          destroy: function() {
            Jt(At), Tt(At);
          },
          use: function(Et) {
            q.setFBO({
              framebuffer: he
            }, Et);
          }
        });
      }
      function zt(ut) {
        var St = Array(6);
        function At(ce) {
          var Et;
          _(
            St.indexOf(q.next) < 0,
            "can not update framebuffer which is currently in use"
          );
          var Nt = {
            color: null
          }, ne = 0, fe = null, je = "rgba", Qi = "uint8", sr = 1;
          if (typeof ce == "number")
            ne = ce | 0;
          else if (!ce)
            ne = 1;
          else {
            _.type(ce, "object", "invalid arguments for framebuffer");
            var Ye = ce;
            if ("shape" in Ye) {
              var Cr = Ye.shape;
              _(
                Array.isArray(Cr) && Cr.length >= 2,
                "invalid shape for framebuffer"
              ), _(
                Cr[0] === Cr[1],
                "cube framebuffer must be square"
              ), ne = Cr[0];
            } else
              "radius" in Ye && (ne = Ye.radius | 0), "width" in Ye ? (ne = Ye.width | 0, "height" in Ye && _(Ye.height === ne, "must be square")) : "height" in Ye && (ne = Ye.height | 0);
            ("color" in Ye || "colors" in Ye) && (fe = Ye.color || Ye.colors, Array.isArray(fe) && _(
              fe.length === 1 || y.webgl_draw_buffers,
              "multiple render targets not supported"
            )), fe || ("colorCount" in Ye && (sr = Ye.colorCount | 0, _(sr > 0, "invalid color buffer count")), "colorType" in Ye && (_.oneOf(
              Ye.colorType,
              pt,
              "invalid color type"
            ), Qi = Ye.colorType), "colorFormat" in Ye && (je = Ye.colorFormat, _.oneOf(
              Ye.colorFormat,
              lt,
              "invalid color format for texture"
            ))), "depth" in Ye && (Nt.depth = Ye.depth), "stencil" in Ye && (Nt.stencil = Ye.stencil), "depthStencil" in Ye && (Nt.depthStencil = Ye.depthStencil);
          }
          var Gi;
          if (fe)
            if (Array.isArray(fe))
              for (Gi = [], Et = 0; Et < fe.length; ++Et)
                Gi[Et] = fe[Et];
            else
              Gi = [fe];
          else {
            Gi = Array(sr);
            var Sr = {
              radius: ne,
              format: je,
              type: Qi
            };
            for (Et = 0; Et < sr; ++Et)
              Gi[Et] = G.createCube(Sr);
          }
          for (Nt.color = Array(Gi.length), Et = 0; Et < Gi.length; ++Et) {
            var Or = Gi[Et];
            _(
              typeof Or == "function" && Or._reglType === "textureCube",
              "invalid cube map"
            ), ne = ne || Or.width, _(
              Or.width === ne && Or.height === ne,
              "invalid cube map shape"
            ), Nt.color[Et] = {
              target: om,
              data: Gi[Et]
            };
          }
          for (Et = 0; Et < 6; ++Et) {
            for (var Dr = 0; Dr < Gi.length; ++Dr)
              Nt.color[Dr].target = om + Et;
            Et > 0 && (Nt.depth = St[0].depth, Nt.stencil = St[0].stencil, Nt.depthStencil = St[0].depthStencil), St[Et] ? St[Et](Nt) : St[Et] = Q(Nt);
          }
          return r(At, {
            width: ne,
            height: ne,
            color: Gi
          });
        }
        function he(ce) {
          var Et, Nt = ce | 0;
          if (_(
            Nt > 0 && Nt <= T.maxCubeMapSize,
            "invalid radius for cube fbo"
          ), Nt === At.width)
            return At;
          var ne = At.color;
          for (Et = 0; Et < ne.length; ++Et)
            ne[Et].resize(Nt);
          for (Et = 0; Et < 6; ++Et)
            St[Et].resize(Nt);
          return At.width = At.height = Nt, At;
        }
        return At(ut), r(At, {
          faces: St,
          resize: he,
          _reglType: "framebufferCube",
          destroy: function() {
            St.forEach(function(ce) {
              ce.destroy();
            });
          }
        });
      }
      function wt() {
        q.cur = null, q.next = null, q.dirty = !0, Xn(st).forEach(function(ut) {
          ut.framebuffer = f.createFramebuffer(), it(ut);
        });
      }
      return r(q, {
        getFramebuffer: function(ut) {
          if (typeof ut == "function" && ut._reglType === "framebuffer") {
            var St = ut._framebuffer;
            if (St instanceof Ot)
              return St;
          }
          return null;
        },
        create: Q,
        createCube: zt,
        clear: function() {
          Xn(st).forEach(Jt);
        },
        restore: wt
      });
    }
    var T6 = 5126, NS = 34962, lm = 34963, LS = [
      "attributes",
      "elements",
      "offset",
      "count",
      "primitive",
      "instances"
    ];
    function wv() {
      this.state = 0, this.x = 0, this.y = 0, this.z = 0, this.w = 0, this.buffer = null, this.size = 0, this.normalized = !1, this.type = T6, this.offset = 0, this.stride = 0, this.divisor = 0;
    }
    function E6(f, y, T, G, tt, j, q) {
      for (var lt = T.maxAttributes, ct = new Array(lt), pt = 0; pt < lt; ++pt)
        ct[pt] = new wv();
      var gt = 0, mt = {}, xt = {
        Record: wv,
        scope: {},
        state: ct,
        currentVAO: null,
        targetVAO: null,
        restore: ft() ? Tt : function() {
        },
        createVAO: Jt,
        getVAO: Y,
        destroyBuffer: dt,
        setVAO: ft() ? ht : Lt,
        clear: ft() ? st : function() {
        }
      };
      function dt(it) {
        for (var Q = 0; Q < ct.length; ++Q) {
          var zt = ct[Q];
          zt.buffer === it && (f.disableVertexAttribArray(Q), zt.buffer = null);
        }
      }
      function ft() {
        return y.oes_vertex_array_object;
      }
      function R() {
        return y.angle_instanced_arrays;
      }
      function Y(it) {
        return typeof it == "function" && it._vao ? it._vao : null;
      }
      function ht(it) {
        if (it !== xt.currentVAO) {
          var Q = ft();
          it ? Q.bindVertexArrayOES(it.vao) : Q.bindVertexArrayOES(null), xt.currentVAO = it;
        }
      }
      function Lt(it) {
        if (it !== xt.currentVAO) {
          if (it)
            it.bindAttrs();
          else {
            for (var Q = R(), zt = 0; zt < ct.length; ++zt) {
              var wt = ct[zt];
              wt.buffer ? (f.enableVertexAttribArray(zt), wt.buffer.bind(), f.vertexAttribPointer(zt, wt.size, wt.type, wt.normalized, wt.stride, wt.offfset), Q && wt.divisor && Q.vertexAttribDivisorANGLE(zt, wt.divisor)) : (f.disableVertexAttribArray(zt), f.vertexAttrib4f(zt, wt.x, wt.y, wt.z, wt.w));
            }
            q.elements ? f.bindBuffer(lm, q.elements.buffer.buffer) : f.bindBuffer(lm, null);
          }
          xt.currentVAO = it;
        }
      }
      function st() {
        Xn(mt).forEach(function(it) {
          it.destroy();
        });
      }
      function Ot() {
        this.id = ++gt, this.attributes = [], this.elements = null, this.ownsElements = !1, this.count = 0, this.offset = 0, this.instances = -1, this.primitive = 4;
        var it = ft();
        it ? this.vao = it.createVertexArrayOES() : this.vao = null, mt[this.id] = this, this.buffers = [];
      }
      Ot.prototype.bindAttrs = function() {
        for (var it = R(), Q = this.attributes, zt = 0; zt < Q.length; ++zt) {
          var wt = Q[zt];
          wt.buffer ? (f.enableVertexAttribArray(zt), f.bindBuffer(NS, wt.buffer.buffer), f.vertexAttribPointer(zt, wt.size, wt.type, wt.normalized, wt.stride, wt.offset), it && wt.divisor && it.vertexAttribDivisorANGLE(zt, wt.divisor)) : (f.disableVertexAttribArray(zt), f.vertexAttrib4f(zt, wt.x, wt.y, wt.z, wt.w));
        }
        for (var ut = Q.length; ut < lt; ++ut)
          f.disableVertexAttribArray(ut);
        var St = j.getElements(this.elements);
        St ? f.bindBuffer(lm, St.buffer.buffer) : f.bindBuffer(lm, null);
      }, Ot.prototype.refresh = function() {
        var it = ft();
        it && (it.bindVertexArrayOES(this.vao), this.bindAttrs(), xt.currentVAO = null, it.bindVertexArrayOES(null));
      }, Ot.prototype.destroy = function() {
        if (this.vao) {
          var it = ft();
          this === xt.currentVAO && (xt.currentVAO = null, it.bindVertexArrayOES(null)), it.deleteVertexArrayOES(this.vao), this.vao = null;
        }
        this.ownsElements && (this.elements.destroy(), this.elements = null, this.ownsElements = !1), mt[this.id] && (delete mt[this.id], G.vaoCount -= 1);
      };
      function Tt() {
        var it = ft();
        it && Xn(mt).forEach(function(Q) {
          Q.refresh();
        });
      }
      function Jt(it) {
        var Q = new Ot();
        G.vaoCount += 1;
        function zt(wt) {
          var ut;
          if (Array.isArray(wt))
            ut = wt, Q.elements && Q.ownsElements && Q.elements.destroy(), Q.elements = null, Q.ownsElements = !1, Q.offset = 0, Q.count = 0, Q.instances = -1, Q.primitive = 4;
          else {
            if (_(typeof wt == "object", "invalid arguments for create vao"), _("attributes" in wt, "must specify attributes for vao"), wt.elements) {
              var St = wt.elements;
              Q.ownsElements ? typeof St == "function" && St._reglType === "elements" ? (Q.elements.destroy(), Q.ownsElements = !1) : (Q.elements(St), Q.ownsElements = !1) : j.getElements(wt.elements) ? (Q.elements = wt.elements, Q.ownsElements = !1) : (Q.elements = j.create(wt.elements), Q.ownsElements = !0);
            } else
              Q.elements = null, Q.ownsElements = !1;
            ut = wt.attributes, Q.offset = 0, Q.count = -1, Q.instances = -1, Q.primitive = 4, Q.elements && (Q.count = Q.elements._elements.vertCount, Q.primitive = Q.elements._elements.primType), "offset" in wt && (Q.offset = wt.offset | 0), "count" in wt && (Q.count = wt.count | 0), "instances" in wt && (Q.instances = wt.instances | 0), "primitive" in wt && (_(wt.primitive in Xo, "bad primitive type: " + wt.primitive), Q.primitive = Xo[wt.primitive]), _.optional(() => {
              for (var Qi = Object.keys(wt), sr = 0; sr < Qi.length; ++sr)
                _(LS.indexOf(Qi[sr]) >= 0, 'invalid option for vao: "' + Qi[sr] + '" valid options are ' + LS);
            }), _(Array.isArray(ut), "attributes must be an array");
          }
          _(ut.length < lt, "too many attributes"), _(ut.length > 0, "must specify at least one attribute");
          var At = {}, he = Q.attributes;
          he.length = ut.length;
          for (var ce = 0; ce < ut.length; ++ce) {
            var Et = ut[ce], Nt = he[ce] = new wv(), ne = Et.data || Et;
            if (Array.isArray(ne) || i(ne) || Os(ne)) {
              var fe;
              Q.buffers[ce] && (fe = Q.buffers[ce], i(ne) && fe._buffer.byteLength >= ne.byteLength ? fe.subdata(ne) : (fe.destroy(), Q.buffers[ce] = null)), Q.buffers[ce] || (fe = Q.buffers[ce] = tt.create(Et, NS, !1, !0)), Nt.buffer = tt.getBuffer(fe), Nt.size = Nt.buffer.dimension | 0, Nt.normalized = !1, Nt.type = Nt.buffer.dtype, Nt.offset = 0, Nt.stride = 0, Nt.divisor = 0, Nt.state = 1, At[ce] = 1;
            } else
              tt.getBuffer(Et) ? (Nt.buffer = tt.getBuffer(Et), Nt.size = Nt.buffer.dimension | 0, Nt.normalized = !1, Nt.type = Nt.buffer.dtype, Nt.offset = 0, Nt.stride = 0, Nt.divisor = 0, Nt.state = 1) : tt.getBuffer(Et.buffer) ? (Nt.buffer = tt.getBuffer(Et.buffer), Nt.size = (+Et.size || Nt.buffer.dimension) | 0, Nt.normalized = !!Et.normalized || !1, "type" in Et ? (_.parameter(Et.type, qc, "invalid buffer type"), Nt.type = qc[Et.type]) : Nt.type = Nt.buffer.dtype, Nt.offset = (Et.offset || 0) | 0, Nt.stride = (Et.stride || 0) | 0, Nt.divisor = (Et.divisor || 0) | 0, Nt.state = 1, _(Nt.size >= 1 && Nt.size <= 4, "size must be between 1 and 4"), _(Nt.offset >= 0, "invalid offset"), _(Nt.stride >= 0 && Nt.stride <= 255, "stride must be between 0 and 255"), _(Nt.divisor >= 0, "divisor must be positive"), _(!Nt.divisor || !!y.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor")) : "x" in Et ? (_(ce > 0, "first attribute must not be a constant"), Nt.x = +Et.x || 0, Nt.y = +Et.y || 0, Nt.z = +Et.z || 0, Nt.w = +Et.w || 0, Nt.state = 2) : _(!1, "invalid attribute spec for location " + ce);
          }
          for (var je = 0; je < Q.buffers.length; ++je)
            !At[je] && Q.buffers[je] && (Q.buffers[je].destroy(), Q.buffers[je] = null);
          return Q.refresh(), zt;
        }
        return zt.destroy = function() {
          for (var wt = 0; wt < Q.buffers.length; ++wt)
            Q.buffers[wt] && Q.buffers[wt].destroy();
          Q.buffers.length = 0, Q.ownsElements && (Q.elements.destroy(), Q.elements = null, Q.ownsElements = !1), Q.destroy();
        }, zt._vao = Q, zt._reglType = "vao", zt(it);
      }
      return xt;
    }
    var FS = 35632, k6 = 35633, C6 = 35718, O6 = 35721;
    function D6(f, y, T, G) {
      var tt = {}, j = {};
      function q(R, Y, ht, Lt) {
        this.name = R, this.id = Y, this.location = ht, this.info = Lt;
      }
      function lt(R, Y) {
        for (var ht = 0; ht < R.length; ++ht)
          if (R[ht].id === Y.id) {
            R[ht].location = Y.location;
            return;
          }
        R.push(Y);
      }
      function ct(R, Y, ht) {
        var Lt = R === FS ? tt : j, st = Lt[Y];
        if (!st) {
          var Ot = y.str(Y);
          st = f.createShader(R), f.shaderSource(st, Ot), f.compileShader(st), _.shaderError(f, st, Ot, R, ht), Lt[Y] = st;
        }
        return st;
      }
      var pt = {}, gt = [], mt = 0;
      function xt(R, Y) {
        this.id = mt++, this.fragId = R, this.vertId = Y, this.program = null, this.uniforms = [], this.attributes = [], this.refCount = 1, G.profile && (this.stats = {
          uniformsCount: 0,
          attributesCount: 0
        });
      }
      function dt(R, Y, ht) {
        var Lt, st, Ot = ct(FS, R.fragId), Tt = ct(k6, R.vertId), Jt = R.program = f.createProgram();
        if (f.attachShader(Jt, Ot), f.attachShader(Jt, Tt), ht)
          for (Lt = 0; Lt < ht.length; ++Lt) {
            var it = ht[Lt];
            f.bindAttribLocation(Jt, it[0], it[1]);
          }
        f.linkProgram(Jt), _.linkError(
          f,
          Jt,
          y.str(R.fragId),
          y.str(R.vertId),
          Y
        );
        var Q = f.getProgramParameter(Jt, C6);
        G.profile && (R.stats.uniformsCount = Q);
        var zt = R.uniforms;
        for (Lt = 0; Lt < Q; ++Lt)
          if (st = f.getActiveUniform(Jt, Lt), st) {
            if (st.size > 1)
              for (var wt = 0; wt < st.size; ++wt) {
                var ut = st.name.replace("[0]", "[" + wt + "]");
                lt(zt, new q(
                  ut,
                  y.id(ut),
                  f.getUniformLocation(Jt, ut),
                  st
                ));
              }
            var St = st.name;
            st.size > 1 && (St = St.replace("[0]", "")), lt(zt, new q(
              St,
              y.id(St),
              f.getUniformLocation(Jt, St),
              st
            ));
          }
        var At = f.getProgramParameter(Jt, O6);
        G.profile && (R.stats.attributesCount = At);
        var he = R.attributes;
        for (Lt = 0; Lt < At; ++Lt)
          st = f.getActiveAttrib(Jt, Lt), st && lt(he, new q(
            st.name,
            y.id(st.name),
            f.getAttribLocation(Jt, st.name),
            st
          ));
      }
      G.profile && (T.getMaxUniformsCount = function() {
        var R = 0;
        return gt.forEach(function(Y) {
          Y.stats.uniformsCount > R && (R = Y.stats.uniformsCount);
        }), R;
      }, T.getMaxAttributesCount = function() {
        var R = 0;
        return gt.forEach(function(Y) {
          Y.stats.attributesCount > R && (R = Y.stats.attributesCount);
        }), R;
      });
      function ft() {
        tt = {}, j = {};
        for (var R = 0; R < gt.length; ++R)
          dt(gt[R], null, gt[R].attributes.map(function(Y) {
            return [Y.location, Y.name];
          }));
      }
      return {
        clear: function() {
          var R = f.deleteShader.bind(f);
          Xn(tt).forEach(R), tt = {}, Xn(j).forEach(R), j = {}, gt.forEach(function(Y) {
            f.deleteProgram(Y.program);
          }), gt.length = 0, pt = {}, T.shaderCount = 0;
        },
        program: function(R, Y, ht, Lt) {
          _.command(R >= 0, "missing vertex shader", ht), _.command(Y >= 0, "missing fragment shader", ht);
          var st = pt[Y];
          st || (st = pt[Y] = {});
          var Ot = st[R];
          if (Ot && (Ot.refCount++, !Lt))
            return Ot;
          var Tt = new xt(Y, R);
          return T.shaderCount++, dt(Tt, ht, Lt), Ot || (st[R] = Tt), gt.push(Tt), r(Tt, {
            destroy: function() {
              if (Tt.refCount--, Tt.refCount <= 0) {
                f.deleteProgram(Tt.program);
                var Jt = gt.indexOf(Tt);
                gt.splice(Jt, 1), T.shaderCount--;
              }
              st[Tt.vertId].refCount <= 0 && (f.deleteShader(j[Tt.vertId]), delete j[Tt.vertId], delete pt[Tt.fragId][Tt.vertId]), Object.keys(pt[Tt.fragId]).length || (f.deleteShader(tt[Tt.fragId]), delete tt[Tt.fragId], delete pt[Tt.fragId]);
            }
          });
        },
        restore: ft,
        shader: ct,
        frag: -1,
        vert: -1
      };
    }
    var N6 = 6408, xh = 5121, L6 = 3333, dm = 5126;
    function F6(f, y, T, G, tt, j, q) {
      function lt(gt) {
        var mt;
        y.next === null ? (_(
          tt.preserveDrawingBuffer,
          'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'
        ), mt = xh) : (_(
          y.next.colorAttachments[0].texture !== null,
          "You cannot read from a renderbuffer"
        ), mt = y.next.colorAttachments[0].texture._texture.type, _.optional(function() {
          j.oes_texture_float ? (_(
            mt === xh || mt === dm,
            "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"
          ), mt === dm && _(q.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")) : _(
            mt === xh,
            "Reading from a framebuffer is only allowed for the type 'uint8'"
          );
        }));
        var xt = 0, dt = 0, ft = G.framebufferWidth, R = G.framebufferHeight, Y = null;
        i(gt) ? Y = gt : gt && (_.type(gt, "object", "invalid arguments to regl.read()"), xt = gt.x | 0, dt = gt.y | 0, _(
          xt >= 0 && xt < G.framebufferWidth,
          "invalid x offset for regl.read"
        ), _(
          dt >= 0 && dt < G.framebufferHeight,
          "invalid y offset for regl.read"
        ), ft = (gt.width || G.framebufferWidth - xt) | 0, R = (gt.height || G.framebufferHeight - dt) | 0, Y = gt.data || null), Y && (mt === xh ? _(
          Y instanceof Uint8Array,
          "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"
        ) : mt === dm && _(
          Y instanceof Float32Array,
          "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'"
        )), _(
          ft > 0 && ft + xt <= G.framebufferWidth,
          "invalid width for read pixels"
        ), _(
          R > 0 && R + dt <= G.framebufferHeight,
          "invalid height for read pixels"
        ), T();
        var ht = ft * R * 4;
        return Y || (mt === xh ? Y = new Uint8Array(ht) : mt === dm && (Y = Y || new Float32Array(ht))), _.isTypedArray(Y, "data buffer for regl.read() must be a typedarray"), _(Y.byteLength >= ht, "data buffer for regl.read() too small"), f.pixelStorei(L6, 4), f.readPixels(
          xt,
          dt,
          ft,
          R,
          N6,
          mt,
          Y
        ), Y;
      }
      function ct(gt) {
        var mt;
        return y.setFBO({
          framebuffer: gt.framebuffer
        }, function() {
          mt = lt(gt);
        }), mt;
      }
      function pt(gt) {
        return !gt || !("framebuffer" in gt) ? lt(gt) : ct(gt);
      }
      return pt;
    }
    function cd(f) {
      return Array.prototype.slice.call(f);
    }
    function ld(f) {
      return cd(f).join("");
    }
    function B6() {
      var f = 0, y = [], T = [];
      function G(mt) {
        for (var xt = 0; xt < T.length; ++xt)
          if (T[xt] === mt)
            return y[xt];
        var dt = "g" + f++;
        return y.push(dt), T.push(mt), dt;
      }
      function tt() {
        var mt = [];
        function xt() {
          mt.push.apply(mt, cd(arguments));
        }
        var dt = [];
        function ft() {
          var R = "v" + f++;
          return dt.push(R), arguments.length > 0 && (mt.push(R, "="), mt.push.apply(mt, cd(arguments)), mt.push(";")), R;
        }
        return r(xt, {
          def: ft,
          toString: function() {
            return ld([
              dt.length > 0 ? "var " + dt.join(",") + ";" : "",
              ld(mt)
            ]);
          }
        });
      }
      function j() {
        var mt = tt(), xt = tt(), dt = mt.toString, ft = xt.toString;
        function R(Y, ht) {
          xt(Y, ht, "=", mt.def(Y, ht), ";");
        }
        return r(function() {
          mt.apply(mt, cd(arguments));
        }, {
          def: mt.def,
          entry: mt,
          exit: xt,
          save: R,
          set: function(Y, ht, Lt) {
            R(Y, ht), mt(Y, ht, "=", Lt, ";");
          },
          toString: function() {
            return dt() + ft();
          }
        });
      }
      function q() {
        var mt = ld(arguments), xt = j(), dt = j(), ft = xt.toString, R = dt.toString;
        return r(xt, {
          then: function() {
            return xt.apply(xt, cd(arguments)), this;
          },
          else: function() {
            return dt.apply(dt, cd(arguments)), this;
          },
          toString: function() {
            var Y = R();
            return Y && (Y = "else{" + Y + "}"), ld([
              "if(",
              mt,
              "){",
              ft(),
              "}",
              Y
            ]);
          }
        });
      }
      var lt = tt(), ct = {};
      function pt(mt, xt) {
        var dt = [];
        function ft() {
          var st = "a" + dt.length;
          return dt.push(st), st;
        }
        xt = xt || 0;
        for (var R = 0; R < xt; ++R)
          ft();
        var Y = j(), ht = Y.toString, Lt = ct[mt] = r(Y, {
          arg: ft,
          toString: function() {
            return ld([
              "function(",
              dt.join(),
              "){",
              ht(),
              "}"
            ]);
          }
        });
        return Lt;
      }
      function gt() {
        var mt = [
          '"use strict";',
          lt,
          "return {"
        ];
        Object.keys(ct).forEach(function(ft) {
          mt.push('"', ft, '":', ct[ft].toString(), ",");
        }), mt.push("}");
        var xt = ld(mt).replace(/;/g, `;
`).replace(/}/g, `}
`).replace(/{/g, `{
`), dt = Function.apply(null, y.concat(xt));
        return dt.apply(null, T);
      }
      return {
        global: lt,
        link: G,
        block: tt,
        proc: pt,
        scope: j,
        cond: q,
        compile: gt
      };
    }
    var dd = "xyzw".split(""), BS = 5121, ud = 1, Sv = 2, Iv = 0, Av = 1, Tv = 2, Ev = 3, um = 4, RS = 5, MS = 6, PS = "dither", $S = "blend.enable", zS = "blend.color", kv = "blend.equation", Cv = "blend.func", US = "depth.enable", VS = "depth.func", jS = "depth.range", GS = "depth.mask", Ov = "colorMask", HS = "cull.enable", WS = "cull.face", Dv = "frontFace", Nv = "lineWidth", YS = "polygonOffset.enable", Lv = "polygonOffset.offset", qS = "sample.alpha", ZS = "sample.enable", Fv = "sample.coverage", XS = "stencil.enable", KS = "stencil.mask", Bv = "stencil.func", Rv = "stencil.opFront", wh = "stencil.opBack", JS = "scissor.enable", hm = "scissor.box", Ja = "viewport", Sh = "profile", Qc = "framebuffer", Ih = "vert", Ah = "frag", tl = "elements", el = "primitive", il = "count", fm = "offset", pm = "instances", Th = "vao", Mv = "Width", Pv = "Height", hd = Qc + Mv, fd = Qc + Pv, R6 = Ja + Mv, M6 = Ja + Pv, QS = "drawingBuffer", t2 = QS + Mv, e2 = QS + Pv, P6 = [
      Cv,
      kv,
      Bv,
      Rv,
      wh,
      Fv,
      Ja,
      hm,
      Lv
    ], pd = 34962, $v = 34963, $6 = 35632, z6 = 35633, i2 = 3553, U6 = 34067, V6 = 2884, j6 = 3042, G6 = 3024, H6 = 2960, W6 = 2929, Y6 = 3089, q6 = 32823, Z6 = 32926, X6 = 32928, zv = 5126, mm = 35664, gm = 35665, ym = 35666, Uv = 5124, vm = 35667, _m = 35668, bm = 35669, Vv = 35670, xm = 35671, wm = 35672, Sm = 35673, Eh = 35674, kh = 35675, Ch = 35676, Oh = 35678, Dh = 35680, jv = 4, Nh = 1028, rl = 1029, r2 = 2304, Gv = 2305, K6 = 32775, J6 = 32776, Q6 = 519, Jo = 7680, n2 = 0, s2 = 1, a2 = 32774, tF = 513, o2 = 36160, eF = 36064, ca = {
      0: 0,
      1: 1,
      zero: 0,
      one: 1,
      "src color": 768,
      "one minus src color": 769,
      "src alpha": 770,
      "one minus src alpha": 771,
      "dst color": 774,
      "one minus dst color": 775,
      "dst alpha": 772,
      "one minus dst alpha": 773,
      "constant color": 32769,
      "one minus constant color": 32770,
      "constant alpha": 32771,
      "one minus constant alpha": 32772,
      "src alpha saturate": 776
    }, c2 = [
      "constant color, constant alpha",
      "one minus constant color, constant alpha",
      "constant color, one minus constant alpha",
      "one minus constant color, one minus constant alpha",
      "constant alpha, constant color",
      "constant alpha, one minus constant color",
      "one minus constant alpha, constant color",
      "one minus constant alpha, one minus constant color"
    ], md = {
      never: 512,
      less: 513,
      "<": 513,
      equal: 514,
      "=": 514,
      "==": 514,
      "===": 514,
      lequal: 515,
      "<=": 515,
      greater: 516,
      ">": 516,
      notequal: 517,
      "!=": 517,
      "!==": 517,
      gequal: 518,
      ">=": 518,
      always: 519
    }, Qo = {
      0: 0,
      zero: 0,
      keep: 7680,
      replace: 7681,
      increment: 7682,
      decrement: 7683,
      "increment wrap": 34055,
      "decrement wrap": 34056,
      invert: 5386
    }, l2 = {
      frag: $6,
      vert: z6
    }, Hv = {
      cw: r2,
      ccw: Gv
    };
    function Im(f) {
      return Array.isArray(f) || i(f) || Os(f);
    }
    function d2(f) {
      return f.sort(function(y, T) {
        return y === Ja ? -1 : T === Ja ? 1 : y < T ? -1 : 1;
      });
    }
    function zr(f, y, T, G) {
      this.thisDep = f, this.contextDep = y, this.propDep = T, this.append = G;
    }
    function tc(f) {
      return f && !(f.thisDep || f.contextDep || f.propDep);
    }
    function wr(f) {
      return new zr(!1, !1, !1, f);
    }
    function Fn(f, y) {
      var T = f.type;
      if (T === Iv) {
        var G = f.data.length;
        return new zr(
          !0,
          G >= 1,
          G >= 2,
          y
        );
      } else if (T === um) {
        var tt = f.data;
        return new zr(
          tt.thisDep,
          tt.contextDep,
          tt.propDep,
          y
        );
      } else {
        if (T === RS)
          return new zr(
            !1,
            !1,
            !1,
            y
          );
        if (T === MS) {
          for (var j = !1, q = !1, lt = !1, ct = 0; ct < f.data.length; ++ct) {
            var pt = f.data[ct];
            if (pt.type === Av)
              lt = !0;
            else if (pt.type === Tv)
              q = !0;
            else if (pt.type === Ev)
              j = !0;
            else if (pt.type === Iv) {
              j = !0;
              var gt = pt.data;
              gt >= 1 && (q = !0), gt >= 2 && (lt = !0);
            } else
              pt.type === um && (j = j || pt.data.thisDep, q = q || pt.data.contextDep, lt = lt || pt.data.propDep);
          }
          return new zr(
            j,
            q,
            lt,
            y
          );
        } else
          return new zr(
            T === Ev,
            T === Tv,
            T === Av,
            y
          );
      }
    }
    var u2 = new zr(!1, !1, !1, function() {
    });
    function iF(f, y, T, G, tt, j, q, lt, ct, pt, gt, mt, xt, dt, ft) {
      var R = pt.Record, Y = {
        add: 32774,
        subtract: 32778,
        "reverse subtract": 32779
      };
      T.ext_blend_minmax && (Y.min = K6, Y.max = J6);
      var ht = T.angle_instanced_arrays, Lt = T.webgl_draw_buffers, st = T.oes_vertex_array_object, Ot = {
        dirty: !0,
        profile: ft.profile
      }, Tt = {}, Jt = [], it = {}, Q = {};
      function zt(b) {
        return b.replace(".", "_");
      }
      function wt(b, g, k) {
        var B = zt(b);
        Jt.push(b), Tt[B] = Ot[B] = !!k, it[B] = g;
      }
      function ut(b, g, k) {
        var B = zt(b);
        Jt.push(b), Array.isArray(k) ? (Ot[B] = k.slice(), Tt[B] = k.slice()) : Ot[B] = Tt[B] = k, Q[B] = g;
      }
      wt(PS, G6), wt($S, j6), ut(zS, "blendColor", [0, 0, 0, 0]), ut(
        kv,
        "blendEquationSeparate",
        [a2, a2]
      ), ut(
        Cv,
        "blendFuncSeparate",
        [s2, n2, s2, n2]
      ), wt(US, W6, !0), ut(VS, "depthFunc", tF), ut(jS, "depthRange", [0, 1]), ut(GS, "depthMask", !0), ut(Ov, Ov, [!0, !0, !0, !0]), wt(HS, V6), ut(WS, "cullFace", rl), ut(Dv, Dv, Gv), ut(Nv, Nv, 1), wt(YS, q6), ut(Lv, "polygonOffset", [0, 0]), wt(qS, Z6), wt(ZS, X6), ut(Fv, "sampleCoverage", [1, !1]), wt(XS, H6), ut(KS, "stencilMask", -1), ut(Bv, "stencilFunc", [Q6, 0, -1]), ut(
        Rv,
        "stencilOpSeparate",
        [Nh, Jo, Jo, Jo]
      ), ut(
        wh,
        "stencilOpSeparate",
        [rl, Jo, Jo, Jo]
      ), wt(JS, Y6), ut(
        hm,
        "scissor",
        [0, 0, f.drawingBufferWidth, f.drawingBufferHeight]
      ), ut(
        Ja,
        Ja,
        [0, 0, f.drawingBufferWidth, f.drawingBufferHeight]
      );
      var St = {
        gl: f,
        context: xt,
        strings: y,
        next: Tt,
        current: Ot,
        draw: mt,
        elements: j,
        buffer: tt,
        shader: gt,
        attributes: pt.state,
        vao: pt,
        uniforms: ct,
        framebuffer: lt,
        extensions: T,
        timer: dt,
        isBufferArgs: Im
      }, At = {
        primTypes: Xo,
        compareFuncs: md,
        blendFuncs: ca,
        blendEquations: Y,
        stencilOps: Qo,
        glTypes: qc,
        orientationType: Hv
      };
      _.optional(function() {
        St.isArrayLike = Ji;
      }), Lt && (At.backBuffer = [rl], At.drawBuffer = Xi(G.maxDrawbuffers, function(b) {
        return b === 0 ? [0] : Xi(b, function(g) {
          return eF + g;
        });
      }));
      var he = 0;
      function ce() {
        var b = B6(), g = b.link, k = b.global;
        b.id = he++, b.batchId = "0";
        var B = g(St), P = b.shared = {
          props: "a0"
        };
        Object.keys(St).forEach(function(A) {
          P[A] = k.def(B, ".", A);
        }), _.optional(function() {
          b.CHECK = g(_), b.commandStr = _.guessCommand(), b.command = g(b.commandStr), b.assert = function(A, S, z) {
            A(
              "if(!(",
              S,
              "))",
              this.CHECK,
              ".commandRaise(",
              g(z),
              ",",
              this.command,
              ");"
            );
          }, At.invalidBlendCombinations = c2;
        });
        var N = b.next = {}, D = b.current = {};
        Object.keys(Q).forEach(function(A) {
          Array.isArray(Ot[A]) && (N[A] = k.def(P.next, ".", A), D[A] = k.def(P.current, ".", A));
        });
        var L = b.constants = {};
        Object.keys(At).forEach(function(A) {
          L[A] = k.def(JSON.stringify(At[A]));
        }), b.invoke = function(A, S) {
          switch (S.type) {
            case Iv:
              var z = [
                "this",
                P.context,
                P.props,
                b.batchId
              ];
              return A.def(
                g(S.data),
                ".call(",
                z.slice(0, Math.max(S.data.length + 1, 4)),
                ")"
              );
            case Av:
              return A.def(P.props, S.data);
            case Tv:
              return A.def(P.context, S.data);
            case Ev:
              return A.def("this", S.data);
            case um:
              return S.data.append(b, A), S.data.ref;
            case RS:
              return S.data.toString();
            case MS:
              return S.data.map(function($) {
                return b.invoke(A, $);
              });
          }
        }, b.attribCache = {};
        var x = {};
        return b.scopeAttrib = function(A) {
          var S = y.id(A);
          if (S in x)
            return x[S];
          var z = pt.scope[S];
          z || (z = pt.scope[S] = new R());
          var $ = x[S] = g(z);
          return $;
        }, b;
      }
      function Et(b) {
        var g = b.static, k = b.dynamic, B;
        if (Sh in g) {
          var P = !!g[Sh];
          B = wr(function(D, L) {
            return P;
          }), B.enable = P;
        } else if (Sh in k) {
          var N = k[Sh];
          B = Fn(N, function(D, L) {
            return D.invoke(L, N);
          });
        }
        return B;
      }
      function Nt(b, g) {
        var k = b.static, B = b.dynamic;
        if (Qc in k) {
          var P = k[Qc];
          return P ? (P = lt.getFramebuffer(P), _.command(P, "invalid framebuffer object"), wr(function(D, L) {
            var x = D.link(P), A = D.shared;
            L.set(
              A.framebuffer,
              ".next",
              x
            );
            var S = A.context;
            return L.set(
              S,
              "." + hd,
              x + ".width"
            ), L.set(
              S,
              "." + fd,
              x + ".height"
            ), x;
          })) : wr(function(D, L) {
            var x = D.shared;
            L.set(
              x.framebuffer,
              ".next",
              "null"
            );
            var A = x.context;
            return L.set(
              A,
              "." + hd,
              A + "." + t2
            ), L.set(
              A,
              "." + fd,
              A + "." + e2
            ), "null";
          });
        } else if (Qc in B) {
          var N = B[Qc];
          return Fn(N, function(D, L) {
            var x = D.invoke(L, N), A = D.shared, S = A.framebuffer, z = L.def(
              S,
              ".getFramebuffer(",
              x,
              ")"
            );
            _.optional(function() {
              D.assert(
                L,
                "!" + x + "||" + z,
                "invalid framebuffer object"
              );
            }), L.set(
              S,
              ".next",
              z
            );
            var $ = A.context;
            return L.set(
              $,
              "." + hd,
              z + "?" + z + ".width:" + $ + "." + t2
            ), L.set(
              $,
              "." + fd,
              z + "?" + z + ".height:" + $ + "." + e2
            ), z;
          });
        } else
          return null;
      }
      function ne(b, g, k) {
        var B = b.static, P = b.dynamic;
        function N(x) {
          if (x in B) {
            var A = B[x];
            _.commandType(A, "object", "invalid " + x, k.commandStr);
            var S = !0, z = A.x | 0, $ = A.y | 0, J, rt;
            return "width" in A ? (J = A.width | 0, _.command(J >= 0, "invalid " + x, k.commandStr)) : S = !1, "height" in A ? (rt = A.height | 0, _.command(rt >= 0, "invalid " + x, k.commandStr)) : S = !1, new zr(
              !S && g && g.thisDep,
              !S && g && g.contextDep,
              !S && g && g.propDep,
              function(Kt, Pt) {
                var nt = Kt.shared.context, K = J;
                "width" in A || (K = Pt.def(nt, ".", hd, "-", z));
                var Ht = rt;
                return "height" in A || (Ht = Pt.def(nt, ".", fd, "-", $)), [z, $, K, Ht];
              }
            );
          } else if (x in P) {
            var _t = P[x], ae = Fn(_t, function(Kt, Pt) {
              var nt = Kt.invoke(Pt, _t);
              _.optional(function() {
                Kt.assert(
                  Pt,
                  nt + "&&typeof " + nt + '==="object"',
                  "invalid " + x
                );
              });
              var K = Kt.shared.context, Ht = Pt.def(nt, ".x|0"), Ut = Pt.def(nt, ".y|0"), se = Pt.def(
                '"width" in ',
                nt,
                "?",
                nt,
                ".width|0:",
                "(",
                K,
                ".",
                hd,
                "-",
                Ht,
                ")"
              ), gi = Pt.def(
                '"height" in ',
                nt,
                "?",
                nt,
                ".height|0:",
                "(",
                K,
                ".",
                fd,
                "-",
                Ut,
                ")"
              );
              return _.optional(function() {
                Kt.assert(
                  Pt,
                  se + ">=0&&" + gi + ">=0",
                  "invalid " + x
                );
              }), [Ht, Ut, se, gi];
            });
            return g && (ae.thisDep = ae.thisDep || g.thisDep, ae.contextDep = ae.contextDep || g.contextDep, ae.propDep = ae.propDep || g.propDep), ae;
          } else
            return g ? new zr(
              g.thisDep,
              g.contextDep,
              g.propDep,
              function(Kt, Pt) {
                var nt = Kt.shared.context;
                return [
                  0,
                  0,
                  Pt.def(nt, ".", hd),
                  Pt.def(nt, ".", fd)
                ];
              }
            ) : null;
        }
        var D = N(Ja);
        if (D) {
          var L = D;
          D = new zr(
            D.thisDep,
            D.contextDep,
            D.propDep,
            function(x, A) {
              var S = L.append(x, A), z = x.shared.context;
              return A.set(
                z,
                "." + R6,
                S[2]
              ), A.set(
                z,
                "." + M6,
                S[3]
              ), S;
            }
          );
        }
        return {
          viewport: D,
          scissor_box: N(hm)
        };
      }
      function fe(b, g) {
        var k = b.static, B = typeof k[Ah] == "string" && typeof k[Ih] == "string";
        if (B) {
          if (Object.keys(g.dynamic).length > 0)
            return null;
          var P = g.static, N = Object.keys(P);
          if (N.length > 0 && typeof P[N[0]] == "number") {
            for (var D = [], L = 0; L < N.length; ++L)
              _(typeof P[N[L]] == "number", "must specify all vertex attribute locations when using vaos"), D.push([P[N[L]] | 0, N[L]]);
            return D;
          }
        }
        return null;
      }
      function je(b, g, k) {
        var B = b.static, P = b.dynamic;
        function N(S) {
          if (S in B) {
            var z = y.id(B[S]);
            _.optional(function() {
              gt.shader(l2[S], z, _.guessCommand());
            });
            var $ = wr(function() {
              return z;
            });
            return $.id = z, $;
          } else if (S in P) {
            var J = P[S];
            return Fn(J, function(rt, _t) {
              var ae = rt.invoke(_t, J), Kt = _t.def(rt.shared.strings, ".id(", ae, ")");
              return _.optional(function() {
                _t(
                  rt.shared.shader,
                  ".shader(",
                  l2[S],
                  ",",
                  Kt,
                  ",",
                  rt.command,
                  ");"
                );
              }), Kt;
            });
          }
          return null;
        }
        var D = N(Ah), L = N(Ih), x = null, A;
        return tc(D) && tc(L) ? (x = gt.program(L.id, D.id, null, k), A = wr(function(S, z) {
          return S.link(x);
        })) : A = new zr(
          D && D.thisDep || L && L.thisDep,
          D && D.contextDep || L && L.contextDep,
          D && D.propDep || L && L.propDep,
          function(S, z) {
            var $ = S.shared.shader, J;
            D ? J = D.append(S, z) : J = z.def($, ".", Ah);
            var rt;
            L ? rt = L.append(S, z) : rt = z.def($, ".", Ih);
            var _t = $ + ".program(" + rt + "," + J;
            return _.optional(function() {
              _t += "," + S.command;
            }), z.def(_t + ")");
          }
        ), {
          frag: D,
          vert: L,
          progVar: A,
          program: x
        };
      }
      function Qi(b, g) {
        var k = b.static, B = b.dynamic, P = {}, N = !1;
        function D() {
          if (Th in k) {
            var Pt = k[Th];
            return Pt !== null && pt.getVAO(Pt) === null && (Pt = pt.createVAO(Pt)), N = !0, P.vao = Pt, wr(function(K) {
              var Ht = pt.getVAO(Pt);
              return Ht ? K.link(Ht) : "null";
            });
          } else if (Th in B) {
            N = !0;
            var nt = B[Th];
            return Fn(nt, function(K, Ht) {
              var Ut = K.invoke(Ht, nt);
              return Ht.def(K.shared.vao + ".getVAO(" + Ut + ")");
            });
          }
          return null;
        }
        var L = D(), x = !1;
        function A() {
          if (tl in k) {
            var Pt = k[tl];
            if (P.elements = Pt, Im(Pt)) {
              var nt = P.elements = j.create(Pt, !0);
              Pt = j.getElements(nt), x = !0;
            } else
              Pt && (Pt = j.getElements(Pt), x = !0, _.command(Pt, "invalid elements", g.commandStr));
            var K = wr(function(Ut, se) {
              if (Pt) {
                var gi = Ut.link(Pt);
                return Ut.ELEMENTS = gi, gi;
              }
              return Ut.ELEMENTS = null, null;
            });
            return K.value = Pt, K;
          } else if (tl in B) {
            x = !0;
            var Ht = B[tl];
            return Fn(Ht, function(Ut, se) {
              var gi = Ut.shared, sn = gi.isBufferArgs, sl = gi.elements, Qa = Ut.invoke(se, Ht), da = se.def("null"), ec = se.def(sn, "(", Qa, ")"), al = Ut.cond(ec).then(da, "=", sl, ".createStream(", Qa, ");").else(da, "=", sl, ".getElements(", Qa, ");");
              return _.optional(function() {
                Ut.assert(
                  al.else,
                  "!" + Qa + "||" + da,
                  "invalid elements"
                );
              }), se.entry(al), se.exit(
                Ut.cond(ec).then(sl, ".destroyStream(", da, ");")
              ), Ut.ELEMENTS = da, da;
            });
          } else if (N)
            return new zr(
              L.thisDep,
              L.contextDep,
              L.propDep,
              function(Ut, se) {
                return se.def(Ut.shared.vao + ".currentVAO?" + Ut.shared.elements + ".getElements(" + Ut.shared.vao + ".currentVAO.elements):null");
              }
            );
          return null;
        }
        var S = A();
        function z() {
          if (el in k) {
            var Pt = k[el];
            return P.primitive = Pt, _.commandParameter(Pt, Xo, "invalid primitve", g.commandStr), wr(function(K, Ht) {
              return Xo[Pt];
            });
          } else if (el in B) {
            var nt = B[el];
            return Fn(nt, function(K, Ht) {
              var Ut = K.constants.primTypes, se = K.invoke(Ht, nt);
              return _.optional(function() {
                K.assert(
                  Ht,
                  se + " in " + Ut,
                  "invalid primitive, must be one of " + Object.keys(Xo)
                );
              }), Ht.def(Ut, "[", se, "]");
            });
          } else {
            if (x)
              return tc(S) ? S.value ? wr(function(K, Ht) {
                return Ht.def(K.ELEMENTS, ".primType");
              }) : wr(function() {
                return jv;
              }) : new zr(
                S.thisDep,
                S.contextDep,
                S.propDep,
                function(K, Ht) {
                  var Ut = K.ELEMENTS;
                  return Ht.def(Ut, "?", Ut, ".primType:", jv);
                }
              );
            if (N)
              return new zr(
                L.thisDep,
                L.contextDep,
                L.propDep,
                function(K, Ht) {
                  return Ht.def(K.shared.vao + ".currentVAO?" + K.shared.vao + ".currentVAO.primitive:" + jv);
                }
              );
          }
          return null;
        }
        function $(Pt, nt) {
          if (Pt in k) {
            var K = k[Pt] | 0;
            return nt ? P.offset = K : P.instances = K, _.command(!nt || K >= 0, "invalid " + Pt, g.commandStr), wr(function(Ut, se) {
              return nt && (Ut.OFFSET = K), K;
            });
          } else if (Pt in B) {
            var Ht = B[Pt];
            return Fn(Ht, function(Ut, se) {
              var gi = Ut.invoke(se, Ht);
              return nt && (Ut.OFFSET = gi, _.optional(function() {
                Ut.assert(
                  se,
                  gi + ">=0",
                  "invalid " + Pt
                );
              })), gi;
            });
          } else if (nt) {
            if (x)
              return wr(function(Ut, se) {
                return Ut.OFFSET = 0, 0;
              });
            if (N)
              return new zr(
                L.thisDep,
                L.contextDep,
                L.propDep,
                function(Ut, se) {
                  return se.def(Ut.shared.vao + ".currentVAO?" + Ut.shared.vao + ".currentVAO.offset:0");
                }
              );
          } else if (N)
            return new zr(
              L.thisDep,
              L.contextDep,
              L.propDep,
              function(Ut, se) {
                return se.def(Ut.shared.vao + ".currentVAO?" + Ut.shared.vao + ".currentVAO.instances:-1");
              }
            );
          return null;
        }
        var J = $(fm, !0);
        function rt() {
          if (il in k) {
            var Pt = k[il] | 0;
            return P.count = Pt, _.command(
              typeof Pt == "number" && Pt >= 0,
              "invalid vertex count",
              g.commandStr
            ), wr(function() {
              return Pt;
            });
          } else if (il in B) {
            var nt = B[il];
            return Fn(nt, function(se, gi) {
              var sn = se.invoke(gi, nt);
              return _.optional(function() {
                se.assert(
                  gi,
                  "typeof " + sn + '==="number"&&' + sn + ">=0&&" + sn + "===(" + sn + "|0)",
                  "invalid vertex count"
                );
              }), sn;
            });
          } else if (x)
            if (tc(S)) {
              if (S)
                return J ? new zr(
                  J.thisDep,
                  J.contextDep,
                  J.propDep,
                  function(se, gi) {
                    var sn = gi.def(
                      se.ELEMENTS,
                      ".vertCount-",
                      se.OFFSET
                    );
                    return _.optional(function() {
                      se.assert(
                        gi,
                        sn + ">=0",
                        "invalid vertex offset/element buffer too small"
                      );
                    }), sn;
                  }
                ) : wr(function(se, gi) {
                  return gi.def(se.ELEMENTS, ".vertCount");
                });
              var K = wr(function() {
                return -1;
              });
              return _.optional(function() {
                K.MISSING = !0;
              }), K;
            } else {
              var Ht = new zr(
                S.thisDep || J.thisDep,
                S.contextDep || J.contextDep,
                S.propDep || J.propDep,
                function(se, gi) {
                  var sn = se.ELEMENTS;
                  return se.OFFSET ? gi.def(
                    sn,
                    "?",
                    sn,
                    ".vertCount-",
                    se.OFFSET,
                    ":-1"
                  ) : gi.def(sn, "?", sn, ".vertCount:-1");
                }
              );
              return _.optional(function() {
                Ht.DYNAMIC = !0;
              }), Ht;
            }
          else if (N) {
            var Ut = new zr(
              L.thisDep,
              L.contextDep,
              L.propDep,
              function(se, gi) {
                return gi.def(se.shared.vao, ".currentVAO?", se.shared.vao, ".currentVAO.count:-1");
              }
            );
            return Ut;
          }
          return null;
        }
        var _t = z(), ae = rt(), Kt = $(pm, !1);
        return {
          elements: S,
          primitive: _t,
          count: ae,
          instances: Kt,
          offset: J,
          vao: L,
          vaoActive: N,
          elementsActive: x,
          // static draw props
          static: P
        };
      }
      function sr(b, g) {
        var k = b.static, B = b.dynamic, P = {};
        return Jt.forEach(function(N) {
          var D = zt(N);
          function L(x, A) {
            if (N in k) {
              var S = x(k[N]);
              P[D] = wr(function() {
                return S;
              });
            } else if (N in B) {
              var z = B[N];
              P[D] = Fn(z, function($, J) {
                return A($, J, $.invoke(J, z));
              });
            }
          }
          switch (N) {
            case HS:
            case $S:
            case PS:
            case XS:
            case US:
            case JS:
            case YS:
            case qS:
            case ZS:
            case GS:
              return L(
                function(x) {
                  return _.commandType(x, "boolean", N, g.commandStr), x;
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      "typeof " + S + '==="boolean"',
                      "invalid flag " + N,
                      x.commandStr
                    );
                  }), S;
                }
              );
            case VS:
              return L(
                function(x) {
                  return _.commandParameter(x, md, "invalid " + N, g.commandStr), md[x];
                },
                function(x, A, S) {
                  var z = x.constants.compareFuncs;
                  return _.optional(function() {
                    x.assert(
                      A,
                      S + " in " + z,
                      "invalid " + N + ", must be one of " + Object.keys(md)
                    );
                  }), A.def(z, "[", S, "]");
                }
              );
            case jS:
              return L(
                function(x) {
                  return _.command(
                    Ji(x) && x.length === 2 && typeof x[0] == "number" && typeof x[1] == "number" && x[0] <= x[1],
                    "depth range is 2d array",
                    g.commandStr
                  ), x;
                },
                function(x, A, S) {
                  _.optional(function() {
                    x.assert(
                      A,
                      x.shared.isArrayLike + "(" + S + ")&&" + S + ".length===2&&typeof " + S + '[0]==="number"&&typeof ' + S + '[1]==="number"&&' + S + "[0]<=" + S + "[1]",
                      "depth range must be a 2d array"
                    );
                  });
                  var z = A.def("+", S, "[0]"), $ = A.def("+", S, "[1]");
                  return [z, $];
                }
              );
            case Cv:
              return L(
                function(x) {
                  _.commandType(x, "object", "blend.func", g.commandStr);
                  var A = "srcRGB" in x ? x.srcRGB : x.src, S = "srcAlpha" in x ? x.srcAlpha : x.src, z = "dstRGB" in x ? x.dstRGB : x.dst, $ = "dstAlpha" in x ? x.dstAlpha : x.dst;
                  return _.commandParameter(A, ca, D + ".srcRGB", g.commandStr), _.commandParameter(S, ca, D + ".srcAlpha", g.commandStr), _.commandParameter(z, ca, D + ".dstRGB", g.commandStr), _.commandParameter($, ca, D + ".dstAlpha", g.commandStr), _.command(
                    c2.indexOf(A + ", " + z) === -1,
                    "unallowed blending combination (srcRGB, dstRGB) = (" + A + ", " + z + ")",
                    g.commandStr
                  ), [
                    ca[A],
                    ca[z],
                    ca[S],
                    ca[$]
                  ];
                },
                function(x, A, S) {
                  var z = x.constants.blendFuncs;
                  _.optional(function() {
                    x.assert(
                      A,
                      S + "&&typeof " + S + '==="object"',
                      "invalid blend func, must be an object"
                    );
                  });
                  function $(nt, K) {
                    var Ht = A.def(
                      '"',
                      nt,
                      K,
                      '" in ',
                      S,
                      "?",
                      S,
                      ".",
                      nt,
                      K,
                      ":",
                      S,
                      ".",
                      nt
                    );
                    return _.optional(function() {
                      x.assert(
                        A,
                        Ht + " in " + z,
                        "invalid " + N + "." + nt + K + ", must be one of " + Object.keys(ca)
                      );
                    }), Ht;
                  }
                  var J = $("src", "RGB"), rt = $("dst", "RGB");
                  _.optional(function() {
                    var nt = x.constants.invalidBlendCombinations;
                    x.assert(
                      A,
                      nt + ".indexOf(" + J + '+", "+' + rt + ") === -1 ",
                      "unallowed blending combination for (srcRGB, dstRGB)"
                    );
                  });
                  var _t = A.def(z, "[", J, "]"), ae = A.def(z, "[", $("src", "Alpha"), "]"), Kt = A.def(z, "[", rt, "]"), Pt = A.def(z, "[", $("dst", "Alpha"), "]");
                  return [_t, Kt, ae, Pt];
                }
              );
            case kv:
              return L(
                function(x) {
                  if (typeof x == "string")
                    return _.commandParameter(x, Y, "invalid " + N, g.commandStr), [
                      Y[x],
                      Y[x]
                    ];
                  if (typeof x == "object")
                    return _.commandParameter(
                      x.rgb,
                      Y,
                      N + ".rgb",
                      g.commandStr
                    ), _.commandParameter(
                      x.alpha,
                      Y,
                      N + ".alpha",
                      g.commandStr
                    ), [
                      Y[x.rgb],
                      Y[x.alpha]
                    ];
                  _.commandRaise("invalid blend.equation", g.commandStr);
                },
                function(x, A, S) {
                  var z = x.constants.blendEquations, $ = A.def(), J = A.def(), rt = x.cond("typeof ", S, '==="string"');
                  return _.optional(function() {
                    function _t(ae, Kt, Pt) {
                      x.assert(
                        ae,
                        Pt + " in " + z,
                        "invalid " + Kt + ", must be one of " + Object.keys(Y)
                      );
                    }
                    _t(rt.then, N, S), x.assert(
                      rt.else,
                      S + "&&typeof " + S + '==="object"',
                      "invalid " + N
                    ), _t(rt.else, N + ".rgb", S + ".rgb"), _t(rt.else, N + ".alpha", S + ".alpha");
                  }), rt.then(
                    $,
                    "=",
                    J,
                    "=",
                    z,
                    "[",
                    S,
                    "];"
                  ), rt.else(
                    $,
                    "=",
                    z,
                    "[",
                    S,
                    ".rgb];",
                    J,
                    "=",
                    z,
                    "[",
                    S,
                    ".alpha];"
                  ), A(rt), [$, J];
                }
              );
            case zS:
              return L(
                function(x) {
                  return _.command(
                    Ji(x) && x.length === 4,
                    "blend.color must be a 4d array",
                    g.commandStr
                  ), Xi(4, function(A) {
                    return +x[A];
                  });
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      x.shared.isArrayLike + "(" + S + ")&&" + S + ".length===4",
                      "blend.color must be a 4d array"
                    );
                  }), Xi(4, function(z) {
                    return A.def("+", S, "[", z, "]");
                  });
                }
              );
            case KS:
              return L(
                function(x) {
                  return _.commandType(x, "number", D, g.commandStr), x | 0;
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      "typeof " + S + '==="number"',
                      "invalid stencil.mask"
                    );
                  }), A.def(S, "|0");
                }
              );
            case Bv:
              return L(
                function(x) {
                  _.commandType(x, "object", D, g.commandStr);
                  var A = x.cmp || "keep", S = x.ref || 0, z = "mask" in x ? x.mask : -1;
                  return _.commandParameter(A, md, N + ".cmp", g.commandStr), _.commandType(S, "number", N + ".ref", g.commandStr), _.commandType(z, "number", N + ".mask", g.commandStr), [
                    md[A],
                    S,
                    z
                  ];
                },
                function(x, A, S) {
                  var z = x.constants.compareFuncs;
                  _.optional(function() {
                    function _t() {
                      x.assert(
                        A,
                        Array.prototype.join.call(arguments, ""),
                        "invalid stencil.func"
                      );
                    }
                    _t(S + "&&typeof ", S, '==="object"'), _t(
                      '!("cmp" in ',
                      S,
                      ")||(",
                      S,
                      ".cmp in ",
                      z,
                      ")"
                    );
                  });
                  var $ = A.def(
                    '"cmp" in ',
                    S,
                    "?",
                    z,
                    "[",
                    S,
                    ".cmp]",
                    ":",
                    Jo
                  ), J = A.def(S, ".ref|0"), rt = A.def(
                    '"mask" in ',
                    S,
                    "?",
                    S,
                    ".mask|0:-1"
                  );
                  return [$, J, rt];
                }
              );
            case Rv:
            case wh:
              return L(
                function(x) {
                  _.commandType(x, "object", D, g.commandStr);
                  var A = x.fail || "keep", S = x.zfail || "keep", z = x.zpass || "keep";
                  return _.commandParameter(A, Qo, N + ".fail", g.commandStr), _.commandParameter(S, Qo, N + ".zfail", g.commandStr), _.commandParameter(z, Qo, N + ".zpass", g.commandStr), [
                    N === wh ? rl : Nh,
                    Qo[A],
                    Qo[S],
                    Qo[z]
                  ];
                },
                function(x, A, S) {
                  var z = x.constants.stencilOps;
                  _.optional(function() {
                    x.assert(
                      A,
                      S + "&&typeof " + S + '==="object"',
                      "invalid " + N
                    );
                  });
                  function $(J) {
                    return _.optional(function() {
                      x.assert(
                        A,
                        '!("' + J + '" in ' + S + ")||(" + S + "." + J + " in " + z + ")",
                        "invalid " + N + "." + J + ", must be one of " + Object.keys(Qo)
                      );
                    }), A.def(
                      '"',
                      J,
                      '" in ',
                      S,
                      "?",
                      z,
                      "[",
                      S,
                      ".",
                      J,
                      "]:",
                      Jo
                    );
                  }
                  return [
                    N === wh ? rl : Nh,
                    $("fail"),
                    $("zfail"),
                    $("zpass")
                  ];
                }
              );
            case Lv:
              return L(
                function(x) {
                  _.commandType(x, "object", D, g.commandStr);
                  var A = x.factor | 0, S = x.units | 0;
                  return _.commandType(A, "number", D + ".factor", g.commandStr), _.commandType(S, "number", D + ".units", g.commandStr), [A, S];
                },
                function(x, A, S) {
                  _.optional(function() {
                    x.assert(
                      A,
                      S + "&&typeof " + S + '==="object"',
                      "invalid " + N
                    );
                  });
                  var z = A.def(S, ".factor|0"), $ = A.def(S, ".units|0");
                  return [z, $];
                }
              );
            case WS:
              return L(
                function(x) {
                  var A = 0;
                  return x === "front" ? A = Nh : x === "back" && (A = rl), _.command(!!A, D, g.commandStr), A;
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      S + '==="front"||' + S + '==="back"',
                      "invalid cull.face"
                    );
                  }), A.def(S, '==="front"?', Nh, ":", rl);
                }
              );
            case Nv:
              return L(
                function(x) {
                  return _.command(
                    typeof x == "number" && x >= G.lineWidthDims[0] && x <= G.lineWidthDims[1],
                    "invalid line width, must be a positive number between " + G.lineWidthDims[0] + " and " + G.lineWidthDims[1],
                    g.commandStr
                  ), x;
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      "typeof " + S + '==="number"&&' + S + ">=" + G.lineWidthDims[0] + "&&" + S + "<=" + G.lineWidthDims[1],
                      "invalid line width"
                    );
                  }), S;
                }
              );
            case Dv:
              return L(
                function(x) {
                  return _.commandParameter(x, Hv, D, g.commandStr), Hv[x];
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      S + '==="cw"||' + S + '==="ccw"',
                      "invalid frontFace, must be one of cw,ccw"
                    );
                  }), A.def(S + '==="cw"?' + r2 + ":" + Gv);
                }
              );
            case Ov:
              return L(
                function(x) {
                  return _.command(
                    Ji(x) && x.length === 4,
                    "color.mask must be length 4 array",
                    g.commandStr
                  ), x.map(function(A) {
                    return !!A;
                  });
                },
                function(x, A, S) {
                  return _.optional(function() {
                    x.assert(
                      A,
                      x.shared.isArrayLike + "(" + S + ")&&" + S + ".length===4",
                      "invalid color.mask"
                    );
                  }), Xi(4, function(z) {
                    return "!!" + S + "[" + z + "]";
                  });
                }
              );
            case Fv:
              return L(
                function(x) {
                  _.command(typeof x == "object" && x, D, g.commandStr);
                  var A = "value" in x ? x.value : 1, S = !!x.invert;
                  return _.command(
                    typeof A == "number" && A >= 0 && A <= 1,
                    "sample.coverage.value must be a number between 0 and 1",
                    g.commandStr
                  ), [A, S];
                },
                function(x, A, S) {
                  _.optional(function() {
                    x.assert(
                      A,
                      S + "&&typeof " + S + '==="object"',
                      "invalid sample.coverage"
                    );
                  });
                  var z = A.def(
                    '"value" in ',
                    S,
                    "?+",
                    S,
                    ".value:1"
                  ), $ = A.def("!!", S, ".invert");
                  return [z, $];
                }
              );
          }
        }), P;
      }
      function Ye(b, g) {
        var k = b.static, B = b.dynamic, P = {};
        return Object.keys(k).forEach(function(N) {
          var D = k[N], L;
          if (typeof D == "number" || typeof D == "boolean")
            L = wr(function() {
              return D;
            });
          else if (typeof D == "function") {
            var x = D._reglType;
            x === "texture2d" || x === "textureCube" ? L = wr(function(A) {
              return A.link(D);
            }) : x === "framebuffer" || x === "framebufferCube" ? (_.command(
              D.color.length > 0,
              'missing color attachment for framebuffer sent to uniform "' + N + '"',
              g.commandStr
            ), L = wr(function(A) {
              return A.link(D.color[0]);
            })) : _.commandRaise('invalid data for uniform "' + N + '"', g.commandStr);
          } else
            Ji(D) ? L = wr(function(A) {
              var S = A.global.def(
                "[",
                Xi(D.length, function(z) {
                  return _.command(
                    typeof D[z] == "number" || typeof D[z] == "boolean",
                    "invalid uniform " + N,
                    A.commandStr
                  ), D[z];
                }),
                "]"
              );
              return S;
            }) : _.commandRaise('invalid or missing data for uniform "' + N + '"', g.commandStr);
          L.value = D, P[N] = L;
        }), Object.keys(B).forEach(function(N) {
          var D = B[N];
          P[N] = Fn(D, function(L, x) {
            return L.invoke(x, D);
          });
        }), P;
      }
      function Cr(b, g) {
        var k = b.static, B = b.dynamic, P = {};
        return Object.keys(k).forEach(function(N) {
          var D = k[N], L = y.id(N), x = new R();
          if (Im(D))
            x.state = ud, x.buffer = tt.getBuffer(
              tt.create(D, pd, !1, !0)
            ), x.type = 0;
          else {
            var A = tt.getBuffer(D);
            if (A)
              x.state = ud, x.buffer = A, x.type = 0;
            else if (_.command(
              typeof D == "object" && D,
              "invalid data for attribute " + N,
              g.commandStr
            ), "constant" in D) {
              var S = D.constant;
              x.buffer = "null", x.state = Sv, typeof S == "number" ? x.x = S : (_.command(
                Ji(S) && S.length > 0 && S.length <= 4,
                "invalid constant for attribute " + N,
                g.commandStr
              ), dd.forEach(function(Kt, Pt) {
                Pt < S.length && (x[Kt] = S[Pt]);
              }));
            } else {
              Im(D.buffer) ? A = tt.getBuffer(
                tt.create(D.buffer, pd, !1, !0)
              ) : A = tt.getBuffer(D.buffer), _.command(!!A, 'missing buffer for attribute "' + N + '"', g.commandStr);
              var z = D.offset | 0;
              _.command(
                z >= 0,
                'invalid offset for attribute "' + N + '"',
                g.commandStr
              );
              var $ = D.stride | 0;
              _.command(
                $ >= 0 && $ < 256,
                'invalid stride for attribute "' + N + '", must be integer betweeen [0, 255]',
                g.commandStr
              );
              var J = D.size | 0;
              _.command(
                !("size" in D) || J > 0 && J <= 4,
                'invalid size for attribute "' + N + '", must be 1,2,3,4',
                g.commandStr
              );
              var rt = !!D.normalized, _t = 0;
              "type" in D && (_.commandParameter(
                D.type,
                qc,
                "invalid type for attribute " + N,
                g.commandStr
              ), _t = qc[D.type]);
              var ae = D.divisor | 0;
              _.optional(function() {
                "divisor" in D && (_.command(
                  ae === 0 || ht,
                  'cannot specify divisor for attribute "' + N + '", instancing not supported',
                  g.commandStr
                ), _.command(
                  ae >= 0,
                  'invalid divisor for attribute "' + N + '"',
                  g.commandStr
                ));
                var Kt = g.commandStr, Pt = [
                  "buffer",
                  "offset",
                  "divisor",
                  "normalized",
                  "type",
                  "size",
                  "stride"
                ];
                Object.keys(D).forEach(function(nt) {
                  _.command(
                    Pt.indexOf(nt) >= 0,
                    'unknown parameter "' + nt + '" for attribute pointer "' + N + '" (valid parameters are ' + Pt + ")",
                    Kt
                  );
                });
              }), x.buffer = A, x.state = ud, x.size = J, x.normalized = rt, x.type = _t || A.dtype, x.offset = z, x.stride = $, x.divisor = ae;
            }
          }
          P[N] = wr(function(Kt, Pt) {
            var nt = Kt.attribCache;
            if (L in nt)
              return nt[L];
            var K = {
              isStream: !1
            };
            return Object.keys(x).forEach(function(Ht) {
              K[Ht] = x[Ht];
            }), x.buffer && (K.buffer = Kt.link(x.buffer), K.type = K.type || K.buffer + ".dtype"), nt[L] = K, K;
          });
        }), Object.keys(B).forEach(function(N) {
          var D = B[N];
          function L(x, A) {
            var S = x.invoke(A, D), z = x.shared, $ = x.constants, J = z.isBufferArgs, rt = z.buffer;
            _.optional(function() {
              x.assert(
                A,
                S + "&&(typeof " + S + '==="object"||typeof ' + S + '==="function")&&(' + J + "(" + S + ")||" + rt + ".getBuffer(" + S + ")||" + rt + ".getBuffer(" + S + ".buffer)||" + J + "(" + S + '.buffer)||("constant" in ' + S + "&&(typeof " + S + '.constant==="number"||' + z.isArrayLike + "(" + S + ".constant))))",
                'invalid dynamic attribute "' + N + '"'
              );
            });
            var _t = {
              isStream: A.def(!1)
            }, ae = new R();
            ae.state = ud, Object.keys(ae).forEach(function(K) {
              _t[K] = A.def("" + ae[K]);
            });
            var Kt = _t.buffer, Pt = _t.type;
            A(
              "if(",
              J,
              "(",
              S,
              ")){",
              _t.isStream,
              "=true;",
              Kt,
              "=",
              rt,
              ".createStream(",
              pd,
              ",",
              S,
              ");",
              Pt,
              "=",
              Kt,
              ".dtype;",
              "}else{",
              Kt,
              "=",
              rt,
              ".getBuffer(",
              S,
              ");",
              "if(",
              Kt,
              "){",
              Pt,
              "=",
              Kt,
              ".dtype;",
              '}else if("constant" in ',
              S,
              "){",
              _t.state,
              "=",
              Sv,
              ";",
              "if(typeof " + S + '.constant === "number"){',
              _t[dd[0]],
              "=",
              S,
              ".constant;",
              dd.slice(1).map(function(K) {
                return _t[K];
              }).join("="),
              "=0;",
              "}else{",
              dd.map(function(K, Ht) {
                return _t[K] + "=" + S + ".constant.length>" + Ht + "?" + S + ".constant[" + Ht + "]:0;";
              }).join(""),
              "}}else{",
              "if(",
              J,
              "(",
              S,
              ".buffer)){",
              Kt,
              "=",
              rt,
              ".createStream(",
              pd,
              ",",
              S,
              ".buffer);",
              "}else{",
              Kt,
              "=",
              rt,
              ".getBuffer(",
              S,
              ".buffer);",
              "}",
              Pt,
              '="type" in ',
              S,
              "?",
              $.glTypes,
              "[",
              S,
              ".type]:",
              Kt,
              ".dtype;",
              _t.normalized,
              "=!!",
              S,
              ".normalized;"
            );
            function nt(K) {
              A(_t[K], "=", S, ".", K, "|0;");
            }
            return nt("size"), nt("offset"), nt("stride"), nt("divisor"), A("}}"), A.exit(
              "if(",
              _t.isStream,
              "){",
              rt,
              ".destroyStream(",
              Kt,
              ");",
              "}"
            ), _t;
          }
          P[N] = Fn(D, L);
        }), P;
      }
      function Gi(b) {
        var g = b.static, k = b.dynamic, B = {};
        return Object.keys(g).forEach(function(P) {
          var N = g[P];
          B[P] = wr(function(D, L) {
            return typeof N == "number" || typeof N == "boolean" ? "" + N : D.link(N);
          });
        }), Object.keys(k).forEach(function(P) {
          var N = k[P];
          B[P] = Fn(N, function(D, L) {
            return D.invoke(L, N);
          });
        }), B;
      }
      function Sr(b, g, k, B, P) {
        var N = b.static, D = b.dynamic;
        _.optional(function() {
          var nt = [
            Qc,
            Ih,
            Ah,
            tl,
            el,
            fm,
            il,
            pm,
            Sh,
            Th
          ].concat(Jt);
          function K(Ht) {
            Object.keys(Ht).forEach(function(Ut) {
              _.command(
                nt.indexOf(Ut) >= 0,
                'unknown parameter "' + Ut + '"',
                P.commandStr
              );
            });
          }
          K(N), K(D);
        });
        var L = fe(b, g), x = Nt(b), A = ne(b, x, P), S = Qi(b, P), z = sr(b, P), $ = je(b, P, L);
        function J(nt) {
          var K = A[nt];
          K && (z[nt] = K);
        }
        J(Ja), J(zt(hm));
        var rt = Object.keys(z).length > 0, _t = {
          framebuffer: x,
          draw: S,
          shader: $,
          state: z,
          dirty: rt,
          scopeVAO: null,
          drawVAO: null,
          useVAO: !1,
          attributes: {}
        };
        if (_t.profile = Et(b), _t.uniforms = Ye(k, P), _t.drawVAO = _t.scopeVAO = S.vao, !_t.drawVAO && $.program && !L && T.angle_instanced_arrays && S.static.elements) {
          var ae = !0, Kt = $.program.attributes.map(function(nt) {
            var K = g.static[nt];
            return ae = ae && !!K, K;
          });
          if (ae && Kt.length > 0) {
            var Pt = pt.getVAO(pt.createVAO({
              attributes: Kt,
              elements: S.static.elements
            }));
            _t.drawVAO = new zr(null, null, null, function(nt, K) {
              return nt.link(Pt);
            }), _t.useVAO = !0;
          }
        }
        return L ? _t.useVAO = !0 : _t.attributes = Cr(g, P), _t.context = Gi(B), _t;
      }
      function Or(b, g, k) {
        var B = b.shared, P = B.context, N = b.scope();
        Object.keys(k).forEach(function(D) {
          g.save(P, "." + D);
          var L = k[D], x = L.append(b, g);
          Array.isArray(x) ? N(P, ".", D, "=[", x.join(), "];") : N(P, ".", D, "=", x, ";");
        }), g(N);
      }
      function Dr(b, g, k, B) {
        var P = b.shared, N = P.gl, D = P.framebuffer, L;
        Lt && (L = g.def(P.extensions, ".webgl_draw_buffers"));
        var x = b.constants, A = x.drawBuffer, S = x.backBuffer, z;
        k ? z = k.append(b, g) : z = g.def(D, ".next"), B || g("if(", z, "!==", D, ".cur){"), g(
          "if(",
          z,
          "){",
          N,
          ".bindFramebuffer(",
          o2,
          ",",
          z,
          ".framebuffer);"
        ), Lt && g(
          L,
          ".drawBuffersWEBGL(",
          A,
          "[",
          z,
          ".colorAttachments.length]);"
        ), g(
          "}else{",
          N,
          ".bindFramebuffer(",
          o2,
          ",null);"
        ), Lt && g(L, ".drawBuffersWEBGL(", S, ");"), g(
          "}",
          D,
          ".cur=",
          z,
          ";"
        ), B || g("}");
      }
      function Zr(b, g, k) {
        var B = b.shared, P = B.gl, N = b.current, D = b.next, L = B.current, x = B.next, A = b.cond(L, ".dirty");
        Jt.forEach(function(S) {
          var z = zt(S);
          if (!(z in k.state)) {
            var $, J;
            if (z in D) {
              $ = D[z], J = N[z];
              var rt = Xi(Ot[z].length, function(ae) {
                return A.def($, "[", ae, "]");
              });
              A(b.cond(rt.map(function(ae, Kt) {
                return ae + "!==" + J + "[" + Kt + "]";
              }).join("||")).then(
                P,
                ".",
                Q[z],
                "(",
                rt,
                ");",
                rt.map(function(ae, Kt) {
                  return J + "[" + Kt + "]=" + ae;
                }).join(";"),
                ";"
              ));
            } else {
              $ = A.def(x, ".", z);
              var _t = b.cond($, "!==", L, ".", z);
              A(_t), z in it ? _t(
                b.cond($).then(P, ".enable(", it[z], ");").else(P, ".disable(", it[z], ");"),
                L,
                ".",
                z,
                "=",
                $,
                ";"
              ) : _t(
                P,
                ".",
                Q[z],
                "(",
                $,
                ");",
                L,
                ".",
                z,
                "=",
                $,
                ";"
              );
            }
          }
        }), Object.keys(k.state).length === 0 && A(L, ".dirty=false;"), g(A);
      }
      function rn(b, g, k, B) {
        var P = b.shared, N = b.current, D = P.current, L = P.gl;
        d2(Object.keys(k)).forEach(function(x) {
          var A = k[x];
          if (!(B && !B(A))) {
            var S = A.append(b, g);
            if (it[x]) {
              var z = it[x];
              tc(A) ? S ? g(L, ".enable(", z, ");") : g(L, ".disable(", z, ");") : g(b.cond(S).then(L, ".enable(", z, ");").else(L, ".disable(", z, ");")), g(D, ".", x, "=", S, ";");
            } else if (Ji(S)) {
              var $ = N[x];
              g(
                L,
                ".",
                Q[x],
                "(",
                S,
                ");",
                S.map(function(J, rt) {
                  return $ + "[" + rt + "]=" + J;
                }).join(";"),
                ";"
              );
            } else
              g(
                L,
                ".",
                Q[x],
                "(",
                S,
                ");",
                D,
                ".",
                x,
                "=",
                S,
                ";"
              );
          }
        });
      }
      function pr(b, g) {
        ht && (b.instancing = g.def(
          b.shared.extensions,
          ".angle_instanced_arrays"
        ));
      }
      function we(b, g, k, B, P) {
        var N = b.shared, D = b.stats, L = N.current, x = N.timer, A = k.profile;
        function S() {
          return typeof performance > "u" ? "Date.now()" : "performance.now()";
        }
        var z, $;
        function J(nt) {
          z = g.def(), nt(z, "=", S(), ";"), typeof P == "string" ? nt(D, ".count+=", P, ";") : nt(D, ".count++;"), dt && (B ? ($ = g.def(), nt($, "=", x, ".getNumPendingQueries();")) : nt(x, ".beginQuery(", D, ");"));
        }
        function rt(nt) {
          nt(D, ".cpuTime+=", S(), "-", z, ";"), dt && (B ? nt(
            x,
            ".pushScopeStats(",
            $,
            ",",
            x,
            ".getNumPendingQueries(),",
            D,
            ");"
          ) : nt(x, ".endQuery();"));
        }
        function _t(nt) {
          var K = g.def(L, ".profile");
          g(L, ".profile=", nt, ";"), g.exit(L, ".profile=", K, ";");
        }
        var ae;
        if (A) {
          if (tc(A)) {
            A.enable ? (J(g), rt(g.exit), _t("true")) : _t("false");
            return;
          }
          ae = A.append(b, g), _t(ae);
        } else
          ae = g.def(L, ".profile");
        var Kt = b.block();
        J(Kt), g("if(", ae, "){", Kt, "}");
        var Pt = b.block();
        rt(Pt), g.exit("if(", ae, "){", Pt, "}");
      }
      function nn(b, g, k, B, P) {
        var N = b.shared;
        function D(x) {
          switch (x) {
            case mm:
            case vm:
            case xm:
              return 2;
            case gm:
            case _m:
            case wm:
              return 3;
            case ym:
            case bm:
            case Sm:
              return 4;
            default:
              return 1;
          }
        }
        function L(x, A, S) {
          var z = N.gl, $ = g.def(x, ".location"), J = g.def(N.attributes, "[", $, "]"), rt = S.state, _t = S.buffer, ae = [
            S.x,
            S.y,
            S.z,
            S.w
          ], Kt = [
            "buffer",
            "normalized",
            "offset",
            "stride"
          ];
          function Pt() {
            g(
              "if(!",
              J,
              ".buffer){",
              z,
              ".enableVertexAttribArray(",
              $,
              ");}"
            );
            var K = S.type, Ht;
            if (S.size ? Ht = g.def(S.size, "||", A) : Ht = A, g(
              "if(",
              J,
              ".type!==",
              K,
              "||",
              J,
              ".size!==",
              Ht,
              "||",
              Kt.map(function(se) {
                return J + "." + se + "!==" + S[se];
              }).join("||"),
              "){",
              z,
              ".bindBuffer(",
              pd,
              ",",
              _t,
              ".buffer);",
              z,
              ".vertexAttribPointer(",
              [
                $,
                Ht,
                K,
                S.normalized,
                S.stride,
                S.offset
              ],
              ");",
              J,
              ".type=",
              K,
              ";",
              J,
              ".size=",
              Ht,
              ";",
              Kt.map(function(se) {
                return J + "." + se + "=" + S[se] + ";";
              }).join(""),
              "}"
            ), ht) {
              var Ut = S.divisor;
              g(
                "if(",
                J,
                ".divisor!==",
                Ut,
                "){",
                b.instancing,
                ".vertexAttribDivisorANGLE(",
                [$, Ut],
                ");",
                J,
                ".divisor=",
                Ut,
                ";}"
              );
            }
          }
          function nt() {
            g(
              "if(",
              J,
              ".buffer){",
              z,
              ".disableVertexAttribArray(",
              $,
              ");",
              J,
              ".buffer=null;",
              "}if(",
              dd.map(function(K, Ht) {
                return J + "." + K + "!==" + ae[Ht];
              }).join("||"),
              "){",
              z,
              ".vertexAttrib4f(",
              $,
              ",",
              ae,
              ");",
              dd.map(function(K, Ht) {
                return J + "." + K + "=" + ae[Ht] + ";";
              }).join(""),
              "}"
            );
          }
          rt === ud ? Pt() : rt === Sv ? nt() : (g("if(", rt, "===", ud, "){"), Pt(), g("}else{"), nt(), g("}"));
        }
        B.forEach(function(x) {
          var A = x.name, S = k.attributes[A], z;
          if (S) {
            if (!P(S))
              return;
            z = S.append(b, g);
          } else {
            if (!P(u2))
              return;
            var $ = b.scopeAttrib(A);
            _.optional(function() {
              b.assert(
                g,
                $ + ".state",
                "missing attribute " + A
              );
            }), z = {}, Object.keys(new R()).forEach(function(J) {
              z[J] = g.def($, ".", J);
            });
          }
          L(
            b.link(x),
            D(x.info.type),
            z
          );
        });
      }
      function hi(b, g, k, B, P, N) {
        for (var D = b.shared, L = D.gl, x = {}, A, S = 0; S < B.length; ++S) {
          var z = B[S], $ = z.name, J = z.info.type, rt = z.info.size, _t = k.uniforms[$];
          if (rt > 1) {
            if (!_t)
              continue;
            var ae = $.replace("[0]", "");
            if (x[ae])
              continue;
            x[ae] = 1;
          }
          var Kt = b.link(z), Pt = Kt + ".location", nt;
          if (_t) {
            if (!P(_t))
              continue;
            if (tc(_t)) {
              var K = _t.value;
              if (_.command(
                K !== null && typeof K < "u",
                'missing uniform "' + $ + '"',
                b.commandStr
              ), J === Oh || J === Dh) {
                _.command(
                  typeof K == "function" && (J === Oh && (K._reglType === "texture2d" || K._reglType === "framebuffer") || J === Dh && (K._reglType === "textureCube" || K._reglType === "framebufferCube")),
                  "invalid texture for uniform " + $,
                  b.commandStr
                );
                var Ht = b.link(K._texture || K.color[0]._texture);
                g(L, ".uniform1i(", Pt, ",", Ht + ".bind());"), g.exit(Ht, ".unbind();");
              } else if (J === Eh || J === kh || J === Ch) {
                _.optional(function() {
                  _.command(
                    Ji(K),
                    "invalid matrix for uniform " + $,
                    b.commandStr
                  ), _.command(
                    J === Eh && K.length === 4 || J === kh && K.length === 9 || J === Ch && K.length === 16,
                    "invalid length for matrix uniform " + $,
                    b.commandStr
                  );
                });
                var Ut = b.global.def("new Float32Array([" + Array.prototype.slice.call(K) + "])"), se = 2;
                J === kh ? se = 3 : J === Ch && (se = 4), g(
                  L,
                  ".uniformMatrix",
                  se,
                  "fv(",
                  Pt,
                  ",false,",
                  Ut,
                  ");"
                );
              } else {
                switch (J) {
                  case zv:
                    rt === 1 ? _.commandType(K, "number", "uniform " + $, b.commandStr) : _.command(
                      Ji(K) && K.length === rt,
                      "uniform " + $,
                      b.commandStr
                    ), A = "1f";
                    break;
                  case mm:
                    _.command(
                      Ji(K) && K.length && K.length % 2 === 0 && K.length <= rt * 2,
                      "uniform " + $,
                      b.commandStr
                    ), A = "2f";
                    break;
                  case gm:
                    _.command(
                      Ji(K) && K.length && K.length % 3 === 0 && K.length <= rt * 3,
                      "uniform " + $,
                      b.commandStr
                    ), A = "3f";
                    break;
                  case ym:
                    _.command(
                      Ji(K) && K.length && K.length % 4 === 0 && K.length <= rt * 4,
                      "uniform " + $,
                      b.commandStr
                    ), A = "4f";
                    break;
                  case Vv:
                    rt === 1 ? _.commandType(K, "boolean", "uniform " + $, b.commandStr) : _.command(
                      Ji(K) && K.length === rt,
                      "uniform " + $,
                      b.commandStr
                    ), A = "1i";
                    break;
                  case Uv:
                    rt === 1 ? _.commandType(K, "number", "uniform " + $, b.commandStr) : _.command(
                      Ji(K) && K.length === rt,
                      "uniform " + $,
                      b.commandStr
                    ), A = "1i";
                    break;
                  case xm:
                    _.command(
                      Ji(K) && K.length && K.length % 2 === 0 && K.length <= rt * 2,
                      "uniform " + $,
                      b.commandStr
                    ), A = "2i";
                    break;
                  case vm:
                    _.command(
                      Ji(K) && K.length && K.length % 2 === 0 && K.length <= rt * 2,
                      "uniform " + $,
                      b.commandStr
                    ), A = "2i";
                    break;
                  case wm:
                    _.command(
                      Ji(K) && K.length && K.length % 3 === 0 && K.length <= rt * 3,
                      "uniform " + $,
                      b.commandStr
                    ), A = "3i";
                    break;
                  case _m:
                    _.command(
                      Ji(K) && K.length && K.length % 3 === 0 && K.length <= rt * 3,
                      "uniform " + $,
                      b.commandStr
                    ), A = "3i";
                    break;
                  case Sm:
                    _.command(
                      Ji(K) && K.length && K.length % 4 === 0 && K.length <= rt * 4,
                      "uniform " + $,
                      b.commandStr
                    ), A = "4i";
                    break;
                  case bm:
                    _.command(
                      Ji(K) && K.length && K.length % 4 === 0 && K.length <= rt * 4,
                      "uniform " + $,
                      b.commandStr
                    ), A = "4i";
                    break;
                }
                rt > 1 ? (A += "v", K = b.global.def("[" + Array.prototype.slice.call(K) + "]")) : K = Ji(K) ? Array.prototype.slice.call(K) : K, g(
                  L,
                  ".uniform",
                  A,
                  "(",
                  Pt,
                  ",",
                  K,
                  ");"
                );
              }
              continue;
            } else
              nt = _t.append(b, g);
          } else {
            if (!P(u2))
              continue;
            nt = g.def(D.uniforms, "[", y.id($), "]");
          }
          J === Oh ? (_(!Array.isArray(nt), "must specify a scalar prop for textures"), g(
            "if(",
            nt,
            "&&",
            nt,
            '._reglType==="framebuffer"){',
            nt,
            "=",
            nt,
            ".color[0];",
            "}"
          )) : J === Dh && (_(!Array.isArray(nt), "must specify a scalar prop for cube maps"), g(
            "if(",
            nt,
            "&&",
            nt,
            '._reglType==="framebufferCube"){',
            nt,
            "=",
            nt,
            ".color[0];",
            "}"
          )), _.optional(function() {
            function Kn(Bn, Am) {
              b.assert(
                g,
                Bn,
                'bad data or missing for uniform "' + $ + '".  ' + Am
              );
            }
            function ol(Bn, Am) {
              Am === 1 && _(!Array.isArray(nt), "must not specify an array type for uniform"), Kn(
                "Array.isArray(" + nt + ") && typeof " + nt + '[0]===" ' + Bn + '" || typeof ' + nt + '==="' + Bn + '"',
                "invalid type, expected " + Bn
              );
            }
            function as(Bn, Am, Tm) {
              Array.isArray(nt) ? _(nt.length && nt.length % Bn === 0 && nt.length <= Bn * Tm, "must have length of " + (Tm === 1 ? "" : "n * ") + Bn) : Kn(
                D.isArrayLike + "(" + nt + ")&&" + nt + ".length && " + nt + ".length % " + Bn + " === 0 && " + nt + ".length<=" + Bn * Tm,
                "invalid vector, should have length of " + (Tm === 1 ? "" : "n * ") + Bn,
                b.commandStr
              );
            }
            function v2(Bn) {
              _(!Array.isArray(nt), "must not specify a value type"), Kn(
                "typeof " + nt + '==="function"&&' + nt + '._reglType==="texture' + (Bn === i2 ? "2d" : "Cube") + '"',
                "invalid texture type",
                b.commandStr
              );
            }
            switch (J) {
              case Uv:
                ol("number", rt);
                break;
              case vm:
                as(2, "number", rt);
                break;
              case _m:
                as(3, "number", rt);
                break;
              case bm:
                as(4, "number", rt);
                break;
              case zv:
                ol("number", rt);
                break;
              case mm:
                as(2, "number", rt);
                break;
              case gm:
                as(3, "number", rt);
                break;
              case ym:
                as(4, "number", rt);
                break;
              case Vv:
                ol("boolean", rt);
                break;
              case xm:
                as(2, "boolean", rt);
                break;
              case wm:
                as(3, "boolean", rt);
                break;
              case Sm:
                as(4, "boolean", rt);
                break;
              case Eh:
                as(4, "number", rt);
                break;
              case kh:
                as(9, "number", rt);
                break;
              case Ch:
                as(16, "number", rt);
                break;
              case Oh:
                v2(i2);
                break;
              case Dh:
                v2(U6);
                break;
            }
          });
          var gi = 1;
          switch (J) {
            case Oh:
            case Dh:
              var sn = g.def(nt, "._texture");
              g(L, ".uniform1i(", Pt, ",", sn, ".bind());"), g.exit(sn, ".unbind();");
              continue;
            case Uv:
            case Vv:
              A = "1i";
              break;
            case vm:
            case xm:
              A = "2i", gi = 2;
              break;
            case _m:
            case wm:
              A = "3i", gi = 3;
              break;
            case bm:
            case Sm:
              A = "4i", gi = 4;
              break;
            case zv:
              A = "1f";
              break;
            case mm:
              A = "2f", gi = 2;
              break;
            case gm:
              A = "3f", gi = 3;
              break;
            case ym:
              A = "4f", gi = 4;
              break;
            case Eh:
              A = "Matrix2fv";
              break;
            case kh:
              A = "Matrix3fv";
              break;
            case Ch:
              A = "Matrix4fv";
              break;
          }
          if (A.indexOf("Matrix") === -1 && rt > 1 && (A += "v", gi = 1), A.charAt(0) === "M") {
            g(L, ".uniform", A, "(", Pt, ",");
            var sl = Math.pow(J - Eh + 2, 2), Qa = b.global.def("new Float32Array(", sl, ")");
            Array.isArray(nt) ? g(
              "false,(",
              Xi(sl, function(Kn) {
                return Qa + "[" + Kn + "]=" + nt[Kn];
              }),
              ",",
              Qa,
              ")"
            ) : g(
              "false,(Array.isArray(",
              nt,
              ")||",
              nt,
              " instanceof Float32Array)?",
              nt,
              ":(",
              Xi(sl, function(Kn) {
                return Qa + "[" + Kn + "]=" + nt + "[" + Kn + "]";
              }),
              ",",
              Qa,
              ")"
            ), g(");");
          } else if (gi > 1) {
            for (var da = [], ec = [], al = 0; al < gi; ++al)
              Array.isArray(nt) ? ec.push(nt[al]) : ec.push(g.def(nt + "[" + al + "]")), N && da.push(g.def());
            N && g("if(!", b.batchId, "||", da.map(function(Kn, ol) {
              return Kn + "!==" + ec[ol];
            }).join("||"), "){", da.map(function(Kn, ol) {
              return Kn + "=" + ec[ol] + ";";
            }).join("")), g(L, ".uniform", A, "(", Pt, ",", ec.join(","), ");"), N && g("}");
          } else {
            if (_(!Array.isArray(nt), "uniform value must not be an array"), N) {
              var y2 = g.def();
              g(
                "if(!",
                b.batchId,
                "||",
                y2,
                "!==",
                nt,
                "){",
                y2,
                "=",
                nt,
                ";"
              );
            }
            g(L, ".uniform", A, "(", Pt, ",", nt, ");"), N && g("}");
          }
        }
      }
      function ie(b, g, k, B) {
        var P = b.shared, N = P.gl, D = P.draw, L = B.draw;
        function x() {
          var Ht = L.elements, Ut, se = g;
          return Ht ? ((Ht.contextDep && B.contextDynamic || Ht.propDep) && (se = k), Ut = Ht.append(b, se), L.elementsActive && se(
            "if(" + Ut + ")" + N + ".bindBuffer(" + $v + "," + Ut + ".buffer.buffer);"
          )) : (Ut = se.def(), se(
            Ut,
            "=",
            D,
            ".",
            tl,
            ";",
            "if(",
            Ut,
            "){",
            N,
            ".bindBuffer(",
            $v,
            ",",
            Ut,
            ".buffer.buffer);}",
            "else if(",
            P.vao,
            ".currentVAO){",
            Ut,
            "=",
            b.shared.elements + ".getElements(" + P.vao,
            ".currentVAO.elements);",
            st ? "" : "if(" + Ut + ")" + N + ".bindBuffer(" + $v + "," + Ut + ".buffer.buffer);",
            "}"
          )), Ut;
        }
        function A() {
          var Ht = L.count, Ut, se = g;
          return Ht ? ((Ht.contextDep && B.contextDynamic || Ht.propDep) && (se = k), Ut = Ht.append(b, se), _.optional(function() {
            Ht.MISSING && b.assert(g, "false", "missing vertex count"), Ht.DYNAMIC && b.assert(se, Ut + ">=0", "missing vertex count");
          })) : (Ut = se.def(D, ".", il), _.optional(function() {
            b.assert(se, Ut + ">=0", "missing vertex count");
          })), Ut;
        }
        var S = x();
        function z(Ht) {
          var Ut = L[Ht];
          return Ut ? Ut.contextDep && B.contextDynamic || Ut.propDep ? Ut.append(b, k) : Ut.append(b, g) : g.def(D, ".", Ht);
        }
        var $ = z(el), J = z(fm), rt = A();
        if (typeof rt == "number") {
          if (rt === 0)
            return;
        } else
          k("if(", rt, "){"), k.exit("}");
        var _t, ae;
        ht && (_t = z(pm), ae = b.instancing);
        var Kt = S + ".type", Pt = L.elements && tc(L.elements) && !L.vaoActive;
        function nt() {
          function Ht() {
            k(ae, ".drawElementsInstancedANGLE(", [
              $,
              rt,
              Kt,
              J + "<<((" + Kt + "-" + BS + ")>>1)",
              _t
            ], ");");
          }
          function Ut() {
            k(
              ae,
              ".drawArraysInstancedANGLE(",
              [$, J, rt, _t],
              ");"
            );
          }
          S && S !== "null" ? Pt ? Ht() : (k("if(", S, "){"), Ht(), k("}else{"), Ut(), k("}")) : Ut();
        }
        function K() {
          function Ht() {
            k(N + ".drawElements(" + [
              $,
              rt,
              Kt,
              J + "<<((" + Kt + "-" + BS + ")>>1)"
            ] + ");");
          }
          function Ut() {
            k(N + ".drawArrays(" + [$, J, rt] + ");");
          }
          S && S !== "null" ? Pt ? Ht() : (k("if(", S, "){"), Ht(), k("}else{"), Ut(), k("}")) : Ut();
        }
        ht && (typeof _t != "number" || _t >= 0) ? typeof _t == "string" ? (k("if(", _t, ">0){"), nt(), k("}else if(", _t, "<0){"), K(), k("}")) : nt() : K();
      }
      function Ge(b, g, k, B, P) {
        var N = ce(), D = N.proc("body", P);
        return _.optional(function() {
          N.commandStr = g.commandStr, N.command = N.link(g.commandStr);
        }), ht && (N.instancing = D.def(
          N.shared.extensions,
          ".angle_instanced_arrays"
        )), b(N, D, k, B), N.compile().body;
      }
      function ri(b, g, k, B) {
        pr(b, g), k.useVAO ? k.drawVAO ? g(b.shared.vao, ".setVAO(", k.drawVAO.append(b, g), ");") : g(b.shared.vao, ".setVAO(", b.shared.vao, ".targetVAO);") : (g(b.shared.vao, ".setVAO(null);"), nn(b, g, k, B.attributes, function() {
          return !0;
        })), hi(b, g, k, B.uniforms, function() {
          return !0;
        }, !1), ie(b, g, g, k);
      }
      function mr(b, g) {
        var k = b.proc("draw", 1);
        pr(b, k), Or(b, k, g.context), Dr(b, k, g.framebuffer), Zr(b, k, g), rn(b, k, g.state), we(b, k, g, !1, !0);
        var B = g.shader.progVar.append(b, k);
        if (k(b.shared.gl, ".useProgram(", B, ".program);"), g.shader.program)
          ri(b, k, g, g.shader.program);
        else {
          k(b.shared.vao, ".setVAO(null);");
          var P = b.global.def("{}"), N = k.def(B, ".id"), D = k.def(P, "[", N, "]");
          k(
            b.cond(D).then(D, ".call(this,a0);").else(
              D,
              "=",
              P,
              "[",
              N,
              "]=",
              b.link(function(L) {
                return Ge(ri, b, g, L, 1);
              }),
              "(",
              B,
              ");",
              D,
              ".call(this,a0);"
            )
          );
        }
        Object.keys(g.state).length > 0 && k(b.shared.current, ".dirty=true;"), b.shared.vao && k(b.shared.vao, ".setVAO(null);");
      }
      function la(b, g, k, B) {
        b.batchId = "a1", pr(b, g);
        function P() {
          return !0;
        }
        nn(b, g, k, B.attributes, P), hi(b, g, k, B.uniforms, P, !1), ie(b, g, g, k);
      }
      function nl(b, g, k, B) {
        pr(b, g);
        var P = k.contextDep, N = g.def(), D = "a0", L = "a1", x = g.def();
        b.shared.props = x, b.batchId = N;
        var A = b.scope(), S = b.scope();
        g(
          A.entry,
          "for(",
          N,
          "=0;",
          N,
          "<",
          L,
          ";++",
          N,
          "){",
          x,
          "=",
          D,
          "[",
          N,
          "];",
          S,
          "}",
          A.exit
        );
        function z(Kt) {
          return Kt.contextDep && P || Kt.propDep;
        }
        function $(Kt) {
          return !z(Kt);
        }
        if (k.needsContext && Or(b, S, k.context), k.needsFramebuffer && Dr(b, S, k.framebuffer), rn(b, S, k.state, z), k.profile && z(k.profile) && we(b, S, k, !1, !0), B)
          k.useVAO ? k.drawVAO ? z(k.drawVAO) ? S(b.shared.vao, ".setVAO(", k.drawVAO.append(b, S), ");") : A(b.shared.vao, ".setVAO(", k.drawVAO.append(b, A), ");") : A(b.shared.vao, ".setVAO(", b.shared.vao, ".targetVAO);") : (A(b.shared.vao, ".setVAO(null);"), nn(b, A, k, B.attributes, $), nn(b, S, k, B.attributes, z)), hi(b, A, k, B.uniforms, $, !1), hi(b, S, k, B.uniforms, z, !0), ie(b, A, S, k);
        else {
          var J = b.global.def("{}"), rt = k.shader.progVar.append(b, S), _t = S.def(rt, ".id"), ae = S.def(J, "[", _t, "]");
          S(
            b.shared.gl,
            ".useProgram(",
            rt,
            ".program);",
            "if(!",
            ae,
            "){",
            ae,
            "=",
            J,
            "[",
            _t,
            "]=",
            b.link(function(Kt) {
              return Ge(
                la,
                b,
                k,
                Kt,
                2
              );
            }),
            "(",
            rt,
            ");}",
            ae,
            ".call(this,a0[",
            N,
            "],",
            N,
            ");"
          );
        }
      }
      function I(b, g) {
        var k = b.proc("batch", 2);
        b.batchId = "0", pr(b, k);
        var B = !1, P = !0;
        Object.keys(g.context).forEach(function(J) {
          B = B || g.context[J].propDep;
        }), B || (Or(b, k, g.context), P = !1);
        var N = g.framebuffer, D = !1;
        N ? (N.propDep ? B = D = !0 : N.contextDep && B && (D = !0), D || Dr(b, k, N)) : Dr(b, k, null), g.state.viewport && g.state.viewport.propDep && (B = !0);
        function L(J) {
          return J.contextDep && B || J.propDep;
        }
        Zr(b, k, g), rn(b, k, g.state, function(J) {
          return !L(J);
        }), (!g.profile || !L(g.profile)) && we(b, k, g, !1, "a1"), g.contextDep = B, g.needsContext = P, g.needsFramebuffer = D;
        var x = g.shader.progVar;
        if (x.contextDep && B || x.propDep)
          nl(
            b,
            k,
            g,
            null
          );
        else {
          var A = x.append(b, k);
          if (k(b.shared.gl, ".useProgram(", A, ".program);"), g.shader.program)
            nl(
              b,
              k,
              g,
              g.shader.program
            );
          else {
            k(b.shared.vao, ".setVAO(null);");
            var S = b.global.def("{}"), z = k.def(A, ".id"), $ = k.def(S, "[", z, "]");
            k(
              b.cond($).then($, ".call(this,a0,a1);").else(
                $,
                "=",
                S,
                "[",
                z,
                "]=",
                b.link(function(J) {
                  return Ge(nl, b, g, J, 2);
                }),
                "(",
                A,
                ");",
                $,
                ".call(this,a0,a1);"
              )
            );
          }
        }
        Object.keys(g.state).length > 0 && k(b.shared.current, ".dirty=true;"), b.shared.vao && k(b.shared.vao, ".setVAO(null);");
      }
      function H(b, g) {
        var k = b.proc("scope", 3);
        b.batchId = "a2";
        var B = b.shared, P = B.current;
        Or(b, k, g.context), g.framebuffer && g.framebuffer.append(b, k), d2(Object.keys(g.state)).forEach(function(D) {
          var L = g.state[D], x = L.append(b, k);
          Ji(x) ? x.forEach(function(A, S) {
            k.set(b.next[D], "[" + S + "]", A);
          }) : k.set(B.next, "." + D, x);
        }), we(b, k, g, !0, !0), [tl, fm, il, pm, el].forEach(
          function(D) {
            var L = g.draw[D];
            L && k.set(B.draw, "." + D, "" + L.append(b, k));
          }
        ), Object.keys(g.uniforms).forEach(function(D) {
          var L = g.uniforms[D].append(b, k);
          Array.isArray(L) && (L = "[" + L.join() + "]"), k.set(
            B.uniforms,
            "[" + y.id(D) + "]",
            L
          );
        }), Object.keys(g.attributes).forEach(function(D) {
          var L = g.attributes[D].append(b, k), x = b.scopeAttrib(D);
          Object.keys(new R()).forEach(function(A) {
            k.set(x, "." + A, L[A]);
          });
        }), g.scopeVAO && k.set(B.vao, ".targetVAO", g.scopeVAO.append(b, k));
        function N(D) {
          var L = g.shader[D];
          L && k.set(B.shader, "." + D, L.append(b, k));
        }
        N(Ih), N(Ah), Object.keys(g.state).length > 0 && (k(P, ".dirty=true;"), k.exit(P, ".dirty=true;")), k("a1(", b.shared.context, ",a0,", b.batchId, ");");
      }
      function U(b) {
        if (!(typeof b != "object" || Ji(b))) {
          for (var g = Object.keys(b), k = 0; k < g.length; ++k)
            if (Ii.isDynamic(b[g[k]]))
              return !0;
          return !1;
        }
      }
      function $t(b, g, k) {
        var B = g.static[k];
        if (!B || !U(B))
          return;
        var P = b.global, N = Object.keys(B), D = !1, L = !1, x = !1, A = b.global.def("{}");
        N.forEach(function(z) {
          var $ = B[z];
          if (Ii.isDynamic($)) {
            typeof $ == "function" && ($ = B[z] = Ii.unbox($));
            var J = Fn($, null);
            D = D || J.thisDep, x = x || J.propDep, L = L || J.contextDep;
          } else {
            switch (P(A, ".", z, "="), typeof $) {
              case "number":
                P($);
                break;
              case "string":
                P('"', $, '"');
                break;
              case "object":
                Array.isArray($) && P("[", $.join(), "]");
                break;
              default:
                P(b.link($));
                break;
            }
            P(";");
          }
        });
        function S(z, $) {
          N.forEach(function(J) {
            var rt = B[J];
            if (Ii.isDynamic(rt)) {
              var _t = z.invoke($, rt);
              $(A, ".", J, "=", _t, ";");
            }
          });
        }
        g.dynamic[k] = new Ii.DynamicVariable(um, {
          thisDep: D,
          contextDep: L,
          propDep: x,
          ref: A,
          append: S
        }), delete g.static[k];
      }
      function Ue(b, g, k, B, P) {
        var N = ce();
        N.stats = N.link(P), Object.keys(g.static).forEach(function(L) {
          $t(N, g, L);
        }), P6.forEach(function(L) {
          $t(N, b, L);
        });
        var D = Sr(b, g, k, B, N);
        return mr(N, D), H(N, D), I(N, D), r(N.compile(), {
          destroy: function() {
            D.shader.program.destroy();
          }
        });
      }
      return {
        next: Tt,
        current: Ot,
        procs: function() {
          var b = ce(), g = b.proc("poll"), k = b.proc("refresh"), B = b.block();
          g(B), k(B);
          var P = b.shared, N = P.gl, D = P.next, L = P.current;
          B(L, ".dirty=false;"), Dr(b, g), Dr(b, k, null, !0);
          var x;
          ht && (x = b.link(ht)), T.oes_vertex_array_object && k(b.link(T.oes_vertex_array_object), ".bindVertexArrayOES(null);");
          for (var A = 0; A < G.maxAttributes; ++A) {
            var S = k.def(P.attributes, "[", A, "]"), z = b.cond(S, ".buffer");
            z.then(
              N,
              ".enableVertexAttribArray(",
              A,
              ");",
              N,
              ".bindBuffer(",
              pd,
              ",",
              S,
              ".buffer.buffer);",
              N,
              ".vertexAttribPointer(",
              A,
              ",",
              S,
              ".size,",
              S,
              ".type,",
              S,
              ".normalized,",
              S,
              ".stride,",
              S,
              ".offset);"
            ).else(
              N,
              ".disableVertexAttribArray(",
              A,
              ");",
              N,
              ".vertexAttrib4f(",
              A,
              ",",
              S,
              ".x,",
              S,
              ".y,",
              S,
              ".z,",
              S,
              ".w);",
              S,
              ".buffer=null;"
            ), k(z), ht && k(
              x,
              ".vertexAttribDivisorANGLE(",
              A,
              ",",
              S,
              ".divisor);"
            );
          }
          return k(
            b.shared.vao,
            ".currentVAO=null;",
            b.shared.vao,
            ".setVAO(",
            b.shared.vao,
            ".targetVAO);"
          ), Object.keys(it).forEach(function($) {
            var J = it[$], rt = B.def(D, ".", $), _t = b.block();
            _t(
              "if(",
              rt,
              "){",
              N,
              ".enable(",
              J,
              ")}else{",
              N,
              ".disable(",
              J,
              ")}",
              L,
              ".",
              $,
              "=",
              rt,
              ";"
            ), k(_t), g(
              "if(",
              rt,
              "!==",
              L,
              ".",
              $,
              "){",
              _t,
              "}"
            );
          }), Object.keys(Q).forEach(function($) {
            var J = Q[$], rt = Ot[$], _t, ae, Kt = b.block();
            if (Kt(N, ".", J, "("), Ji(rt)) {
              var Pt = rt.length;
              _t = b.global.def(D, ".", $), ae = b.global.def(L, ".", $), Kt(
                Xi(Pt, function(nt) {
                  return _t + "[" + nt + "]";
                }),
                ");",
                Xi(Pt, function(nt) {
                  return ae + "[" + nt + "]=" + _t + "[" + nt + "];";
                }).join("")
              ), g(
                "if(",
                Xi(Pt, function(nt) {
                  return _t + "[" + nt + "]!==" + ae + "[" + nt + "]";
                }).join("||"),
                "){",
                Kt,
                "}"
              );
            } else
              _t = B.def(D, ".", $), ae = B.def(L, ".", $), Kt(
                _t,
                ");",
                L,
                ".",
                $,
                "=",
                _t,
                ";"
              ), g(
                "if(",
                _t,
                "!==",
                ae,
                "){",
                Kt,
                "}"
              );
            k(Kt);
          }), b.compile();
        }(),
        compile: Ue
      };
    }
    function rF() {
      return {
        vaoCount: 0,
        bufferCount: 0,
        elementsCount: 0,
        framebufferCount: 0,
        shaderCount: 0,
        textureCount: 0,
        cubeCount: 0,
        renderbufferCount: 0,
        maxTextureUnits: 0
      };
    }
    var nF = 34918, sF = 34919, h2 = 35007, aF = function(f, y) {
      if (!y.ext_disjoint_timer_query)
        return null;
      var T = [];
      function G() {
        return T.pop() || y.ext_disjoint_timer_query.createQueryEXT();
      }
      function tt(ht) {
        T.push(ht);
      }
      var j = [];
      function q(ht) {
        var Lt = G();
        y.ext_disjoint_timer_query.beginQueryEXT(h2, Lt), j.push(Lt), dt(j.length - 1, j.length, ht);
      }
      function lt() {
        y.ext_disjoint_timer_query.endQueryEXT(h2);
      }
      function ct() {
        this.startQueryIndex = -1, this.endQueryIndex = -1, this.sum = 0, this.stats = null;
      }
      var pt = [];
      function gt() {
        return pt.pop() || new ct();
      }
      function mt(ht) {
        pt.push(ht);
      }
      var xt = [];
      function dt(ht, Lt, st) {
        var Ot = gt();
        Ot.startQueryIndex = ht, Ot.endQueryIndex = Lt, Ot.sum = 0, Ot.stats = st, xt.push(Ot);
      }
      var ft = [], R = [];
      function Y() {
        var ht, Lt, st = j.length;
        if (st !== 0) {
          R.length = Math.max(R.length, st + 1), ft.length = Math.max(ft.length, st + 1), ft[0] = 0, R[0] = 0;
          var Ot = 0;
          for (ht = 0, Lt = 0; Lt < j.length; ++Lt) {
            var Tt = j[Lt];
            y.ext_disjoint_timer_query.getQueryObjectEXT(Tt, sF) ? (Ot += y.ext_disjoint_timer_query.getQueryObjectEXT(Tt, nF), tt(Tt)) : j[ht++] = Tt, ft[Lt + 1] = Ot, R[Lt + 1] = ht;
          }
          for (j.length = ht, ht = 0, Lt = 0; Lt < xt.length; ++Lt) {
            var Jt = xt[Lt], it = Jt.startQueryIndex, Q = Jt.endQueryIndex;
            Jt.sum += ft[Q] - ft[it];
            var zt = R[it], wt = R[Q];
            wt === zt ? (Jt.stats.gpuTime += Jt.sum / 1e6, mt(Jt)) : (Jt.startQueryIndex = zt, Jt.endQueryIndex = wt, xt[ht++] = Jt);
          }
          xt.length = ht;
        }
      }
      return {
        beginQuery: q,
        endQuery: lt,
        pushScopeStats: dt,
        update: Y,
        getNumPendingQueries: function() {
          return j.length;
        },
        clear: function() {
          T.push.apply(T, j);
          for (var ht = 0; ht < T.length; ht++)
            y.ext_disjoint_timer_query.deleteQueryEXT(T[ht]);
          j.length = 0, T.length = 0;
        },
        restore: function() {
          j.length = 0, T.length = 0;
        }
      };
    }, oF = 16384, cF = 256, lF = 1024, dF = 34962, f2 = "webglcontextlost", p2 = "webglcontextrestored", m2 = 1, uF = 2, hF = 3;
    function g2(f, y) {
      for (var T = 0; T < f.length; ++T)
        if (f[T] === y)
          return T;
      return -1;
    }
    function fF(f) {
      var y = Wc(f);
      if (!y)
        return null;
      var T = y.gl, G = T.getContextAttributes(), tt = T.isContextLost(), j = Yo(T, y);
      if (!j)
        return null;
      var q = pn(), lt = rF(), ct = j.extensions, pt = aF(T, ct), gt = fr(), mt = T.drawingBufferWidth, xt = T.drawingBufferHeight, dt = {
        tick: 0,
        time: 0,
        viewportWidth: mt,
        viewportHeight: xt,
        framebufferWidth: mt,
        framebufferHeight: xt,
        drawingBufferWidth: mt,
        drawingBufferHeight: xt,
        pixelRatio: y.pixelRatio
      }, ft = {}, R = {
        elements: null,
        primitive: 4,
        // GL_TRIANGLES
        count: -1,
        offset: 0,
        instances: -1
      }, Y = QN(T, ct), ht = mL(
        T,
        lt,
        y,
        Ot
      ), Lt = EL(T, ct, ht, lt), st = E6(
        T,
        ct,
        Y,
        lt,
        ht,
        Lt,
        R
      );
      function Ot(ie) {
        return st.destroyBuffer(ie);
      }
      var Tt = D6(T, q, lt, y), Jt = n6(
        T,
        ct,
        Y,
        function() {
          zt.procs.poll();
        },
        dt,
        lt,
        y
      ), it = s6(T, ct, Y, lt, y), Q = A6(
        T,
        ct,
        Y,
        Jt,
        it,
        lt
      ), zt = iF(
        T,
        q,
        ct,
        Y,
        ht,
        Lt,
        Jt,
        Q,
        ft,
        st,
        Tt,
        R,
        dt,
        pt,
        y
      ), wt = F6(
        T,
        Q,
        zt.procs.poll,
        dt,
        G,
        ct,
        Y
      ), ut = zt.next, St = T.canvas, At = [], he = [], ce = [], Et = [y.onDestroy], Nt = null;
      function ne() {
        if (At.length === 0) {
          pt && pt.update(), Nt = null;
          return;
        }
        Nt = xr.next(ne), rn();
        for (var ie = At.length - 1; ie >= 0; --ie) {
          var Ge = At[ie];
          Ge && Ge(dt, null, 0);
        }
        T.flush(), pt && pt.update();
      }
      function fe() {
        !Nt && At.length > 0 && (Nt = xr.next(ne));
      }
      function je() {
        Nt && (xr.cancel(ne), Nt = null);
      }
      function Qi(ie) {
        ie.preventDefault(), tt = !0, je(), he.forEach(function(Ge) {
          Ge();
        });
      }
      function sr(ie) {
        T.getError(), tt = !1, j.restore(), Tt.restore(), ht.restore(), Jt.restore(), it.restore(), Q.restore(), st.restore(), pt && pt.restore(), zt.procs.refresh(), fe(), ce.forEach(function(Ge) {
          Ge();
        });
      }
      St && (St.addEventListener(f2, Qi, !1), St.addEventListener(p2, sr, !1));
      function Ye() {
        At.length = 0, je(), St && (St.removeEventListener(f2, Qi), St.removeEventListener(p2, sr)), Tt.clear(), Q.clear(), it.clear(), st.clear(), Jt.clear(), Lt.clear(), ht.clear(), pt && pt.clear(), Et.forEach(function(ie) {
          ie();
        });
      }
      function Cr(ie) {
        _(!!ie, "invalid args to regl({...})"), _.type(ie, "object", "invalid args to regl({...})");
        function Ge(P) {
          var N = r({}, P);
          delete N.uniforms, delete N.attributes, delete N.context, delete N.vao, "stencil" in N && N.stencil.op && (N.stencil.opBack = N.stencil.opFront = N.stencil.op, delete N.stencil.op);
          function D(L) {
            if (L in N) {
              var x = N[L];
              delete N[L], Object.keys(x).forEach(function(A) {
                N[L + "." + A] = x[A];
              });
            }
          }
          return D("blend"), D("depth"), D("cull"), D("stencil"), D("polygonOffset"), D("scissor"), D("sample"), "vao" in P && (N.vao = P.vao), N;
        }
        function ri(P, N) {
          var D = {}, L = {};
          return Object.keys(P).forEach(function(x) {
            var A = P[x];
            if (Ii.isDynamic(A)) {
              L[x] = Ii.unbox(A, x);
              return;
            } else if (N && Array.isArray(A)) {
              for (var S = 0; S < A.length; ++S)
                if (Ii.isDynamic(A[S])) {
                  L[x] = Ii.unbox(A, x);
                  return;
                }
            }
            D[x] = A;
          }), {
            dynamic: L,
            static: D
          };
        }
        var mr = ri(ie.context || {}, !0), la = ri(ie.uniforms || {}, !0), nl = ri(ie.attributes || {}, !1), I = ri(Ge(ie), !1), H = {
          gpuTime: 0,
          cpuTime: 0,
          count: 0
        }, U = zt.compile(I, nl, la, mr, H), $t = U.draw, Ue = U.batch, b = U.scope, g = [];
        function k(P) {
          for (; g.length < P; )
            g.push(null);
          return g;
        }
        function B(P, N) {
          var D;
          if (tt && _.raise("context lost"), typeof P == "function")
            return b.call(this, null, P, 0);
          if (typeof N == "function")
            if (typeof P == "number")
              for (D = 0; D < P; ++D)
                b.call(this, null, N, D);
            else if (Array.isArray(P))
              for (D = 0; D < P.length; ++D)
                b.call(this, P[D], N, D);
            else
              return b.call(this, P, N, 0);
          else if (typeof P == "number") {
            if (P > 0)
              return Ue.call(this, k(P | 0), P | 0);
          } else if (Array.isArray(P)) {
            if (P.length)
              return Ue.call(this, P, P.length);
          } else
            return $t.call(this, P);
        }
        return r(B, {
          stats: H,
          destroy: function() {
            U.destroy();
          }
        });
      }
      var Gi = Q.setFBO = Cr({
        framebuffer: Ii.define.call(null, m2, "framebuffer")
      });
      function Sr(ie, Ge) {
        var ri = 0;
        zt.procs.poll();
        var mr = Ge.color;
        mr && (T.clearColor(+mr[0] || 0, +mr[1] || 0, +mr[2] || 0, +mr[3] || 0), ri |= oF), "depth" in Ge && (T.clearDepth(+Ge.depth), ri |= cF), "stencil" in Ge && (T.clearStencil(Ge.stencil | 0), ri |= lF), _(!!ri, "called regl.clear with no buffer specified"), T.clear(ri);
      }
      function Or(ie) {
        if (_(
          typeof ie == "object" && ie,
          "regl.clear() takes an object as input"
        ), "framebuffer" in ie)
          if (ie.framebuffer && ie.framebuffer_reglType === "framebufferCube")
            for (var Ge = 0; Ge < 6; ++Ge)
              Gi(r({
                framebuffer: ie.framebuffer.faces[Ge]
              }, ie), Sr);
          else
            Gi(ie, Sr);
        else
          Sr(null, ie);
      }
      function Dr(ie) {
        _.type(ie, "function", "regl.frame() callback must be a function"), At.push(ie);
        function Ge() {
          var ri = g2(At, ie);
          _(ri >= 0, "cannot cancel a frame twice");
          function mr() {
            var la = g2(At, mr);
            At[la] = At[At.length - 1], At.length -= 1, At.length <= 0 && je();
          }
          At[ri] = mr;
        }
        return fe(), {
          cancel: Ge
        };
      }
      function Zr() {
        var ie = ut.viewport, Ge = ut.scissor_box;
        ie[0] = ie[1] = Ge[0] = Ge[1] = 0, dt.viewportWidth = dt.framebufferWidth = dt.drawingBufferWidth = ie[2] = Ge[2] = T.drawingBufferWidth, dt.viewportHeight = dt.framebufferHeight = dt.drawingBufferHeight = ie[3] = Ge[3] = T.drawingBufferHeight;
      }
      function rn() {
        dt.tick += 1, dt.time = we(), Zr(), zt.procs.poll();
      }
      function pr() {
        Jt.refresh(), Zr(), zt.procs.refresh(), pt && pt.update();
      }
      function we() {
        return (fr() - gt) / 1e3;
      }
      pr();
      function nn(ie, Ge) {
        _.type(Ge, "function", "listener callback must be a function");
        var ri;
        switch (ie) {
          case "frame":
            return Dr(Ge);
          case "lost":
            ri = he;
            break;
          case "restore":
            ri = ce;
            break;
          case "destroy":
            ri = Et;
            break;
          default:
            _.raise("invalid event, must be one of frame,lost,restore,destroy");
        }
        return ri.push(Ge), {
          cancel: function() {
            for (var mr = 0; mr < ri.length; ++mr)
              if (ri[mr] === Ge) {
                ri[mr] = ri[ri.length - 1], ri.pop();
                return;
              }
          }
        };
      }
      var hi = r(Cr, {
        // Clear current FBO
        clear: Or,
        // Short cuts for dynamic variables
        prop: Ii.define.bind(null, m2),
        context: Ii.define.bind(null, uF),
        this: Ii.define.bind(null, hF),
        // executes an empty draw command
        draw: Cr({}),
        // Resources
        buffer: function(ie) {
          return ht.create(ie, dF, !1, !1);
        },
        elements: function(ie) {
          return Lt.create(ie, !1);
        },
        texture: Jt.create2D,
        cube: Jt.createCube,
        renderbuffer: it.create,
        framebuffer: Q.create,
        framebufferCube: Q.createCube,
        vao: st.createVAO,
        // Expose context attributes
        attributes: G,
        // Frame rendering
        frame: Dr,
        on: nn,
        // System limits
        limits: Y,
        hasExtension: function(ie) {
          return Y.extensions.indexOf(ie.toLowerCase()) >= 0;
        },
        // Read pixels
        read: wt,
        // Destroy regl and all associated resources
        destroy: Ye,
        // Direct GL state manipulation
        _gl: T,
        _refresh: pr,
        poll: function() {
          rn(), pt && pt.update();
        },
        // Current time
        now: we,
        // regl Statistics Information
        stats: lt
      });
      return y.onDone(null, hi), hi;
    }
    return fF;
  });
})(uT);
var VM = uT.exports;
const jM = /* @__PURE__ */ o1(VM);
function Xm(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function GM(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function hT(e) {
  let t, i, r;
  e.length !== 2 ? (t = Xm, i = (o, c) => Xm(e(o), c), r = (o, c) => e(o) - c) : (t = e === Xm || e === GM ? e : HM, i = e, r = e);
  function n(o, c, l = 0, d = o.length) {
    if (l < d) {
      if (t(c, c) !== 0)
        return d;
      do {
        const u = l + d >>> 1;
        i(o[u], c) < 0 ? l = u + 1 : d = u;
      } while (l < d);
    }
    return l;
  }
  function s(o, c, l = 0, d = o.length) {
    if (l < d) {
      if (t(c, c) !== 0)
        return d;
      do {
        const u = l + d >>> 1;
        i(o[u], c) <= 0 ? l = u + 1 : d = u;
      } while (l < d);
    }
    return l;
  }
  function a(o, c, l = 0, d = o.length) {
    const u = n(o, c, l, d - 1);
    return u > l && r(o[u - 1], c) > -r(o[u], c) ? u - 1 : u;
  }
  return { left: n, center: a, right: s };
}
function HM() {
  return 0;
}
function WM(e) {
  return e === null ? NaN : +e;
}
const YM = hT(Xm), qM = YM.right;
hT(WM).center;
function B2(e, t) {
  let i, r;
  if (t === void 0)
    for (const n of e)
      n != null && (i === void 0 ? n >= n && (i = r = n) : (i > n && (i = n), r < n && (r = n)));
  else {
    let n = -1;
    for (let s of e)
      (s = t(s, ++n, e)) != null && (i === void 0 ? s >= s && (i = r = s) : (i > s && (i = s), r < s && (r = s)));
  }
  return [i, r];
}
const ZM = Math.sqrt(50), XM = Math.sqrt(10), KM = Math.sqrt(2);
function Dg(e, t, i) {
  const r = (t - e) / Math.max(0, i), n = Math.floor(Math.log10(r)), s = r / Math.pow(10, n), a = s >= ZM ? 10 : s >= XM ? 5 : s >= KM ? 2 : 1;
  let o, c, l;
  return n < 0 ? (l = Math.pow(10, -n) / a, o = Math.round(e * l), c = Math.round(t * l), o / l < e && ++o, c / l > t && --c, l = -l) : (l = Math.pow(10, n) * a, o = Math.round(e / l), c = Math.round(t / l), o * l < e && ++o, c * l > t && --c), c < o && 0.5 <= i && i < 2 ? Dg(e, t, i * 2) : [o, c, l];
}
function JM(e, t, i) {
  if (t = +t, e = +e, i = +i, !(i > 0))
    return [];
  if (e === t)
    return [e];
  const r = t < e, [n, s, a] = r ? Dg(t, e, i) : Dg(e, t, i);
  if (!(s >= n))
    return [];
  const o = s - n + 1, c = new Array(o);
  if (r)
    if (a < 0)
      for (let l = 0; l < o; ++l)
        c[l] = (s - l) / -a;
    else
      for (let l = 0; l < o; ++l)
        c[l] = (s - l) * a;
  else if (a < 0)
    for (let l = 0; l < o; ++l)
      c[l] = (n + l) / -a;
  else
    for (let l = 0; l < o; ++l)
      c[l] = (n + l) * a;
  return c;
}
function j_(e, t, i) {
  return t = +t, e = +e, i = +i, Dg(e, t, i)[2];
}
function QM(e, t, i) {
  t = +t, e = +e, i = +i;
  const r = t < e, n = r ? j_(t, e, i) : j_(e, t, i);
  return (r ? -1 : 1) * (n < 0 ? 1 / -n : n);
}
function t5(e, t, i) {
  e = +e, t = +t, i = (n = arguments.length) < 2 ? (t = e, e = 0, 1) : n < 3 ? 1 : +i;
  for (var r = -1, n = Math.max(0, Math.ceil((t - e) / i)) | 0, s = new Array(n); ++r < n; )
    s[r] = e + r * i;
  return s;
}
function fT(e, t) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(e);
      break;
    default:
      this.range(t).domain(e);
      break;
  }
  return this;
}
function e5(e) {
  return function() {
    return e;
  };
}
function i5(e) {
  return +e;
}
var R2 = [0, 1];
function Ea(e) {
  return e;
}
function G_(e, t) {
  return (t -= e = +e) ? function(i) {
    return (i - e) / t;
  } : e5(isNaN(t) ? NaN : 0.5);
}
function r5(e, t) {
  var i;
  return e > t && (i = e, e = t, t = i), function(r) {
    return Math.max(e, Math.min(t, r));
  };
}
function n5(e, t, i) {
  var r = e[0], n = e[1], s = t[0], a = t[1];
  return n < r ? (r = G_(n, r), s = i(a, s)) : (r = G_(r, n), s = i(s, a)), function(o) {
    return s(r(o));
  };
}
function s5(e, t, i) {
  var r = Math.min(e.length, t.length) - 1, n = new Array(r), s = new Array(r), a = -1;
  for (e[r] < e[0] && (e = e.slice().reverse(), t = t.slice().reverse()); ++a < r; )
    n[a] = G_(e[a], e[a + 1]), s[a] = i(t[a], t[a + 1]);
  return function(o) {
    var c = qM(e, o, 1, r) - 1;
    return s[c](n[c](o));
  };
}
function pT(e, t) {
  return t.domain(e.domain()).range(e.range()).interpolate(e.interpolate()).clamp(e.clamp()).unknown(e.unknown());
}
function mT() {
  var e = R2, t = R2, i = s1, r, n, s, a = Ea, o, c, l;
  function d() {
    var h = Math.min(e.length, t.length);
    return a !== Ea && (a = r5(e[0], e[h - 1])), o = h > 2 ? s5 : n5, c = l = null, u;
  }
  function u(h) {
    return h == null || isNaN(h = +h) ? s : (c || (c = o(e.map(r), t, i)))(r(a(h)));
  }
  return u.invert = function(h) {
    return a(n((l || (l = o(t, e.map(r), Ps)))(h)));
  }, u.domain = function(h) {
    return arguments.length ? (e = Array.from(h, i5), d()) : e.slice();
  }, u.range = function(h) {
    return arguments.length ? (t = Array.from(h), d()) : t.slice();
  }, u.rangeRound = function(h) {
    return t = Array.from(h), i = TR, d();
  }, u.clamp = function(h) {
    return arguments.length ? (a = h ? !0 : Ea, d()) : a !== Ea;
  }, u.interpolate = function(h) {
    return arguments.length ? (i = h, d()) : i;
  }, u.unknown = function(h) {
    return arguments.length ? (s = h, u) : s;
  }, function(h, p) {
    return r = h, n = p, d();
  };
}
function a5() {
  return mT()(Ea, Ea);
}
function o5(e) {
  return Math.abs(e = Math.round(e)) >= 1e21 ? e.toLocaleString("en").replace(/,/g, "") : e.toString(10);
}
function Ng(e, t) {
  if ((i = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) < 0)
    return null;
  var i, r = e.slice(0, i);
  return [
    r.length > 1 ? r[0] + r.slice(2) : r,
    +e.slice(i + 1)
  ];
}
function Au(e) {
  return e = Ng(Math.abs(e)), e ? e[1] : NaN;
}
function c5(e, t) {
  return function(i, r) {
    for (var n = i.length, s = [], a = 0, o = e[0], c = 0; n > 0 && o > 0 && (c + o + 1 > r && (o = Math.max(1, r - c)), s.push(i.substring(n -= o, n + o)), !((c += o + 1) > r)); )
      o = e[a = (a + 1) % e.length];
    return s.reverse().join(t);
  };
}
function l5(e) {
  return function(t) {
    return t.replace(/[0-9]/g, function(i) {
      return e[+i];
    });
  };
}
var d5 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Lg(e) {
  if (!(t = d5.exec(e)))
    throw new Error("invalid format: " + e);
  var t;
  return new c1({
    fill: t[1],
    align: t[2],
    sign: t[3],
    symbol: t[4],
    zero: t[5],
    width: t[6],
    comma: t[7],
    precision: t[8] && t[8].slice(1),
    trim: t[9],
    type: t[10]
  });
}
Lg.prototype = c1.prototype;
function c1(e) {
  this.fill = e.fill === void 0 ? " " : e.fill + "", this.align = e.align === void 0 ? ">" : e.align + "", this.sign = e.sign === void 0 ? "-" : e.sign + "", this.symbol = e.symbol === void 0 ? "" : e.symbol + "", this.zero = !!e.zero, this.width = e.width === void 0 ? void 0 : +e.width, this.comma = !!e.comma, this.precision = e.precision === void 0 ? void 0 : +e.precision, this.trim = !!e.trim, this.type = e.type === void 0 ? "" : e.type + "";
}
c1.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function u5(e) {
  t:
    for (var t = e.length, i = 1, r = -1, n; i < t; ++i)
      switch (e[i]) {
        case ".":
          r = n = i;
          break;
        case "0":
          r === 0 && (r = i), n = i;
          break;
        default:
          if (!+e[i])
            break t;
          r > 0 && (r = 0);
          break;
      }
  return r > 0 ? e.slice(0, r) + e.slice(n + 1) : e;
}
var gT;
function h5(e, t) {
  var i = Ng(e, t);
  if (!i)
    return e + "";
  var r = i[0], n = i[1], s = n - (gT = Math.max(-8, Math.min(8, Math.floor(n / 3))) * 3) + 1, a = r.length;
  return s === a ? r : s > a ? r + new Array(s - a + 1).join("0") : s > 0 ? r.slice(0, s) + "." + r.slice(s) : "0." + new Array(1 - s).join("0") + Ng(e, Math.max(0, t + s - 1))[0];
}
function M2(e, t) {
  var i = Ng(e, t);
  if (!i)
    return e + "";
  var r = i[0], n = i[1];
  return n < 0 ? "0." + new Array(-n).join("0") + r : r.length > n + 1 ? r.slice(0, n + 1) + "." + r.slice(n + 1) : r + new Array(n - r.length + 2).join("0");
}
const P2 = {
  "%": (e, t) => (e * 100).toFixed(t),
  b: (e) => Math.round(e).toString(2),
  c: (e) => e + "",
  d: o5,
  e: (e, t) => e.toExponential(t),
  f: (e, t) => e.toFixed(t),
  g: (e, t) => e.toPrecision(t),
  o: (e) => Math.round(e).toString(8),
  p: (e, t) => M2(e * 100, t),
  r: M2,
  s: h5,
  X: (e) => Math.round(e).toString(16).toUpperCase(),
  x: (e) => Math.round(e).toString(16)
};
function $2(e) {
  return e;
}
var z2 = Array.prototype.map, U2 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function f5(e) {
  var t = e.grouping === void 0 || e.thousands === void 0 ? $2 : c5(z2.call(e.grouping, Number), e.thousands + ""), i = e.currency === void 0 ? "" : e.currency[0] + "", r = e.currency === void 0 ? "" : e.currency[1] + "", n = e.decimal === void 0 ? "." : e.decimal + "", s = e.numerals === void 0 ? $2 : l5(z2.call(e.numerals, String)), a = e.percent === void 0 ? "%" : e.percent + "", o = e.minus === void 0 ? "−" : e.minus + "", c = e.nan === void 0 ? "NaN" : e.nan + "";
  function l(u) {
    u = Lg(u);
    var h = u.fill, p = u.align, m = u.sign, w = u.symbol, C = u.zero, F = u.width, W = u.comma, et = u.precision, E = u.trim, Z = u.type;
    Z === "n" ? (W = !0, Z = "g") : P2[Z] || (et === void 0 && (et = 12), E = !0, Z = "g"), (C || h === "0" && p === "=") && (C = !0, h = "0", p = "=");
    var yt = w === "$" ? i : w === "#" && /[boxX]/.test(Z) ? "0" + Z.toLowerCase() : "", bt = w === "$" ? r : /[%p]/.test(Z) ? a : "", Ct = P2[Z], Mt = /[defgprs%]/.test(Z);
    et = et === void 0 ? 6 : /[gprs]/.test(Z) ? Math.max(1, Math.min(21, et)) : Math.max(0, Math.min(20, et));
    function Me(kt) {
      var le = yt, ye = bt, V, Bt, at;
      if (Z === "c")
        ye = Ct(kt) + ye, kt = "";
      else {
        kt = +kt;
        var vt = kt < 0 || 1 / kt < 0;
        if (kt = isNaN(kt) ? c : Ct(Math.abs(kt), et), E && (kt = u5(kt)), vt && +kt == 0 && m !== "+" && (vt = !1), le = (vt ? m === "(" ? m : o : m === "-" || m === "(" ? "" : m) + le, ye = (Z === "s" ? U2[8 + gT / 3] : "") + ye + (vt && m === "(" ? ")" : ""), Mt) {
          for (V = -1, Bt = kt.length; ++V < Bt; )
            if (at = kt.charCodeAt(V), 48 > at || at > 57) {
              ye = (at === 46 ? n + kt.slice(V + 1) : kt.slice(V)) + ye, kt = kt.slice(0, V);
              break;
            }
        }
      }
      W && !C && (kt = t(kt, 1 / 0));
      var oe = le.length + kt.length + ye.length, Yt = oe < F ? new Array(F - oe + 1).join(h) : "";
      switch (W && C && (kt = t(Yt + kt, Yt.length ? F - ye.length : 1 / 0), Yt = ""), p) {
        case "<":
          kt = le + kt + ye + Yt;
          break;
        case "=":
          kt = le + Yt + kt + ye;
          break;
        case "^":
          kt = Yt.slice(0, oe = Yt.length >> 1) + le + kt + ye + Yt.slice(oe);
          break;
        default:
          kt = Yt + le + kt + ye;
          break;
      }
      return s(kt);
    }
    return Me.toString = function() {
      return u + "";
    }, Me;
  }
  function d(u, h) {
    var p = l((u = Lg(u), u.type = "f", u)), m = Math.max(-8, Math.min(8, Math.floor(Au(h) / 3))) * 3, w = Math.pow(10, -m), C = U2[8 + m / 3];
    return function(F) {
      return p(w * F) + C;
    };
  }
  return {
    format: l,
    formatPrefix: d
  };
}
var Om, yT, vT;
p5({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function p5(e) {
  return Om = f5(e), yT = Om.format, vT = Om.formatPrefix, Om;
}
function m5(e) {
  return Math.max(0, -Au(Math.abs(e)));
}
function g5(e, t) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Au(t) / 3))) * 3 - Au(Math.abs(e)));
}
function y5(e, t) {
  return e = Math.abs(e), t = Math.abs(t) - e, Math.max(0, Au(t) - Au(e)) + 1;
}
function v5(e, t, i, r) {
  var n = QM(e, t, i), s;
  switch (r = Lg(r ?? ",f"), r.type) {
    case "s": {
      var a = Math.max(Math.abs(e), Math.abs(t));
      return r.precision == null && !isNaN(s = g5(n, a)) && (r.precision = s), vT(r, a);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      r.precision == null && !isNaN(s = y5(n, Math.max(Math.abs(e), Math.abs(t)))) && (r.precision = s - (r.type === "e"));
      break;
    }
    case "f":
    case "%": {
      r.precision == null && !isNaN(s = m5(n)) && (r.precision = s - (r.type === "%") * 2);
      break;
    }
  }
  return yT(r);
}
function _T(e) {
  var t = e.domain;
  return e.ticks = function(i) {
    var r = t();
    return JM(r[0], r[r.length - 1], i ?? 10);
  }, e.tickFormat = function(i, r) {
    var n = t();
    return v5(n[0], n[n.length - 1], i ?? 10, r);
  }, e.nice = function(i) {
    i == null && (i = 10);
    var r = t(), n = 0, s = r.length - 1, a = r[n], o = r[s], c, l, d = 10;
    for (o < a && (l = a, a = o, o = l, l = n, n = s, s = l); d-- > 0; ) {
      if (l = j_(a, o, i), l === c)
        return r[n] = a, r[s] = o, t(r);
      if (l > 0)
        a = Math.floor(a / l) * l, o = Math.ceil(o / l) * l;
      else if (l < 0)
        a = Math.ceil(a * l) / l, o = Math.floor(o * l) / l;
      else
        break;
      c = l;
    }
    return e;
  }, e;
}
function Of() {
  var e = a5();
  return e.copy = function() {
    return pT(e, Of());
  }, fT.apply(e, arguments), _T(e);
}
function V2(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function _5(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function b5(e) {
  return e < 0 ? -e * e : e * e;
}
function x5(e) {
  var t = e(Ea, Ea), i = 1;
  function r() {
    return i === 1 ? e(Ea, Ea) : i === 0.5 ? e(_5, b5) : e(V2(i), V2(1 / i));
  }
  return t.exponent = function(n) {
    return arguments.length ? (i = +n, r()) : i;
  }, _T(t);
}
function bT() {
  var e = x5(mT());
  return e.copy = function() {
    return pT(e, bT()).exponent(e.exponent());
  }, fT.apply(e, arguments), e;
}
const qv = /* @__PURE__ */ new Date(), Zv = /* @__PURE__ */ new Date();
function Va(e, t, i, r) {
  function n(s) {
    return e(s = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+s)), s;
  }
  return n.floor = (s) => (e(s = /* @__PURE__ */ new Date(+s)), s), n.ceil = (s) => (e(s = new Date(s - 1)), t(s, 1), e(s), s), n.round = (s) => {
    const a = n(s), o = n.ceil(s);
    return s - a < o - s ? a : o;
  }, n.offset = (s, a) => (t(s = /* @__PURE__ */ new Date(+s), a == null ? 1 : Math.floor(a)), s), n.range = (s, a, o) => {
    const c = [];
    if (s = n.ceil(s), o = o == null ? 1 : Math.floor(o), !(s < a) || !(o > 0))
      return c;
    let l;
    do
      c.push(l = /* @__PURE__ */ new Date(+s)), t(s, o), e(s);
    while (l < s && s < a);
    return c;
  }, n.filter = (s) => Va((a) => {
    if (a >= a)
      for (; e(a), !s(a); )
        a.setTime(a - 1);
  }, (a, o) => {
    if (a >= a)
      if (o < 0)
        for (; ++o <= 0; )
          for (; t(a, -1), !s(a); )
            ;
      else
        for (; --o >= 0; )
          for (; t(a, 1), !s(a); )
            ;
  }), i && (n.count = (s, a) => (qv.setTime(+s), Zv.setTime(+a), e(qv), e(Zv), Math.floor(i(qv, Zv))), n.every = (s) => (s = Math.floor(s), !isFinite(s) || !(s > 0) ? null : s > 1 ? n.filter(r ? (a) => r(a) % s === 0 : (a) => n.count(0, a) % s === 0) : n)), n;
}
const w5 = 1e3, l1 = w5 * 60, S5 = l1 * 60, Df = S5 * 24, xT = Df * 7, d1 = Va(
  (e) => e.setHours(0, 0, 0, 0),
  (e, t) => e.setDate(e.getDate() + t),
  (e, t) => (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * l1) / Df,
  (e) => e.getDate() - 1
);
d1.range;
const u1 = Va((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Df, (e) => e.getUTCDate() - 1);
u1.range;
const I5 = Va((e) => {
  e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCDate(e.getUTCDate() + t);
}, (e, t) => (t - e) / Df, (e) => Math.floor(e / Df));
I5.range;
function Hl(e) {
  return Va((t) => {
    t.setDate(t.getDate() - (t.getDay() + 7 - e) % 7), t.setHours(0, 0, 0, 0);
  }, (t, i) => {
    t.setDate(t.getDate() + i * 7);
  }, (t, i) => (i - t - (i.getTimezoneOffset() - t.getTimezoneOffset()) * l1) / xT);
}
const wT = Hl(0), Fg = Hl(1), A5 = Hl(2), T5 = Hl(3), Tu = Hl(4), E5 = Hl(5), k5 = Hl(6);
wT.range;
Fg.range;
A5.range;
T5.range;
Tu.range;
E5.range;
k5.range;
function Wl(e) {
  return Va((t) => {
    t.setUTCDate(t.getUTCDate() - (t.getUTCDay() + 7 - e) % 7), t.setUTCHours(0, 0, 0, 0);
  }, (t, i) => {
    t.setUTCDate(t.getUTCDate() + i * 7);
  }, (t, i) => (i - t) / xT);
}
const ST = Wl(0), Bg = Wl(1), C5 = Wl(2), O5 = Wl(3), Eu = Wl(4), D5 = Wl(5), N5 = Wl(6);
ST.range;
Bg.range;
C5.range;
O5.range;
Eu.range;
D5.range;
N5.range;
const Ml = Va((e) => {
  e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, t) => {
  e.setFullYear(e.getFullYear() + t);
}, (e, t) => t.getFullYear() - e.getFullYear(), (e) => e.getFullYear());
Ml.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Va((t) => {
  t.setFullYear(Math.floor(t.getFullYear() / e) * e), t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, i) => {
  t.setFullYear(t.getFullYear() + i * e);
});
Ml.range;
const Pl = Va((e) => {
  e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, t) => {
  e.setUTCFullYear(e.getUTCFullYear() + t);
}, (e, t) => t.getUTCFullYear() - e.getUTCFullYear(), (e) => e.getUTCFullYear());
Pl.every = (e) => !isFinite(e = Math.floor(e)) || !(e > 0) ? null : Va((t) => {
  t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e), t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, i) => {
  t.setUTCFullYear(t.getUTCFullYear() + i * e);
});
Pl.range;
function Xv(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
    return t.setFullYear(e.y), t;
  }
  return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
}
function Kv(e) {
  if (0 <= e.y && e.y < 100) {
    var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
}
function Fh(e, t, i) {
  return { y: e, m: t, d: i, H: 0, M: 0, S: 0, L: 0 };
}
function L5(e) {
  var t = e.dateTime, i = e.date, r = e.time, n = e.periods, s = e.days, a = e.shortDays, o = e.months, c = e.shortMonths, l = Bh(n), d = Rh(n), u = Bh(s), h = Rh(s), p = Bh(a), m = Rh(a), w = Bh(o), C = Rh(o), F = Bh(c), W = Rh(c), et = {
    a: vt,
    A: oe,
    b: Yt,
    B: pe,
    c: null,
    d: q2,
    e: q2,
    f: i8,
    g: h8,
    G: p8,
    H: Q5,
    I: t8,
    j: e8,
    L: IT,
    m: r8,
    M: n8,
    p: ei,
    q: ii,
    Q: K2,
    s: J2,
    S: s8,
    u: a8,
    U: o8,
    V: c8,
    w: l8,
    W: d8,
    x: null,
    X: null,
    y: u8,
    Y: f8,
    Z: m8,
    "%": X2
  }, E = {
    a: cr,
    A: Oi,
    b: Ri,
    B: Zi,
    c: null,
    d: Z2,
    e: Z2,
    f: _8,
    g: C8,
    G: D8,
    H: g8,
    I: y8,
    j: v8,
    L: TT,
    m: b8,
    M: x8,
    p: hr,
    q: br,
    Q: K2,
    s: J2,
    S: w8,
    u: S8,
    U: I8,
    V: A8,
    w: T8,
    W: E8,
    x: null,
    X: null,
    y: k8,
    Y: O8,
    Z: N8,
    "%": X2
  }, Z = {
    a: Me,
    A: kt,
    b: le,
    B: ye,
    c: V,
    d: W2,
    e: W2,
    f: Z5,
    g: H2,
    G: G2,
    H: Y2,
    I: Y2,
    j: H5,
    L: q5,
    m: G5,
    M: W5,
    p: Mt,
    q: j5,
    Q: K5,
    s: J5,
    S: Y5,
    u: P5,
    U: $5,
    V: z5,
    w: M5,
    W: U5,
    x: Bt,
    X: at,
    y: H2,
    Y: G2,
    Z: V5,
    "%": X5
  };
  et.x = yt(i, et), et.X = yt(r, et), et.c = yt(t, et), E.x = yt(i, E), E.X = yt(r, E), E.c = yt(t, E);
  function yt(qt, Ze) {
    return function(ai) {
      var It = [], Er = -1, Di = 0, Gr = qt.length, Hr, Zn, Wr;
      for (ai instanceof Date || (ai = /* @__PURE__ */ new Date(+ai)); ++Er < Gr; )
        qt.charCodeAt(Er) === 37 && (It.push(qt.slice(Di, Er)), (Zn = j2[Hr = qt.charAt(++Er)]) != null ? Hr = qt.charAt(++Er) : Zn = Hr === "e" ? " " : "0", (Wr = Ze[Hr]) && (Hr = Wr(ai, Zn)), It.push(Hr), Di = Er + 1);
      return It.push(qt.slice(Di, Er)), It.join("");
    };
  }
  function bt(qt, Ze) {
    return function(ai) {
      var It = Fh(1900, void 0, 1), Er = Ct(It, qt, ai += "", 0), Di, Gr;
      if (Er != ai.length)
        return null;
      if ("Q" in It)
        return new Date(It.Q);
      if ("s" in It)
        return new Date(It.s * 1e3 + ("L" in It ? It.L : 0));
      if (Ze && !("Z" in It) && (It.Z = 0), "p" in It && (It.H = It.H % 12 + It.p * 12), It.m === void 0 && (It.m = "q" in It ? It.q : 0), "V" in It) {
        if (It.V < 1 || It.V > 53)
          return null;
        "w" in It || (It.w = 1), "Z" in It ? (Di = Kv(Fh(It.y, 0, 1)), Gr = Di.getUTCDay(), Di = Gr > 4 || Gr === 0 ? Bg.ceil(Di) : Bg(Di), Di = u1.offset(Di, (It.V - 1) * 7), It.y = Di.getUTCFullYear(), It.m = Di.getUTCMonth(), It.d = Di.getUTCDate() + (It.w + 6) % 7) : (Di = Xv(Fh(It.y, 0, 1)), Gr = Di.getDay(), Di = Gr > 4 || Gr === 0 ? Fg.ceil(Di) : Fg(Di), Di = d1.offset(Di, (It.V - 1) * 7), It.y = Di.getFullYear(), It.m = Di.getMonth(), It.d = Di.getDate() + (It.w + 6) % 7);
      } else
        ("W" in It || "U" in It) && ("w" in It || (It.w = "u" in It ? It.u % 7 : "W" in It ? 1 : 0), Gr = "Z" in It ? Kv(Fh(It.y, 0, 1)).getUTCDay() : Xv(Fh(It.y, 0, 1)).getDay(), It.m = 0, It.d = "W" in It ? (It.w + 6) % 7 + It.W * 7 - (Gr + 5) % 7 : It.w + It.U * 7 - (Gr + 6) % 7);
      return "Z" in It ? (It.H += It.Z / 100 | 0, It.M += It.Z % 100, Kv(It)) : Xv(It);
    };
  }
  function Ct(qt, Ze, ai, It) {
    for (var Er = 0, Di = Ze.length, Gr = ai.length, Hr, Zn; Er < Di; ) {
      if (It >= Gr)
        return -1;
      if (Hr = Ze.charCodeAt(Er++), Hr === 37) {
        if (Hr = Ze.charAt(Er++), Zn = Z[Hr in j2 ? Ze.charAt(Er++) : Hr], !Zn || (It = Zn(qt, ai, It)) < 0)
          return -1;
      } else if (Hr != ai.charCodeAt(It++))
        return -1;
    }
    return It;
  }
  function Mt(qt, Ze, ai) {
    var It = l.exec(Ze.slice(ai));
    return It ? (qt.p = d.get(It[0].toLowerCase()), ai + It[0].length) : -1;
  }
  function Me(qt, Ze, ai) {
    var It = p.exec(Ze.slice(ai));
    return It ? (qt.w = m.get(It[0].toLowerCase()), ai + It[0].length) : -1;
  }
  function kt(qt, Ze, ai) {
    var It = u.exec(Ze.slice(ai));
    return It ? (qt.w = h.get(It[0].toLowerCase()), ai + It[0].length) : -1;
  }
  function le(qt, Ze, ai) {
    var It = F.exec(Ze.slice(ai));
    return It ? (qt.m = W.get(It[0].toLowerCase()), ai + It[0].length) : -1;
  }
  function ye(qt, Ze, ai) {
    var It = w.exec(Ze.slice(ai));
    return It ? (qt.m = C.get(It[0].toLowerCase()), ai + It[0].length) : -1;
  }
  function V(qt, Ze, ai) {
    return Ct(qt, t, Ze, ai);
  }
  function Bt(qt, Ze, ai) {
    return Ct(qt, i, Ze, ai);
  }
  function at(qt, Ze, ai) {
    return Ct(qt, r, Ze, ai);
  }
  function vt(qt) {
    return a[qt.getDay()];
  }
  function oe(qt) {
    return s[qt.getDay()];
  }
  function Yt(qt) {
    return c[qt.getMonth()];
  }
  function pe(qt) {
    return o[qt.getMonth()];
  }
  function ei(qt) {
    return n[+(qt.getHours() >= 12)];
  }
  function ii(qt) {
    return 1 + ~~(qt.getMonth() / 3);
  }
  function cr(qt) {
    return a[qt.getUTCDay()];
  }
  function Oi(qt) {
    return s[qt.getUTCDay()];
  }
  function Ri(qt) {
    return c[qt.getUTCMonth()];
  }
  function Zi(qt) {
    return o[qt.getUTCMonth()];
  }
  function hr(qt) {
    return n[+(qt.getUTCHours() >= 12)];
  }
  function br(qt) {
    return 1 + ~~(qt.getUTCMonth() / 3);
  }
  return {
    format: function(qt) {
      var Ze = yt(qt += "", et);
      return Ze.toString = function() {
        return qt;
      }, Ze;
    },
    parse: function(qt) {
      var Ze = bt(qt += "", !1);
      return Ze.toString = function() {
        return qt;
      }, Ze;
    },
    utcFormat: function(qt) {
      var Ze = yt(qt += "", E);
      return Ze.toString = function() {
        return qt;
      }, Ze;
    },
    utcParse: function(qt) {
      var Ze = bt(qt += "", !0);
      return Ze.toString = function() {
        return qt;
      }, Ze;
    }
  };
}
var j2 = { "-": "", _: " ", 0: "0" }, an = /^\s*\d+/, F5 = /^%/, B5 = /[\\^$*+?|[\]().{}]/g;
function Ci(e, t, i) {
  var r = e < 0 ? "-" : "", n = (r ? -e : e) + "", s = n.length;
  return r + (s < i ? new Array(i - s + 1).join(t) + n : n);
}
function R5(e) {
  return e.replace(B5, "\\$&");
}
function Bh(e) {
  return new RegExp("^(?:" + e.map(R5).join("|") + ")", "i");
}
function Rh(e) {
  return new Map(e.map((t, i) => [t.toLowerCase(), i]));
}
function M5(e, t, i) {
  var r = an.exec(t.slice(i, i + 1));
  return r ? (e.w = +r[0], i + r[0].length) : -1;
}
function P5(e, t, i) {
  var r = an.exec(t.slice(i, i + 1));
  return r ? (e.u = +r[0], i + r[0].length) : -1;
}
function $5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.U = +r[0], i + r[0].length) : -1;
}
function z5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.V = +r[0], i + r[0].length) : -1;
}
function U5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.W = +r[0], i + r[0].length) : -1;
}
function G2(e, t, i) {
  var r = an.exec(t.slice(i, i + 4));
  return r ? (e.y = +r[0], i + r[0].length) : -1;
}
function H2(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3), i + r[0].length) : -1;
}
function V5(e, t, i) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(i, i + 6));
  return r ? (e.Z = r[1] ? 0 : -(r[2] + (r[3] || "00")), i + r[0].length) : -1;
}
function j5(e, t, i) {
  var r = an.exec(t.slice(i, i + 1));
  return r ? (e.q = r[0] * 3 - 3, i + r[0].length) : -1;
}
function G5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.m = r[0] - 1, i + r[0].length) : -1;
}
function W2(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.d = +r[0], i + r[0].length) : -1;
}
function H5(e, t, i) {
  var r = an.exec(t.slice(i, i + 3));
  return r ? (e.m = 0, e.d = +r[0], i + r[0].length) : -1;
}
function Y2(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.H = +r[0], i + r[0].length) : -1;
}
function W5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.M = +r[0], i + r[0].length) : -1;
}
function Y5(e, t, i) {
  var r = an.exec(t.slice(i, i + 2));
  return r ? (e.S = +r[0], i + r[0].length) : -1;
}
function q5(e, t, i) {
  var r = an.exec(t.slice(i, i + 3));
  return r ? (e.L = +r[0], i + r[0].length) : -1;
}
function Z5(e, t, i) {
  var r = an.exec(t.slice(i, i + 6));
  return r ? (e.L = Math.floor(r[0] / 1e3), i + r[0].length) : -1;
}
function X5(e, t, i) {
  var r = F5.exec(t.slice(i, i + 1));
  return r ? i + r[0].length : -1;
}
function K5(e, t, i) {
  var r = an.exec(t.slice(i));
  return r ? (e.Q = +r[0], i + r[0].length) : -1;
}
function J5(e, t, i) {
  var r = an.exec(t.slice(i));
  return r ? (e.s = +r[0], i + r[0].length) : -1;
}
function q2(e, t) {
  return Ci(e.getDate(), t, 2);
}
function Q5(e, t) {
  return Ci(e.getHours(), t, 2);
}
function t8(e, t) {
  return Ci(e.getHours() % 12 || 12, t, 2);
}
function e8(e, t) {
  return Ci(1 + d1.count(Ml(e), e), t, 3);
}
function IT(e, t) {
  return Ci(e.getMilliseconds(), t, 3);
}
function i8(e, t) {
  return IT(e, t) + "000";
}
function r8(e, t) {
  return Ci(e.getMonth() + 1, t, 2);
}
function n8(e, t) {
  return Ci(e.getMinutes(), t, 2);
}
function s8(e, t) {
  return Ci(e.getSeconds(), t, 2);
}
function a8(e) {
  var t = e.getDay();
  return t === 0 ? 7 : t;
}
function o8(e, t) {
  return Ci(wT.count(Ml(e) - 1, e), t, 2);
}
function AT(e) {
  var t = e.getDay();
  return t >= 4 || t === 0 ? Tu(e) : Tu.ceil(e);
}
function c8(e, t) {
  return e = AT(e), Ci(Tu.count(Ml(e), e) + (Ml(e).getDay() === 4), t, 2);
}
function l8(e) {
  return e.getDay();
}
function d8(e, t) {
  return Ci(Fg.count(Ml(e) - 1, e), t, 2);
}
function u8(e, t) {
  return Ci(e.getFullYear() % 100, t, 2);
}
function h8(e, t) {
  return e = AT(e), Ci(e.getFullYear() % 100, t, 2);
}
function f8(e, t) {
  return Ci(e.getFullYear() % 1e4, t, 4);
}
function p8(e, t) {
  var i = e.getDay();
  return e = i >= 4 || i === 0 ? Tu(e) : Tu.ceil(e), Ci(e.getFullYear() % 1e4, t, 4);
}
function m8(e) {
  var t = e.getTimezoneOffset();
  return (t > 0 ? "-" : (t *= -1, "+")) + Ci(t / 60 | 0, "0", 2) + Ci(t % 60, "0", 2);
}
function Z2(e, t) {
  return Ci(e.getUTCDate(), t, 2);
}
function g8(e, t) {
  return Ci(e.getUTCHours(), t, 2);
}
function y8(e, t) {
  return Ci(e.getUTCHours() % 12 || 12, t, 2);
}
function v8(e, t) {
  return Ci(1 + u1.count(Pl(e), e), t, 3);
}
function TT(e, t) {
  return Ci(e.getUTCMilliseconds(), t, 3);
}
function _8(e, t) {
  return TT(e, t) + "000";
}
function b8(e, t) {
  return Ci(e.getUTCMonth() + 1, t, 2);
}
function x8(e, t) {
  return Ci(e.getUTCMinutes(), t, 2);
}
function w8(e, t) {
  return Ci(e.getUTCSeconds(), t, 2);
}
function S8(e) {
  var t = e.getUTCDay();
  return t === 0 ? 7 : t;
}
function I8(e, t) {
  return Ci(ST.count(Pl(e) - 1, e), t, 2);
}
function ET(e) {
  var t = e.getUTCDay();
  return t >= 4 || t === 0 ? Eu(e) : Eu.ceil(e);
}
function A8(e, t) {
  return e = ET(e), Ci(Eu.count(Pl(e), e) + (Pl(e).getUTCDay() === 4), t, 2);
}
function T8(e) {
  return e.getUTCDay();
}
function E8(e, t) {
  return Ci(Bg.count(Pl(e) - 1, e), t, 2);
}
function k8(e, t) {
  return Ci(e.getUTCFullYear() % 100, t, 2);
}
function C8(e, t) {
  return e = ET(e), Ci(e.getUTCFullYear() % 100, t, 2);
}
function O8(e, t) {
  return Ci(e.getUTCFullYear() % 1e4, t, 4);
}
function D8(e, t) {
  var i = e.getUTCDay();
  return e = i >= 4 || i === 0 ? Eu(e) : Eu.ceil(e), Ci(e.getUTCFullYear() % 1e4, t, 4);
}
function N8() {
  return "+0000";
}
function X2() {
  return "%";
}
function K2(e) {
  return +e;
}
function J2(e) {
  return Math.floor(+e / 1e3);
}
var gd, Fo;
L8({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function L8(e) {
  return gd = L5(e), Fo = gd.format, gd.parse, gd.utcFormat, gd.utcParse, gd;
}
var Q2 = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var e = 0, t = arguments.length; t--; )
    e += arguments[t] * arguments[t];
  return Math.sqrt(e);
});
function F8() {
  var e = new Q2(9);
  return Q2 != Float32Array && (e[1] = 0, e[2] = 0, e[3] = 0, e[5] = 0, e[6] = 0, e[7] = 0), e[0] = 1, e[4] = 1, e[8] = 1, e;
}
function tI(e, t, i) {
  var r = t[0], n = t[1], s = t[2], a = t[3], o = t[4], c = t[5], l = t[6], d = t[7], u = t[8], h = i[0], p = i[1];
  return e[0] = r, e[1] = n, e[2] = s, e[3] = a, e[4] = o, e[5] = c, e[6] = h * r + p * a + l, e[7] = h * n + p * o + d, e[8] = h * s + p * c + u, e;
}
function Jv(e, t, i) {
  var r = i[0], n = i[1];
  return e[0] = r * t[0], e[1] = r * t[1], e[2] = r * t[2], e[3] = n * t[3], e[4] = n * t[4], e[5] = n * t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
}
function B8(e, t, i) {
  return e[0] = 2 / t, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = -2 / i, e[5] = 0, e[6] = -1, e[7] = 1, e[8] = 1, e;
}
var h1 = { exports: {} };
h1.exports;
(function(e) {
  (function(t, i, r) {
    function n(c) {
      var l = this, d = o();
      l.next = function() {
        var u = 2091639 * l.s0 + l.c * 23283064365386963e-26;
        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = u - (l.c = u | 0);
      }, l.c = 1, l.s0 = d(" "), l.s1 = d(" "), l.s2 = d(" "), l.s0 -= d(c), l.s0 < 0 && (l.s0 += 1), l.s1 -= d(c), l.s1 < 0 && (l.s1 += 1), l.s2 -= d(c), l.s2 < 0 && (l.s2 += 1), d = null;
    }
    function s(c, l) {
      return l.c = c.c, l.s0 = c.s0, l.s1 = c.s1, l.s2 = c.s2, l;
    }
    function a(c, l) {
      var d = new n(c), u = l && l.state, h = d.next;
      return h.int32 = function() {
        return d.next() * 4294967296 | 0;
      }, h.double = function() {
        return h() + (h() * 2097152 | 0) * 11102230246251565e-32;
      }, h.quick = h, u && (typeof u == "object" && s(u, d), h.state = function() {
        return s(d, {});
      }), h;
    }
    function o() {
      var c = 4022871197, l = function(d) {
        d = String(d);
        for (var u = 0; u < d.length; u++) {
          c += d.charCodeAt(u);
          var h = 0.02519603282416938 * c;
          c = h >>> 0, h -= c, h *= c, c = h >>> 0, h -= c, c += h * 4294967296;
        }
        return (c >>> 0) * 23283064365386963e-26;
      };
      return l;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.alea = a;
  })(
    $c,
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(h1);
var R8 = h1.exports, f1 = { exports: {} };
f1.exports;
(function(e) {
  (function(t, i, r) {
    function n(o) {
      var c = this, l = "";
      c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.next = function() {
        var u = c.x ^ c.x << 11;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w ^= c.w >>> 19 ^ u ^ u >>> 8;
      }, o === (o | 0) ? c.x = o : l += o;
      for (var d = 0; d < l.length + 64; d++)
        c.x ^= l.charCodeAt(d) | 0, c.next();
    }
    function s(o, c) {
      return c.x = o.x, c.y = o.y, c.z = o.z, c.w = o.w, c;
    }
    function a(o, c) {
      var l = new n(o), d = c && c.state, u = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return u.double = function() {
        do
          var h = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, m = (h + p) / (1 << 21);
        while (m === 0);
        return m;
      }, u.int32 = l.next, u.quick = u, d && (typeof d == "object" && s(d, l), u.state = function() {
        return s(l, {});
      }), u;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.xor128 = a;
  })(
    $c,
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(f1);
var M8 = f1.exports, p1 = { exports: {} };
p1.exports;
(function(e) {
  (function(t, i, r) {
    function n(o) {
      var c = this, l = "";
      c.next = function() {
        var u = c.x ^ c.x >>> 2;
        return c.x = c.y, c.y = c.z, c.z = c.w, c.w = c.v, (c.d = c.d + 362437 | 0) + (c.v = c.v ^ c.v << 4 ^ (u ^ u << 1)) | 0;
      }, c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.v = 0, o === (o | 0) ? c.x = o : l += o;
      for (var d = 0; d < l.length + 64; d++)
        c.x ^= l.charCodeAt(d) | 0, d == l.length && (c.d = c.x << 10 ^ c.x >>> 4), c.next();
    }
    function s(o, c) {
      return c.x = o.x, c.y = o.y, c.z = o.z, c.w = o.w, c.v = o.v, c.d = o.d, c;
    }
    function a(o, c) {
      var l = new n(o), d = c && c.state, u = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return u.double = function() {
        do
          var h = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, m = (h + p) / (1 << 21);
        while (m === 0);
        return m;
      }, u.int32 = l.next, u.quick = u, d && (typeof d == "object" && s(d, l), u.state = function() {
        return s(l, {});
      }), u;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.xorwow = a;
  })(
    $c,
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(p1);
var P8 = p1.exports, m1 = { exports: {} };
m1.exports;
(function(e) {
  (function(t, i, r) {
    function n(o) {
      var c = this;
      c.next = function() {
        var d = c.x, u = c.i, h, p;
        return h = d[u], h ^= h >>> 7, p = h ^ h << 24, h = d[u + 1 & 7], p ^= h ^ h >>> 10, h = d[u + 3 & 7], p ^= h ^ h >>> 3, h = d[u + 4 & 7], p ^= h ^ h << 7, h = d[u + 7 & 7], h = h ^ h << 13, p ^= h ^ h << 9, d[u] = p, c.i = u + 1 & 7, p;
      };
      function l(d, u) {
        var h, p = [];
        if (u === (u | 0))
          p[0] = u;
        else
          for (u = "" + u, h = 0; h < u.length; ++h)
            p[h & 7] = p[h & 7] << 15 ^ u.charCodeAt(h) + p[h + 1 & 7] << 13;
        for (; p.length < 8; )
          p.push(0);
        for (h = 0; h < 8 && p[h] === 0; ++h)
          ;
        for (h == 8 ? p[7] = -1 : p[h], d.x = p, d.i = 0, h = 256; h > 0; --h)
          d.next();
      }
      l(c, o);
    }
    function s(o, c) {
      return c.x = o.x.slice(), c.i = o.i, c;
    }
    function a(o, c) {
      o == null && (o = +/* @__PURE__ */ new Date());
      var l = new n(o), d = c && c.state, u = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return u.double = function() {
        do
          var h = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, m = (h + p) / (1 << 21);
        while (m === 0);
        return m;
      }, u.int32 = l.next, u.quick = u, d && (d.x && s(d, l), u.state = function() {
        return s(l, {});
      }), u;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.xorshift7 = a;
  })(
    $c,
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(m1);
var $8 = m1.exports, g1 = { exports: {} };
g1.exports;
(function(e) {
  (function(t, i, r) {
    function n(o) {
      var c = this;
      c.next = function() {
        var d = c.w, u = c.X, h = c.i, p, m;
        return c.w = d = d + 1640531527 | 0, m = u[h + 34 & 127], p = u[h = h + 1 & 127], m ^= m << 13, p ^= p << 17, m ^= m >>> 15, p ^= p >>> 12, m = u[h] = m ^ p, c.i = h, m + (d ^ d >>> 16) | 0;
      };
      function l(d, u) {
        var h, p, m, w, C, F = [], W = 128;
        for (u === (u | 0) ? (p = u, u = null) : (u = u + "\0", p = 0, W = Math.max(W, u.length)), m = 0, w = -32; w < W; ++w)
          u && (p ^= u.charCodeAt((w + 32) % u.length)), w === 0 && (C = p), p ^= p << 10, p ^= p >>> 15, p ^= p << 4, p ^= p >>> 13, w >= 0 && (C = C + 1640531527 | 0, h = F[w & 127] ^= p + C, m = h == 0 ? m + 1 : 0);
        for (m >= 128 && (F[(u && u.length || 0) & 127] = -1), m = 127, w = 4 * 128; w > 0; --w)
          p = F[m + 34 & 127], h = F[m = m + 1 & 127], p ^= p << 13, h ^= h << 17, p ^= p >>> 15, h ^= h >>> 12, F[m] = p ^ h;
        d.w = C, d.X = F, d.i = m;
      }
      l(c, o);
    }
    function s(o, c) {
      return c.i = o.i, c.w = o.w, c.X = o.X.slice(), c;
    }
    function a(o, c) {
      o == null && (o = +/* @__PURE__ */ new Date());
      var l = new n(o), d = c && c.state, u = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return u.double = function() {
        do
          var h = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, m = (h + p) / (1 << 21);
        while (m === 0);
        return m;
      }, u.int32 = l.next, u.quick = u, d && (d.X && s(d, l), u.state = function() {
        return s(l, {});
      }), u;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.xor4096 = a;
  })(
    $c,
    // window object or global
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(g1);
var z8 = g1.exports, y1 = { exports: {} };
y1.exports;
(function(e) {
  (function(t, i, r) {
    function n(o) {
      var c = this, l = "";
      c.next = function() {
        var u = c.b, h = c.c, p = c.d, m = c.a;
        return u = u << 25 ^ u >>> 7 ^ h, h = h - p | 0, p = p << 24 ^ p >>> 8 ^ m, m = m - u | 0, c.b = u = u << 20 ^ u >>> 12 ^ h, c.c = h = h - p | 0, c.d = p << 16 ^ h >>> 16 ^ m, c.a = m - u | 0;
      }, c.a = 0, c.b = 0, c.c = -1640531527, c.d = 1367130551, o === Math.floor(o) ? (c.a = o / 4294967296 | 0, c.b = o | 0) : l += o;
      for (var d = 0; d < l.length + 20; d++)
        c.b ^= l.charCodeAt(d) | 0, c.next();
    }
    function s(o, c) {
      return c.a = o.a, c.b = o.b, c.c = o.c, c.d = o.d, c;
    }
    function a(o, c) {
      var l = new n(o), d = c && c.state, u = function() {
        return (l.next() >>> 0) / 4294967296;
      };
      return u.double = function() {
        do
          var h = l.next() >>> 11, p = (l.next() >>> 0) / 4294967296, m = (h + p) / (1 << 21);
        while (m === 0);
        return m;
      }, u.int32 = l.next, u.quick = u, d && (typeof d == "object" && s(d, l), u.state = function() {
        return s(l, {});
      }), u;
    }
    i && i.exports ? i.exports = a : r && r.amd ? r(function() {
      return a;
    }) : this.tychei = a;
  })(
    $c,
    e,
    // present in node.js
    !1
    // present with an AMD loader
  );
})(y1);
var U8 = y1.exports, kT = { exports: {} };
const V8 = {}, j8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: V8
}, Symbol.toStringTag, { value: "Module" })), G8 = /* @__PURE__ */ UM(j8);
(function(e) {
  (function(t, i, r) {
    var n = 256, s = 6, a = 52, o = "random", c = r.pow(n, s), l = r.pow(2, a), d = l * 2, u = n - 1, h;
    function p(E, Z, yt) {
      var bt = [];
      Z = Z == !0 ? { entropy: !0 } : Z || {};
      var Ct = F(C(
        Z.entropy ? [E, et(i)] : E ?? W(),
        3
      ), bt), Mt = new m(bt), Me = function() {
        for (var kt = Mt.g(s), le = c, ye = 0; kt < l; )
          kt = (kt + ye) * n, le *= n, ye = Mt.g(1);
        for (; kt >= d; )
          kt /= 2, le /= 2, ye >>>= 1;
        return (kt + ye) / le;
      };
      return Me.int32 = function() {
        return Mt.g(4) | 0;
      }, Me.quick = function() {
        return Mt.g(4) / 4294967296;
      }, Me.double = Me, F(et(Mt.S), i), (Z.pass || yt || function(kt, le, ye, V) {
        return V && (V.S && w(V, Mt), kt.state = function() {
          return w(Mt, {});
        }), ye ? (r[o] = kt, le) : kt;
      })(
        Me,
        Ct,
        "global" in Z ? Z.global : this == r,
        Z.state
      );
    }
    function m(E) {
      var Z, yt = E.length, bt = this, Ct = 0, Mt = bt.i = bt.j = 0, Me = bt.S = [];
      for (yt || (E = [yt++]); Ct < n; )
        Me[Ct] = Ct++;
      for (Ct = 0; Ct < n; Ct++)
        Me[Ct] = Me[Mt = u & Mt + E[Ct % yt] + (Z = Me[Ct])], Me[Mt] = Z;
      (bt.g = function(kt) {
        for (var le, ye = 0, V = bt.i, Bt = bt.j, at = bt.S; kt--; )
          le = at[V = u & V + 1], ye = ye * n + at[u & (at[V] = at[Bt = u & Bt + le]) + (at[Bt] = le)];
        return bt.i = V, bt.j = Bt, ye;
      })(n);
    }
    function w(E, Z) {
      return Z.i = E.i, Z.j = E.j, Z.S = E.S.slice(), Z;
    }
    function C(E, Z) {
      var yt = [], bt = typeof E, Ct;
      if (Z && bt == "object")
        for (Ct in E)
          try {
            yt.push(C(E[Ct], Z - 1));
          } catch {
          }
      return yt.length ? yt : bt == "string" ? E : E + "\0";
    }
    function F(E, Z) {
      for (var yt = E + "", bt, Ct = 0; Ct < yt.length; )
        Z[u & Ct] = u & (bt ^= Z[u & Ct] * 19) + yt.charCodeAt(Ct++);
      return et(Z);
    }
    function W() {
      try {
        var E;
        return h && (E = h.randomBytes) ? E = E(n) : (E = new Uint8Array(n), (t.crypto || t.msCrypto).getRandomValues(E)), et(E);
      } catch {
        var Z = t.navigator, yt = Z && Z.plugins;
        return [+/* @__PURE__ */ new Date(), t, yt, t.screen, et(i)];
      }
    }
    function et(E) {
      return String.fromCharCode.apply(0, E);
    }
    if (F(r.random(), i), e.exports) {
      e.exports = p;
      try {
        h = G8;
      } catch {
      }
    } else
      r["seed" + o] = p;
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self < "u" ? self : $c,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(kT);
var H8 = kT.exports, W8 = R8, Y8 = M8, q8 = P8, Z8 = $8, X8 = z8, K8 = U8, Yl = H8;
Yl.alea = W8;
Yl.xor128 = Y8;
Yl.xorwow = q8;
Yl.xorshift7 = Z8;
Yl.xor4096 = X8;
Yl.tychei = K8;
var J8 = Yl;
const Q8 = /* @__PURE__ */ o1(J8);
function eI(e, t) {
  for (var i = 0; i < t.length; i++) {
    var r = t[i];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, eP(r.key), r);
  }
}
function v1(e, t, i) {
  return t && eI(e.prototype, t), i && eI(e, i), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function CT(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, H_(e, t);
}
function H_(e, t) {
  return H_ = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, H_(e, t);
}
function tP(e, t) {
  if (typeof e != "object" || e === null)
    return e;
  var i = e[Symbol.toPrimitive];
  if (i !== void 0) {
    var r = i.call(e, t || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function eP(e) {
  var t = tP(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
var ly = /* @__PURE__ */ function() {
  function e() {
  }
  var t = e.prototype;
  return t._seed = function(r, n) {
    if (r === (r || 0))
      return r;
    for (var s = "" + r, a = 0, o = 0; o < s.length; ++o)
      a ^= s.charCodeAt(o) | 0;
    return a;
  }, e;
}(), iI = /* @__PURE__ */ function(e) {
  CT(t, e);
  function t(r, n) {
    var s;
    return s = e.call(this) || this, s._rng = void 0, s.seed(r, n), s;
  }
  var i = t.prototype;
  return i.next = function() {
    return this._rng();
  }, i.seed = function(n, s) {
    this._rng = n;
  }, i.clone = function(n, s) {
    return new t(this._rng, s);
  }, v1(t, [{
    key: "name",
    get: function() {
      return "function";
    }
  }]), t;
}(ly), rI = function() {
  var e = [].slice.call(arguments), t = e, i = t[0], r = i === void 0 ? "default" : i;
  switch (typeof r) {
    case "object":
      if (r instanceof ly)
        return r;
      break;
    case "function":
      return new iI(r);
    case "number":
    case "string":
    default:
      return new iI(Q8.apply(void 0, e));
  }
  throw new Error('invalid RNG "' + r + '"');
}, iP = function(e, t, i) {
  return t === void 0 && (t = 0), i === void 0 && (i = 1), function() {
    return e.next() * (i - t) + t;
  };
};
function Zs(e) {
  return new rP(e);
}
var rP = function(t) {
  var i = this;
  this.n = void 0, this.isInt = function() {
    if (Number.isInteger(i.n))
      return i;
    throw new Error("Expected number to be an integer, got " + i.n);
  }, this.isPositive = function() {
    if (i.n > 0)
      return i;
    throw new Error("Expected number to be positive, got " + i.n);
  }, this.lessThan = function(r) {
    if (i.n < r)
      return i;
    throw new Error("Expected number to be less than " + r + ", got " + i.n);
  }, this.greaterThanOrEqual = function(r) {
    if (i.n >= r)
      return i;
    throw new Error("Expected number to be greater than or equal to " + r + ", got " + i.n);
  }, this.greaterThan = function(r) {
    if (i.n > r)
      return i;
    throw new Error("Expected number to be greater than " + r + ", got " + i.n);
  }, this.n = t;
}, nP = function(e, t, i) {
  return t === void 0 && (t = 0), i === void 0 && (i = 1), i === void 0 && (i = t === void 0 ? 1 : t, t = 0), Zs(t).isInt(), Zs(i).isInt(), function() {
    return Math.floor(e.next() * (i - t + 1) + t);
  };
}, sP = function(e) {
  return function() {
    return e.next() >= 0.5;
  };
}, aP = function(e, t, i) {
  return t === void 0 && (t = 0), i === void 0 && (i = 1), function() {
    var r, n, s;
    do
      r = e.next() * 2 - 1, n = e.next() * 2 - 1, s = r * r + n * n;
    while (!s || s > 1);
    return t + i * n * Math.sqrt(-2 * Math.log(s) / s);
  };
}, oP = function(e, t, i) {
  t === void 0 && (t = 0), i === void 0 && (i = 1);
  var r = e.normal(t, i);
  return function() {
    return Math.exp(r());
  };
}, cP = function(e, t) {
  return t === void 0 && (t = 0.5), Zs(t).greaterThanOrEqual(0).lessThan(1), function() {
    return Math.floor(e.next() + t);
  };
}, lP = function(e, t, i) {
  return t === void 0 && (t = 1), i === void 0 && (i = 0.5), Zs(t).isInt().isPositive(), Zs(i).greaterThanOrEqual(0).lessThan(1), function() {
    for (var r = 0, n = 0; r++ < t; )
      e.next() < i && n++;
    return n;
  };
}, dP = function(e, t) {
  t === void 0 && (t = 0.5), Zs(t).greaterThan(0).lessThan(1);
  var i = 1 / Math.log(1 - t);
  return function() {
    return Math.floor(1 + Math.log(e.next()) * i);
  };
}, uP = [0, 0, 0.6931471805599453, 1.791759469228055, 3.1780538303479458, 4.787491742782046, 6.579251212010101, 8.525161361065415, 10.60460290274525, 12.801827480081469], hP = function(t) {
  return uP[t];
}, fP = 0.9189385332046727, pP = function(e, t) {
  if (t === void 0 && (t = 1), Zs(t).isPositive(), t < 10) {
    var i = Math.exp(-t);
    return function() {
      for (var c = i, l = 0, d = e.next(); d > c; )
        d = d - c, c = t * c / ++l;
      return l;
    };
  } else {
    var r = Math.sqrt(t), n = 0.931 + 2.53 * r, s = -0.059 + 0.02483 * n, a = 1.1239 + 1.1328 / (n - 3.4), o = 0.9277 - 3.6224 / (n - 2);
    return function() {
      for (; ; ) {
        var c = void 0, l = e.next();
        if (l <= 0.86 * o)
          return c = l / o - 0.43, Math.floor((2 * s / (0.5 - Math.abs(c)) + n) * c + t + 0.445);
        l >= o ? c = e.next() - 0.5 : (c = l / o - 0.93, c = (c < 0 ? -0.5 : 0.5) - c, l = e.next() * o);
        var d = 0.5 - Math.abs(c);
        if (!(d < 0.013 && l > d)) {
          var u = Math.floor((2 * s / d + n) * c + t + 0.445);
          if (l = l * a / (s / (d * d) + n), u >= 10) {
            var h = (u + 0.5) * Math.log(t / u) - t - fP + u - (0.08333333333333333 - (0.002777777777777778 - 1 / (1260 * u * u)) / (u * u)) / u;
            if (Math.log(l * r) <= h)
              return u;
          } else if (u >= 0) {
            var p, m = (p = hP(u)) != null ? p : 0;
            if (Math.log(l) <= u * Math.log(t) - t - m)
              return u;
          }
        }
      }
    };
  }
}, mP = function(e, t) {
  return t === void 0 && (t = 1), Zs(t).isPositive(), function() {
    return -Math.log(1 - e.next()) / t;
  };
}, gP = function(e, t) {
  return t === void 0 && (t = 1), Zs(t).isInt().greaterThanOrEqual(0), function() {
    for (var i = 0, r = 0; r < t; ++r)
      i += e.next();
    return i;
  };
}, yP = function(e, t) {
  t === void 0 && (t = 1), Zs(t).isInt().isPositive();
  var i = e.irwinHall(t);
  return function() {
    return i() / t;
  };
}, vP = function(e, t) {
  t === void 0 && (t = 1), Zs(t).greaterThanOrEqual(0);
  var i = 1 / t;
  return function() {
    return 1 / Math.pow(1 - e.next(), i);
  };
}, _P = /* @__PURE__ */ function(e) {
  CT(t, e);
  function t() {
    return e.apply(this, arguments) || this;
  }
  var i = t.prototype;
  return i.next = function() {
    return Math.random();
  }, i.seed = function(n, s) {
  }, i.clone = function() {
    return new t();
  }, v1(t, [{
    key: "name",
    get: function() {
      return "default";
    }
  }]), t;
}(ly), OT = /* @__PURE__ */ function() {
  function e(i) {
    var r = this;
    this._rng = void 0, this._patch = void 0, this._cache = {}, this.next = function() {
      return r._rng.next();
    }, this.float = function(n, s) {
      return r.uniform(n, s)();
    }, this.int = function(n, s) {
      return r.uniformInt(n, s)();
    }, this.integer = function(n, s) {
      return r.uniformInt(n, s)();
    }, this.bool = function() {
      return r.uniformBoolean()();
    }, this.boolean = function() {
      return r.uniformBoolean()();
    }, this.uniform = function(n, s) {
      return r._memoize("uniform", iP, n, s);
    }, this.uniformInt = function(n, s) {
      return r._memoize("uniformInt", nP, n, s);
    }, this.uniformBoolean = function() {
      return r._memoize("uniformBoolean", sP);
    }, this.normal = function(n, s) {
      return aP(r, n, s);
    }, this.logNormal = function(n, s) {
      return oP(r, n, s);
    }, this.bernoulli = function(n) {
      return cP(r, n);
    }, this.binomial = function(n, s) {
      return lP(r, n, s);
    }, this.geometric = function(n) {
      return dP(r, n);
    }, this.poisson = function(n) {
      return pP(r, n);
    }, this.exponential = function(n) {
      return mP(r, n);
    }, this.irwinHall = function(n) {
      return gP(r, n);
    }, this.bates = function(n) {
      return yP(r, n);
    }, this.pareto = function(n) {
      return vP(r, n);
    }, i && i instanceof ly ? this.use(i) : this.use(new _P()), this._cache = {};
  }
  var t = e.prototype;
  return t.clone = function() {
    var r = [].slice.call(arguments);
    return r.length ? new e(rI.apply(void 0, r)) : new e(this.rng.clone());
  }, t.use = function() {
    this._rng = rI.apply(void 0, [].slice.call(arguments));
  }, t.patch = function() {
    if (this._patch)
      throw new Error("Math.random already patched");
    this._patch = Math.random, Math.random = this.uniform();
  }, t.unpatch = function() {
    this._patch && (Math.random = this._patch, delete this._patch);
  }, t.choice = function(r) {
    if (!Array.isArray(r))
      throw new Error("Random.choice expected input to be an array, got " + typeof r);
    var n = r == null ? void 0 : r.length;
    if (n > 0) {
      var s = this.uniformInt(0, n - 1)();
      return r[s];
    } else
      return;
  }, t._memoize = function(r, n) {
    var s = [].slice.call(arguments, 2), a = "" + s.join(";"), o = this._cache[r];
    return (o === void 0 || o.key !== a) && (o = {
      key: a,
      distribution: n.apply(void 0, [this].concat(s))
    }, this._cache[r] = o), o.distribution;
  }, v1(e, [{
    key: "rng",
    get: function() {
      return this._rng;
    }
  }]), e;
}();
new OT();
const W_ = { capture: !0, passive: !1 };
function Y_(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function bP(e) {
  var t = e.document.documentElement, i = wa(e).on("dragstart.drag", Y_, W_);
  "onselectstart" in t ? i.on("selectstart.drag", Y_, W_) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function xP(e, t) {
  var i = e.document.documentElement, r = wa(e).on("dragstart.drag", null);
  t && (r.on("click.drag", Y_, W_), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in i ? r.on("selectstart.drag", null) : (i.style.MozUserSelect = i.__noselect, delete i.__noselect);
}
const Dm = (e) => () => e;
function wP(e, {
  sourceEvent: t,
  target: i,
  transform: r,
  dispatch: n
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: i, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: n }
  });
}
function vo(e, t, i) {
  this.k = e, this.x = t, this.y = i;
}
vo.prototype = {
  constructor: vo,
  scale: function(e) {
    return e === 1 ? this : new vo(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new vo(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var _f = new vo(1, 0, 0);
vo.prototype;
function Qv(e) {
  e.stopImmediatePropagation();
}
function Mh(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function SP(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function IP() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function nI() {
  return this.__zoom || _f;
}
function AP(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function TP() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function EP(e, t, i) {
  var r = e.invertX(t[0][0]) - i[0][0], n = e.invertX(t[1][0]) - i[1][0], s = e.invertY(t[0][1]) - i[0][1], a = e.invertY(t[1][1]) - i[1][1];
  return e.translate(
    n > r ? (r + n) / 2 : Math.min(0, r) || Math.max(0, n),
    a > s ? (s + a) / 2 : Math.min(0, s) || Math.max(0, a)
  );
}
function kP() {
  var e = SP, t = IP, i = EP, r = AP, n = TP, s = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], o = 250, c = FR, l = t1("start", "zoom", "end"), d, u, h, p = 500, m = 150, w = 0, C = 10;
  function F(V) {
    V.property("__zoom", nI).on("wheel.zoom", Ct, { passive: !1 }).on("mousedown.zoom", Mt).on("dblclick.zoom", Me).filter(n).on("touchstart.zoom", kt).on("touchmove.zoom", le).on("touchend.zoom touchcancel.zoom", ye).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  F.transform = function(V, Bt, at, vt) {
    var oe = V.selection ? V.selection() : V;
    oe.property("__zoom", nI), V !== oe ? Z(V, Bt, at, vt) : oe.interrupt().each(function() {
      yt(this, arguments).event(vt).start().zoom(null, typeof Bt == "function" ? Bt.apply(this, arguments) : Bt).end();
    });
  }, F.scaleBy = function(V, Bt, at, vt) {
    F.scaleTo(V, function() {
      var oe = this.__zoom.k, Yt = typeof Bt == "function" ? Bt.apply(this, arguments) : Bt;
      return oe * Yt;
    }, at, vt);
  }, F.scaleTo = function(V, Bt, at, vt) {
    F.transform(V, function() {
      var oe = t.apply(this, arguments), Yt = this.__zoom, pe = at == null ? E(oe) : typeof at == "function" ? at.apply(this, arguments) : at, ei = Yt.invert(pe), ii = typeof Bt == "function" ? Bt.apply(this, arguments) : Bt;
      return i(et(W(Yt, ii), pe, ei), oe, a);
    }, at, vt);
  }, F.translateBy = function(V, Bt, at, vt) {
    F.transform(V, function() {
      return i(this.__zoom.translate(
        typeof Bt == "function" ? Bt.apply(this, arguments) : Bt,
        typeof at == "function" ? at.apply(this, arguments) : at
      ), t.apply(this, arguments), a);
    }, null, vt);
  }, F.translateTo = function(V, Bt, at, vt, oe) {
    F.transform(V, function() {
      var Yt = t.apply(this, arguments), pe = this.__zoom, ei = vt == null ? E(Yt) : typeof vt == "function" ? vt.apply(this, arguments) : vt;
      return i(_f.translate(ei[0], ei[1]).scale(pe.k).translate(
        typeof Bt == "function" ? -Bt.apply(this, arguments) : -Bt,
        typeof at == "function" ? -at.apply(this, arguments) : -at
      ), Yt, a);
    }, vt, oe);
  };
  function W(V, Bt) {
    return Bt = Math.max(s[0], Math.min(s[1], Bt)), Bt === V.k ? V : new vo(Bt, V.x, V.y);
  }
  function et(V, Bt, at) {
    var vt = Bt[0] - at[0] * V.k, oe = Bt[1] - at[1] * V.k;
    return vt === V.x && oe === V.y ? V : new vo(V.k, vt, oe);
  }
  function E(V) {
    return [(+V[0][0] + +V[1][0]) / 2, (+V[0][1] + +V[1][1]) / 2];
  }
  function Z(V, Bt, at, vt) {
    V.on("start.zoom", function() {
      yt(this, arguments).event(vt).start();
    }).on("interrupt.zoom end.zoom", function() {
      yt(this, arguments).event(vt).end();
    }).tween("zoom", function() {
      var oe = this, Yt = arguments, pe = yt(oe, Yt).event(vt), ei = t.apply(oe, Yt), ii = at == null ? E(ei) : typeof at == "function" ? at.apply(oe, Yt) : at, cr = Math.max(ei[1][0] - ei[0][0], ei[1][1] - ei[0][1]), Oi = oe.__zoom, Ri = typeof Bt == "function" ? Bt.apply(oe, Yt) : Bt, Zi = c(Oi.invert(ii).concat(cr / Oi.k), Ri.invert(ii).concat(cr / Ri.k));
      return function(hr) {
        if (hr === 1)
          hr = Ri;
        else {
          var br = Zi(hr), qt = cr / br[2];
          hr = new vo(qt, ii[0] - br[0] * qt, ii[1] - br[1] * qt);
        }
        pe.zoom(null, hr);
      };
    });
  }
  function yt(V, Bt, at) {
    return !at && V.__zooming || new bt(V, Bt);
  }
  function bt(V, Bt) {
    this.that = V, this.args = Bt, this.active = 0, this.sourceEvent = null, this.extent = t.apply(V, Bt), this.taps = 0;
  }
  bt.prototype = {
    event: function(V) {
      return V && (this.sourceEvent = V), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(V, Bt) {
      return this.mouse && V !== "mouse" && (this.mouse[1] = Bt.invert(this.mouse[0])), this.touch0 && V !== "touch" && (this.touch0[1] = Bt.invert(this.touch0[0])), this.touch1 && V !== "touch" && (this.touch1[1] = Bt.invert(this.touch1[0])), this.that.__zoom = Bt, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(V) {
      var Bt = wa(this.that).datum();
      l.call(
        V,
        this.that,
        new wP(V, {
          sourceEvent: this.sourceEvent,
          target: F,
          type: V,
          transform: this.that.__zoom,
          dispatch: l
        }),
        Bt
      );
    }
  };
  function Ct(V, ...Bt) {
    if (!e.apply(this, arguments))
      return;
    var at = yt(this, Bt).event(V), vt = this.__zoom, oe = Math.max(s[0], Math.min(s[1], vt.k * Math.pow(2, r.apply(this, arguments)))), Yt = cl(V);
    if (at.wheel)
      (at.mouse[0][0] !== Yt[0] || at.mouse[0][1] !== Yt[1]) && (at.mouse[1] = vt.invert(at.mouse[0] = Yt)), clearTimeout(at.wheel);
    else {
      if (vt.k === oe)
        return;
      at.mouse = [Yt, vt.invert(Yt)], Zm(this), at.start();
    }
    Mh(V), at.wheel = setTimeout(pe, m), at.zoom("mouse", i(et(W(vt, oe), at.mouse[0], at.mouse[1]), at.extent, a));
    function pe() {
      at.wheel = null, at.end();
    }
  }
  function Mt(V, ...Bt) {
    if (h || !e.apply(this, arguments))
      return;
    var at = V.currentTarget, vt = yt(this, Bt, !0).event(V), oe = wa(V.view).on("mousemove.zoom", ii, !0).on("mouseup.zoom", cr, !0), Yt = cl(V, at), pe = V.clientX, ei = V.clientY;
    bP(V.view), Qv(V), vt.mouse = [Yt, this.__zoom.invert(Yt)], Zm(this), vt.start();
    function ii(Oi) {
      if (Mh(Oi), !vt.moved) {
        var Ri = Oi.clientX - pe, Zi = Oi.clientY - ei;
        vt.moved = Ri * Ri + Zi * Zi > w;
      }
      vt.event(Oi).zoom("mouse", i(et(vt.that.__zoom, vt.mouse[0] = cl(Oi, at), vt.mouse[1]), vt.extent, a));
    }
    function cr(Oi) {
      oe.on("mousemove.zoom mouseup.zoom", null), xP(Oi.view, vt.moved), Mh(Oi), vt.event(Oi).end();
    }
  }
  function Me(V, ...Bt) {
    if (e.apply(this, arguments)) {
      var at = this.__zoom, vt = cl(V.changedTouches ? V.changedTouches[0] : V, this), oe = at.invert(vt), Yt = at.k * (V.shiftKey ? 0.5 : 2), pe = i(et(W(at, Yt), vt, oe), t.apply(this, Bt), a);
      Mh(V), o > 0 ? wa(this).transition().duration(o).call(Z, pe, vt, V) : wa(this).call(F.transform, pe, vt, V);
    }
  }
  function kt(V, ...Bt) {
    if (e.apply(this, arguments)) {
      var at = V.touches, vt = at.length, oe = yt(this, Bt, V.changedTouches.length === vt).event(V), Yt, pe, ei, ii;
      for (Qv(V), pe = 0; pe < vt; ++pe)
        ei = at[pe], ii = cl(ei, this), ii = [ii, this.__zoom.invert(ii), ei.identifier], oe.touch0 ? !oe.touch1 && oe.touch0[2] !== ii[2] && (oe.touch1 = ii, oe.taps = 0) : (oe.touch0 = ii, Yt = !0, oe.taps = 1 + !!d);
      d && (d = clearTimeout(d)), Yt && (oe.taps < 2 && (u = ii[0], d = setTimeout(function() {
        d = null;
      }, p)), Zm(this), oe.start());
    }
  }
  function le(V, ...Bt) {
    if (this.__zooming) {
      var at = yt(this, Bt).event(V), vt = V.changedTouches, oe = vt.length, Yt, pe, ei, ii;
      for (Mh(V), Yt = 0; Yt < oe; ++Yt)
        pe = vt[Yt], ei = cl(pe, this), at.touch0 && at.touch0[2] === pe.identifier ? at.touch0[0] = ei : at.touch1 && at.touch1[2] === pe.identifier && (at.touch1[0] = ei);
      if (pe = at.that.__zoom, at.touch1) {
        var cr = at.touch0[0], Oi = at.touch0[1], Ri = at.touch1[0], Zi = at.touch1[1], hr = (hr = Ri[0] - cr[0]) * hr + (hr = Ri[1] - cr[1]) * hr, br = (br = Zi[0] - Oi[0]) * br + (br = Zi[1] - Oi[1]) * br;
        pe = W(pe, Math.sqrt(hr / br)), ei = [(cr[0] + Ri[0]) / 2, (cr[1] + Ri[1]) / 2], ii = [(Oi[0] + Zi[0]) / 2, (Oi[1] + Zi[1]) / 2];
      } else if (at.touch0)
        ei = at.touch0[0], ii = at.touch0[1];
      else
        return;
      at.zoom("touch", i(et(pe, ei, ii), at.extent, a));
    }
  }
  function ye(V, ...Bt) {
    if (this.__zooming) {
      var at = yt(this, Bt).event(V), vt = V.changedTouches, oe = vt.length, Yt, pe;
      for (Qv(V), h && clearTimeout(h), h = setTimeout(function() {
        h = null;
      }, p), Yt = 0; Yt < oe; ++Yt)
        pe = vt[Yt], at.touch0 && at.touch0[2] === pe.identifier ? delete at.touch0 : at.touch1 && at.touch1[2] === pe.identifier && delete at.touch1;
      if (at.touch1 && !at.touch0 && (at.touch0 = at.touch1, delete at.touch1), at.touch0)
        at.touch0[1] = this.__zoom.invert(at.touch0[0]);
      else if (at.end(), at.taps === 2 && (pe = cl(pe, this), Math.hypot(u[0] - pe[0], u[1] - pe[1]) < C)) {
        var ei = wa(this).on("dblclick.zoom");
        ei && ei.apply(this, arguments);
      }
    }
  }
  return F.wheelDelta = function(V) {
    return arguments.length ? (r = typeof V == "function" ? V : Dm(+V), F) : r;
  }, F.filter = function(V) {
    return arguments.length ? (e = typeof V == "function" ? V : Dm(!!V), F) : e;
  }, F.touchable = function(V) {
    return arguments.length ? (n = typeof V == "function" ? V : Dm(!!V), F) : n;
  }, F.extent = function(V) {
    return arguments.length ? (t = typeof V == "function" ? V : Dm([[+V[0][0], +V[0][1]], [+V[1][0], +V[1][1]]]), F) : t;
  }, F.scaleExtent = function(V) {
    return arguments.length ? (s[0] = +V[0], s[1] = +V[1], F) : [s[0], s[1]];
  }, F.translateExtent = function(V) {
    return arguments.length ? (a[0][0] = +V[0][0], a[1][0] = +V[1][0], a[0][1] = +V[0][1], a[1][1] = +V[1][1], F) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, F.constrain = function(V) {
    return arguments.length ? (i = V, F) : i;
  }, F.duration = function(V) {
    return arguments.length ? (o = +V, F) : o;
  }, F.interpolate = function(V) {
    return arguments.length ? (c = V, F) : c;
  }, F.on = function() {
    var V = l.on.apply(l, arguments);
    return V === l ? F : V;
  }, F.clickDistance = function(V) {
    return arguments.length ? (w = (V = +V) * V, F) : Math.sqrt(w);
  }, F.tapDistance = function(V) {
    return arguments.length ? (C = +V, F) : C;
  }, F;
}
const DT = "#b3b3b3", CP = 0.1, NT = 4, LT = "#666666", OP = 0.1, FT = 1, DP = "#222222", Je = {
  disableSimulation: !1,
  spaceSize: 4096,
  nodeSizeScale: 1,
  linkWidthScale: 1,
  arrowSizeScale: 1,
  renderLinks: !0,
  curvedLinks: !1,
  curvedLinkSegments: 19,
  curvedLinkWeight: 0.8,
  curvedLinkControlPointDistance: 0.5,
  arrowLinks: !0,
  linkVisibilityDistanceRange: [50, 150],
  linkVisibilityMinTransparency: 0.25,
  hoveredNodeRingColor: "white",
  focusedNodeRingColor: "white",
  useQuadtree: !1,
  simulation: {
    decay: 1e3,
    gravity: 0,
    center: 0,
    repulsion: 0.1,
    repulsionTheta: 1.7,
    repulsionQuadtreeLevels: 12,
    linkSpring: 1,
    linkDistance: 2,
    linkDistRandomVariationRange: [1, 1.2],
    repulsionFromMouse: 2,
    friction: 0.85
  },
  showFPSMonitor: !1,
  pixelRatio: 2,
  scaleNodesOnZoom: !0,
  initialZoomLevel: 1,
  disableZoom: !1,
  fitViewOnInit: !0,
  fitViewDelay: 250,
  nodeSamplingDistance: 150
}, NP = 0.7, LP = 0.95, sI = 3, BT = (e) => typeof e == "function", RT = (e) => Array.isArray(e), FP = (e) => e instanceof Object, BP = (e) => e instanceof Object ? e.constructor.name !== "Function" && e.constructor.name !== "Object" : !1, aI = (e) => FP(e) && !RT(e) && !BT(e) && !BP(e);
function Rg(e, t, i) {
  return BT(t) ? t(e, i) : t;
}
function ku(e) {
  var t;
  let i;
  if (RT(e))
    i = e;
  else {
    const r = So(e), n = r == null ? void 0 : r.rgb();
    i = [(n == null ? void 0 : n.r) || 0, (n == null ? void 0 : n.g) || 0, (n == null ? void 0 : n.b) || 0, (t = r == null ? void 0 : r.opacity) !== null && t !== void 0 ? t : 1];
  }
  return [
    i[0] / 255,
    i[1] / 255,
    i[2] / 255,
    i[3]
  ];
}
function hc(e, t) {
  let i = new Float32Array();
  return e({ framebuffer: t })(() => {
    i = e.read();
  }), i;
}
function RP(e, t, i) {
  return Math.min(Math.max(e, t), i);
}
class MP {
  constructor() {
    this.disableSimulation = Je.disableSimulation, this.backgroundColor = DP, this.spaceSize = Je.spaceSize, this.nodeColor = DT, this.nodeGreyoutOpacity = CP, this.nodeSize = NT, this.nodeSizeScale = Je.nodeSizeScale, this.renderHighlightedNodeRing = !0, this.highlightedNodeRingColor = void 0, this.renderHoveredNodeRing = !0, this.hoveredNodeRingColor = Je.hoveredNodeRingColor, this.focusedNodeRingColor = Je.focusedNodeRingColor, this.linkColor = LT, this.linkGreyoutOpacity = OP, this.linkWidth = FT, this.linkWidthScale = Je.linkWidthScale, this.renderLinks = Je.renderLinks, this.curvedLinks = Je.curvedLinks, this.curvedLinkSegments = Je.curvedLinkSegments, this.curvedLinkWeight = Je.curvedLinkWeight, this.curvedLinkControlPointDistance = Je.curvedLinkControlPointDistance, this.linkArrows = Je.arrowLinks, this.linkArrowsSizeScale = Je.arrowSizeScale, this.linkVisibilityDistanceRange = Je.linkVisibilityDistanceRange, this.linkVisibilityMinTransparency = Je.linkVisibilityMinTransparency, this.useQuadtree = Je.useQuadtree, this.simulation = {
      decay: Je.simulation.decay,
      gravity: Je.simulation.gravity,
      center: Je.simulation.center,
      repulsion: Je.simulation.repulsion,
      repulsionTheta: Je.simulation.repulsionTheta,
      repulsionQuadtreeLevels: Je.simulation.repulsionQuadtreeLevels,
      linkSpring: Je.simulation.linkSpring,
      linkDistance: Je.simulation.linkDistance,
      linkDistRandomVariationRange: Je.simulation.linkDistRandomVariationRange,
      repulsionFromMouse: Je.simulation.repulsionFromMouse,
      friction: Je.simulation.friction,
      onStart: void 0,
      onTick: void 0,
      onEnd: void 0,
      onPause: void 0,
      onRestart: void 0
    }, this.events = {
      onClick: void 0,
      onMouseMove: void 0,
      onNodeMouseOver: void 0,
      onNodeMouseOut: void 0,
      onZoomStart: void 0,
      onZoom: void 0,
      onZoomEnd: void 0
    }, this.showFPSMonitor = Je.showFPSMonitor, this.pixelRatio = Je.pixelRatio, this.scaleNodesOnZoom = Je.scaleNodesOnZoom, this.initialZoomLevel = Je.initialZoomLevel, this.disableZoom = Je.disableZoom, this.fitViewOnInit = Je.fitViewOnInit, this.fitViewDelay = Je.fitViewDelay, this.fitViewByNodesInRect = void 0, this.randomSeed = void 0, this.nodeSamplingDistance = Je.nodeSamplingDistance;
  }
  init(t) {
    Object.keys(t).forEach((i) => {
      this.deepMergeConfig(this.getConfig(), t, i);
    });
  }
  deepMergeConfig(t, i, r) {
    aI(t[r]) && aI(i[r]) ? Object.keys(i[r]).forEach((n) => {
      this.deepMergeConfig(t[r], i[r], n);
    }) : t[r] = i[r];
  }
  getConfig() {
    return this;
  }
}
class zc {
  constructor(t, i, r, n, s) {
    this.reglInstance = t, this.config = i, this.store = r, this.data = n, s && (this.points = s);
  }
}
var PP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec4 rgba;void main(){gl_FragColor=rgba;}`, $P = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float pointsTextureSize;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,indexes/pointsTextureSize);rgba=vec4(pointPosition.xy,1.0,0.0);gl_Position=vec4(0.0,0.0,0.0,1.0);gl_PointSize=1.0;}`, zP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D centermass;uniform float center;uniform float alpha;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec4 centermassValues=texture2D(centermass,vec2(0.0));vec2 centermassPosition=centermassValues.xy/centermassValues.b;vec2 distVector=centermassPosition-pointPosition.xy;float dist=sqrt(dot(distVector,distVector));if(dist>0.0){float angle=atan(distVector.y,distVector.x);float addV=alpha*center*dist*0.01;velocity.rg+=addV*vec2(cos(angle),sin(angle));}gl_FragColor=velocity;}`;
function ln(e) {
  return {
    buffer: e.buffer(new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1])),
    size: 2
  };
}
function lu(e, t) {
  const i = new Float32Array(t * t * 2);
  for (let n = 0; n < t; n++)
    for (let s = 0; s < t; s++) {
      const a = n * t * 2 + s * 2;
      i[a + 0] = s, i[a + 1] = n;
    }
  return {
    buffer: e.buffer(i),
    size: 2
  };
}
function Ir(e) {
  var t;
  e && !((t = e == null ? void 0 : e._framebuffer) === null || t === void 0) && t.framebuffer && e.destroy();
}
function t_(e) {
  var t;
  e && !((t = e == null ? void 0 : e._buffer) === null || t === void 0) && t.buffer && e.destroy();
}
var Cu = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec2 index;void main(){gl_FragColor=vec4(0.0);}`, yn = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
attribute vec2 quad;varying vec2 index;void main(){index=(quad+1.0)/2.0;gl_Position=vec4(quad,0,1);}`;
class UP extends zc {
  create() {
    const { reglInstance: t } = this;
    this.centermassFbo = t.framebuffer({
      color: t.texture({
        data: new Float32Array(4).fill(0),
        shape: [1, 1, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    });
  }
  initPrograms() {
    const { reglInstance: t, config: i, store: r, data: n, points: s } = this;
    this.clearCentermassCommand = t({
      frag: Cu,
      vert: yn,
      framebuffer: this.centermassFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) }
    }), this.calculateCentermassCommand = t({
      frag: PP,
      vert: $P,
      framebuffer: () => this.centermassFbo,
      primitive: "points",
      count: () => n.nodes.length,
      attributes: { indexes: lu(t, r.pointsTextureSize) },
      uniforms: {
        position: () => s == null ? void 0 : s.previousPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: !1, mask: !1 },
      stencil: { enable: !1 }
    }), this.runCommand = t({
      frag: zP,
      vert: yn,
      framebuffer: () => s == null ? void 0 : s.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => s == null ? void 0 : s.previousPositionFbo,
        centermass: () => this.centermassFbo,
        center: () => {
          var a;
          return (a = i.simulation) === null || a === void 0 ? void 0 : a.center;
        },
        alpha: () => r.alpha
      }
    });
  }
  run() {
    var t, i, r;
    (t = this.clearCentermassCommand) === null || t === void 0 || t.call(this), (i = this.calculateCentermassCommand) === null || i === void 0 || i.call(this), (r = this.runCommand) === null || r === void 0 || r.call(this);
  }
  destroy() {
    Ir(this.centermassFbo);
  }
}
var VP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float gravity;uniform float spaceSize;uniform float alpha;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec2 centerPosition=vec2(spaceSize/2.0);vec2 distVector=centerPosition-pointPosition.rg;float dist=sqrt(dot(distVector,distVector));if(dist>0.0){float angle=atan(distVector.y,distVector.x);float addV=alpha*gravity*dist*0.1;velocity.rg+=addV*vec2(cos(angle),sin(angle));}gl_FragColor=velocity;}`;
class jP extends zc {
  initPrograms() {
    const { reglInstance: t, config: i, store: r, points: n } = this;
    this.runCommand = t({
      frag: VP,
      vert: yn,
      framebuffer: () => n == null ? void 0 : n.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => n == null ? void 0 : n.previousPositionFbo,
        gravity: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.gravity;
        },
        spaceSize: () => r.adjustedSpaceSize,
        alpha: () => r.alpha
      }
    });
  }
  run() {
    var t;
    (t = this.runCommand) === null || t === void 0 || t.call(this);
  }
}
function GP(e) {
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D position;
uniform float linkSpring;
uniform float linkDistance;
uniform vec2 linkDistRandomVariationRange;

uniform sampler2D linkFirstIndicesAndAmount;
uniform sampler2D linkIndices;
uniform sampler2D linkBiasAndStrength;
uniform sampler2D linkRandomDistanceFbo;

uniform float pointsTextureSize;
uniform float linksTextureSize;
uniform float alpha;

varying vec2 index;

const float MAX_LINKS = ${e}.0;

void main() {
  vec4 pointPosition = texture2D(position, index);
  vec4 velocity = vec4(0.0);

  vec4 linkFirstIJAndAmount = texture2D(linkFirstIndicesAndAmount, index);
  float iCount = linkFirstIJAndAmount.r;
  float jCount = linkFirstIJAndAmount.g;
  float linkAmount = linkFirstIJAndAmount.b;
  if (linkAmount > 0.0) {
    for (float i = 0.0; i < MAX_LINKS; i += 1.0) {
      if (i < linkAmount) {
        if (iCount >= linksTextureSize) {
          iCount = 0.0;
          jCount += 1.0;
        }
        vec2 linkTextureIndex = (vec2(iCount, jCount) + 0.5) / linksTextureSize;
        vec4 connectedPointIndex = texture2D(linkIndices, linkTextureIndex);
        vec4 biasAndStrength = texture2D(linkBiasAndStrength, linkTextureIndex);
        vec4 randomMinDistance = texture2D(linkRandomDistanceFbo, linkTextureIndex);
        float bias = biasAndStrength.r;
        float strength = biasAndStrength.g;
        float randomMinLinkDist = randomMinDistance.r * (linkDistRandomVariationRange.g - linkDistRandomVariationRange.r) + linkDistRandomVariationRange.r;
        randomMinLinkDist *= linkDistance;

        iCount += 1.0;

        vec4 connectedPointPosition = texture2D(position, (connectedPointIndex.rg + 0.5) / pointsTextureSize);
        float x = connectedPointPosition.x - (pointPosition.x + velocity.x);
        float y = connectedPointPosition.y - (pointPosition.y + velocity.y);
        float l = sqrt(x * x + y * y);
        l = max(l, randomMinLinkDist * 0.99);
        l = (l - randomMinLinkDist) / l;
        l *= linkSpring * alpha;
        l *= strength;
        l *= bias;
        x *= l;
        y *= l;
        velocity.x += x;
        velocity.y += y;
      }
    }
  }

  gl_FragColor = vec4(velocity.rg, 0.0, 0.0);
}
  `;
}
var Nf;
(function(e) {
  e.OUTGOING = "outgoing", e.INCOMING = "incoming";
})(Nf || (Nf = {}));
class oI extends zc {
  constructor() {
    super(...arguments), this.linkFirstIndicesAndAmount = new Float32Array(), this.indices = new Float32Array(), this.maxPointDegree = 0;
  }
  create(t) {
    const { reglInstance: i, store: { pointsTextureSize: r, linksTextureSize: n }, data: s } = this;
    if (!r || !n)
      return;
    this.linkFirstIndicesAndAmount = new Float32Array(r * r * 4), this.indices = new Float32Array(n * n * 4);
    const a = new Float32Array(n * n * 4), o = new Float32Array(n * n * 4), c = t === Nf.INCOMING ? s.groupedSourceToTargetLinks : s.groupedTargetToSourceLinks;
    this.maxPointDegree = 0;
    let l = 0;
    c.forEach((d, u) => {
      this.linkFirstIndicesAndAmount[u * 4 + 0] = l % n, this.linkFirstIndicesAndAmount[u * 4 + 1] = Math.floor(l / n), this.linkFirstIndicesAndAmount[u * 4 + 2] = d.size, d.forEach((h) => {
        var p, m;
        this.indices[l * 4 + 0] = h % r, this.indices[l * 4 + 1] = Math.floor(h / r);
        const w = (p = s.degree[s.getInputIndexBySortedIndex(h)]) !== null && p !== void 0 ? p : 0, C = (m = s.degree[s.getInputIndexBySortedIndex(u)]) !== null && m !== void 0 ? m : 0, F = w / (w + C);
        let W = 1 / Math.min(w, C);
        W = Math.sqrt(W), a[l * 4 + 0] = F, a[l * 4 + 1] = W, o[l * 4] = this.store.getRandomFloat(0, 1), l += 1;
      }), this.maxPointDegree = Math.max(this.maxPointDegree, d.size);
    }), this.linkFirstIndicesAndAmountFbo = i.framebuffer({
      color: i.texture({
        data: this.linkFirstIndicesAndAmount,
        shape: [r, r, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.indicesFbo = i.framebuffer({
      color: i.texture({
        data: this.indices,
        shape: [n, n, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.biasAndStrengthFbo = i.framebuffer({
      color: i.texture({
        data: a,
        shape: [n, n, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.randomDistanceFbo = i.framebuffer({
      color: i.texture({
        data: o,
        shape: [n, n, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    });
  }
  initPrograms() {
    const { reglInstance: t, config: i, store: r, points: n } = this;
    this.runCommand = t({
      frag: () => GP(this.maxPointDegree),
      vert: yn,
      framebuffer: () => n == null ? void 0 : n.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => n == null ? void 0 : n.previousPositionFbo,
        linkSpring: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.linkSpring;
        },
        linkDistance: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.linkDistance;
        },
        linkDistRandomVariationRange: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.linkDistRandomVariationRange;
        },
        linkFirstIndicesAndAmount: () => this.linkFirstIndicesAndAmountFbo,
        linkIndices: () => this.indicesFbo,
        linkBiasAndStrength: () => this.biasAndStrengthFbo,
        linkRandomDistanceFbo: () => this.randomDistanceFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        linksTextureSize: () => r.linksTextureSize,
        alpha: () => r.alpha
      }
    });
  }
  run() {
    var t;
    (t = this.runCommand) === null || t === void 0 || t.call(this);
  }
  destroy() {
    Ir(this.linkFirstIndicesAndAmountFbo), Ir(this.indicesFbo), Ir(this.biasAndStrengthFbo), Ir(this.randomDistanceFbo);
  }
}
var MT = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec4 rgba;void main(){gl_FragColor=rgba;}`, PT = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float pointsTextureSize;uniform float levelTextureSize;uniform float cellSize;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,indexes/pointsTextureSize);rgba=vec4(pointPosition.rg,1.0,0.0);float n=floor(pointPosition.x/cellSize);float m=floor(pointPosition.y/cellSize);vec2 levelPosition=2.0*(vec2(n,m)+0.5)/levelTextureSize-1.0;gl_Position=vec4(levelPosition,0.0,1.0);gl_PointSize=1.0;}`, HP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D levelFbo;uniform float level;uniform float levels;uniform float levelTextureSize;uniform float repulsion;uniform float alpha;uniform float spaceSize;uniform float theta;varying vec2 index;const float MAX_LEVELS_NUM=14.0;vec2 calcAdd(vec2 ij,vec2 pp){vec2 add=vec2(0.0);vec4 centermass=texture2D(levelFbo,ij);if(centermass.r>0.0&&centermass.g>0.0&&centermass.b>0.0){vec2 centermassPosition=vec2(centermass.rg/centermass.b);vec2 distVector=pp-centermassPosition;float l=dot(distVector,distVector);float dist=sqrt(l);if(l>0.0){float angle=atan(distVector.y,distVector.x);float c=alpha*repulsion*centermass.b;float distanceMin2=1.0;if(l<distanceMin2)l=sqrt(distanceMin2*l);float addV=c/sqrt(l);add=addV*vec2(cos(angle),sin(angle));}}return add;}void main(){vec4 pointPosition=texture2D(position,index);float x=pointPosition.x;float y=pointPosition.y;float left=0.0;float top=0.0;float right=spaceSize;float bottom=spaceSize;float n_left=0.0;float n_top=0.0;float n_right=0.0;float n_bottom=0.0;float cellSize=0.0;for(float i=0.0;i<MAX_LEVELS_NUM;i+=1.0){if(i<=level){left+=cellSize*n_left;top+=cellSize*n_top;right-=cellSize*n_right;bottom-=cellSize*n_bottom;cellSize=pow(2.0,levels-i-1.0);float dist_left=x-left;n_left=max(0.0,floor(dist_left/cellSize-theta));float dist_top=y-top;n_top=max(0.0,floor(dist_top/cellSize-theta));float dist_right=right-x;n_right=max(0.0,floor(dist_right/cellSize-theta));float dist_bottom=bottom-y;n_bottom=max(0.0,floor(dist_bottom/cellSize-theta));}}vec4 velocity=vec4(vec2(0.0),1.0,0.0);for(float i=0.0;i<12.0;i+=1.0){for(float j=0.0;j<4.0;j+=1.0){float n=left+cellSize*j;float m=top+cellSize*n_top+cellSize*i;if(n<(left+n_left*cellSize)&&m<bottom){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=left+cellSize*i;m=top+cellSize*j;if(n<(right-n_right*cellSize)&&m<(top+n_top*cellSize)){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=right-n_right*cellSize+cellSize*j;m=top+cellSize*i;if(n<right&&m<(bottom-n_bottom*cellSize)){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}n=left+n_left*cellSize+cellSize*i;m=bottom-n_bottom*cellSize+cellSize*j;if(n<right&&m<bottom){velocity.xy+=calcAdd(vec2(n/cellSize,m/cellSize)/levelTextureSize,pointPosition.xy);}}}gl_FragColor=velocity;}`, WP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D levelFbo;uniform sampler2D randomValues;uniform float levelTextureSize;uniform float repulsion;uniform float alpha;varying vec2 index;vec2 calcAdd(vec2 ij,vec2 pp){vec2 add=vec2(0.0);vec4 centermass=texture2D(levelFbo,ij);if(centermass.r>0.0&&centermass.g>0.0&&centermass.b>0.0){vec2 centermassPosition=vec2(centermass.rg/centermass.b);vec2 distVector=pp-centermassPosition;float l=dot(distVector,distVector);float dist=sqrt(l);if(l>0.0){float angle=atan(distVector.y,distVector.x);float c=alpha*repulsion*centermass.b;float distanceMin2=1.0;if(l<distanceMin2)l=sqrt(distanceMin2*l);float addV=c/sqrt(l);add=addV*vec2(cos(angle),sin(angle));}}return add;}void main(){vec4 pointPosition=texture2D(position,index);vec4 random=texture2D(randomValues,index);vec4 velocity=vec4(0.0);velocity.xy+=calcAdd(pointPosition.xy/levelTextureSize,pointPosition.xy);velocity.xy+=velocity.xy*random.rg;gl_FragColor=velocity;}`;
class YP extends zc {
  constructor() {
    super(...arguments), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: t, store: i } = this;
    if (!i.pointsTextureSize)
      return;
    this.quadtreeLevels = Math.log2(i.adjustedSpaceSize);
    for (let n = 0; n < this.quadtreeLevels; n += 1) {
      const s = Math.pow(2, n + 1);
      this.levelsFbos.set(`level[${n}]`, t.framebuffer({
        shape: [s, s],
        colorType: "float",
        depth: !1,
        stencil: !1
      }));
    }
    const r = new Float32Array(i.pointsTextureSize * i.pointsTextureSize * 4);
    for (let n = 0; n < i.pointsTextureSize * i.pointsTextureSize; ++n)
      r[n * 4] = i.getRandomFloat(-1, 1) * 1e-5, r[n * 4 + 1] = i.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesFbo = t.framebuffer({
      color: t.texture({
        data: r,
        shape: [i.pointsTextureSize, i.pointsTextureSize, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    });
  }
  initPrograms() {
    const { reglInstance: t, config: i, store: r, data: n, points: s } = this;
    this.clearLevelsCommand = t({
      frag: Cu,
      vert: yn,
      framebuffer: (a, o) => o.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) }
    }), this.calculateLevelsCommand = t({
      frag: MT,
      vert: PT,
      framebuffer: (a, o) => o.levelFbo,
      primitive: "points",
      count: () => n.nodes.length,
      attributes: { indexes: lu(t, r.pointsTextureSize) },
      uniforms: {
        position: () => s == null ? void 0 : s.previousPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        levelTextureSize: (a, o) => o.levelTextureSize,
        cellSize: (a, o) => o.cellSize
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: !1, mask: !1 },
      stencil: { enable: !1 }
    }), this.forceCommand = t({
      frag: HP,
      vert: yn,
      framebuffer: () => s == null ? void 0 : s.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => s == null ? void 0 : s.previousPositionFbo,
        level: (a, o) => o.level,
        levels: this.quadtreeLevels,
        levelFbo: (a, o) => o.levelFbo,
        levelTextureSize: (a, o) => o.levelTextureSize,
        alpha: () => r.alpha,
        repulsion: () => {
          var a;
          return (a = i.simulation) === null || a === void 0 ? void 0 : a.repulsion;
        },
        spaceSize: () => r.adjustedSpaceSize,
        theta: () => {
          var a;
          return (a = i.simulation) === null || a === void 0 ? void 0 : a.repulsionTheta;
        }
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: !1, mask: !1 },
      stencil: { enable: !1 }
    }), this.forceFromItsOwnCentermassCommand = t({
      frag: WP,
      vert: yn,
      framebuffer: () => s == null ? void 0 : s.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => s == null ? void 0 : s.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        levelFbo: (a, o) => o.levelFbo,
        levelTextureSize: (a, o) => o.levelTextureSize,
        alpha: () => r.alpha,
        repulsion: () => {
          var a;
          return (a = i.simulation) === null || a === void 0 ? void 0 : a.repulsion;
        },
        spaceSize: () => r.adjustedSpaceSize
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: !1, mask: !1 },
      stencil: { enable: !1 }
    }), this.clearVelocityCommand = t({
      frag: Cu,
      vert: yn,
      framebuffer: () => s == null ? void 0 : s.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) }
    });
  }
  run() {
    var t, i, r, n, s;
    const { store: a } = this;
    for (let o = 0; o < this.quadtreeLevels; o += 1) {
      (t = this.clearLevelsCommand) === null || t === void 0 || t.call(this, { levelFbo: this.levelsFbos.get(`level[${o}]`) });
      const c = Math.pow(2, o + 1), l = a.adjustedSpaceSize / c;
      (i = this.calculateLevelsCommand) === null || i === void 0 || i.call(this, {
        levelFbo: this.levelsFbos.get(`level[${o}]`),
        levelTextureSize: c,
        cellSize: l
      });
    }
    (r = this.clearVelocityCommand) === null || r === void 0 || r.call(this);
    for (let o = 0; o < this.quadtreeLevels; o += 1) {
      const c = Math.pow(2, o + 1);
      (n = this.forceCommand) === null || n === void 0 || n.call(this, {
        levelFbo: this.levelsFbos.get(`level[${o}]`),
        levelTextureSize: c,
        level: o
      }), o === this.quadtreeLevels - 1 && ((s = this.forceFromItsOwnCentermassCommand) === null || s === void 0 || s.call(this, {
        levelFbo: this.levelsFbos.get(`level[${o}]`),
        levelTextureSize: c,
        level: o
      }));
    }
  }
  destroy() {
    Ir(this.randomValuesFbo), this.levelsFbos.forEach((t) => {
      Ir(t);
    }), this.levelsFbos.clear();
  }
}
function qP(e, t) {
  e = Math.min(e, t);
  const i = t - e, r = `
    float dist = sqrt(l);
    if (dist > 0.0) {
      float c = alpha * repulsion * centermass.b;
      addVelocity += calcAdd(vec2(x, y), l, c);
      addVelocity += addVelocity * random.rg;
    }
  `;
  function n(s) {
    if (s >= t)
      return r;
    {
      const a = Math.pow(2, s + 1), o = new Array(s + 1 - i).fill(0).map((l, d) => `pow(2.0, ${s - (d + i)}.0) * i${d + i}`).join("+"), c = new Array(s + 1 - i).fill(0).map((l, d) => `pow(2.0, ${s - (d + i)}.0) * j${d + i}`).join("+");
      return `
      for (float ij${s} = 0.0; ij${s} < 4.0; ij${s} += 1.0) {
        float i${s} = 0.0;
        float j${s} = 0.0;
        if (ij${s} == 1.0 || ij${s} == 3.0) i${s} = 1.0;
        if (ij${s} == 2.0 || ij${s} == 3.0) j${s} = 1.0;
        float i = pow(2.0, ${e}.0) * n / width${s + 1} + ${o};
        float j = pow(2.0, ${e}.0) * m / width${s + 1} + ${c};
        float groupPosX = (i + 0.5) / ${a}.0;
        float groupPosY = (j + 0.5) / ${a}.0;
        
        vec4 centermass = texture2D(level[${s}], vec2(groupPosX, groupPosY));
        if (centermass.r > 0.0 && centermass.g > 0.0 && centermass.b > 0.0) {
          float x = centermass.r / centermass.b - pointPosition.r;
          float y = centermass.g / centermass.b - pointPosition.g;
          float l = x * x + y * y;
          if ((width${s + 1} * width${s + 1}) / theta < l) {
            ${r}
          } else {
            ${n(s + 1)}
          }
        }
      }
      `;
    }
  }
  return `
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D position;
uniform sampler2D randomValues;
uniform float spaceSize;
uniform float repulsion;
uniform float theta;
uniform float alpha;
uniform sampler2D level[${t}];
varying vec2 index;

vec2 calcAdd(vec2 xy, float l, float c) {
  float distanceMin2 = 1.0;
  if (l < distanceMin2) l = sqrt(distanceMin2 * l);
  float add = c / l;
  return add * xy;
}

void main() {
  vec4 pointPosition = texture2D(position, index);
  vec4 random = texture2D(randomValues, index);

  float width0 = spaceSize;

  vec2 velocity = vec2(0.0);
  vec2 addVelocity = vec2(0.0);

  ${new Array(t).fill(0).map((s, a) => `float width${a + 1} = width${a} / 2.0;`).join(`
`)}

  for (float n = 0.0; n < pow(2.0, ${i}.0); n += 1.0) {
    for (float m = 0.0; m < pow(2.0, ${i}.0); m += 1.0) {
      ${n(i)}
    }
  }

  velocity -= addVelocity;

  gl_FragColor = vec4(velocity, 0.0, 0.0);
}
`;
}
class ZP extends zc {
  constructor() {
    super(...arguments), this.levelsFbos = /* @__PURE__ */ new Map(), this.quadtreeLevels = 0;
  }
  create() {
    const { reglInstance: t, store: i } = this;
    if (!i.pointsTextureSize)
      return;
    this.quadtreeLevels = Math.log2(i.adjustedSpaceSize);
    for (let n = 0; n < this.quadtreeLevels; n += 1) {
      const s = Math.pow(2, n + 1);
      this.levelsFbos.set(`level[${n}]`, t.framebuffer({
        color: t.texture({
          data: new Float32Array(s * s * 4),
          shape: [s, s, 4],
          type: "float"
        }),
        depth: !1,
        stencil: !1
      }));
    }
    const r = new Float32Array(i.pointsTextureSize * i.pointsTextureSize * 4);
    for (let n = 0; n < i.pointsTextureSize * i.pointsTextureSize; ++n)
      r[n * 4] = i.getRandomFloat(-1, 1) * 1e-5, r[n * 4 + 1] = i.getRandomFloat(-1, 1) * 1e-5;
    this.randomValuesFbo = t.framebuffer({
      color: t.texture({
        data: r,
        shape: [i.pointsTextureSize, i.pointsTextureSize, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    });
  }
  initPrograms() {
    var t, i;
    const { reglInstance: r, config: n, store: s, data: a, points: o } = this;
    this.clearLevelsCommand = r({
      frag: Cu,
      vert: yn,
      framebuffer: (c, l) => l.levelFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(r) }
    }), this.calculateLevelsCommand = r({
      frag: MT,
      vert: PT,
      framebuffer: (c, l) => l.levelFbo,
      primitive: "points",
      count: () => a.nodes.length,
      attributes: { indexes: lu(r, s.pointsTextureSize) },
      uniforms: {
        position: () => o == null ? void 0 : o.previousPositionFbo,
        pointsTextureSize: () => s.pointsTextureSize,
        levelTextureSize: (c, l) => l.levelTextureSize,
        cellSize: (c, l) => l.cellSize
      },
      blend: {
        enable: !0,
        func: {
          src: "one",
          dst: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: { enable: !1, mask: !1 },
      stencil: { enable: !1 }
    }), this.quadtreeCommand = r({
      frag: qP((i = (t = n.simulation) === null || t === void 0 ? void 0 : t.repulsionQuadtreeLevels) !== null && i !== void 0 ? i : this.quadtreeLevels, this.quadtreeLevels),
      vert: yn,
      framebuffer: () => o == null ? void 0 : o.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(r) },
      uniforms: {
        position: () => o == null ? void 0 : o.previousPositionFbo,
        randomValues: () => this.randomValuesFbo,
        spaceSize: () => s.adjustedSpaceSize,
        repulsion: () => {
          var c;
          return (c = n.simulation) === null || c === void 0 ? void 0 : c.repulsion;
        },
        theta: () => {
          var c;
          return (c = n.simulation) === null || c === void 0 ? void 0 : c.repulsionTheta;
        },
        alpha: () => s.alpha,
        ...Object.fromEntries(this.levelsFbos)
      }
    });
  }
  run() {
    var t, i, r;
    const { store: n } = this;
    for (let s = 0; s < this.quadtreeLevels; s += 1) {
      (t = this.clearLevelsCommand) === null || t === void 0 || t.call(this, { levelFbo: this.levelsFbos.get(`level[${s}]`) });
      const a = Math.pow(2, s + 1), o = n.adjustedSpaceSize / a;
      (i = this.calculateLevelsCommand) === null || i === void 0 || i.call(this, {
        levelFbo: this.levelsFbos.get(`level[${s}]`),
        levelTextureSize: a,
        cellSize: o
      });
    }
    (r = this.quadtreeCommand) === null || r === void 0 || r.call(this);
  }
  destroy() {
    Ir(this.randomValuesFbo), this.levelsFbos.forEach((t) => {
      Ir(t);
    }), this.levelsFbos.clear();
  }
}
var XP = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float repulsion;uniform vec2 mousePos;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 velocity=vec4(0.0);vec2 mouse=mousePos;vec2 distVector=mouse-pointPosition.rg;float dist=sqrt(dot(distVector,distVector));dist=max(dist,10.0);float angle=atan(distVector.y,distVector.x);float addV=100.0*repulsion/(dist*dist);velocity.rg-=addV*vec2(cos(angle),sin(angle));gl_FragColor=velocity;}`;
class KP extends zc {
  initPrograms() {
    const { reglInstance: t, config: i, store: r, points: n } = this;
    this.runCommand = t({
      frag: XP,
      vert: yn,
      framebuffer: () => n == null ? void 0 : n.velocityFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => n == null ? void 0 : n.previousPositionFbo,
        mousePos: () => r.mousePosition,
        repulsion: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.repulsionFromMouse;
        }
      }
    });
  }
  run() {
    var t;
    (t = this.runCommand) === null || t === void 0 || t.call(this);
  }
}
var JP = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, $T = { exports: {} };
(function(e, t) {
  (function(i, r) {
    e.exports = r();
  })(JP, function() {
    var i = `<div class="gl-box">
  <svg viewBox="0 0 55 60">
    <text x="27" y="56" class="gl-fps">00 FPS</text>
    <text x="28" y="8" class="gl-mem"></text>
    <rect x="0" y="14" rx="4" ry="4" width="55" height="32"></rect>
    <polyline class="gl-chart"></polyline>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-cpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-cpu" stroke-dasharray="0 27"/>
    <path d="M5.35 43c-.464 0-.812.377-.812.812v1.16c-.783.1972-1.421.812-1.595 1.624h-1.16c-.435 0-.812.348-.812.812s.348.812.812.812h1.102v1.653H1.812c-.464 0-.812.377-.812.812 0 .464.377.812.812.812h1.131c.1943.783.812 1.392 1.595 1.595v1.131c0 .464.377.812.812.812.464 0 .812-.377.812-.812V53.15h1.653v1.073c0 .464.377.812.812.812.464 0 .812-.377.812-.812v-1.131c.783-.1943 1.392-.812 1.595-1.595h1.131c.464 0 .812-.377.812-.812 0-.464-.377-.812-.812-.812h-1.073V48.22h1.102c.435 0 .812-.348.812-.812s-.348-.812-.812-.812h-1.16c-.1885-.783-.812-1.421-1.595-1.624v-1.131c0-.464-.377-.812-.812-.812-.464 0-.812.377-.812.812v1.073H6.162v-1.073c0-.464-.377-.812-.812-.812zm.58 3.48h2.088c.754 0 1.363.609 1.363 1.363v2.088c0 .754-.609 1.363-1.363 1.363H5.93c-.754 0-1.363-.609-1.363-1.363v-2.088c0-.754.609-1.363 1.363-1.363z"/>
  </svg>
  <svg viewBox="0 0 14 60" class="gl-gpu-svg">
    <line x1="7" y1="38" x2="7" y2="11" class="opacity"/>
    <line x1="7" y1="38" x2="7" y2="11" class="gl-gpu" stroke-dasharray="0 27"/>
    <path d="M1.94775 43.3772a.736.736 0 10-.00416 1.472c.58535.00231.56465.1288.6348.3197.07015.18975.04933.43585.04933.43585l-.00653.05405v8.671a.736.736 0 101.472 0v-1.4145c.253.09522.52785.1495.81765.1495h5.267c1.2535 0 2.254-.9752 2.254-2.185v-3.105c0-1.2075-1.00625-2.185-2.254-2.185h-5.267c-.28865 0-.5635.05405-.8165.1495.01806-.16445.04209-.598-.1357-1.0787-.22425-.6072-.9499-1.2765-2.0125-1.2765zm2.9095 3.6455c.42435 0 .7659.36225.7659.8119v2.9785c0 .44965-.34155.8119-.7659.8119s-.7659-.36225-.7659-.8119v-2.9785c0-.44965.34155-.8119.7659-.8119zm4.117 0a2.3 2.3 0 012.3 2.3 2.3 2.3 0 01-2.3 2.3 2.3 2.3 0 01-2.3-2.3 2.3 2.3 0 012.3-2.3z"/>
  </svg>
</div>`, r = `#gl-bench {
  position:absolute;
  left:0;
  top:0;
  z-index:1000;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
}

#gl-bench div {
  position: relative;
  display: block;
  margin: 4px;
  padding: 0 7px 0 10px;
  background: #6c6;
  border-radius: 15px;
  cursor: pointer;
  opacity: 0.9;
}

#gl-bench svg {
  height: 60px;
  margin: 0 -1px;
}

#gl-bench text {
  font-size: 12px;
  font-family: Helvetica,Arial,sans-serif;
  font-weight: 700;
  dominant-baseline: middle;
  text-anchor: middle;
}

#gl-bench .gl-mem {
  font-size: 9px;
}

#gl-bench line {
  stroke-width: 5;
  stroke: #112211;
  stroke-linecap: round;
}

#gl-bench polyline {
  fill: none;
  stroke: #112211;
  stroke-linecap: round;
  stroke-linejoin: round;
  stroke-width: 3.5;
}

#gl-bench rect {
  fill: #448844;
}

#gl-bench .opacity {
  stroke: #448844;
}
`;
    class n {
      /** GLBench constructor
       * @param { WebGLRenderingContext | WebGL2RenderingContext } gl context
       * @param { Object | undefined } settings additional settings
       */
      constructor(a, o = {}) {
        this.css = r, this.svg = i, this.paramLogger = () => {
        }, this.chartLogger = () => {
        }, this.chartLen = 20, this.chartHz = 20, this.names = [], this.cpuAccums = [], this.gpuAccums = [], this.activeAccums = [], this.chart = new Array(this.chartLen), this.now = () => performance && performance.now ? performance.now() : Date.now(), this.updateUI = () => {
          [].forEach.call(this.nodes["gl-gpu-svg"], (h) => {
            h.style.display = this.trackGPU ? "inline" : "none";
          });
        }, Object.assign(this, o), this.detected = 0, this.finished = [], this.isFramebuffer = 0, this.frameId = 0;
        let c, l = 0, d, u = (h) => {
          ++l < 20 ? c = requestAnimationFrame(u) : (this.detected = Math.ceil(1e3 * l / (h - d) / 70), cancelAnimationFrame(c)), d || (d = h);
        };
        if (requestAnimationFrame(u), a) {
          const h = async (m, w) => Promise.resolve(setTimeout(() => {
            a.getError();
            const C = this.now() - m;
            w.forEach((F, W) => {
              F && (this.gpuAccums[W] += C);
            });
          }, 0)), p = (m, w, C) => function() {
            const F = w.now();
            m.apply(C, arguments), w.trackGPU && w.finished.push(h(F, w.activeAccums.slice(0)));
          };
          [
            "drawArrays",
            "drawElements",
            "drawArraysInstanced",
            "drawBuffers",
            "drawElementsInstanced",
            "drawRangeElements"
          ].forEach((m) => {
            a[m] && (a[m] = p(a[m], this, a));
          }), a.getExtension = /* @__PURE__ */ ((m, w) => function() {
            let C = m.apply(a, arguments);
            return C && ["drawElementsInstancedANGLE", "drawBuffersWEBGL"].forEach((F) => {
              C[F] && (C[F] = p(C[F], w, C));
            }), C;
          })(a.getExtension, this);
        }
        if (!this.withoutUI) {
          this.dom || (this.dom = document.body);
          let h = document.createElement("div");
          h.id = "gl-bench", this.dom.appendChild(h), this.dom.insertAdjacentHTML("afterbegin", '<style id="gl-bench-style">' + this.css + "</style>"), this.dom = h, this.dom.addEventListener("click", () => {
            this.trackGPU = !this.trackGPU, this.updateUI();
          }), this.paramLogger = ((p, m, w) => {
            const C = ["gl-cpu", "gl-gpu", "gl-mem", "gl-fps", "gl-gpu-svg", "gl-chart"], F = Object.assign({}, C);
            return C.forEach((W) => F[W] = m.getElementsByClassName(W)), this.nodes = F, (W, et, E, Z, yt, bt, Ct) => {
              F["gl-cpu"][W].style.strokeDasharray = (et * 0.27).toFixed(0) + " 100", F["gl-gpu"][W].style.strokeDasharray = (E * 0.27).toFixed(0) + " 100", F["gl-mem"][W].innerHTML = w[W] ? w[W] : Z ? "mem: " + Z.toFixed(0) + "mb" : "", F["gl-fps"][W].innerHTML = yt.toFixed(0) + " FPS", p(w[W], et, E, Z, yt, bt, Ct);
            };
          })(this.paramLogger, this.dom, this.names), this.chartLogger = ((p, m) => {
            let w = { "gl-chart": m.getElementsByClassName("gl-chart") };
            return (C, F, W) => {
              let et = "", E = F.length;
              for (let Z = 0; Z < E; Z++) {
                let yt = (W + Z + 1) % E;
                F[yt] != null && (et = et + " " + (55 * Z / (E - 1)).toFixed(1) + "," + (45 - F[yt] * 22 / 60 / this.detected).toFixed(1));
              }
              w["gl-chart"][C].setAttribute("points", et), p(this.names[C], F, W);
            };
          })(this.chartLogger, this.dom);
        }
      }
      /**
       * Explicit UI add
       * @param { string | undefined } name 
       */
      addUI(a) {
        this.names.indexOf(a) == -1 && (this.names.push(a), this.dom && (this.dom.insertAdjacentHTML("beforeend", this.svg), this.updateUI()), this.cpuAccums.push(0), this.gpuAccums.push(0), this.activeAccums.push(!1));
      }
      /**
       * Increase frameID
       * @param { number | undefined } now
       */
      nextFrame(a) {
        this.frameId++;
        const o = a || this.now();
        if (this.frameId <= 1)
          this.paramFrame = this.frameId, this.paramTime = o;
        else {
          let c = o - this.paramTime;
          if (c >= 1e3) {
            const l = this.frameId - this.paramFrame, d = l / c * 1e3;
            for (let u = 0; u < this.names.length; u++) {
              const h = this.cpuAccums[u] / c * 100, p = this.gpuAccums[u] / c * 100, m = performance && performance.memory ? performance.memory.usedJSHeapSize / (1 << 20) : 0;
              this.paramLogger(u, h, p, m, d, c, l), this.cpuAccums[u] = 0, Promise.all(this.finished).then(() => {
                this.gpuAccums[u] = 0, this.finished = [];
              });
            }
            this.paramFrame = this.frameId, this.paramTime = o;
          }
        }
        if (!this.detected || !this.chartFrame)
          this.chartFrame = this.frameId, this.chartTime = o, this.circularId = 0;
        else {
          let c = o - this.chartTime, l = this.chartHz * c / 1e3;
          for (; --l > 0 && this.detected; ) {
            const u = (this.frameId - this.chartFrame) / c * 1e3;
            this.chart[this.circularId % this.chartLen] = u;
            for (let h = 0; h < this.names.length; h++)
              this.chartLogger(h, this.chart, this.circularId);
            this.circularId++, this.chartFrame = this.frameId, this.chartTime = o;
          }
        }
      }
      /**
       * Begin named measurement
       * @param { string | undefined } name
       */
      begin(a) {
        this.updateAccums(a);
      }
      /**
       * End named measure
       * @param { string | undefined } name
       */
      end(a) {
        this.updateAccums(a);
      }
      updateAccums(a) {
        let o = this.names.indexOf(a);
        o == -1 && (o = this.names.length, this.addUI(a));
        const c = this.now(), l = c - this.t0;
        for (let d = 0; d < o + 1; d++)
          this.activeAccums[d] && (this.cpuAccums[d] += l);
        this.activeAccums[o] = !this.activeAccums[o], this.t0 = c;
      }
    }
    return n;
  });
})($T);
var QP = $T.exports;
const t7 = `
  #gl-bench {
    position:absolute;
    right:0;
    top:0;
    z-index:1000;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }
  #gl-bench div {
    position: relative;
    display: block;
    margin: 4px;
    padding: 0 7px 0 10px;
    background: #5f69de;
    border-radius: 15px;
    cursor: pointer;
    opacity: 0.9;
  }
  #gl-bench svg {
    height: 60px;
    margin: 0 -1px;
  }
  #gl-bench text {
    font-size: 12px;
    font-family: Helvetica,Arial,sans-serif;
    font-weight: 700;
    dominant-baseline: middle;
    text-anchor: middle;
  }
  #gl-bench .gl-mem {
    font-size: 9px;
  }
  #gl-bench line {
    stroke-width: 5;
    stroke: #112211;
    stroke-linecap: round;
  }
  #gl-bench polyline {
    fill: none;
    stroke: #112211;
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 3.5;
  }
  #gl-bench rect {
    fill: #8288e4;
  }
  #gl-bench .opacity {
    stroke: #8288e4;
  }
`;
class cI {
  constructor(t) {
    this.destroy();
    const i = t.getContext("webgl") || t.getContext("experimental-webgl");
    this.bench = new QP(i, { css: t7 });
  }
  begin() {
    var t;
    (t = this.bench) === null || t === void 0 || t.begin("frame");
  }
  end(t) {
    var i, r;
    (i = this.bench) === null || i === void 0 || i.end("frame"), (r = this.bench) === null || r === void 0 || r.nextFrame(t);
  }
  destroy() {
    this.bench = void 0, wa("#gl-bench").remove();
  }
}
class e7 {
  constructor() {
    this.completeLinks = /* @__PURE__ */ new Set(), this.degree = [], this.groupedSourceToTargetLinks = /* @__PURE__ */ new Map(), this.groupedTargetToSourceLinks = /* @__PURE__ */ new Map(), this._nodes = [], this._links = [], this.idToNodeMap = /* @__PURE__ */ new Map(), this.sortedIndexToInputIndexMap = /* @__PURE__ */ new Map(), this.inputIndexToSortedIndexMap = /* @__PURE__ */ new Map(), this.idToSortedIndexMap = /* @__PURE__ */ new Map(), this.inputIndexToIdMap = /* @__PURE__ */ new Map(), this.idToIndegreeMap = /* @__PURE__ */ new Map(), this.idToOutdegreeMap = /* @__PURE__ */ new Map();
  }
  get nodes() {
    return this._nodes;
  }
  get links() {
    return this._links;
  }
  get linksNumber() {
    return this.completeLinks.size;
  }
  setData(t, i) {
    this.idToNodeMap.clear(), this.idToSortedIndexMap.clear(), this.inputIndexToIdMap.clear(), this.idToIndegreeMap.clear(), this.idToOutdegreeMap.clear(), t.forEach((n, s) => {
      this.idToNodeMap.set(n.id, n), this.inputIndexToIdMap.set(s, n.id), this.idToIndegreeMap.set(n.id, 0), this.idToOutdegreeMap.set(n.id, 0);
    }), this.completeLinks.clear(), i.forEach((n) => {
      const s = this.idToNodeMap.get(n.source), a = this.idToNodeMap.get(n.target);
      if (s !== void 0 && a !== void 0) {
        this.completeLinks.add(n);
        const o = this.idToOutdegreeMap.get(s.id);
        o !== void 0 && this.idToOutdegreeMap.set(s.id, o + 1);
        const c = this.idToIndegreeMap.get(a.id);
        c !== void 0 && this.idToIndegreeMap.set(a.id, c + 1);
      }
    }), this.degree = new Array(t.length), t.forEach((n, s) => {
      const a = this.idToOutdegreeMap.get(n.id), o = this.idToIndegreeMap.get(n.id);
      this.degree[s] = (a ?? 0) + (o ?? 0);
    }), this.sortedIndexToInputIndexMap.clear(), this.inputIndexToSortedIndexMap.clear(), Object.entries(this.degree).sort((n, s) => n[1] - s[1]).forEach(([n], s) => {
      const a = +n;
      this.sortedIndexToInputIndexMap.set(s, a), this.inputIndexToSortedIndexMap.set(a, s), this.idToSortedIndexMap.set(this.inputIndexToIdMap.get(a), s);
    }), this.groupedSourceToTargetLinks.clear(), this.groupedTargetToSourceLinks.clear(), i.forEach((n) => {
      const s = this.idToSortedIndexMap.get(n.source), a = this.idToSortedIndexMap.get(n.target);
      if (s !== void 0 && a !== void 0) {
        this.groupedSourceToTargetLinks.get(s) === void 0 && this.groupedSourceToTargetLinks.set(s, /* @__PURE__ */ new Set());
        const o = this.groupedSourceToTargetLinks.get(s);
        o == null || o.add(a), this.groupedTargetToSourceLinks.get(a) === void 0 && this.groupedTargetToSourceLinks.set(a, /* @__PURE__ */ new Set());
        const c = this.groupedTargetToSourceLinks.get(a);
        c == null || c.add(s);
      }
    }), this._nodes = t, this._links = i;
  }
  getNodeById(t) {
    return this.idToNodeMap.get(t);
  }
  getNodeByIndex(t) {
    return this._nodes[t];
  }
  getSortedIndexByInputIndex(t) {
    return this.inputIndexToSortedIndexMap.get(t);
  }
  getInputIndexBySortedIndex(t) {
    return this.sortedIndexToInputIndexMap.get(t);
  }
  getSortedIndexById(t) {
    return t !== void 0 ? this.idToSortedIndexMap.get(t) : void 0;
  }
  getInputIndexById(t) {
    if (t === void 0)
      return;
    const i = this.getSortedIndexById(t);
    if (i !== void 0)
      return this.getInputIndexBySortedIndex(i);
  }
  getAdjacentNodes(t) {
    var i, r;
    const n = this.getSortedIndexById(t);
    if (n === void 0)
      return;
    const s = (i = this.groupedSourceToTargetLinks.get(n)) !== null && i !== void 0 ? i : [], a = (r = this.groupedTargetToSourceLinks.get(n)) !== null && r !== void 0 ? r : [];
    return [.../* @__PURE__ */ new Set([...s, ...a])].map((o) => this.getNodeByIndex(this.getInputIndexBySortedIndex(o)));
  }
}
var i7 = `precision highp float;
#define GLSLIFY 1
uniform bool useArrow;varying vec4 rgbaColor;varying vec2 pos;varying float arrowLength;varying float linkWidthArrowWidthRatio;varying float smoothWidthRatio;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}void main(){float opacity=1.0;vec3 color=rgbaColor.rgb;float smoothDelta=smoothWidthRatio/2.0;if(useArrow){float end_arrow=0.5+arrowLength/2.0;float start_arrow=end_arrow-arrowLength;float arrowWidthDelta=linkWidthArrowWidthRatio/2.0;float linkOpacity=rgbaColor.a*smoothstep(0.5-arrowWidthDelta,0.5-arrowWidthDelta-smoothDelta,abs(pos.y));float arrowOpacity=1.0;if(pos.x>start_arrow&&pos.x<start_arrow+arrowLength){float xmapped=map(pos.x,start_arrow,end_arrow,0.0,1.0);arrowOpacity=rgbaColor.a*smoothstep(xmapped-smoothDelta,xmapped,map(abs(pos.y),0.5,0.0,0.0,1.0));if(linkOpacity!=arrowOpacity){linkOpacity+=arrowOpacity;}}opacity=linkOpacity;}else opacity=rgbaColor.a*smoothstep(0.5,0.5-smoothDelta,abs(pos.y));gl_FragColor=vec4(color,opacity);}`, r7 = `precision highp float;
#define GLSLIFY 1
attribute vec2 position,pointA,pointB;attribute vec4 color;attribute float width;uniform sampler2D positions;uniform sampler2D particleGreyoutStatus;uniform mat3 transform;uniform float pointsTextureSize;uniform float widthScale;uniform float nodeSizeScale;uniform bool useArrow;uniform float arrowSizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform vec2 linkVisibilityDistanceRange;uniform float linkVisibilityMinTransparency;uniform float greyoutOpacity;uniform bool scaleNodesOnZoom;uniform float curvedWeight;uniform float curvedLinkControlPointDistance;uniform float curvedLinkSegments;varying vec4 rgbaColor;varying vec2 pos;varying float arrowLength;varying float linkWidthArrowWidthRatio;varying float smoothWidthRatio;float map(float value,float min1,float max1,float min2,float max2){return min2+(value-min1)*(max2-min2)/(max1-min1);}vec2 conicParametricCurve(vec2 A,vec2 B,vec2 ControlPoint,float t,float w){vec2 divident=(1.0-t)*(1.0-t)*A+2.0*(1.0-t)*t*w*ControlPoint+t*t*B;float divisor=(1.0-t)*(1.0-t)+2.0*(1.0-t)*t*w+t*t;return divident/divisor;}void main(){pos=position;vec2 pointTexturePosA=(pointA+0.5)/pointsTextureSize;vec2 pointTexturePosB=(pointB+0.5)/pointsTextureSize;vec4 greyoutStatusA=texture2D(particleGreyoutStatus,pointTexturePosA);vec4 greyoutStatusB=texture2D(particleGreyoutStatus,pointTexturePosB);vec4 pointPositionA=texture2D(positions,pointTexturePosA);vec4 pointPositionB=texture2D(positions,pointTexturePosB);vec2 a=pointPositionA.xy;vec2 b=pointPositionB.xy;vec2 xBasis=b-a;vec2 yBasis=normalize(vec2(-xBasis.y,xBasis.x));float linkDist=length(xBasis);float h=curvedLinkControlPointDistance;vec2 controlPoint=(a+b)/2.0+yBasis*linkDist*h;float linkDistPx=linkDist*transform[0][0];float linkWidth=width*widthScale;float k=2.0;float arrowWidth=max(5.0,linkWidth*k);arrowWidth*=arrowSizeScale;float arrowWidthPx=arrowWidth/transform[0][0];arrowLength=min(0.3,(0.866*arrowWidthPx*2.0)/linkDist);float smoothWidth=2.0;float arrowExtraWidth=arrowWidth-linkWidth;linkWidth+=smoothWidth/2.0;if(useArrow){linkWidth+=arrowExtraWidth;}smoothWidthRatio=smoothWidth/linkWidth;linkWidthArrowWidthRatio=arrowExtraWidth/linkWidth;float linkWidthPx=linkWidth/transform[0][0];vec3 rgbColor=color.rgb;float opacity=color.a*max(linkVisibilityMinTransparency,map(linkDistPx,linkVisibilityDistanceRange.g,linkVisibilityDistanceRange.r,0.0,1.0));if(greyoutStatusA.r>0.0||greyoutStatusB.r>0.0){opacity*=greyoutOpacity;}rgbaColor=vec4(rgbColor,opacity);float t=position.x;float w=curvedWeight;float tPrev=t-1.0/curvedLinkSegments;float tNext=t+1.0/curvedLinkSegments;vec2 pointCurr=conicParametricCurve(a,b,controlPoint,t,w);vec2 pointPrev=conicParametricCurve(a,b,controlPoint,max(0.0,tPrev),w);vec2 pointNext=conicParametricCurve(a,b,controlPoint,min(tNext,1.0),w);vec2 xBasisCurved=pointNext-pointPrev;vec2 yBasisCurved=normalize(vec2(-xBasisCurved.y,xBasisCurved.x));pointCurr+=yBasisCurved*linkWidthPx*position.y;vec2 p=2.0*pointCurr/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);}`;
const n7 = (e) => {
  const t = bT().exponent(2).range([0, 1]).domain([-1, 1]), i = t5(0, e).map((n) => -0.5 + n / e);
  i.push(0.5);
  const r = new Array(i.length * 2);
  return i.forEach((n, s) => {
    r[s * 2] = [t(n * 2), 0.5], r[s * 2 + 1] = [t(n * 2), -0.5];
  }), r;
};
class s7 extends zc {
  create() {
    this.updateColor(), this.updateWidth(), this.updateCurveLineGeometry();
  }
  initPrograms() {
    const { reglInstance: t, config: i, store: r, data: n, points: s } = this, { pointsTextureSize: a } = r, o = [];
    n.completeLinks.forEach((l) => {
      const d = n.getSortedIndexById(l.target), u = n.getSortedIndexById(l.source), h = u % a, p = Math.floor(u / a), m = d % a, w = Math.floor(d / a);
      o.push([h, p]), o.push([m, w]);
    });
    const c = t.buffer(o);
    this.drawCurveCommand = t({
      vert: r7,
      frag: i7,
      attributes: {
        position: {
          buffer: () => this.curveLineBuffer,
          divisor: 0
        },
        pointA: {
          buffer: () => c,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        pointB: {
          buffer: () => c,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 2,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        color: {
          buffer: () => this.colorBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 4
        },
        width: {
          buffer: () => this.widthBuffer,
          divisor: 1,
          offset: Float32Array.BYTES_PER_ELEMENT * 0,
          stride: Float32Array.BYTES_PER_ELEMENT * 1
        }
      },
      uniforms: {
        positions: () => s == null ? void 0 : s.currentPositionFbo,
        particleGreyoutStatus: () => s == null ? void 0 : s.greyoutStatusFbo,
        transform: () => r.transform,
        pointsTextureSize: () => r.pointsTextureSize,
        nodeSizeScale: () => i.nodeSizeScale,
        widthScale: () => i.linkWidthScale,
        useArrow: () => i.linkArrows,
        arrowSizeScale: () => i.linkArrowsSizeScale,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        ratio: () => i.pixelRatio,
        linkVisibilityDistanceRange: () => i.linkVisibilityDistanceRange,
        linkVisibilityMinTransparency: () => i.linkVisibilityMinTransparency,
        greyoutOpacity: () => i.linkGreyoutOpacity,
        scaleNodesOnZoom: () => i.scaleNodesOnZoom,
        curvedWeight: () => i.curvedLinkWeight,
        curvedLinkControlPointDistance: () => i.curvedLinkControlPointDistance,
        curvedLinkSegments: () => {
          var l;
          return i.curvedLinks ? (l = i.curvedLinkSegments) !== null && l !== void 0 ? l : Je.curvedLinkSegments : 1;
        }
      },
      cull: {
        enable: !0,
        face: "back"
      },
      blend: {
        enable: !0,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: !1,
        mask: !1
      },
      count: () => {
        var l, d;
        return (d = (l = this.curveLineGeometry) === null || l === void 0 ? void 0 : l.length) !== null && d !== void 0 ? d : 0;
      },
      instances: () => n.linksNumber,
      primitive: "triangle strip"
    });
  }
  draw() {
    var t;
    !this.colorBuffer || !this.widthBuffer || !this.curveLineBuffer || (t = this.drawCurveCommand) === null || t === void 0 || t.call(this);
  }
  updateColor() {
    const { reglInstance: t, config: i, data: r } = this, n = [];
    r.completeLinks.forEach((s) => {
      var a;
      const o = (a = Rg(s, i.linkColor)) !== null && a !== void 0 ? a : LT, c = ku(o);
      n.push(c);
    }), this.colorBuffer = t.buffer(n);
  }
  updateWidth() {
    const { reglInstance: t, config: i, data: r } = this, n = [];
    r.completeLinks.forEach((s) => {
      const a = Rg(s, i.linkWidth);
      n.push([a ?? FT]);
    }), this.widthBuffer = t.buffer(n);
  }
  updateCurveLineGeometry() {
    const { reglInstance: t, config: { curvedLinks: i, curvedLinkSegments: r } } = this;
    this.curveLineGeometry = n7(i ? r ?? Je.curvedLinkSegments : 1), this.curveLineBuffer = t.buffer(this.curveLineGeometry);
  }
  destroy() {
    t_(this.colorBuffer), t_(this.widthBuffer), t_(this.curveLineBuffer);
  }
}
function a7(e, t, i, r) {
  var n;
  if (i === 0)
    return;
  const s = new Float32Array(i * i * 4);
  for (let o = 0; o < e.nodes.length; ++o) {
    const c = e.getSortedIndexByInputIndex(o), l = e.nodes[o];
    if (l && c !== void 0) {
      const d = (n = Rg(l, r, o)) !== null && n !== void 0 ? n : DT, u = ku(d);
      s[c * 4 + 0] = u[0], s[c * 4 + 1] = u[1], s[c * 4 + 2] = u[2], s[c * 4 + 3] = u[3];
    }
  }
  const a = t.texture({
    data: s,
    width: i,
    height: i,
    type: "float"
  });
  return t.framebuffer({
    color: a,
    depth: !1,
    stencil: !1
  });
}
function o7(e, t, i) {
  if (i === 0)
    return;
  const r = new Float32Array(i * i * 4).fill(e ? 1 : 0);
  if (e)
    for (const s of e)
      r[s * 4] = 0;
  const n = t.texture({
    data: r,
    width: i,
    height: i,
    type: "float"
  });
  return t.framebuffer({
    color: n,
    depth: !1,
    stencil: !1
  });
}
var c7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec2 index;varying vec3 rgbColor;varying float alpha;const float smoothing=0.9;void main(){if(alpha==0.0){discard;}float r=0.0;float delta=0.0;vec2 cxy=2.0*gl_PointCoord-1.0;r=dot(cxy,cxy);float opacity=alpha*(1.0-smoothstep(smoothing,1.0,r));gl_FragColor=vec4(rgbColor,opacity);}`, l7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
attribute vec2 indexes;uniform sampler2D positions;uniform sampler2D particleColor;uniform sampler2D particleGreyoutStatus;uniform sampler2D particleSize;uniform float ratio;uniform mat3 transform;uniform float pointsTextureSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float greyoutOpacity;uniform bool scaleNodesOnZoom;varying vec2 index;varying vec3 rgbColor;varying float alpha;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return pSize;}void main(){index=indexes;vec4 pointPosition=texture2D(positions,(index+0.5)/pointsTextureSize);vec2 point=pointPosition.rg;vec2 p=2.0*point/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);vec4 pSize=texture2D(particleSize,(index+0.5)/pointsTextureSize);float size=pSize.r*sizeScale;vec4 pColor=texture2D(particleColor,(index+0.5)/pointsTextureSize);rgbColor=pColor.rgb;gl_PointSize=pointSize(size);alpha=pColor.a;vec4 greyoutStatus=texture2D(particleGreyoutStatus,(index+0.5)/pointsTextureSize);if(greyoutStatus.r>0.0){alpha*=greyoutOpacity;}}`, d7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D particleSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform mat3 transform;uniform vec2 selection[2];uniform bool scaleNodesOnZoom;uniform float maxPointSize;varying vec2 index;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}void main(){vec4 pointPosition=texture2D(position,index);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec4 pSize=texture2D(particleSize,index);float size=pSize.r*sizeScale;float left=2.0*(selection[0].x-0.5*pointSize(size))/screenSize.x-1.0;float right=2.0*(selection[1].x+0.5*pointSize(size))/screenSize.x-1.0;float top=2.0*(selection[0].y-0.5*pointSize(size))/screenSize.y-1.0;float bottom=2.0*(selection[1].y+0.5*pointSize(size))/screenSize.y-1.0;gl_FragColor=vec4(0.0,0.0,pointPosition.rg);if(final.x>=left&&final.x<=right&&final.y>=top&&final.y<=bottom){gl_FragColor.r=1.0;}}`, u7 = `precision mediump float;
#define GLSLIFY 1
uniform vec4 color;uniform float width;varying vec2 pos;varying float particleOpacity;const float smoothing=1.05;void main(){vec2 cxy=pos;float r=dot(cxy,cxy);float opacity=smoothstep(r,r*smoothing,1.0);float stroke=smoothstep(width,width*smoothing,r);gl_FragColor=vec4(color.rgb,opacity*stroke*color.a*particleOpacity);}`, h7 = `precision mediump float;
#define GLSLIFY 1
attribute vec2 quad;uniform sampler2D positions;uniform sampler2D particleColor;uniform sampler2D particleGreyoutStatus;uniform sampler2D particleSize;uniform mat3 transform;uniform float pointsTextureSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform bool scaleNodesOnZoom;uniform float pointIndex;uniform float maxPointSize;uniform vec4 color;uniform float greyoutOpacity;varying vec2 pos;varying float particleOpacity;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*transform[0][0];}else{pSize=size*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}const float relativeRingRadius=1.3;void main(){pos=quad;vec2 ij=vec2(mod(pointIndex,pointsTextureSize),floor(pointIndex/pointsTextureSize))+0.5;vec4 pointPosition=texture2D(positions,ij/pointsTextureSize);vec4 pSize=texture2D(particleSize,ij/pointsTextureSize);vec4 pColor=texture2D(particleColor,ij/pointsTextureSize);particleOpacity=pColor.a;vec4 greyoutStatus=texture2D(particleGreyoutStatus,ij/pointsTextureSize);if(greyoutStatus.r>0.0){particleOpacity*=greyoutOpacity;}float size=(pointSize(pSize.r*sizeScale)*relativeRingRadius)/transform[0][0];float radius=size*0.5;vec2 a=pointPosition.xy;vec2 b=pointPosition.xy+vec2(0.0,radius);vec2 xBasis=b-a;vec2 yBasis=normalize(vec2(-xBasis.y,xBasis.x));vec2 point=a+xBasis*quad.x+yBasis*radius*quad.y;vec2 p=2.0*point/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);gl_Position=vec4(final.rg,0,1);}`, f7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec4 rgba;void main(){gl_FragColor=rgba;}`, p7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float pointsTextureSize;uniform sampler2D particleSize;uniform float sizeScale;uniform float spaceSize;uniform vec2 screenSize;uniform float ratio;uniform mat3 transform;uniform vec2 mousePosition;uniform bool scaleNodesOnZoom;uniform float maxPointSize;attribute vec2 indexes;varying vec4 rgba;float pointSize(float size){float pSize;if(scaleNodesOnZoom){pSize=size*ratio*transform[0][0];}else{pSize=size*ratio*min(5.0,max(1.0,transform[0][0]*0.01));}return min(pSize,maxPointSize);}float euclideanDistance(float x1,float x2,float y1,float y2){return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}void main(){vec4 pointPosition=texture2D(position,(indexes+0.5)/pointsTextureSize);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec4 pSize=texture2D(particleSize,indexes/pointsTextureSize);float size=pSize.r*sizeScale;float pointRadius=0.5*pointSize(size);vec2 pointScreenPosition=(final.xy+1.0)*screenSize/2.0;rgba=vec4(0.0);gl_Position=vec4(0.5,0.5,0.0,1.0);if(euclideanDistance(pointScreenPosition.x,mousePosition.x,pointScreenPosition.y,mousePosition.y)<pointRadius){float index=indexes.g*pointsTextureSize+indexes.r;rgba=vec4(index,pSize.r,pointPosition.xy);gl_Position=vec4(-0.5,-0.5,0.0,1.0);}gl_PointSize=1.0;}`, m7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
varying vec4 rgba;void main(){gl_FragColor=rgba;}`, g7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform float pointsTextureSize;uniform float spaceSize;uniform vec2 screenSize;uniform mat3 transform;attribute vec2 indexes;varying vec4 rgba;void main(){vec4 pointPosition=texture2D(position,(indexes+0.5)/pointsTextureSize);vec2 p=2.0*pointPosition.rg/spaceSize-1.0;p*=spaceSize/screenSize;vec3 final=transform*vec3(p,1);vec2 pointScreenPosition=(final.xy+1.0)*screenSize/2.0;float index=indexes.g*pointsTextureSize+indexes.r;rgba=vec4(index,1.0,pointPosition.xy);float i=(pointScreenPosition.x+0.5)/screenSize.x;float j=(pointScreenPosition.y+0.5)/screenSize.y;gl_Position=vec4(2.0*vec2(i,j)-1.0,0.0,1.0);gl_PointSize=1.0;}`;
function y7(e, t, i) {
  const r = Rg(e, t, i);
  return r ?? NT;
}
function v7(e, t, i, r, n) {
  if (i === 0)
    return;
  const s = e.nodes.length, a = new Float32Array(i * i * 4);
  for (let c = 0; c < s; ++c) {
    const l = e.getSortedIndexByInputIndex(c), d = e.nodes[c];
    if (d && l !== void 0) {
      const u = y7(d, r, c);
      a[l * 4] = u, n[c] = u;
    }
  }
  const o = t.texture({
    data: a,
    width: i,
    height: i,
    type: "float"
  });
  return t.framebuffer({
    color: o,
    depth: !1,
    stencil: !1
  });
}
var _7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D velocity;uniform float friction;uniform float spaceSize;varying vec2 index;void main(){vec4 pointPosition=texture2D(position,index);vec4 pointVelocity=texture2D(velocity,index);pointVelocity.rg*=friction;pointPosition.rg+=pointVelocity.rg;pointPosition.r=clamp(pointPosition.r,0.0,spaceSize);pointPosition.g=clamp(pointPosition.g,0.0,spaceSize);gl_FragColor=pointPosition;}`;
function b7(e, t) {
  const i = Math.ceil(Math.sqrt(e.length));
  return t.framebuffer({
    shape: [i, i],
    depth: !1,
    stencil: !1,
    colorType: "float"
  });
}
function x7(e, t, i) {
  const r = Math.ceil(Math.sqrt(e.length));
  if (r === 0)
    return;
  const n = new Float32Array(r * r * 4).fill(-1);
  for (const [a, o] of e.entries())
    o !== void 0 && (n[a * 4] = o % t, n[a * 4 + 1] = Math.floor(o / t), n[a * 4 + 2] = 0, n[a * 4 + 3] = 0);
  const s = i.texture({
    data: n,
    width: r,
    height: r,
    type: "float"
  });
  return i.framebuffer({
    color: s,
    depth: !1,
    stencil: !1
  });
}
var w7 = `#ifdef GL_ES
precision highp float;
#define GLSLIFY 1
#endif
uniform sampler2D position;uniform sampler2D trackedIndices;uniform float pointsTextureSize;varying vec2 index;void main(){vec4 trackedPointIndicies=texture2D(trackedIndices,index);if(trackedPointIndicies.r<0.0)discard;vec4 pointPosition=texture2D(position,(trackedPointIndicies.rg+0.5)/pointsTextureSize);gl_FragColor=vec4(pointPosition.rg,1.0,1.0);}`;
class S7 extends zc {
  constructor() {
    super(...arguments), this.trackedPositionsById = /* @__PURE__ */ new Map();
  }
  create() {
    var t, i;
    const { reglInstance: r, store: n, data: s, config: a } = this, { pointsTextureSize: o, adjustedSpaceSize: c } = n;
    if (!o)
      return;
    const l = s.nodes.length, d = new Float32Array(o * o * 4);
    a.disableSimulation || this.rescaleInitialNodePositions();
    for (let u = 0; u < l; ++u) {
      const h = this.data.getSortedIndexByInputIndex(u), p = s.nodes[u];
      p && h !== void 0 && (d[h * 4 + 0] = (t = p.x) !== null && t !== void 0 ? t : c * n.getRandomFloat(0.495, 0.505), d[h * 4 + 1] = (i = p.y) !== null && i !== void 0 ? i : c * n.getRandomFloat(0.495, 0.505));
    }
    this.currentPositionFbo = r.framebuffer({
      color: r.texture({
        data: d,
        shape: [o, o, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.config.disableSimulation || (this.previousPositionFbo = r.framebuffer({
      color: r.texture({
        data: d,
        shape: [o, o, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.velocityFbo = r.framebuffer({
      color: r.texture({
        data: new Float32Array(o * o * 4).fill(0),
        shape: [o, o, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    })), this.selectedFbo = r.framebuffer({
      color: r.texture({
        data: d,
        shape: [o, o, 4],
        type: "float"
      }),
      depth: !1,
      stencil: !1
    }), this.hoveredFbo = r.framebuffer({
      shape: [2, 2],
      colorType: "float",
      depth: !1,
      stencil: !1
    }), this.updateSize(), this.updateColor(), this.updateGreyoutStatus(), this.updateSampledNodesGrid();
  }
  initPrograms() {
    const { reglInstance: t, config: i, store: r, data: n } = this;
    i.disableSimulation || (this.updatePositionCommand = t({
      frag: _7,
      vert: yn,
      framebuffer: () => this.currentPositionFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => this.previousPositionFbo,
        velocity: () => this.velocityFbo,
        friction: () => {
          var s;
          return (s = i.simulation) === null || s === void 0 ? void 0 : s.friction;
        },
        spaceSize: () => r.adjustedSpaceSize
      }
    })), this.drawCommand = t({
      frag: c7,
      vert: l7,
      primitive: "points",
      count: () => n.nodes.length,
      attributes: { indexes: lu(t, r.pointsTextureSize) },
      uniforms: {
        positions: () => this.currentPositionFbo,
        particleColor: () => this.colorFbo,
        particleGreyoutStatus: () => this.greyoutStatusFbo,
        particleSize: () => this.sizeFbo,
        ratio: () => i.pixelRatio,
        sizeScale: () => i.nodeSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transform: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        greyoutOpacity: () => i.nodeGreyoutOpacity,
        scaleNodesOnZoom: () => i.scaleNodesOnZoom
      },
      blend: {
        enable: !0,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: !1,
        mask: !1
      }
    }), this.findPointsOnAreaSelectionCommand = t({
      frag: d7,
      vert: yn,
      framebuffer: () => this.selectedFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => this.currentPositionFbo,
        particleSize: () => this.sizeFbo,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        sizeScale: () => i.nodeSizeScale,
        transform: () => r.transform,
        ratio: () => i.pixelRatio,
        "selection[0]": () => r.selectedArea[0],
        "selection[1]": () => r.selectedArea[1],
        scaleNodesOnZoom: () => i.scaleNodesOnZoom,
        maxPointSize: () => r.maxPointSize
      }
    }), this.clearHoveredFboCommand = t({
      frag: Cu,
      vert: yn,
      framebuffer: this.hoveredFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) }
    }), this.findHoveredPointCommand = t({
      frag: f7,
      vert: p7,
      primitive: "points",
      count: () => n.nodes.length,
      framebuffer: () => this.hoveredFbo,
      attributes: { indexes: lu(t, r.pointsTextureSize) },
      uniforms: {
        position: () => this.currentPositionFbo,
        particleSize: () => this.sizeFbo,
        ratio: () => i.pixelRatio,
        sizeScale: () => i.nodeSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transform: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        scaleNodesOnZoom: () => i.scaleNodesOnZoom,
        mousePosition: () => r.screenMousePosition,
        maxPointSize: () => r.maxPointSize
      },
      depth: {
        enable: !1,
        mask: !1
      }
    }), this.clearSampledNodesFboCommand = t({
      frag: Cu,
      vert: yn,
      framebuffer: () => this.sampledNodesFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) }
    }), this.fillSampledNodesFboCommand = t({
      frag: m7,
      vert: g7,
      primitive: "points",
      count: () => n.nodes.length,
      framebuffer: () => this.sampledNodesFbo,
      attributes: { indexes: lu(t, r.pointsTextureSize) },
      uniforms: {
        position: () => this.currentPositionFbo,
        pointsTextureSize: () => r.pointsTextureSize,
        transform: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize
      },
      depth: {
        enable: !1,
        mask: !1
      }
    }), this.drawHighlightedCommand = t({
      frag: u7,
      vert: h7,
      attributes: { quad: ln(t) },
      primitive: "triangle strip",
      count: 4,
      uniforms: {
        color: t.prop("color"),
        width: t.prop("width"),
        pointIndex: t.prop("pointIndex"),
        positions: () => this.currentPositionFbo,
        particleColor: () => this.colorFbo,
        particleSize: () => this.sizeFbo,
        sizeScale: () => i.nodeSizeScale,
        pointsTextureSize: () => r.pointsTextureSize,
        transform: () => r.transform,
        spaceSize: () => r.adjustedSpaceSize,
        screenSize: () => r.screenSize,
        scaleNodesOnZoom: () => i.scaleNodesOnZoom,
        maxPointSize: () => r.maxPointSize,
        particleGreyoutStatus: () => this.greyoutStatusFbo,
        greyoutOpacity: () => i.nodeGreyoutOpacity
      },
      blend: {
        enable: !0,
        func: {
          dstRGB: "one minus src alpha",
          srcRGB: "src alpha",
          dstAlpha: "one minus src alpha",
          srcAlpha: "one"
        },
        equation: {
          rgb: "add",
          alpha: "add"
        }
      },
      depth: {
        enable: !1,
        mask: !1
      }
    }), this.trackPointsCommand = t({
      frag: w7,
      vert: yn,
      framebuffer: () => this.trackedPositionsFbo,
      primitive: "triangle strip",
      count: 4,
      attributes: { quad: ln(t) },
      uniforms: {
        position: () => this.currentPositionFbo,
        trackedIndices: () => this.trackedIndicesFbo,
        pointsTextureSize: () => r.pointsTextureSize
      }
    });
  }
  updateColor() {
    const { reglInstance: t, config: i, store: { pointsTextureSize: r }, data: n } = this;
    r && (this.colorFbo = a7(n, t, r, i.nodeColor));
  }
  updateGreyoutStatus() {
    const { reglInstance: t, store: i } = this;
    this.greyoutStatusFbo = o7(i.selectedIndices, t, i.pointsTextureSize);
  }
  updateSize() {
    const { reglInstance: t, config: i, store: { pointsTextureSize: r }, data: n } = this;
    r && (this.sizeByIndex = new Float32Array(n.nodes.length), this.sizeFbo = v7(n, t, r, i.nodeSize, this.sizeByIndex));
  }
  updateSampledNodesGrid() {
    const { store: { screenSize: t }, config: { nodeSamplingDistance: i }, reglInstance: r } = this, n = i ?? Math.min(...t) / 2, s = Math.ceil(t[0] / n), a = Math.ceil(t[1] / n);
    Ir(this.sampledNodesFbo), this.sampledNodesFbo = r.framebuffer({
      shape: [s, a],
      depth: !1,
      stencil: !1,
      colorType: "float"
    });
  }
  trackPoints() {
    var t;
    !this.trackedIndicesFbo || !this.trackedPositionsFbo || (t = this.trackPointsCommand) === null || t === void 0 || t.call(this);
  }
  draw() {
    var t, i, r;
    const { config: { renderHoveredNodeRing: n, renderHighlightedNodeRing: s }, store: a } = this;
    (t = this.drawCommand) === null || t === void 0 || t.call(this), (n ?? s) && a.hoveredNode && ((i = this.drawHighlightedCommand) === null || i === void 0 || i.call(this, {
      width: 0.85,
      color: a.hoveredNodeRingColor,
      pointIndex: a.hoveredNode.index
    })), a.focusedNode && ((r = this.drawHighlightedCommand) === null || r === void 0 || r.call(this, {
      width: 0.75,
      color: a.focusedNodeRingColor,
      pointIndex: a.focusedNode.index
    }));
  }
  updatePosition() {
    var t;
    (t = this.updatePositionCommand) === null || t === void 0 || t.call(this), this.swapFbo();
  }
  findPointsOnAreaSelection() {
    var t;
    (t = this.findPointsOnAreaSelectionCommand) === null || t === void 0 || t.call(this);
  }
  findHoveredPoint() {
    var t, i;
    (t = this.clearHoveredFboCommand) === null || t === void 0 || t.call(this), (i = this.findHoveredPointCommand) === null || i === void 0 || i.call(this);
  }
  getNodeRadiusByIndex(t) {
    var i;
    return (i = this.sizeByIndex) === null || i === void 0 ? void 0 : i[t];
  }
  trackNodesByIds(t) {
    this.trackedIds = t.length ? t : void 0, this.trackedPositionsById.clear();
    const i = t.map((r) => this.data.getSortedIndexById(r)).filter((r) => r !== void 0);
    Ir(this.trackedIndicesFbo), this.trackedIndicesFbo = void 0, Ir(this.trackedPositionsFbo), this.trackedPositionsFbo = void 0, i.length && (this.trackedIndicesFbo = x7(i, this.store.pointsTextureSize, this.reglInstance), this.trackedPositionsFbo = b7(i, this.reglInstance)), this.trackPoints();
  }
  getTrackedPositions() {
    if (!this.trackedIds)
      return this.trackedPositionsById;
    const t = hc(this.reglInstance, this.trackedPositionsFbo);
    return this.trackedIds.forEach((i, r) => {
      const n = t[r * 4], s = t[r * 4 + 1];
      n !== void 0 && s !== void 0 && this.trackedPositionsById.set(i, [n, s]);
    }), this.trackedPositionsById;
  }
  getSampledNodePositionsMap() {
    var t, i, r;
    const n = /* @__PURE__ */ new Map();
    if (!this.sampledNodesFbo)
      return n;
    (t = this.clearSampledNodesFboCommand) === null || t === void 0 || t.call(this), (i = this.fillSampledNodesFboCommand) === null || i === void 0 || i.call(this);
    const s = hc(this.reglInstance, this.sampledNodesFbo);
    for (let a = 0; a < s.length / 4; a++) {
      const o = s[a * 4], c = !!s[a * 4 + 1], l = s[a * 4 + 2], d = s[a * 4 + 3];
      if (c && o !== void 0 && l !== void 0 && d !== void 0) {
        const u = this.data.getInputIndexBySortedIndex(o);
        if (u !== void 0) {
          const h = (r = this.data.getNodeByIndex(u)) === null || r === void 0 ? void 0 : r.id;
          h !== void 0 && n.set(h, [l, d]);
        }
      }
    }
    return n;
  }
  destroy() {
    Ir(this.currentPositionFbo), Ir(this.previousPositionFbo), Ir(this.velocityFbo), Ir(this.selectedFbo), Ir(this.colorFbo), Ir(this.sizeFbo), Ir(this.greyoutStatusFbo), Ir(this.hoveredFbo), Ir(this.trackedIndicesFbo), Ir(this.trackedPositionsFbo);
  }
  swapFbo() {
    const t = this.previousPositionFbo;
    this.previousPositionFbo = this.currentPositionFbo, this.currentPositionFbo = t;
  }
  rescaleInitialNodePositions() {
    const { nodes: t } = this.data, { spaceSize: i } = this.config;
    if (t.length === 0)
      return;
    const r = t.map((C) => C.x).filter((C) => C !== void 0);
    if (r.length === 0)
      return;
    const n = t.map((C) => C.y).filter((C) => C !== void 0);
    if (n.length === 0)
      return;
    const s = Math.min(...r), a = Math.max(...r), o = Math.min(...n), c = Math.max(...n), l = a - s, d = c - o, u = Math.max(l, d), h = (u - l) / 2, p = (u - d) / 2, m = Of().range([0, i ?? Je.spaceSize]).domain([s - h, a + h]), w = Of().range([0, i ?? Je.spaceSize]).domain([o - p, c + p]);
    t.forEach((C) => {
      C.x = m(C.x), C.y = w(C.y);
    });
  }
}
const q_ = 1e-3, Z_ = 64;
class I7 {
  constructor() {
    this.pointsTextureSize = 0, this.linksTextureSize = 0, this.alpha = 1, this.transform = F8(), this.backgroundColor = [0, 0, 0, 0], this.screenSize = [0, 0], this.mousePosition = [0, 0], this.screenMousePosition = [0, 0], this.selectedArea = [[0, 0], [0, 0]], this.isSimulationRunning = !1, this.simulationProgress = 0, this.selectedIndices = null, this.maxPointSize = Z_, this.hoveredNode = void 0, this.focusedNode = void 0, this.adjustedSpaceSize = Je.spaceSize, this.hoveredNodeRingColor = [1, 1, 1, NP], this.focusedNodeRingColor = [1, 1, 1, LP], this.alphaTarget = 0, this.scaleNodeX = Of(), this.scaleNodeY = Of(), this.random = new OT(), this.alphaDecay = (t) => 1 - Math.pow(q_, 1 / t);
  }
  addRandomSeed(t) {
    this.random = this.random.clone(t);
  }
  getRandomFloat(t, i) {
    return this.random.float(t, i);
  }
  /**
   * If the config parameter `spaceSize` exceeds the limits of WebGL,
   * it reduces the space size without changing the config parameter.
   */
  adjustSpaceSize(t, i) {
    t >= i ? (this.adjustedSpaceSize = i / 2, console.warn(`The \`spaceSize\` has been reduced to ${this.adjustedSpaceSize} due to WebGL limits`)) : this.adjustedSpaceSize = t;
  }
  updateScreenSize(t, i) {
    const { adjustedSpaceSize: r } = this;
    this.screenSize = [t, i], this.scaleNodeX.domain([0, r]).range([(t - r) / 2, (t + r) / 2]), this.scaleNodeY.domain([r, 0]).range([(i - r) / 2, (i + r) / 2]);
  }
  scaleX(t) {
    return this.scaleNodeX(t);
  }
  scaleY(t) {
    return this.scaleNodeY(t);
  }
  setHoveredNodeRingColor(t) {
    const i = ku(t);
    this.hoveredNodeRingColor[0] = i[0], this.hoveredNodeRingColor[1] = i[1], this.hoveredNodeRingColor[2] = i[2];
  }
  setFocusedNodeRingColor(t) {
    const i = ku(t);
    this.focusedNodeRingColor[0] = i[0], this.focusedNodeRingColor[1] = i[1], this.focusedNodeRingColor[2] = i[2];
  }
  setFocusedNode(t, i) {
    t && i !== void 0 ? this.focusedNode = { node: t, index: i } : this.focusedNode = void 0;
  }
  addAlpha(t) {
    return (this.alphaTarget - this.alpha) * this.alphaDecay(t);
  }
}
class A7 {
  constructor(t, i) {
    this.eventTransform = _f, this.behavior = kP().scaleExtent([1e-3, 1 / 0]).on("start", (r) => {
      var n, s, a;
      this.isRunning = !0;
      const o = !!r.sourceEvent;
      (a = (s = (n = this.config) === null || n === void 0 ? void 0 : n.events) === null || s === void 0 ? void 0 : s.onZoomStart) === null || a === void 0 || a.call(s, r, o);
    }).on("zoom", (r) => {
      var n, s, a;
      this.eventTransform = r.transform;
      const { eventTransform: { x: o, y: c, k: l }, store: { transform: d, screenSize: u } } = this, h = u[0], p = u[1];
      B8(d, h, p), tI(d, d, [o, c]), Jv(d, d, [l, l]), tI(d, d, [h / 2, p / 2]), Jv(d, d, [h / 2, p / 2]), Jv(d, d, [1, -1]);
      const m = !!r.sourceEvent;
      (a = (s = (n = this.config) === null || n === void 0 ? void 0 : n.events) === null || s === void 0 ? void 0 : s.onZoom) === null || a === void 0 || a.call(s, r, m);
    }).on("end", (r) => {
      var n, s, a;
      this.isRunning = !1;
      const o = !!r.sourceEvent;
      (a = (s = (n = this.config) === null || n === void 0 ? void 0 : n.events) === null || s === void 0 ? void 0 : s.onZoomEnd) === null || a === void 0 || a.call(s, r, o);
    }), this.isRunning = !1, this.store = t, this.config = i;
  }
  getTransform(t, i, r = this.store.maxPointSize / 2) {
    if (t.length === 0)
      return this.eventTransform;
    const { store: { screenSize: n } } = this, s = n[0], a = n[1], o = B2(t.map((F) => F[0])), c = B2(t.map((F) => F[1]));
    o[0] = this.store.scaleX(o[0] - r), o[1] = this.store.scaleX(o[1] + r), c[0] = this.store.scaleY(c[0] - r), c[1] = this.store.scaleY(c[1] + r);
    const l = s / (o[1] - o[0]), d = a / (c[0] - c[1]), u = RP(i ?? Math.min(l, d), ...this.behavior.scaleExtent()), h = (o[1] + o[0]) / 2, p = (c[1] + c[0]) / 2, m = s / 2 - h * u, w = a / 2 - p * u;
    return _f.translate(m, w).scale(u);
  }
  getDistanceToPoint(t) {
    const { x: i, y: r, k: n } = this.eventTransform, s = this.getTransform([t], n), a = i - s.x, o = r - s.y;
    return Math.sqrt(a * a + o * o);
  }
  getMiddlePointTransform(t) {
    const { store: { screenSize: i }, eventTransform: { x: r, y: n, k: s } } = this, a = i[0], o = i[1], c = (a / 2 - r) / s, l = (o / 2 - n) / s, d = this.store.scaleX(t[0]), u = this.store.scaleY(t[1]), h = (c + d) / 2, p = (l + u) / 2, m = 1, w = a / 2 - h * m, C = o / 2 - p * m;
    return _f.translate(w, C).scale(m);
  }
  convertSpaceToScreenPosition(t) {
    const i = this.eventTransform.applyX(this.store.scaleX(t[0])), r = this.eventTransform.applyY(this.store.scaleY(t[1]));
    return [i, r];
  }
  convertSpaceToScreenRadius(t) {
    const { config: { scaleNodesOnZoom: i }, store: { maxPointSize: r }, eventTransform: { k: n } } = this;
    let s = t * 2;
    return i ? s *= n : s *= Math.min(5, Math.max(1, n * 0.01)), Math.min(s, r) / 2;
  }
}
class T7 {
  constructor(t, i) {
    var r;
    this.config = new MP(), this.graph = new e7(), this.requestAnimationFrameId = 0, this.isRightClickMouse = !1, this.store = new I7(), this.zoomInstance = new A7(this.store, this.config), this.hasParticleSystemDestroyed = !1, this._findHoveredPointExecutionCount = 0, this._isMouseOnCanvas = !1, this._isFirstDataAfterInit = !0, i && this.config.init(i);
    const n = t.clientWidth, s = t.clientHeight;
    t.width = n * this.config.pixelRatio, t.height = s * this.config.pixelRatio, t.style.width === "" && t.style.height === "" && wa(t).style("width", "100%").style("height", "100%"), this.canvas = t, this.canvasD3Selection = wa(t), this.canvasD3Selection.on("mouseenter.cosmos", () => {
      this._isMouseOnCanvas = !0;
    }).on("mouseleave.cosmos", () => {
      this._isMouseOnCanvas = !1;
    }), this.zoomInstance.behavior.on("start.detect", (a) => {
      this.currentEvent = a;
    }).on("zoom.detect", (a) => {
      !!a.sourceEvent && this.updateMousePosition(a.sourceEvent), this.currentEvent = a;
    }).on("end.detect", (a) => {
      this.currentEvent = a;
    }), this.canvasD3Selection.call(this.zoomInstance.behavior).on("click", this.onClick.bind(this)).on("mousemove", this.onMouseMove.bind(this)).on("contextmenu", this.onRightClickMouse.bind(this)), this.config.disableZoom && this.disableZoom(), this.setZoomLevel(this.config.initialZoomLevel), this.reglInstance = jM({
      canvas: this.canvas,
      attributes: {
        antialias: !1,
        preserveDrawingBuffer: !0,
        premultipliedAlpha: !1,
        alpha: !1
      },
      extensions: ["OES_texture_float", "ANGLE_instanced_arrays"]
    }), this.store.maxPointSize = ((r = this.reglInstance.limits.pointSizeDims[1]) !== null && r !== void 0 ? r : Z_) / this.config.pixelRatio, this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.store.updateScreenSize(n, s), this.points = new S7(this.reglInstance, this.config, this.store, this.graph), this.lines = new s7(this.reglInstance, this.config, this.store, this.graph, this.points), this.config.disableSimulation || (this.forceGravity = new jP(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceCenter = new UP(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceManyBody = this.config.useQuadtree ? new ZP(this.reglInstance, this.config, this.store, this.graph, this.points) : new YP(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkIncoming = new oI(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceLinkOutgoing = new oI(this.reglInstance, this.config, this.store, this.graph, this.points), this.forceMouse = new KP(this.reglInstance, this.config, this.store, this.graph, this.points)), this.store.backgroundColor = ku(this.config.backgroundColor), this.config.highlightedNodeRingColor ? (this.store.setHoveredNodeRingColor(this.config.highlightedNodeRingColor), this.store.setFocusedNodeRingColor(this.config.highlightedNodeRingColor)) : (this.config.hoveredNodeRingColor && this.store.setHoveredNodeRingColor(this.config.hoveredNodeRingColor), this.config.focusedNodeRingColor && this.store.setFocusedNodeRingColor(this.config.focusedNodeRingColor)), this.config.showFPSMonitor && (this.fpsMonitor = new cI(this.canvas)), this.config.randomSeed !== void 0 && this.store.addRandomSeed(this.config.randomSeed);
  }
  get progress() {
    return this.store.simulationProgress;
  }
  /**
   * A value that gives information about the running simulation status.
   */
  get isSimulationRunning() {
    return this.store.isSimulationRunning;
  }
  /**
   * The maximum point size.
   * This value is the maximum size of the `gl.POINTS` primitive that WebGL can render on the user's hardware.
   */
  get maxPointSize() {
    return this.store.maxPointSize;
  }
  /**
   * Set or update Cosmos configuration. The changes will be applied in real time.
   * @param config Cosmos configuration object.
   */
  setConfig(t) {
    var i, r;
    const n = { ...this.config };
    this.config.init(t), n.linkColor !== this.config.linkColor && this.lines.updateColor(), n.nodeColor !== this.config.nodeColor && this.points.updateColor(), n.nodeSize !== this.config.nodeSize && this.points.updateSize(), n.linkWidth !== this.config.linkWidth && this.lines.updateWidth(), (n.curvedLinkSegments !== this.config.curvedLinkSegments || n.curvedLinks !== this.config.curvedLinks) && this.lines.updateCurveLineGeometry(), n.backgroundColor !== this.config.backgroundColor && (this.store.backgroundColor = ku(this.config.backgroundColor)), n.highlightedNodeRingColor !== this.config.highlightedNodeRingColor && (this.store.setHoveredNodeRingColor(this.config.highlightedNodeRingColor), this.store.setFocusedNodeRingColor(this.config.highlightedNodeRingColor)), n.hoveredNodeRingColor !== this.config.hoveredNodeRingColor && this.store.setHoveredNodeRingColor(this.config.hoveredNodeRingColor), n.focusedNodeRingColor !== this.config.focusedNodeRingColor && this.store.setFocusedNodeRingColor(this.config.focusedNodeRingColor), (n.spaceSize !== this.config.spaceSize || n.simulation.repulsionQuadtreeLevels !== this.config.simulation.repulsionQuadtreeLevels) && (this.store.adjustSpaceSize(this.config.spaceSize, this.reglInstance.limits.maxTextureSize), this.resizeCanvas(!0), this.update(this.store.isSimulationRunning)), n.showFPSMonitor !== this.config.showFPSMonitor && (this.config.showFPSMonitor ? this.fpsMonitor = new cI(this.canvas) : ((i = this.fpsMonitor) === null || i === void 0 || i.destroy(), this.fpsMonitor = void 0)), n.pixelRatio !== this.config.pixelRatio && (this.store.maxPointSize = ((r = this.reglInstance.limits.pointSizeDims[1]) !== null && r !== void 0 ? r : Z_) / this.config.pixelRatio), n.disableZoom !== this.config.disableZoom && (this.config.disableZoom ? this.disableZoom() : this.enableZoom());
  }
  /**
   * Pass data to Cosmos.
   * @param nodes Array of nodes.
   * @param links Array of links.
   * @param runSimulation When set to `false`, the simulation won't be started automatically (`true` by default).
   */
  setData(t, i, r = !0) {
    const { fitViewOnInit: n, fitViewDelay: s, fitViewByNodesInRect: a } = this.config;
    if (!t.length && !i.length) {
      this.destroyParticleSystem(), this.reglInstance.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      });
      return;
    }
    this.graph.setData(t, i), this._isFirstDataAfterInit && n && (this._fitViewOnInitTimeoutID = window.setTimeout(() => {
      a ? this.setZoomTransformByNodePositions(a, void 0, void 0, 0) : this.fitView();
    }, s)), this._isFirstDataAfterInit = !1, this.update(r);
  }
  /**
   * Center the view on a node and zoom in, by node id.
   * @param id Id of the node.
   * @param duration Duration of the animation transition in milliseconds (`700` by default).
   * @param scale Scale value to zoom in or out (`3` by default).
   * @param canZoomOut Set to `false` to prevent zooming out from the node (`true` by default).
   */
  zoomToNodeById(t, i = 700, r = sI, n = !0) {
    const s = this.graph.getNodeById(t);
    s && this.zoomToNode(s, i, r, n);
  }
  /**
   * Center the view on a node and zoom in, by node index.
   * @param index The index of the node in the array of nodes.
   * @param duration Duration of the animation transition in milliseconds (`700` by default).
   * @param scale Scale value to zoom in or out (`3` by default).
   * @param canZoomOut Set to `false` to prevent zooming out from the node (`true` by default).
   */
  zoomToNodeByIndex(t, i = 700, r = sI, n = !0) {
    const s = this.graph.getNodeByIndex(t);
    s && this.zoomToNode(s, i, r, n);
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  zoom(t, i = 0) {
    this.setZoomLevel(t, i);
  }
  /**
   * Zoom the view in or out to the specified zoom level.
   * @param value Zoom level
   * @param duration Duration of the zoom in/out transition.
   */
  setZoomLevel(t, i = 0) {
    this.canvasD3Selection.transition().duration(i).call(this.zoomInstance.behavior.scaleTo, t);
  }
  /**
   * Get zoom level.
   * @returns Zoom level value of the view.
   */
  getZoomLevel() {
    return this.zoomInstance.eventTransform.k;
  }
  /**
   * Get current X and Y coordinates of the nodes.
   * @returns Object where keys are the ids of the nodes and values are corresponding `{ x: number; y: number }` objects.
   */
  getNodePositions() {
    if (this.hasParticleSystemDestroyed)
      return {};
    const t = hc(this.reglInstance, this.points.currentPositionFbo);
    return this.graph.nodes.reduce((i, r) => {
      const n = this.graph.getSortedIndexById(r.id), s = t[n * 4 + 0], a = t[n * 4 + 1];
      return s !== void 0 && a !== void 0 && (i[r.id] = {
        x: s,
        y: a
      }), i;
    }, {});
  }
  /**
   * Get current X and Y coordinates of the nodes.
   * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getNodePositionsMap() {
    const t = /* @__PURE__ */ new Map();
    if (this.hasParticleSystemDestroyed)
      return t;
    const i = hc(this.reglInstance, this.points.currentPositionFbo);
    return this.graph.nodes.reduce((r, n) => {
      const s = this.graph.getSortedIndexById(n.id), a = i[s * 4 + 0], o = i[s * 4 + 1];
      return a !== void 0 && o !== void 0 && r.set(n.id, [a, o]), r;
    }, t);
  }
  /**
   * Get current X and Y coordinates of the nodes.
   * @returns Array of `[x: number, y: number]` arrays.
   */
  getNodePositionsArray() {
    const t = [];
    if (this.hasParticleSystemDestroyed)
      return [];
    const i = hc(this.reglInstance, this.points.currentPositionFbo);
    t.length = this.graph.nodes.length;
    for (let r = 0; r < this.graph.nodes.length; r += 1) {
      const n = this.graph.getSortedIndexByInputIndex(r), s = i[n * 4 + 0], a = i[n * 4 + 1];
      s !== void 0 && a !== void 0 && (t[r] = [s, a]);
    }
    return t;
  }
  /**
   * Center and zoom in/out the view to fit all nodes in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   */
  fitView(t = 250) {
    this.setZoomTransformByNodePositions(this.getNodePositionsArray(), t);
  }
  /**
   * Center and zoom in/out the view to fit nodes by their ids in the scene.
   * @param duration Duration of the center and zoom in/out animation in milliseconds (`250` by default).
   */
  fitViewByNodeIds(t, i = 250) {
    const r = this.getNodePositionsMap(), n = t.map((s) => r.get(s)).filter((s) => s !== void 0);
    this.setZoomTransformByNodePositions(n, i);
  }
  /** Select nodes inside a rectangular area.
   * @param selection - Array of two corner points `[[left, top], [right, bottom]]`.
   * The `left` and `right` coordinates should be from 0 to the width of the canvas.
   * The `top` and `bottom` coordinates should be from 0 to the height of the canvas. */
  selectNodesInRange(t) {
    if (t) {
      const i = this.store.screenSize[1];
      this.store.selectedArea = [[t[0][0], i - t[1][1]], [t[1][0], i - t[0][1]]], this.points.findPointsOnAreaSelection();
      const r = hc(this.reglInstance, this.points.selectedFbo);
      this.store.selectedIndices = r.map((n, s) => s % 4 === 0 && n !== 0 ? s / 4 : -1).filter((n) => n !== -1);
    } else
      this.store.selectedIndices = null;
    this.points.updateGreyoutStatus();
  }
  /**
   * Select a node by id. If you want the adjacent nodes to get selected too, provide `true` as the second argument.
   * @param id Id of the node.
   * @param selectAdjacentNodes When set to `true`, selects adjacent nodes (`false` by default).
   */
  selectNodeById(t, i = !1) {
    var r;
    if (i) {
      const n = (r = this.graph.getAdjacentNodes(t)) !== null && r !== void 0 ? r : [];
      this.selectNodesByIds([t, ...n.map((s) => s.id)]);
    } else
      this.selectNodesByIds([t]);
  }
  /**
   * Select a node by index. If you want the adjacent nodes to get selected too, provide `true` as the second argument.
   * @param index The index of the node in the array of nodes.
   * @param selectAdjacentNodes When set to `true`, selects adjacent nodes (`false` by default).
   */
  selectNodeByIndex(t, i = !1) {
    const r = this.graph.getNodeByIndex(t);
    r && this.selectNodeById(r.id, i);
  }
  /**
   * Select multiples nodes by their ids.
   * @param ids Array of nodes ids.
   */
  selectNodesByIds(t) {
    this.selectNodesByIndices(t == null ? void 0 : t.map((i) => this.graph.getSortedIndexById(i)));
  }
  /**
   * Select multiples nodes by their indices.
   * @param indices Array of nodes indices.
   */
  selectNodesByIndices(t) {
    t ? t.length === 0 ? this.store.selectedIndices = new Float32Array() : this.store.selectedIndices = new Float32Array(t.filter((i) => i !== void 0)) : this.store.selectedIndices = null, this.points.updateGreyoutStatus();
  }
  /**
   * Unselect all nodes.
   */
  unselectNodes() {
    this.store.selectedIndices = null, this.points.updateGreyoutStatus();
  }
  /**
   * Get nodes that are currently selected.
   * @returns Array of selected nodes.
   */
  getSelectedNodes() {
    const { selectedIndices: t } = this.store;
    if (!t)
      return null;
    const i = new Array(t.length);
    for (const [r, n] of t.entries())
      if (n !== void 0) {
        const s = this.graph.getInputIndexBySortedIndex(n);
        s !== void 0 && (i[r] = this.graph.nodes[s]);
      }
    return i;
  }
  /**
   * Get nodes that are adjacent to a specific node by its id.
   * @param id Id of the node.
   * @returns Array of adjacent nodes.
   */
  getAdjacentNodes(t) {
    return this.graph.getAdjacentNodes(t);
  }
  /**
   * Set focus on a node by id. A ring will be highlighted around the focused node.
   * If no id is specified, the focus will be reset.
   * @param id Id of the node.
   */
  setFocusedNodeById(t) {
    t === void 0 ? this.store.setFocusedNode() : this.store.setFocusedNode(this.graph.getNodeById(t), this.graph.getSortedIndexById(t));
  }
  /**
   * Set focus on a node by index. A ring will be highlighted around the focused node.
   * If no index is specified, the focus will be reset.
   * @param index The index of the node in the array of nodes.
   */
  setFocusedNodeByIndex(t) {
    t === void 0 ? this.store.setFocusedNode() : this.store.setFocusedNode(this.graph.getNodeByIndex(t), t);
  }
  /**
   * Converts the X and Y node coordinates from the space coordinate system to the screen coordinate system.
   * @param spacePosition Array of x and y coordinates in the space coordinate system.
   * @returns Array of x and y coordinates in the screen coordinate system.
   */
  spaceToScreenPosition(t) {
    return this.zoomInstance.convertSpaceToScreenPosition(t);
  }
  /**
   * Converts the node radius value from the space coordinate system to the screen coordinate system.
   * @param spaceRadius Radius of Node in the space coordinate system.
   * @returns Radius of Node in the screen coordinate system.
   */
  spaceToScreenRadius(t) {
    return this.zoomInstance.convertSpaceToScreenRadius(t);
  }
  /**
   * Get node radius by its index.
   * @param index Index of the node.
   * @returns Radius of the node.
   */
  getNodeRadiusByIndex(t) {
    return this.points.getNodeRadiusByIndex(t);
  }
  /**
   * Get node radius by its id.
   * @param id Id of the node.
   * @returns Radius of the node.
   */
  getNodeRadiusById(t) {
    const i = this.graph.getInputIndexById(t);
    if (i !== void 0)
      return this.points.getNodeRadiusByIndex(i);
  }
  /**
   * Track multiple node positions by their ids on each Cosmos tick.
   * @param ids Array of nodes ids.
   */
  trackNodePositionsByIds(t) {
    this.points.trackNodesByIds(t);
  }
  /**
   * Track multiple node positions by their indices on each Cosmos tick.
   * @param ids Array of nodes indices.
   */
  trackNodePositionsByIndices(t) {
    this.points.trackNodesByIds(t.map((i) => this.graph.getNodeByIndex(i)).filter((i) => i !== void 0).map((i) => i.id));
  }
  /**
   * Get current X and Y coordinates of the tracked nodes.
   * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getTrackedNodePositionsMap() {
    return this.points.getTrackedPositions();
  }
  /**
   * For the nodes that are currently visible on the screen, get a sample of node ids with their coordinates.
   * The resulting number of nodes will depend on the `nodeSamplingDistance` configuration property,
   * and the sampled nodes will be evenly distributed.
   * @returns A Map object where keys are the ids of the nodes and values are their corresponding X and Y coordinates in the [number, number] format.
   */
  getSampledNodePositionsMap() {
    return this.points.getSampledNodePositionsMap();
  }
  /**
   * Start the simulation.
   * @param alpha Value from 0 to 1. The higher the value, the more initial energy the simulation will get.
   */
  start(t = 1) {
    var i, r;
    this.graph.nodes.length && (this.store.isSimulationRunning = !0, this.store.alpha = t, this.store.simulationProgress = 0, (r = (i = this.config.simulation).onStart) === null || r === void 0 || r.call(i), this.stopFrames(), this.frame());
  }
  /**
   * Pause the simulation.
   */
  pause() {
    var t, i;
    this.store.isSimulationRunning = !1, (i = (t = this.config.simulation).onPause) === null || i === void 0 || i.call(t);
  }
  /**
   * Restart the simulation.
   */
  restart() {
    var t, i;
    this.store.isSimulationRunning = !0, (i = (t = this.config.simulation).onRestart) === null || i === void 0 || i.call(t);
  }
  /**
   * Render only one frame of the simulation (stops the simulation if it was running).
   */
  step() {
    this.store.isSimulationRunning = !1, this.stopFrames(), this.frame();
  }
  /**
   * Destroy this Cosmos instance.
   */
  destroy() {
    var t, i;
    window.clearTimeout(this._fitViewOnInitTimeoutID), this.stopFrames(), this.destroyParticleSystem(), (t = this.fpsMonitor) === null || t === void 0 || t.destroy(), (i = document.getElementById("gl-bench-style")) === null || i === void 0 || i.remove();
  }
  /**
   * Create new Cosmos instance.
   */
  create() {
    var t, i, r, n;
    this.points.create(), this.lines.create(), (t = this.forceManyBody) === null || t === void 0 || t.create(), (i = this.forceLinkIncoming) === null || i === void 0 || i.create(Nf.INCOMING), (r = this.forceLinkOutgoing) === null || r === void 0 || r.create(Nf.OUTGOING), (n = this.forceCenter) === null || n === void 0 || n.create(), this.hasParticleSystemDestroyed = !1;
  }
  destroyParticleSystem() {
    var t, i, r, n;
    this.hasParticleSystemDestroyed || (this.points.destroy(), this.lines.destroy(), (t = this.forceCenter) === null || t === void 0 || t.destroy(), (i = this.forceLinkIncoming) === null || i === void 0 || i.destroy(), (r = this.forceLinkOutgoing) === null || r === void 0 || r.destroy(), (n = this.forceManyBody) === null || n === void 0 || n.destroy(), this.reglInstance.destroy(), this.hasParticleSystemDestroyed = !0);
  }
  update(t) {
    const { graph: i } = this;
    this.store.pointsTextureSize = Math.ceil(Math.sqrt(i.nodes.length)), this.store.linksTextureSize = Math.ceil(Math.sqrt(i.linksNumber * 2)), this.destroyParticleSystem(), this.create(), this.initPrograms(), this.setFocusedNodeById(), this.store.hoveredNode = void 0, t ? this.start() : this.step();
  }
  initPrograms() {
    var t, i, r, n, s, a;
    this.points.initPrograms(), this.lines.initPrograms(), (t = this.forceGravity) === null || t === void 0 || t.initPrograms(), (i = this.forceLinkIncoming) === null || i === void 0 || i.initPrograms(), (r = this.forceLinkOutgoing) === null || r === void 0 || r.initPrograms(), (n = this.forceMouse) === null || n === void 0 || n.initPrograms(), (s = this.forceManyBody) === null || s === void 0 || s.initPrograms(), (a = this.forceCenter) === null || a === void 0 || a.initPrograms();
  }
  frame() {
    const { config: { simulation: t, renderLinks: i, disableSimulation: r }, store: { alpha: n, isSimulationRunning: s } } = this;
    n < q_ && s && this.end(), this.store.pointsTextureSize && (this.requestAnimationFrameId = window.requestAnimationFrame((a) => {
      var o, c, l, d, u, h, p, m, w, C, F, W, et;
      (o = this.fpsMonitor) === null || o === void 0 || o.begin(), this.resizeCanvas(), this.findHoveredPoint(), r || (this.isRightClickMouse && (s || this.start(0.1), (c = this.forceMouse) === null || c === void 0 || c.run(), this.points.updatePosition()), s && !this.zoomInstance.isRunning && (t.gravity && ((l = this.forceGravity) === null || l === void 0 || l.run(), this.points.updatePosition()), t.center && ((d = this.forceCenter) === null || d === void 0 || d.run(), this.points.updatePosition()), (u = this.forceManyBody) === null || u === void 0 || u.run(), this.points.updatePosition(), this.store.linksTextureSize && ((h = this.forceLinkIncoming) === null || h === void 0 || h.run(), this.points.updatePosition(), (p = this.forceLinkOutgoing) === null || p === void 0 || p.run(), this.points.updatePosition()), this.store.alpha += this.store.addAlpha((m = this.config.simulation.decay) !== null && m !== void 0 ? m : Je.simulation.decay), this.isRightClickMouse && (this.store.alpha = Math.max(this.store.alpha, 0.1)), this.store.simulationProgress = Math.sqrt(Math.min(1, q_ / this.store.alpha)), (C = (w = this.config.simulation).onTick) === null || C === void 0 || C.call(w, this.store.alpha, (F = this.store.hoveredNode) === null || F === void 0 ? void 0 : F.node, this.store.hoveredNode ? this.graph.getInputIndexBySortedIndex(this.store.hoveredNode.index) : void 0, (W = this.store.hoveredNode) === null || W === void 0 ? void 0 : W.position)), this.points.trackPoints()), this.reglInstance.clear({
        color: this.store.backgroundColor,
        depth: 1,
        stencil: 0
      }), i && this.store.linksTextureSize && this.lines.draw(), this.points.draw(), (et = this.fpsMonitor) === null || et === void 0 || et.end(a), this.currentEvent = void 0, this.frame();
    }));
  }
  stopFrames() {
    this.requestAnimationFrameId && window.cancelAnimationFrame(this.requestAnimationFrameId);
  }
  end() {
    var t, i;
    this.store.isSimulationRunning = !1, this.store.simulationProgress = 1, (i = (t = this.config.simulation).onEnd) === null || i === void 0 || i.call(t);
  }
  onClick(t) {
    var i, r, n, s;
    (r = (i = this.config.events).onClick) === null || r === void 0 || r.call(i, (n = this.store.hoveredNode) === null || n === void 0 ? void 0 : n.node, this.store.hoveredNode ? this.graph.getInputIndexBySortedIndex(this.store.hoveredNode.index) : void 0, (s = this.store.hoveredNode) === null || s === void 0 ? void 0 : s.position, t);
  }
  updateMousePosition(t) {
    if (!t || t.offsetX === void 0 || t.offsetY === void 0)
      return;
    const { x: i, y: r, k: n } = this.zoomInstance.eventTransform, s = this.canvas.clientHeight, a = t.offsetX, o = t.offsetY, c = (a - i) / n, l = (o - r) / n;
    this.store.mousePosition = [c, s - l], this.store.mousePosition[0] -= (this.store.screenSize[0] - this.store.adjustedSpaceSize) / 2, this.store.mousePosition[1] -= (this.store.screenSize[1] - this.store.adjustedSpaceSize) / 2, this.store.screenMousePosition = [a, this.store.screenSize[1] - o];
  }
  onMouseMove(t) {
    var i, r, n, s;
    this.currentEvent = t, this.updateMousePosition(t), this.isRightClickMouse = t.which === 3, (r = (i = this.config.events).onMouseMove) === null || r === void 0 || r.call(i, (n = this.store.hoveredNode) === null || n === void 0 ? void 0 : n.node, this.store.hoveredNode ? this.graph.getInputIndexBySortedIndex(this.store.hoveredNode.index) : void 0, (s = this.store.hoveredNode) === null || s === void 0 ? void 0 : s.position, this.currentEvent);
  }
  onRightClickMouse(t) {
    t.preventDefault();
  }
  resizeCanvas(t = !1) {
    const i = this.canvas.width, r = this.canvas.height, n = this.canvas.clientWidth, s = this.canvas.clientHeight;
    (t || i !== n * this.config.pixelRatio || r !== s * this.config.pixelRatio) && (this.store.updateScreenSize(n, s), this.canvas.width = n * this.config.pixelRatio, this.canvas.height = s * this.config.pixelRatio, this.reglInstance.poll(), this.canvasD3Selection.call(this.zoomInstance.behavior.transform, this.zoomInstance.eventTransform), this.points.updateSampledNodesGrid());
  }
  setZoomTransformByNodePositions(t, i = 250, r, n) {
    this.resizeCanvas();
    const s = this.zoomInstance.getTransform(t, r, n);
    this.canvasD3Selection.transition().ease(RM).duration(i).call(this.zoomInstance.behavior.transform, s);
  }
  zoomToNode(t, i, r, n) {
    const { graph: s, store: { screenSize: a } } = this, o = hc(this.reglInstance, this.points.currentPositionFbo), c = s.getSortedIndexById(t.id);
    if (c === void 0)
      return;
    const l = o[c * 4 + 0], d = o[c * 4 + 1];
    if (l === void 0 || d === void 0)
      return;
    const u = this.zoomInstance.getDistanceToPoint([l, d]), h = n ? r : Math.max(this.getZoomLevel(), r);
    if (u < Math.min(a[0], a[1]))
      this.setZoomTransformByNodePositions([[l, d]], i, h);
    else {
      const p = this.zoomInstance.getTransform([[l, d]], h), m = this.zoomInstance.getMiddlePointTransform([l, d]);
      this.canvasD3Selection.transition().ease(FM).duration(i / 2).call(this.zoomInstance.behavior.transform, m).transition().ease(BM).duration(i / 2).call(this.zoomInstance.behavior.transform, p);
    }
  }
  disableZoom() {
    this.canvasD3Selection.call(this.zoomInstance.behavior).on("wheel.zoom", null);
  }
  enableZoom() {
    this.canvasD3Selection.call(this.zoomInstance.behavior);
  }
  findHoveredPoint() {
    var t, i, r, n, s;
    if (!this._isMouseOnCanvas)
      return;
    if (this._findHoveredPointExecutionCount < 2) {
      this._findHoveredPointExecutionCount += 1;
      return;
    }
    this._findHoveredPointExecutionCount = 0, this.points.findHoveredPoint();
    let a = !1, o = !1;
    const c = hc(this.reglInstance, this.points.hoveredFbo);
    if (c[1]) {
      const d = c[0], u = this.graph.getInputIndexBySortedIndex(d), h = u !== void 0 ? this.graph.getNodeByIndex(u) : void 0;
      ((t = this.store.hoveredNode) === null || t === void 0 ? void 0 : t.node) !== h && (a = !0);
      const p = c[2], m = c[3];
      this.store.hoveredNode = h && {
        node: h,
        index: d,
        position: [p, m]
      };
    } else
      this.store.hoveredNode && (o = !0), this.store.hoveredNode = void 0;
    a && this.store.hoveredNode && ((r = (i = this.config.events).onNodeMouseOver) === null || r === void 0 || r.call(i, this.store.hoveredNode.node, this.graph.getInputIndexBySortedIndex(this.graph.getSortedIndexById(this.store.hoveredNode.node.id)), this.store.hoveredNode.position, this.currentEvent)), o && ((s = (n = this.config.events).onNodeMouseOut) === null || s === void 0 || s.call(n, this.currentEvent));
  }
}
function E7(e, t) {
  const [i, r, n, s] = [e.x, e.y + e.height, e.x + e.width, e.y], [a, o, c, l] = [t.x, t.y + t.height, t.x + t.width, t.y];
  return !(r < l || o < s || n < a || c < i);
}
const yd = 6, vd = 9, Nm = 14, X_ = "css-label--label", zT = "css-label--hidden";
let Ph;
const k7 = () => {
  if (Ph)
    return;
  Ph = document.createElement("style"), Ph.innerHTML = `
  :root {
    --css-label-background-color: #1e2428;
    --css-label-brightness: brightness(150%);
  }

  .${X_} {
    position: absolute;
    top: 0;
    left: 0;

    font-weight: 500;
    cursor: pointer;
    
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    filter: var(--css-label-brightness);
    pointer-events: none;
    background-color: var(--css-label-background-color);
    font-weight: 700;
    border-radius: 6px;
    
    transition: opacity 600ms;
    opacity: 1;
  }

  .${zT} {
    opacity: 0 !important;
  }
`;
  const e = document.head.getElementsByTagName("style")[0];
  e ? document.head.insertBefore(Ph, e) : document.head.appendChild(Ph);
};
class UT {
  constructor(t, i) {
    this.element = document.createElement("div"), this.fontWidthHeightRatio = 0.6, this._x = 0, this._y = 0, this._estimatedWidth = 0, this._estimatedHeight = 0, this._visible = !1, this._prevVisible = !1, this._weight = 0, this._customFontSize = Nm, this._customColor = void 0, this._customOpacity = void 0, this._shouldBeShown = !1, this._text = "", this._customPadding = {
      left: vd,
      top: yd,
      right: vd,
      bottom: yd
    }, k7(), this._container = t, this._updateClasses(), i && this.setText(i), this.resetFontSize(), this.resetPadding();
  }
  /**
   * Sets the text of the element.
   * @param text - The text to set.
   */
  setText(t) {
    this._text !== t && (this._text = t, this.element.innerHTML = t, this._measureText());
  }
  /**
   * Sets the position of the label
   * @param x - The x coordinate of the label
   * @param y - The y coordinate of the label
   */
  setPosition(t, i) {
    this._x = t, this._y = i;
  }
  /**
   * Sets the CSS style of the element.
   * If a color, opacity or pointer-events is specified using the `setColor`,
   * `setOpacity` or `setPointerEvents` method, it takes priority over all custom styles.
   * The `fontSize` style will not apply from `setStyle`, and the `transform` style
   * will not apply, as it is used in the draw method to update the label position.
   * @param style - The style to be set.
   */
  setStyle(t) {
    if (this._customStyle !== t && (this._customStyle = t, this.element.style.cssText = this._customStyle, this._customColor && (this.element.style.color = this._customColor), this._customOpacity && (this.element.style.opacity = String(this._customOpacity)), this._customPointerEvents && (this.element.style.pointerEvents = this._customPointerEvents), this._customFontSize && (this.element.style.fontSize = `${this._customFontSize}px`), this._customPadding)) {
      const { top: i, right: r, bottom: n, left: s } = this._customPadding;
      this.element.style.padding = `${i}px ${r}px ${n}px ${s}px`;
    }
  }
  /**
   * Sets the class name of the component
   * @param className - The class name to be set
   */
  setClassName(t) {
    this._customClassName !== t && (this._customClassName = t, this._updateClasses());
  }
  /**
   * Sets the font size of the text in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param fontSize - The font size to set. If not specified, it will use the default value of `14px`.
   */
  setFontSize(t = Nm) {
    this._customFontSize !== t && (this.element.style.fontSize = `${t}px`, this._customFontSize = t, this._measureText());
  }
  /**
   * Resets the font size of the element to default value.
   */
  resetFontSize() {
    this.element.style.fontSize = `${Nm}px`, this._customFontSize = Nm, this._measureText();
  }
  /**
   * Sets the color of the element.
   * This color will rewrite the color from `setStyle` CSS style if specified.
   * @param color - The color to set
   */
  setColor(t) {
    this._customColor !== t && (this.element.style.color = t, this._customColor = t);
  }
  /**
   * Resets the color of the element.
   */
  resetColor() {
    this.element.style.removeProperty("color"), this._customColor = void 0;
  }
  /**
   * Sets the opacity of the element.
   * This opacity will rewrite the opacity from `setStyle` CSS style if specified.
   * @param opacity - The opacity to set.
   */
  setOpacity(t) {
    this._customOpacity !== t && (this.element.style.opacity = String(t), this._customOpacity = t);
  }
  /**
   * Resets the opacity of the element.
   */
  resetOpacity() {
    this.element.style.removeProperty("opacity"), this._customOpacity = void 0;
  }
  /**
   * Sets the `pointerEvents` property to 'none', 'auto', or 'all'.
   * This `pointerEvents` value will rewrite the opacity from `setStyle` CSS style if specified.
   * @param pointerEvents - The `pointerEvents` value to be set.
   */
  setPointerEvents(t) {
    this._customPointerEvents !== t && (this.element.style.pointerEvents = `${t}`, this._customPointerEvents = t);
  }
  /**
   * Resets the pointer-events of the element.
   */
  resetPointerEvents() {
    this.element.style.removeProperty("pointer-events"), this._customPointerEvents = void 0;
  }
  /**
   * Sets the padding of the element in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param padding - The padding object with left, top, right and bottom properties.
   * If not specified, it will use the default value of `{ left: 9px, top: 6px, right: 9px, bottom: 6px }`.
   */
  setPadding(t = {
    left: vd,
    top: yd,
    right: vd,
    bottom: yd
  }) {
    (this._customPadding.left !== t.left || this._customPadding.top !== t.top || this._customPadding.right !== t.right || this._customPadding.bottom !== t.bottom) && (this._customPadding = t, this.element.style.padding = `${t.top}px ${t.right}px ${t.bottom}px ${t.left}px`, this._measureText());
  }
  resetPadding() {
    const t = {
      left: vd,
      top: yd,
      right: vd,
      bottom: yd
    };
    this.element.style.padding = `${t.top}px ${t.right}px ${t.bottom}px ${t.left}px`, this._customPadding = t, this._measureText();
  }
  /**
   * Sets the boolean value of whether the element should be forced to shown or not
   * @param shouldBeShown - The boolean value to set
   */
  setForceShow(t) {
    this._shouldBeShown = t;
  }
  /**
   * Gets the boolean value of whether the element should be shown or not.
   * @returns The boolean value of whether the element should be shown or not.
   */
  getForceShow() {
    return this._shouldBeShown;
  }
  /**
   * Draws the element to the container and updates the label's coordinate.
   * The label's coordinate updates using `transform` style. It rewrite
   * the `transform` from `setStyle` CSS style if specified.
   */
  draw() {
    const t = this.getVisibility();
    t !== this._prevVisible && (this._prevVisible === !1 ? this._container.appendChild(this.element) : this._container.removeChild(this.element), this._updateClasses(), this._prevVisible = t), t && (this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this._x}px, ${this._y}px, 0)
      `);
  }
  overlaps(t) {
    return E7({
      height: this._estimatedHeight,
      width: this._estimatedWidth,
      x: this._x,
      y: this._y
    }, {
      height: t._estimatedHeight,
      width: t._estimatedWidth,
      x: t._x,
      y: t._y
    });
  }
  setVisibility(t = !0) {
    this._visible = t;
  }
  getVisibility() {
    return this._visible;
  }
  isOnScreen() {
    return this._x > 0 && this._y > 0 && this._x < this._container.offsetWidth && this._y < this._container.offsetHeight;
  }
  setWeight(t) {
    this._weight = t;
  }
  getWeight() {
    return this._weight;
  }
  /**
   * Appends the element to the top of the container
   */
  raise() {
    this._container.appendChild(this.element);
  }
  /**
   * Removes the element from the DOM.
   */
  destroy() {
    this.element.remove();
  }
  _updateClasses() {
    this.getVisibility() ? window.requestAnimationFrame(() => {
      this.element.className = `${X_} ${this._customClassName || ""}`;
    }) : this.element.className = `${X_} ${this._customClassName || ""} ${zT}`;
  }
  _measureText() {
    const { left: t, top: i, right: r, bottom: n } = this._customPadding;
    this._estimatedWidth = this._customFontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + t + r, this._estimatedHeight = this._customFontSize + i + n;
  }
}
const Km = "css-label--labels-container", VT = "css-label--labels-container-hidden";
let $h;
const C7 = () => {
  if ($h)
    return;
  $h = document.createElement("style"), $h.innerHTML = `
  .${Km} {
    transition: opacity 100ms;
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
    top: 0%;
    pointer-events: none;
    opacity: 1;
  }
  .${VT} {
    opacity: 0;

    div {
      pointer-events: none;
    }
  }
`;
  const e = document.head.getElementsByTagName("style")[0];
  e ? document.head.insertBefore($h, e) : document.head.appendChild($h);
};
class O7 {
  constructor(t, i) {
    this._cssLabels = /* @__PURE__ */ new Map(), this._elementToData = /* @__PURE__ */ new Map(), C7(), this._container = t, t.addEventListener("click", this._onClick.bind(this)), this._container.className = Km, i != null && i.onLabelClick && (this._onClickCallback = i.onLabelClick), i != null && i.padding && (this._padding = i.padding), i != null && i.pointerEvents && (this._pointerEvents = i.pointerEvents), i != null && i.dispatchWheelEventElement && (this._dispatchWheelEventElement = i.dispatchWheelEventElement, this._container.addEventListener("wheel", this._onWheel.bind(this)));
  }
  setLabels(t) {
    const i = new Map(this._cssLabels);
    t.forEach((r) => {
      const { x: n, y: s, fontSize: a, color: o, text: c, weight: l, opacity: d, shouldBeShown: u, style: h, className: p } = r;
      if (i.get(r.id))
        i.delete(r.id);
      else {
        const C = new UT(this._container, r.text);
        this._cssLabels.set(r.id, C), this._elementToData.set(C.element, r);
      }
      const w = this._cssLabels.get(r.id);
      w && (w.setText(c), w.setPosition(n, s), h !== void 0 && w.setStyle(h), l !== void 0 && w.setWeight(l), a !== void 0 && w.setFontSize(a), o !== void 0 && w.setColor(o), this._padding !== void 0 && w.setPadding(this._padding), this._pointerEvents !== void 0 && w.setPointerEvents(this._pointerEvents), d !== void 0 && w.setOpacity(d), u !== void 0 && w.setForceShow(u), p !== void 0 && w.setClassName(p));
    });
    for (const [r] of i) {
      const n = this._cssLabels.get(r);
      n && (this._elementToData.delete(n.element), n.destroy()), this._cssLabels.delete(r);
    }
  }
  draw(t = !0) {
    t && this._intersectLabels(), this._cssLabels.forEach((i) => i.draw());
  }
  show() {
    this._container.className = Km;
  }
  hide() {
    this._container.className = `${Km} ${VT}`;
  }
  destroy() {
    this._container.removeEventListener("click", this._onClick.bind(this)), this._container.removeEventListener("wheel", this._onWheel.bind(this)), this._cssLabels.forEach((t) => t.destroy());
  }
  _onClick(t) {
    var i;
    const r = this._elementToData.get(t.target);
    r && ((i = this._onClickCallback) === null || i === void 0 || i.call(this, t, r));
  }
  _onWheel(t) {
    var i;
    t.preventDefault();
    const r = new WheelEvent("wheel", t);
    (i = this._dispatchWheelEventElement) === null || i === void 0 || i.dispatchEvent(r);
  }
  _intersectLabels() {
    const t = Array.from(this._cssLabels.values());
    t.forEach((i) => i.setVisibility(i.isOnScreen()));
    for (let i = 0; i < t.length; i += 1) {
      const r = t[i];
      if (r.getVisibility())
        for (let n = i + 1; n < t.length; n += 1) {
          const s = t[n];
          if (!s.getVisibility())
            continue;
          if (r.overlaps(s)) {
            s.getWeight() > r.getWeight() ? r.setVisibility(s.getForceShow() ? !1 : r.getForceShow()) : s.setVisibility(r.getForceShow() ? !1 : s.getForceShow());
            continue;
          }
        }
    }
  }
}
var lI;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(lI || (lI = {}));
var _1 = function(e) {
  return Object.freeze(e);
}, D7 = /* @__PURE__ */ function() {
  function e(t, i) {
    this.inlineSize = t, this.blockSize = i, _1(this);
  }
  return e;
}(), N7 = function() {
  function e(t, i, r, n) {
    return this.x = t, this.y = i, this.width = r, this.height = n, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, _1(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, i = t.x, r = t.y, n = t.top, s = t.right, a = t.bottom, o = t.left, c = t.width, l = t.height;
    return { x: i, y: r, top: n, right: s, bottom: a, left: o, width: c, height: l };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), dI = typeof window < "u" ? window : {};
/msie|trident/i.test(dI.navigator && dI.navigator.userAgent);
var e_ = function(e, t, i) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = !1), new D7((i ? t : e) || 0, (i ? e : t) || 0);
};
_1({
  devicePixelContentBoxSize: e_(),
  borderBoxSize: e_(),
  contentBoxSize: e_(),
  contentRect: new N7(0, 0, 0, 0)
});
Fo(".%L");
Fo(":%S");
Fo("%I:%M");
Fo("%I %p");
Fo("%a %d");
Fo("%b %d");
Fo("%b");
Fo("%Y");
const L7 = (e) => typeof e == "function", F7 = (e) => Array.isArray(e), B7 = (e) => e instanceof Object, Mg = (e) => e.constructor.name !== "Function" && e.constructor.name !== "Object", uI = (e) => B7(e) && !F7(e) && !L7(e) && !Mg(e), Pg = (e, t = /* @__PURE__ */ new Map()) => {
  if (typeof e != "object" || e === null)
    return e;
  if (e instanceof Date)
    return new Date(e.getTime());
  if (e instanceof Array) {
    const i = [];
    t.set(e, i);
    for (const r of e)
      i.push(t.has(r) ? t.get(r) : Pg(r, t));
    return e;
  }
  if (Mg(e))
    return e;
  if (e instanceof Object) {
    const i = {};
    t.set(e, i);
    const r = e;
    return Object.keys(e).reduce((n, s) => (n[s] = t.has(r[s]) ? t.get(r[s]) : Pg(r[s], t), n), i), i;
  }
  return e;
}, K_ = (e, t, i = /* @__PURE__ */ new Map()) => {
  const r = Mg(e) ? e : Pg(e);
  return e === t ? e : i.has(t) ? i.get(t) : (i.set(t, r), Object.keys(t).forEach((n) => {
    uI(e[n]) && uI(t[n]) ? r[n] = K_(e[n], t[n], i) : Mg(t) ? r[n] = t : r[n] = Pg(t[n]);
  }), r);
};
var hI = [], zh = [];
function gp(e, t) {
  if (e && typeof document < "u") {
    var i, r = t.prepend === !0 ? "prepend" : "append", n = t.singleTag === !0, s = typeof t.container == "string" ? document.querySelector(t.container) : document.getElementsByTagName("head")[0];
    if (n) {
      var a = hI.indexOf(s);
      a === -1 && (a = hI.push(s) - 1, zh[a] = {}), i = zh[a] && zh[a][r] ? zh[a][r] : zh[a][r] = o();
    } else
      i = o();
    e.charCodeAt(0) === 65279 && (e = e.substring(1)), i.styleSheet ? i.styleSheet.cssText += e : i.appendChild(document.createTextNode(e));
  }
  function o() {
    var c = document.createElement("style");
    if (c.setAttribute("type", "text/css"), t.attributes)
      for (var l = Object.keys(t.attributes), d = 0; d < l.length; d++)
        c.setAttribute(l[d], t.attributes[l[d]]);
    var u = r === "prepend" ? "afterbegin" : "beforeend";
    return s.insertAdjacentElement(u, c), c;
  }
}
var R7 = ":root{--cosmograph-timeline-text-color:#fff;--cosmograph-timeline-axis-color:#fff;--cosmograph-timeline-selection-color:#777;--cosmograph-timeline-selection-opacity:0.5;--cosmograph-timeline-bar-color:#7a7a7a;--cosmograph-timeline-font-family:inherit;--cosmograph-timeline-font-size:11px;--cosmograph-timeline-background:#222}.style_module_timeline__f90332e1{background:var(--cosmograph-timeline-background);display:flex;overflow:hidden;position:relative;width:100%}.style_module_timelineSvg__f90332e1{height:100%;position:relative;width:100%}.style_module_selection__f90332e1{fill:var(--cosmograph-timeline-selection-color);fill-opacity:var(--cosmograph-timeline-selection-opacity);stroke:none}.style_module_axisTick__f90332e1{text-anchor:initial;alignment-baseline:text-before-edge;color:var(--cosmograph-timeline-axis-color);font:var(--cosmograph-timeline-font-family);font-size:var(--cosmograph-timeline-font-size);font-weight:400;opacity:.7;user-select:none}.style_module_axisLine__f90332e1{color:var(--cosmograph-timeline-axis-color);opacity:.2}.style_module_bar__f90332e1{fill:var(--cosmograph-timeline-bar-color);opacity:0;transform:scaleY(-1)}.style_module_noData__f90332e1{height:100%;position:absolute;top:0;width:100%}.style_module_noData__f90332e1 div{align-items:center;display:flex;font-size:calc(var(--cosmograph-timeline-font-size) + 5px);font-weight:300;height:100%;justify-content:center;letter-spacing:1;opacity:.25;user-select:none}.style_module_animationControl__f90332e1{align-items:center;color:var(--cosmograph-timeline-axis-color);cursor:pointer;display:flex;height:100%;justify-content:center;max-width:30px;min-width:20px;opacity:.5;position:relative;user-select:none;width:6%}.style_module_animationControl__f90332e1>svg{max-height:20px;padding-right:2px;width:50%}.style_module_hidden__f90332e1{display:none}.style_module_disabled__f90332e1{opacity:.2;pointer-events:none}";
gp(R7, {});
var M7 = ":root{--cosmograph-histogram-text-color:#fff;--cosmograph-histogram-axis-color:#d7d7d7;--cosmograph-histogram-selection-color:#777;--cosmograph-histogram-selection-opacity:0.5;--cosmograph-histogram-bar-color:#7a7a7a;--cosmograph-histogram-highlighted-bar-color:#fff;--cosmograph-histogram-font-family:inherit;--cosmograph-histogram-font-size:11px;--cosmograph-histogram-background:#222}.style_module_histogram__ee5eb209{background:var(--cosmograph-histogram-background);display:flex;position:relative;width:100%}.style_module_histogramSvg__ee5eb209{height:100%;position:relative;width:100%}.style_module_selection__ee5eb209{fill:var(--cosmograph-histogram-selection-color);fill-opacity:var(--cosmograph-histogram-selection-opacity);stroke:none}.style_module_axisTick__ee5eb209{alignment-baseline:text-before-edge;text-anchor:initial;font-size:var(--cosmograph-histogram-font-size);font-weight:400;opacity:1;user-select:none}.style_module_bar__ee5eb209{fill:var(--cosmograph-histogram-bar-color);transform:scaleY(-1)}.style_module_highlightedBar__ee5eb209{fill:var(--cosmograph-histogram-highlighted-bar-color);pointer-events:none;transform:scaleY(-1)}.style_module_axis__ee5eb209{color:var(--cosmograph-histogram-axis-color)}.style_module_noData__ee5eb209{height:100%;position:absolute;top:0;width:100%}.style_module_noData__ee5eb209 div{align-items:center;display:flex;font-size:calc(var(--cosmograph-histogram-font-size));font-weight:300;height:100%;justify-content:center;letter-spacing:1;opacity:.25;user-select:none}";
gp(M7, {});
var fI;
(function(e) {
  e.Input = "input", e.Select = "select", e.Enter = "enter", e.AccessorSelect = "accessorSelect";
})(fI || (fI = {}));
function Ou() {
}
function ws(e, t) {
  for (const i in t)
    e[i] = t[i];
  return e;
}
function jT(e) {
  return e();
}
function pI() {
  return /* @__PURE__ */ Object.create(null);
}
function Bo(e) {
  e.forEach(jT);
}
function ql(e) {
  return typeof e == "function";
}
function yp(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function P7(e) {
  return Object.keys(e).length === 0;
}
function dy(e, t, i, r) {
  if (e) {
    const n = GT(e, t, i, r);
    return e[0](n);
  }
}
function GT(e, t, i, r) {
  return e[1] && r ? ws(i.ctx.slice(), e[1](r(t))) : i.ctx;
}
function uy(e, t, i, r) {
  if (e[2] && r) {
    const n = e[2](r(i));
    if (t.dirty === void 0)
      return n;
    if (typeof n == "object") {
      const s = [], a = Math.max(t.dirty.length, n.length);
      for (let o = 0; o < a; o += 1)
        s[o] = t.dirty[o] | n[o];
      return s;
    }
    return t.dirty | n;
  }
  return t.dirty;
}
function hy(e, t, i, r, n, s) {
  if (n) {
    const a = GT(t, i, r, s);
    e.p(a, n);
  }
}
function fy(e) {
  if (e.ctx.length > 32) {
    const t = [], i = e.ctx.length / 32;
    for (let r = 0; r < i; r++)
      t[r] = -1;
    return t;
  }
  return -1;
}
function b1(e) {
  const t = {};
  for (const i in e)
    i[0] !== "$" && (t[i] = e[i]);
  return t;
}
function Du(e, t) {
  const i = {};
  t = new Set(t);
  for (const r in e)
    t.has(r) || r[0] === "$" || (i[r] = e[r]);
  return i;
}
function wc(e) {
  return e && ql(e.destroy) ? e.destroy : Ou;
}
function Uc(e, t, i) {
  e.insertBefore(t, i || null);
}
function Ro(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function x1(e) {
  return document.createElement(e);
}
function $7(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function z7(e) {
  return document.createTextNode(e);
}
function py() {
  return z7("");
}
function w1(e, t, i) {
  i == null ? e.removeAttribute(t) : e.getAttribute(t) !== i && e.setAttribute(t, i);
}
const U7 = ["width", "height"];
function J_(e, t) {
  const i = Object.getOwnPropertyDescriptors(e.__proto__);
  for (const r in t)
    t[r] == null ? e.removeAttribute(r) : r === "style" ? e.style.cssText = t[r] : r === "__value" ? e.value = e[r] = t[r] : i[r] && i[r].set && U7.indexOf(r) === -1 ? e[r] = t[r] : w1(e, r, t[r]);
}
function mI(e, t) {
  for (const i in t)
    w1(e, i, t[i]);
}
function V7(e, t) {
  Object.keys(t).forEach((i) => {
    j7(e, i, t[i]);
  });
}
function j7(e, t, i) {
  t in e ? e[t] = typeof e[t] == "boolean" && i === "" || i : w1(e, t, i);
}
function $g(e) {
  return /-/.test(e) ? V7 : J_;
}
function G7(e) {
  return Array.from(e.childNodes);
}
function gI(e, t) {
  return new e(t);
}
let Lf;
function bf(e) {
  Lf = e;
}
function Ju() {
  if (!Lf)
    throw new Error("Function called outside component initialization");
  return Lf;
}
function H7(e) {
  Ju().$$.on_destroy.push(e);
}
function W7(e, t) {
  return Ju().$$.context.set(e, t), t;
}
function HT(e) {
  return Ju().$$.context.get(e);
}
const Dd = [], Fl = [];
let du = [];
const yI = [], Y7 = Promise.resolve();
let Q_ = !1;
function q7() {
  Q_ || (Q_ = !0, Y7.then(WT));
}
function tb(e) {
  du.push(e);
}
const i_ = /* @__PURE__ */ new Set();
let _d = 0;
function WT() {
  if (_d !== 0)
    return;
  const e = Lf;
  do {
    try {
      for (; _d < Dd.length; ) {
        const t = Dd[_d];
        _d++, bf(t), Z7(t.$$);
      }
    } catch (t) {
      throw Dd.length = 0, _d = 0, t;
    }
    for (bf(null), Dd.length = 0, _d = 0; Fl.length; )
      Fl.pop()();
    for (let t = 0; t < du.length; t += 1) {
      const i = du[t];
      i_.has(i) || (i_.add(i), i());
    }
    du.length = 0;
  } while (Dd.length);
  for (; yI.length; )
    yI.pop()();
  Q_ = !1, i_.clear(), bf(e);
}
function Z7(e) {
  if (e.fragment !== null) {
    e.update(), Bo(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(tb);
  }
}
function X7(e) {
  const t = [], i = [];
  du.forEach((r) => e.indexOf(r) === -1 ? t.push(r) : i.push(r)), i.forEach((r) => r()), du = t;
}
const Jm = /* @__PURE__ */ new Set();
let Ol;
function YT() {
  Ol = { r: 0, c: [], p: Ol };
}
function qT() {
  Ol.r || Bo(Ol.c), Ol = Ol.p;
}
function Oa(e, t) {
  e && e.i && (Jm.delete(e), e.i(t));
}
function Ao(e, t, i, r) {
  if (e && e.o) {
    if (Jm.has(e))
      return;
    Jm.add(e), Ol.c.push(() => {
      Jm.delete(e), r && (i && e.d(1), r());
    }), e.o(t);
  } else
    r && r();
}
function vp(e, t) {
  const i = {}, r = {}, n = { $$scope: 1 };
  let s = e.length;
  for (; s--; ) {
    const a = e[s], o = t[s];
    if (o) {
      for (const c in a)
        c in o || (r[c] = 1);
      for (const c in o)
        n[c] || (i[c] = o[c], n[c] = 1);
      e[s] = o;
    } else
      for (const c in a)
        n[c] = 1;
  }
  for (const a in r)
    a in i || (i[a] = void 0);
  return i;
}
function vI(e) {
  return typeof e == "object" && e !== null ? e : {};
}
function _I(e) {
  e && e.c();
}
function eb(e, t, i, r) {
  const { fragment: n, after_update: s } = e.$$;
  n && n.m(t, i), r || tb(() => {
    const a = e.$$.on_mount.map(jT).filter(ql);
    e.$$.on_destroy ? e.$$.on_destroy.push(...a) : Bo(a), e.$$.on_mount = [];
  }), s.forEach(tb);
}
function ib(e, t) {
  const i = e.$$;
  i.fragment !== null && (X7(i.after_update), Bo(i.on_destroy), i.fragment && i.fragment.d(t), i.on_destroy = i.fragment = null, i.ctx = []);
}
function S1(e, t, i, r, n, s, a, o = [-1]) {
  const c = Lf;
  bf(e);
  const l = e.$$ = { fragment: null, ctx: [], props: s, update: Ou, not_equal: n, bound: pI(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(t.context || (c ? c.$$.context : [])), callbacks: pI(), dirty: o, skip_bound: !1, root: t.target || c.$$.root };
  a && a(l.root);
  let d = !1;
  if (l.ctx = i ? i(e, t.props || {}, (u, h, ...p) => {
    const m = p.length ? p[0] : h;
    return l.ctx && n(l.ctx[u], l.ctx[u] = m) && (!l.skip_bound && l.bound[u] && l.bound[u](m), d && function(w, C) {
      w.$$.dirty[0] === -1 && (Dd.push(w), q7(), w.$$.dirty.fill(0)), w.$$.dirty[C / 31 | 0] |= 1 << C % 31;
    }(e, u)), h;
  }) : [], l.update(), d = !0, Bo(l.before_update), l.fragment = !!r && r(l.ctx), t.target) {
    if (t.hydrate) {
      const u = G7(t.target);
      l.fragment && l.fragment.l(u), u.forEach(Ro);
    } else
      l.fragment && l.fragment.c();
    t.intro && Oa(e.$$.fragment), eb(e, t.target, t.anchor, t.customElement), WT();
  }
  bf(c);
}
class I1 {
  $destroy() {
    ib(this, 1), this.$destroy = Ou;
  }
  $on(t, i) {
    if (!ql(i))
      return Ou;
    const r = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return r.push(i), () => {
      const n = r.indexOf(i);
      n !== -1 && r.splice(n, 1);
    };
  }
  $set(t) {
    this.$$set && !P7(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
function zg(e) {
  return Object.entries(e).filter(([t, i]) => t !== "" && i).map(([t]) => t).join(" ");
}
const bI = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/, K7 = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
function A1(e) {
  let t, i = [];
  function r(n) {
    const s = e.$$.callbacks[n.type];
    s && s.slice().forEach((a) => a.call(this, n));
  }
  return e.$on = (n, s) => {
    let a = n, o = () => {
    };
    return t ? o = t(a, s) : i.push([a, s]), a.match(bI) && console && console.warn('Event modifiers in SMUI now use "$" instead of ":", so that all events can be bound with modifiers. Please update your event binding: ', a), () => {
      o();
    };
  }, (n) => {
    const s = [], a = {};
    t = (o, c) => {
      let l = o, d = c, u = !1;
      const h = l.match(bI), p = l.match(K7), m = h || p;
      if (l.match(/^SMUI:\w+:/)) {
        const W = l.split(":");
        let et = "";
        for (let E = 0; E < W.length; E++)
          et += E === W.length - 1 ? ":" + W[E] : W[E].split("-").map((Z) => Z.slice(0, 1).toUpperCase() + Z.slice(1)).join("");
        console.warn(`The event ${l.split("$")[0]} has been renamed to ${et.split("$")[0]}.`), l = et;
      }
      if (m) {
        const W = l.split(h ? ":" : "$");
        l = W[0];
        const et = W.slice(1).reduce((E, Z) => (E[Z] = !0, E), {});
        et.passive && (u = u || {}, u.passive = !0), et.nonpassive && (u = u || {}, u.passive = !1), et.capture && (u = u || {}, u.capture = !0), et.once && (u = u || {}, u.once = !0), et.preventDefault && (w = d, d = function(E) {
          return E.preventDefault(), w.call(this, E);
        }), et.stopPropagation && (d = /* @__PURE__ */ function(E) {
          return function(Z) {
            return Z.stopPropagation(), E.call(this, Z);
          };
        }(d)), et.stopImmediatePropagation && (d = /* @__PURE__ */ function(E) {
          return function(Z) {
            return Z.stopImmediatePropagation(), E.call(this, Z);
          };
        }(d)), et.self && (d = /* @__PURE__ */ function(E, Z) {
          return function(yt) {
            if (yt.target === E)
              return Z.call(this, yt);
          };
        }(n, d)), et.trusted && (d = /* @__PURE__ */ function(E) {
          return function(Z) {
            if (Z.isTrusted)
              return E.call(this, Z);
          };
        }(d));
      }
      var w;
      const C = xI(n, l, d, u), F = () => {
        C();
        const W = s.indexOf(F);
        W > -1 && s.splice(W, 1);
      };
      return s.push(F), l in a || (a[l] = xI(n, l, r)), F;
    };
    for (let o = 0; o < i.length; o++)
      t(i[o][0], i[o][1]);
    return { destroy: () => {
      for (let o = 0; o < s.length; o++)
        s[o]();
      for (let o of Object.entries(a))
        o[1]();
    } };
  };
}
function xI(e, t, i, r) {
  return e.addEventListener(t, i, r), () => e.removeEventListener(t, i, r);
}
function my(e, t) {
  let i = [];
  if (t)
    for (let r = 0; r < t.length; r++) {
      const n = t[r], s = Array.isArray(n) ? n[0] : n;
      Array.isArray(n) && n.length > 1 ? i.push(s(e, n[1])) : i.push(s(e));
    }
  return { update(r) {
    if ((r && r.length || 0) != i.length)
      throw new Error("You must not change the length of an actions array.");
    if (r)
      for (let n = 0; n < r.length; n++) {
        const s = i[n];
        if (s && s.update) {
          const a = r[n];
          Array.isArray(a) && a.length > 1 ? s.update(a[1]) : s.update();
        }
      }
  }, destroy() {
    for (let r = 0; r < i.length; r++) {
      const n = i[r];
      n && n.destroy && n.destroy();
    }
  } };
}
function J7(e) {
  let t, i, r = e[1], n = e[1] && r_(e);
  return { c() {
    n && n.c(), t = py();
  }, m(s, a) {
    n && n.m(s, a), Uc(s, t, a), i = !0;
  }, p(s, a) {
    s[1] ? r ? yp(r, s[1]) ? (n.d(1), n = r_(s), r = s[1], n.c(), n.m(t.parentNode, t)) : n.p(s, a) : (n = r_(s), r = s[1], n.c(), n.m(t.parentNode, t)) : r && (n.d(1), n = null, r = s[1]);
  }, i(s) {
    i || (Oa(n), i = !0);
  }, o(s) {
    Ao(n), i = !1;
  }, d(s) {
    s && Ro(t), n && n.d(s);
  } };
}
function Q7(e) {
  let t, i = e[1], r = e[1] && n_(e);
  return { c() {
    r && r.c(), t = py();
  }, m(n, s) {
    r && r.m(n, s), Uc(n, t, s);
  }, p(n, s) {
    n[1] ? i ? yp(i, n[1]) ? (r.d(1), r = n_(n), i = n[1], r.c(), r.m(t.parentNode, t)) : r.p(n, s) : (r = n_(n), i = n[1], r.c(), r.m(t.parentNode, t)) : i && (r.d(1), r = null, i = n[1]);
  }, i: Ou, o: Ou, d(n) {
    n && Ro(t), r && r.d(n);
  } };
}
function t$(e) {
  let t, i, r, n, s;
  const a = e[8].default, o = dy(a, e, e[7], null);
  let c = [e[5]], l = {};
  for (let d = 0; d < c.length; d += 1)
    l = ws(l, c[d]);
  return { c() {
    t = $7("svg"), o && o.c(), mI(t, l);
  }, m(d, u) {
    Uc(d, t, u), o && o.m(t, null), e[9](t), r = !0, n || (s = [wc(i = my.call(null, t, e[0])), wc(e[4].call(null, t))], n = !0);
  }, p(d, u) {
    o && o.p && (!r || 128 & u) && hy(o, a, d, d[7], r ? uy(a, d[7], u, null) : fy(d[7]), null), mI(t, l = vp(c, [32 & u && d[5]])), i && ql(i.update) && 1 & u && i.update.call(null, d[0]);
  }, i(d) {
    r || (Oa(o, d), r = !0);
  }, o(d) {
    Ao(o, d), r = !1;
  }, d(d) {
    d && Ro(t), o && o.d(d), e[9](null), n = !1, Bo(s);
  } };
}
function r_(e) {
  let t, i, r, n, s;
  const a = e[8].default, o = dy(a, e, e[7], null);
  let c = [e[5]], l = {};
  for (let d = 0; d < c.length; d += 1)
    l = ws(l, c[d]);
  return { c() {
    t = x1(e[1]), o && o.c(), $g(e[1])(t, l);
  }, m(d, u) {
    Uc(d, t, u), o && o.m(t, null), e[11](t), r = !0, n || (s = [wc(i = my.call(null, t, e[0])), wc(e[4].call(null, t))], n = !0);
  }, p(d, u) {
    o && o.p && (!r || 128 & u) && hy(o, a, d, d[7], r ? uy(a, d[7], u, null) : fy(d[7]), null), $g(d[1])(t, l = vp(c, [32 & u && d[5]])), i && ql(i.update) && 1 & u && i.update.call(null, d[0]);
  }, i(d) {
    r || (Oa(o, d), r = !0);
  }, o(d) {
    Ao(o, d), r = !1;
  }, d(d) {
    d && Ro(t), o && o.d(d), e[11](null), n = !1, Bo(s);
  } };
}
function n_(e) {
  let t, i, r, n, s = [e[5]], a = {};
  for (let o = 0; o < s.length; o += 1)
    a = ws(a, s[o]);
  return { c() {
    t = x1(e[1]), $g(e[1])(t, a);
  }, m(o, c) {
    Uc(o, t, c), e[10](t), r || (n = [wc(i = my.call(null, t, e[0])), wc(e[4].call(null, t))], r = !0);
  }, p(o, c) {
    $g(o[1])(t, a = vp(s, [32 & c && o[5]])), i && ql(i.update) && 1 & c && i.update.call(null, o[0]);
  }, d(o) {
    o && Ro(t), e[10](null), r = !1, Bo(n);
  } };
}
function e$(e) {
  let t, i, r, n;
  const s = [t$, Q7, J7], a = [];
  function o(c, l) {
    return c[1] === "svg" ? 0 : c[3] ? 1 : 2;
  }
  return t = o(e), i = a[t] = s[t](e), { c() {
    i.c(), r = py();
  }, m(c, l) {
    a[t].m(c, l), Uc(c, r, l), n = !0;
  }, p(c, [l]) {
    let d = t;
    t = o(c), t === d ? a[t].p(c, l) : (YT(), Ao(a[d], 1, 1, () => {
      a[d] = null;
    }), qT(), i = a[t], i ? i.p(c, l) : (i = a[t] = s[t](c), i.c()), Oa(i, 1), i.m(r.parentNode, r));
  }, i(c) {
    n || (Oa(i), n = !0);
  }, o(c) {
    Ao(i), n = !1;
  }, d(c) {
    a[t].d(c), c && Ro(r);
  } };
}
function i$(e, t, i) {
  let r;
  const n = ["use", "tag", "getElement"];
  let s = Du(t, n), { $$slots: a = {}, $$scope: o } = t, { use: c = [] } = t, { tag: l } = t;
  const d = A1(Ju());
  let u;
  return e.$$set = (h) => {
    t = ws(ws({}, t), b1(h)), i(5, s = Du(t, n)), "use" in h && i(0, c = h.use), "tag" in h && i(1, l = h.tag), "$$scope" in h && i(7, o = h.$$scope);
  }, e.$$.update = () => {
    2 & e.$$.dirty && i(3, r = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].indexOf(l) > -1);
  }, [c, l, u, r, d, s, function() {
    return u;
  }, o, a, function(h) {
    Fl[h ? "unshift" : "push"](() => {
      u = h, i(2, u);
    });
  }, function(h) {
    Fl[h ? "unshift" : "push"](() => {
      u = h, i(2, u);
    });
  }, function(h) {
    Fl[h ? "unshift" : "push"](() => {
      u = h, i(2, u);
    });
  }];
}
let ZT = class extends I1 {
  constructor(t) {
    super(), S1(this, t, i$, e$, yp, { use: 0, tag: 1, getElement: 6 });
  }
  get getElement() {
    return this.$$.ctx[6];
  }
};
var rb = function(e, t) {
  return rb = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
    i.__proto__ = r;
  } || function(i, r) {
    for (var n in r)
      Object.prototype.hasOwnProperty.call(r, n) && (i[n] = r[n]);
  }, rb(e, t);
};
function Mo(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function i() {
    this.constructor = e;
  }
  rb(e, t), e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
var Br = function() {
  return Br = Object.assign || function(e) {
    for (var t, i = 1, r = arguments.length; i < r; i++)
      for (var n in t = arguments[i])
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e;
  }, Br.apply(this, arguments);
};
function js(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, i = t && e[t], r = 0;
  if (i)
    return i.call(e);
  if (e && typeof e.length == "number")
    return { next: function() {
      return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
    } };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function wI(e, t) {
  var i = typeof Symbol == "function" && e[Symbol.iterator];
  if (!i)
    return e;
  var r, n, s = i.call(e), a = [];
  try {
    for (; (t === void 0 || t-- > 0) && !(r = s.next()).done; )
      a.push(r.value);
  } catch (o) {
    n = { error: o };
  } finally {
    try {
      r && !r.done && (i = s.return) && i.call(s);
    } finally {
      if (n)
        throw n.error;
    }
  }
  return a;
}
function r$(e, t, i) {
  if (i || arguments.length === 2)
    for (var r, n = 0, s = t.length; n < s; n++)
      !r && n in t || (r || (r = Array.prototype.slice.call(t, 0, n)), r[n] = t[n]);
  return e.concat(r || Array.prototype.slice.call(t));
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Po = function() {
  function e(t) {
    t === void 0 && (t = {}), this.adapter = t;
  }
  return Object.defineProperty(e, "cssClasses", { get: function() {
    return {};
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "strings", { get: function() {
    return {};
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "numbers", { get: function() {
    return {};
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(e, "defaultAdapter", { get: function() {
    return {};
  }, enumerable: !1, configurable: !0 }), e.prototype.init = function() {
  }, e.prototype.destroy = function() {
  }, e;
}();
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ui = { UNKNOWN: "Unknown", BACKSPACE: "Backspace", ENTER: "Enter", SPACEBAR: "Spacebar", PAGE_UP: "PageUp", PAGE_DOWN: "PageDown", END: "End", HOME: "Home", ARROW_LEFT: "ArrowLeft", ARROW_UP: "ArrowUp", ARROW_RIGHT: "ArrowRight", ARROW_DOWN: "ArrowDown", DELETE: "Delete", ESCAPE: "Escape", TAB: "Tab" }, wn = /* @__PURE__ */ new Set();
wn.add(ui.BACKSPACE), wn.add(ui.ENTER), wn.add(ui.SPACEBAR), wn.add(ui.PAGE_UP), wn.add(ui.PAGE_DOWN), wn.add(ui.END), wn.add(ui.HOME), wn.add(ui.ARROW_LEFT), wn.add(ui.ARROW_UP), wn.add(ui.ARROW_RIGHT), wn.add(ui.ARROW_DOWN), wn.add(ui.DELETE), wn.add(ui.ESCAPE), wn.add(ui.TAB);
var n$ = 8, s$ = 13, a$ = 32, o$ = 33, c$ = 34, l$ = 35, d$ = 36, u$ = 37, h$ = 38, f$ = 39, p$ = 40, m$ = 46, g$ = 27, y$ = 9, Sn = /* @__PURE__ */ new Map();
Sn.set(n$, ui.BACKSPACE), Sn.set(s$, ui.ENTER), Sn.set(a$, ui.SPACEBAR), Sn.set(o$, ui.PAGE_UP), Sn.set(c$, ui.PAGE_DOWN), Sn.set(l$, ui.END), Sn.set(d$, ui.HOME), Sn.set(u$, ui.ARROW_LEFT), Sn.set(h$, ui.ARROW_UP), Sn.set(f$, ui.ARROW_RIGHT), Sn.set(p$, ui.ARROW_DOWN), Sn.set(m$, ui.DELETE), Sn.set(g$, ui.ESCAPE), Sn.set(y$, ui.TAB);
var ic = /* @__PURE__ */ new Set();
function gn(e) {
  var t = e.key;
  if (wn.has(t))
    return t;
  var i = Sn.get(e.keyCode);
  return i || ui.UNKNOWN;
}
ic.add(ui.PAGE_UP), ic.add(ui.PAGE_DOWN), ic.add(ui.END), ic.add(ui.HOME), ic.add(ui.ARROW_LEFT), ic.add(ui.ARROW_UP), ic.add(ui.ARROW_RIGHT), ic.add(ui.ARROW_DOWN);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var bd, rc, pi = { LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated", LIST_ITEM_CLASS: "mdc-list-item", LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled", LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected", LIST_ITEM_TEXT_CLASS: "mdc-list-item__text", LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text", ROOT: "mdc-list" };
(bd = {})["" + pi.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", bd["" + pi.LIST_ITEM_CLASS] = "mdc-list-item", bd["" + pi.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", bd["" + pi.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", bd["" + pi.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", bd["" + pi.ROOT] = "mdc-list";
var xd = ((rc = {})["" + pi.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", rc["" + pi.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", rc["" + pi.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", rc["" + pi.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", rc["" + pi.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", rc["" + pi.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", rc["" + pi.ROOT] = "mdc-deprecated-list", rc), nc = { ACTION_EVENT: "MDCList:action", SELECTION_CHANGE_EVENT: "MDCList:selectionChange", ARIA_CHECKED: "aria-checked", ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]', ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]', ARIA_CURRENT: "aria-current", ARIA_DISABLED: "aria-disabled", ARIA_ORIENTATION: "aria-orientation", ARIA_ORIENTATION_HORIZONTAL: "horizontal", ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]', ARIA_SELECTED: "aria-selected", ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]', ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]', CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]', CHECKBOX_SELECTOR: 'input[type="checkbox"]', CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: `
    .` + pi.LIST_ITEM_CLASS + ` button:not(:disabled),
    .` + pi.LIST_ITEM_CLASS + ` a,
    .` + xd[pi.LIST_ITEM_CLASS] + ` button:not(:disabled),
    .` + xd[pi.LIST_ITEM_CLASS] + ` a
  `, DEPRECATED_SELECTOR: ".mdc-deprecated-list", FOCUSABLE_CHILD_ELEMENTS: `
    .` + pi.LIST_ITEM_CLASS + ` button:not(:disabled),
    .` + pi.LIST_ITEM_CLASS + ` a,
    .` + pi.LIST_ITEM_CLASS + ` input[type="radio"]:not(:disabled),
    .` + pi.LIST_ITEM_CLASS + ` input[type="checkbox"]:not(:disabled),
    .` + xd[pi.LIST_ITEM_CLASS] + ` button:not(:disabled),
    .` + xd[pi.LIST_ITEM_CLASS] + ` a,
    .` + xd[pi.LIST_ITEM_CLASS] + ` input[type="radio"]:not(:disabled),
    .` + xd[pi.LIST_ITEM_CLASS] + ` input[type="checkbox"]:not(:disabled)
  `, RADIO_SELECTOR: 'input[type="radio"]', SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]' }, Lr = { UNSET_INDEX: -1, TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300 };
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var v$ = ["input", "button", "textarea", "select"], fs = function(e) {
  var t = e.target;
  if (t) {
    var i = ("" + t.tagName).toLowerCase();
    v$.indexOf(i) === -1 && e.preventDefault();
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function _$() {
  return { bufferClearTimeout: 0, currentFirstChar: "", sortedIndexCursor: 0, typeaheadBuffer: "" };
}
function b$(e, t) {
  for (var i = /* @__PURE__ */ new Map(), r = 0; r < e; r++) {
    var n = t(r).trim();
    if (n) {
      var s = n[0].toLowerCase();
      i.has(s) || i.set(s, []), i.get(s).push({ text: n.toLowerCase(), index: r });
    }
  }
  return i.forEach(function(a) {
    a.sort(function(o, c) {
      return o.index - c.index;
    });
  }), i;
}
function nb(e, t) {
  var i, r = e.nextChar, n = e.focusItemAtIndex, s = e.sortedIndexByFirstChar, a = e.focusedItemIndex, o = e.skipFocus, c = e.isItemAtIndexDisabled;
  return clearTimeout(t.bufferClearTimeout), t.bufferClearTimeout = setTimeout(function() {
    KT(t);
  }, Lr.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS), t.typeaheadBuffer = t.typeaheadBuffer + r, i = t.typeaheadBuffer.length === 1 ? function(l, d, u, h) {
    var p = h.typeaheadBuffer[0], m = l.get(p);
    if (!m)
      return -1;
    if (p === h.currentFirstChar && m[h.sortedIndexCursor].index === d) {
      h.sortedIndexCursor = (h.sortedIndexCursor + 1) % m.length;
      var w = m[h.sortedIndexCursor].index;
      if (!u(w))
        return w;
    }
    h.currentFirstChar = p;
    var C, F = -1;
    for (C = 0; C < m.length; C++)
      if (!u(m[C].index)) {
        F = C;
        break;
      }
    for (; C < m.length; C++)
      if (m[C].index > d && !u(m[C].index)) {
        F = C;
        break;
      }
    return F !== -1 ? (h.sortedIndexCursor = F, m[h.sortedIndexCursor].index) : -1;
  }(s, a, c, t) : function(l, d, u) {
    var h = u.typeaheadBuffer[0], p = l.get(h);
    if (!p)
      return -1;
    var m = p[u.sortedIndexCursor];
    if (m.text.lastIndexOf(u.typeaheadBuffer, 0) === 0 && !d(m.index))
      return m.index;
    for (var w = (u.sortedIndexCursor + 1) % p.length, C = -1; w !== u.sortedIndexCursor; ) {
      var F = p[w], W = F.text.lastIndexOf(u.typeaheadBuffer, 0) === 0, et = !d(F.index);
      if (W && et) {
        C = w;
        break;
      }
      w = (w + 1) % p.length;
    }
    return C !== -1 ? (u.sortedIndexCursor = C, p[u.sortedIndexCursor].index) : -1;
  }(s, c, t), i === -1 || o || n(i), i;
}
function XT(e) {
  return e.typeaheadBuffer.length > 0;
}
function KT(e) {
  e.typeaheadBuffer = "";
}
function SI(e, t) {
  var i = e.event, r = e.isTargetListItem, n = e.focusedItemIndex, s = e.focusItemAtIndex, a = e.sortedIndexByFirstChar, o = e.isItemAtIndexDisabled, c = gn(i) === "ArrowLeft", l = gn(i) === "ArrowUp", d = gn(i) === "ArrowRight", u = gn(i) === "ArrowDown", h = gn(i) === "Home", p = gn(i) === "End", m = gn(i) === "Enter", w = gn(i) === "Spacebar";
  return i.altKey || i.ctrlKey || i.metaKey || c || l || d || u || h || p || m ? -1 : w || i.key.length !== 1 ? w ? (r && fs(i), r && XT(t) ? nb({ focusItemAtIndex: s, focusedItemIndex: n, nextChar: " ", sortedIndexByFirstChar: a, skipFocus: !1, isItemAtIndexDisabled: o }, t) : -1) : -1 : (fs(i), nb({ focusItemAtIndex: s, focusedItemIndex: n, nextChar: i.key.toLowerCase(), sortedIndexByFirstChar: a, skipFocus: !1, isItemAtIndexDisabled: o }, t));
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var x$ = ["Alt", "Control", "Meta", "Shift"];
function II(e) {
  var t = new Set(e ? x$.filter(function(i) {
    return e.getModifierState(i);
  }) : []);
  return function(i) {
    return i.every(function(r) {
      return t.has(r);
    }) && i.length === t.size;
  };
}
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.wrapFocus = !1, r.isVertical = !0, r.isSingleSelectionList = !1, r.areDisabledItemsFocusable = !0, r.selectedIndex = Lr.UNSET_INDEX, r.focusedItemIndex = Lr.UNSET_INDEX, r.useActivatedClass = !1, r.useSelectedAttr = !1, r.ariaCurrentAttrValue = null, r.isCheckboxList = !1, r.isRadioList = !1, r.lastSelectedIndex = null, r.hasTypeahead = !1, r.typeaheadState = _$(), r.sortedIndexByFirstChar = /* @__PURE__ */ new Map(), r;
  }
  return Mo(t, e), Object.defineProperty(t, "strings", { get: function() {
    return nc;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "cssClasses", { get: function() {
    return pi;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return Lr;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClassForElementIndex: function() {
    }, focusItemAtIndex: function() {
    }, getAttributeForElementIndex: function() {
      return null;
    }, getFocusedElementIndex: function() {
      return 0;
    }, getListItemCount: function() {
      return 0;
    }, hasCheckboxAtIndex: function() {
      return !1;
    }, hasRadioAtIndex: function() {
      return !1;
    }, isCheckboxCheckedAtIndex: function() {
      return !1;
    }, isFocusInsideList: function() {
      return !1;
    }, isRootFocused: function() {
      return !1;
    }, listItemAtIndexHasClass: function() {
      return !1;
    }, notifyAction: function() {
    }, notifySelectionChange: function() {
    }, removeClassForElementIndex: function() {
    }, setAttributeForElementIndex: function() {
    }, setCheckedCheckboxOrRadioAtIndex: function() {
    }, setTabIndexForListItemChildren: function() {
    }, getPrimaryTextAtIndex: function() {
      return "";
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.layout = function() {
    this.adapter.getListItemCount() !== 0 && (this.adapter.hasCheckboxAtIndex(0) ? this.isCheckboxList = !0 : this.adapter.hasRadioAtIndex(0) ? this.isRadioList = !0 : this.maybeInitializeSingleSelection(), this.hasTypeahead && (this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex()));
  }, t.prototype.getFocusedItemIndex = function() {
    return this.focusedItemIndex;
  }, t.prototype.setWrapFocus = function(i) {
    this.wrapFocus = i;
  }, t.prototype.setVerticalOrientation = function(i) {
    this.isVertical = i;
  }, t.prototype.setSingleSelection = function(i) {
    this.isSingleSelectionList = i, i && (this.maybeInitializeSingleSelection(), this.selectedIndex = this.getSelectedIndexFromDOM());
  }, t.prototype.setDisabledItemsFocusable = function(i) {
    this.areDisabledItemsFocusable = i;
  }, t.prototype.maybeInitializeSingleSelection = function() {
    var i = this.getSelectedIndexFromDOM();
    i !== Lr.UNSET_INDEX && (this.adapter.listItemAtIndexHasClass(i, pi.LIST_ITEM_ACTIVATED_CLASS) && this.setUseActivatedClass(!0), this.isSingleSelectionList = !0, this.selectedIndex = i);
  }, t.prototype.getSelectedIndexFromDOM = function() {
    for (var i = Lr.UNSET_INDEX, r = this.adapter.getListItemCount(), n = 0; n < r; n++) {
      var s = this.adapter.listItemAtIndexHasClass(n, pi.LIST_ITEM_SELECTED_CLASS), a = this.adapter.listItemAtIndexHasClass(n, pi.LIST_ITEM_ACTIVATED_CLASS);
      if (s || a) {
        i = n;
        break;
      }
    }
    return i;
  }, t.prototype.setHasTypeahead = function(i) {
    this.hasTypeahead = i, i && (this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex());
  }, t.prototype.isTypeaheadInProgress = function() {
    return this.hasTypeahead && XT(this.typeaheadState);
  }, t.prototype.setUseActivatedClass = function(i) {
    this.useActivatedClass = i;
  }, t.prototype.setUseSelectedAttribute = function(i) {
    this.useSelectedAttr = i;
  }, t.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  }, t.prototype.setSelectedIndex = function(i, r) {
    r === void 0 && (r = {}), this.isIndexValid(i) && (this.isCheckboxList ? this.setCheckboxAtIndex(i, r) : this.isRadioList ? this.setRadioAtIndex(i, r) : this.setSingleSelectionAtIndex(i, r));
  }, t.prototype.handleFocusIn = function(i) {
    i >= 0 && (this.focusedItemIndex = i, this.adapter.setAttributeForElementIndex(i, "tabindex", "0"), this.adapter.setTabIndexForListItemChildren(i, "0"));
  }, t.prototype.handleFocusOut = function(i) {
    var r = this;
    i >= 0 && (this.adapter.setAttributeForElementIndex(i, "tabindex", "-1"), this.adapter.setTabIndexForListItemChildren(i, "-1")), setTimeout(function() {
      r.adapter.isFocusInsideList() || r.setTabindexToFirstSelectedOrFocusedItem();
    }, 0);
  }, t.prototype.isIndexDisabled = function(i) {
    return this.adapter.listItemAtIndexHasClass(i, pi.LIST_ITEM_DISABLED_CLASS);
  }, t.prototype.handleKeydown = function(i, r, n) {
    var s, a = this, o = gn(i) === "ArrowLeft", c = gn(i) === "ArrowUp", l = gn(i) === "ArrowRight", d = gn(i) === "ArrowDown", u = gn(i) === "Home", h = gn(i) === "End", p = gn(i) === "Enter", m = gn(i) === "Spacebar", w = this.isVertical && d || !this.isVertical && l, C = this.isVertical && c || !this.isVertical && o, F = i.key === "A" || i.key === "a", W = II(i);
    if (this.adapter.isRootFocused()) {
      if ((C || h) && W([]) ? (i.preventDefault(), this.focusLastElement()) : (w || u) && W([]) ? (i.preventDefault(), this.focusFirstElement()) : C && W(["Shift"]) && this.isCheckboxList ? (i.preventDefault(), (Z = this.focusLastElement()) !== -1 && this.setSelectedIndexOnAction(Z, !1)) : w && W(["Shift"]) && this.isCheckboxList && (i.preventDefault(), (Z = this.focusFirstElement()) !== -1 && this.setSelectedIndexOnAction(Z, !1)), this.hasTypeahead) {
        var et = { event: i, focusItemAtIndex: function(bt) {
          a.focusItemAtIndex(bt);
        }, focusedItemIndex: -1, isTargetListItem: r, sortedIndexByFirstChar: this.sortedIndexByFirstChar, isItemAtIndexDisabled: function(bt) {
          return a.isIndexDisabled(bt);
        } };
        SI(et, this.typeaheadState);
      }
    } else {
      var E = this.adapter.getFocusedElementIndex();
      if (!(E === -1 && (E = n) < 0)) {
        if (w && W([]))
          fs(i), this.focusNextElement(E);
        else if (C && W([]))
          fs(i), this.focusPrevElement(E);
        else if (w && W(["Shift"]) && this.isCheckboxList)
          fs(i), (Z = this.focusNextElement(E)) !== -1 && this.setSelectedIndexOnAction(Z, !1);
        else if (C && W(["Shift"]) && this.isCheckboxList) {
          var Z;
          fs(i), (Z = this.focusPrevElement(E)) !== -1 && this.setSelectedIndexOnAction(Z, !1);
        } else if (u && W([]))
          fs(i), this.focusFirstElement();
        else if (h && W([]))
          fs(i), this.focusLastElement();
        else if (u && W(["Control", "Shift"]) && this.isCheckboxList) {
          if (fs(i), this.isIndexDisabled(E))
            return;
          this.focusFirstElement(), this.toggleCheckboxRange(0, E, E);
        } else if (h && W(["Control", "Shift"]) && this.isCheckboxList) {
          if (fs(i), this.isIndexDisabled(E))
            return;
          this.focusLastElement(), this.toggleCheckboxRange(E, this.adapter.getListItemCount() - 1, E);
        } else if (F && W(["Control"]) && this.isCheckboxList)
          i.preventDefault(), this.checkboxListToggleAll(this.selectedIndex === Lr.UNSET_INDEX ? [] : this.selectedIndex, !0);
        else if ((p || m) && W([])) {
          if (r) {
            if ((yt = i.target) && yt.tagName === "A" && p || (fs(i), this.isIndexDisabled(E)))
              return;
            this.isTypeaheadInProgress() || (this.isSelectableList() && this.setSelectedIndexOnAction(E, !1), this.adapter.notifyAction(E));
          }
        } else if ((p || m) && W(["Shift"]) && this.isCheckboxList) {
          var yt;
          if ((yt = i.target) && yt.tagName === "A" && p || (fs(i), this.isIndexDisabled(E)))
            return;
          this.isTypeaheadInProgress() || (this.toggleCheckboxRange((s = this.lastSelectedIndex) !== null && s !== void 0 ? s : E, E, E), this.adapter.notifyAction(E));
        }
        this.hasTypeahead && (et = { event: i, focusItemAtIndex: function(bt) {
          a.focusItemAtIndex(bt);
        }, focusedItemIndex: this.focusedItemIndex, isTargetListItem: r, sortedIndexByFirstChar: this.sortedIndexByFirstChar, isItemAtIndexDisabled: function(bt) {
          return a.isIndexDisabled(bt);
        } }, SI(et, this.typeaheadState));
      }
    }
  }, t.prototype.handleClick = function(i, r, n) {
    var s, a = II(n);
    i !== Lr.UNSET_INDEX && (this.isIndexDisabled(i) || (a([]) ? (this.isSelectableList() && this.setSelectedIndexOnAction(i, r), this.adapter.notifyAction(i)) : this.isCheckboxList && a(["Shift"]) && (this.toggleCheckboxRange((s = this.lastSelectedIndex) !== null && s !== void 0 ? s : i, i, i), this.adapter.notifyAction(i))));
  }, t.prototype.focusNextElement = function(i) {
    var r = this.adapter.getListItemCount(), n = i, s = null;
    do {
      if (++n >= r) {
        if (!this.wrapFocus)
          return i;
        n = 0;
      }
      if (n === s)
        return -1;
      s = s ?? n;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(n));
    return this.focusItemAtIndex(n), n;
  }, t.prototype.focusPrevElement = function(i) {
    var r = this.adapter.getListItemCount(), n = i, s = null;
    do {
      if (--n < 0) {
        if (!this.wrapFocus)
          return i;
        n = r - 1;
      }
      if (n === s)
        return -1;
      s = s ?? n;
    } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(n));
    return this.focusItemAtIndex(n), n;
  }, t.prototype.focusFirstElement = function() {
    return this.focusNextElement(-1);
  }, t.prototype.focusLastElement = function() {
    return this.focusPrevElement(this.adapter.getListItemCount());
  }, t.prototype.focusInitialElement = function() {
    var i = this.getFirstSelectedOrFocusedItemIndex();
    return this.focusItemAtIndex(i), i;
  }, t.prototype.setEnabled = function(i, r) {
    this.isIndexValid(i, !1) && (r ? (this.adapter.removeClassForElementIndex(i, pi.LIST_ITEM_DISABLED_CLASS), this.adapter.setAttributeForElementIndex(i, nc.ARIA_DISABLED, "false")) : (this.adapter.addClassForElementIndex(i, pi.LIST_ITEM_DISABLED_CLASS), this.adapter.setAttributeForElementIndex(i, nc.ARIA_DISABLED, "true")));
  }, t.prototype.setSingleSelectionAtIndex = function(i, r) {
    if (r === void 0 && (r = {}), this.selectedIndex !== i || r.forceUpdate) {
      var n = pi.LIST_ITEM_SELECTED_CLASS;
      this.useActivatedClass && (n = pi.LIST_ITEM_ACTIVATED_CLASS), this.selectedIndex !== Lr.UNSET_INDEX && this.adapter.removeClassForElementIndex(this.selectedIndex, n), this.setAriaForSingleSelectionAtIndex(i), this.setTabindexAtIndex(i), i !== Lr.UNSET_INDEX && this.adapter.addClassForElementIndex(i, n), this.selectedIndex = i, r.isUserInteraction && !r.forceUpdate && this.adapter.notifySelectionChange([i]);
    }
  }, t.prototype.setAriaForSingleSelectionAtIndex = function(i) {
    this.selectedIndex === Lr.UNSET_INDEX && (this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(i, nc.ARIA_CURRENT));
    var r = this.ariaCurrentAttrValue !== null, n = r ? nc.ARIA_CURRENT : nc.ARIA_SELECTED;
    if (this.selectedIndex !== Lr.UNSET_INDEX && this.adapter.setAttributeForElementIndex(this.selectedIndex, n, "false"), i !== Lr.UNSET_INDEX) {
      var s = r ? this.ariaCurrentAttrValue : "true";
      this.adapter.setAttributeForElementIndex(i, n, s);
    }
  }, t.prototype.getSelectionAttribute = function() {
    return this.useSelectedAttr ? nc.ARIA_SELECTED : nc.ARIA_CHECKED;
  }, t.prototype.setRadioAtIndex = function(i, r) {
    r === void 0 && (r = {});
    var n = this.getSelectionAttribute();
    this.adapter.setCheckedCheckboxOrRadioAtIndex(i, !0), (this.selectedIndex !== i || r.forceUpdate) && (this.selectedIndex !== Lr.UNSET_INDEX && this.adapter.setAttributeForElementIndex(this.selectedIndex, n, "false"), this.adapter.setAttributeForElementIndex(i, n, "true"), this.selectedIndex = i, r.isUserInteraction && !r.forceUpdate && this.adapter.notifySelectionChange([i]));
  }, t.prototype.setCheckboxAtIndex = function(i, r) {
    r === void 0 && (r = {});
    for (var n = this.selectedIndex, s = r.isUserInteraction ? new Set(n === Lr.UNSET_INDEX ? [] : n) : null, a = this.getSelectionAttribute(), o = [], c = 0; c < this.adapter.getListItemCount(); c++) {
      var l = s == null ? void 0 : s.has(c), d = i.indexOf(c) >= 0;
      d !== l && o.push(c), this.adapter.setCheckedCheckboxOrRadioAtIndex(c, d), this.adapter.setAttributeForElementIndex(c, a, d ? "true" : "false");
    }
    this.selectedIndex = i, r.isUserInteraction && o.length && this.adapter.notifySelectionChange(o);
  }, t.prototype.toggleCheckboxRange = function(i, r, n) {
    this.lastSelectedIndex = n;
    for (var s = new Set(this.selectedIndex === Lr.UNSET_INDEX ? [] : this.selectedIndex), a = !(s != null && s.has(n)), o = wI([i, r].sort(), 2), c = o[0], l = o[1], d = this.getSelectionAttribute(), u = [], h = c; h <= l; h++)
      this.isIndexDisabled(h) || a !== s.has(h) && (u.push(h), this.adapter.setCheckedCheckboxOrRadioAtIndex(h, a), this.adapter.setAttributeForElementIndex(h, d, "" + a), a ? s.add(h) : s.delete(h));
    u.length && (this.selectedIndex = r$([], wI(s)), this.adapter.notifySelectionChange(u));
  }, t.prototype.setTabindexAtIndex = function(i) {
    this.focusedItemIndex === Lr.UNSET_INDEX && i !== 0 ? this.adapter.setAttributeForElementIndex(0, "tabindex", "-1") : this.focusedItemIndex >= 0 && this.focusedItemIndex !== i && this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1"), this.selectedIndex instanceof Array || this.selectedIndex === i || this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1"), i !== Lr.UNSET_INDEX && this.adapter.setAttributeForElementIndex(i, "tabindex", "0");
  }, t.prototype.isSelectableList = function() {
    return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
  }, t.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
    var i = this.getFirstSelectedOrFocusedItemIndex();
    this.setTabindexAtIndex(i);
  }, t.prototype.getFirstSelectedOrFocusedItemIndex = function() {
    return this.isSelectableList() ? typeof this.selectedIndex == "number" && this.selectedIndex !== Lr.UNSET_INDEX ? this.selectedIndex : this.selectedIndex instanceof Array && this.selectedIndex.length > 0 ? this.selectedIndex.reduce(function(i, r) {
      return Math.min(i, r);
    }) : 0 : Math.max(this.focusedItemIndex, 0);
  }, t.prototype.isIndexValid = function(i, r) {
    var n = this;
    if (r === void 0 && (r = !0), i instanceof Array) {
      if (!this.isCheckboxList && r)
        throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
      return i.length === 0 || i.some(function(s) {
        return n.isIndexInRange(s);
      });
    }
    if (typeof i == "number") {
      if (this.isCheckboxList && r)
        throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + i);
      return this.isIndexInRange(i) || this.isSingleSelectionList && i === Lr.UNSET_INDEX;
    }
    return !1;
  }, t.prototype.isIndexInRange = function(i) {
    var r = this.adapter.getListItemCount();
    return i >= 0 && i < r;
  }, t.prototype.setSelectedIndexOnAction = function(i, r) {
    this.lastSelectedIndex = i, this.isCheckboxList ? (this.toggleCheckboxAtIndex(i, r), this.adapter.notifySelectionChange([i])) : this.setSelectedIndex(i, { isUserInteraction: !0 });
  }, t.prototype.toggleCheckboxAtIndex = function(i, r) {
    var n, s = this.getSelectionAttribute(), a = this.adapter.isCheckboxCheckedAtIndex(i);
    r ? n = a : (n = !a, this.adapter.setCheckedCheckboxOrRadioAtIndex(i, n)), this.adapter.setAttributeForElementIndex(i, s, n ? "true" : "false");
    var o = this.selectedIndex === Lr.UNSET_INDEX ? [] : this.selectedIndex.slice();
    n ? o.push(i) : o = o.filter(function(c) {
      return c !== i;
    }), this.selectedIndex = o;
  }, t.prototype.focusItemAtIndex = function(i) {
    this.adapter.focusItemAtIndex(i), this.focusedItemIndex = i;
  }, t.prototype.checkboxListToggleAll = function(i, r) {
    var n = this.adapter.getListItemCount();
    if (i.length === n)
      this.setCheckboxAtIndex([], { isUserInteraction: r });
    else {
      for (var s = [], a = 0; a < n; a++)
        (!this.isIndexDisabled(a) || i.indexOf(a) > -1) && s.push(a);
      this.setCheckboxAtIndex(s, { isUserInteraction: r });
    }
  }, t.prototype.typeaheadMatchItem = function(i, r, n) {
    var s = this;
    n === void 0 && (n = !1);
    var a = { focusItemAtIndex: function(o) {
      s.focusItemAtIndex(o);
    }, focusedItemIndex: r || this.focusedItemIndex, nextChar: i, sortedIndexByFirstChar: this.sortedIndexByFirstChar, skipFocus: n, isItemAtIndexDisabled: function(o) {
      return s.isIndexDisabled(o);
    } };
    return nb(a, this.typeaheadState);
  }, t.prototype.typeaheadInitSortedIndex = function() {
    return b$(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
  }, t.prototype.clearTypeaheadBuffer = function() {
    KT(this.typeaheadState);
  }, t;
})(Po);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var w$ = { BG_FOCUSED: "mdc-ripple-upgraded--background-focused", FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation", FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation", ROOT: "mdc-ripple-upgraded", UNBOUNDED: "mdc-ripple-upgraded--unbounded" }, S$ = { VAR_FG_SCALE: "--mdc-ripple-fg-scale", VAR_FG_SIZE: "--mdc-ripple-fg-size", VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end", VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start", VAR_LEFT: "--mdc-ripple-left", VAR_TOP: "--mdc-ripple-top" }, AI = { DEACTIVATION_TIMEOUT_MS: 225, FG_DEACTIVATION_MS: 150, INITIAL_ORIGIN_SCALE: 0.6, PADDING: 10, TAP_DELAY_MS: 300 };
function I$(e, t, i) {
  if (!e)
    return { x: 0, y: 0 };
  var r, n, s = t.x, a = t.y, o = s + i.left, c = a + i.top;
  if (e.type === "touchstart") {
    var l = e;
    r = l.changedTouches[0].pageX - o, n = l.changedTouches[0].pageY - c;
  } else {
    var d = e;
    r = d.pageX - o, n = d.pageY - c;
  }
  return { x: r, y: n };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var TI = ["touchstart", "pointerdown", "mousedown", "keydown"], EI = ["touchend", "pointerup", "mouseup", "contextmenu"], Lm = [];
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.activationAnimationHasEnded = !1, r.activationTimer = 0, r.fgDeactivationRemovalTimer = 0, r.fgScale = "0", r.frame = { width: 0, height: 0 }, r.initialSize = 0, r.layoutFrame = 0, r.maxRadius = 0, r.unboundedCoords = { left: 0, top: 0 }, r.activationState = r.defaultActivationState(), r.activationTimerCallback = function() {
      r.activationAnimationHasEnded = !0, r.runDeactivationUXLogicIfReady();
    }, r.activateHandler = function(n) {
      r.activateImpl(n);
    }, r.deactivateHandler = function() {
      r.deactivateImpl();
    }, r.focusHandler = function() {
      r.handleFocus();
    }, r.blurHandler = function() {
      r.handleBlur();
    }, r.resizeHandler = function() {
      r.layout();
    }, r;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return w$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "strings", { get: function() {
    return S$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return AI;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, browserSupportsCssVars: function() {
      return !0;
    }, computeBoundingRect: function() {
      return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
    }, containsEventTarget: function() {
      return !0;
    }, deregisterDocumentInteractionHandler: function() {
    }, deregisterInteractionHandler: function() {
    }, deregisterResizeHandler: function() {
    }, getWindowPageOffset: function() {
      return { x: 0, y: 0 };
    }, isSurfaceActive: function() {
      return !0;
    }, isSurfaceDisabled: function() {
      return !0;
    }, isUnbounded: function() {
      return !0;
    }, registerDocumentInteractionHandler: function() {
    }, registerInteractionHandler: function() {
    }, registerResizeHandler: function() {
    }, removeClass: function() {
    }, updateCssVariable: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    var i = this, r = this.supportsPressRipple();
    if (this.registerRootHandlers(r), r) {
      var n = t.cssClasses, s = n.ROOT, a = n.UNBOUNDED;
      requestAnimationFrame(function() {
        i.adapter.addClass(s), i.adapter.isUnbounded() && (i.adapter.addClass(a), i.layoutInternal());
      });
    }
  }, t.prototype.destroy = function() {
    var i = this;
    if (this.supportsPressRipple()) {
      this.activationTimer && (clearTimeout(this.activationTimer), this.activationTimer = 0, this.adapter.removeClass(t.cssClasses.FG_ACTIVATION)), this.fgDeactivationRemovalTimer && (clearTimeout(this.fgDeactivationRemovalTimer), this.fgDeactivationRemovalTimer = 0, this.adapter.removeClass(t.cssClasses.FG_DEACTIVATION));
      var r = t.cssClasses, n = r.ROOT, s = r.UNBOUNDED;
      requestAnimationFrame(function() {
        i.adapter.removeClass(n), i.adapter.removeClass(s), i.removeCssVars();
      });
    }
    this.deregisterRootHandlers(), this.deregisterDeactivationHandlers();
  }, t.prototype.activate = function(i) {
    this.activateImpl(i);
  }, t.prototype.deactivate = function() {
    this.deactivateImpl();
  }, t.prototype.layout = function() {
    var i = this;
    this.layoutFrame && cancelAnimationFrame(this.layoutFrame), this.layoutFrame = requestAnimationFrame(function() {
      i.layoutInternal(), i.layoutFrame = 0;
    });
  }, t.prototype.setUnbounded = function(i) {
    var r = t.cssClasses.UNBOUNDED;
    i ? this.adapter.addClass(r) : this.adapter.removeClass(r);
  }, t.prototype.handleFocus = function() {
    var i = this;
    requestAnimationFrame(function() {
      return i.adapter.addClass(t.cssClasses.BG_FOCUSED);
    });
  }, t.prototype.handleBlur = function() {
    var i = this;
    requestAnimationFrame(function() {
      return i.adapter.removeClass(t.cssClasses.BG_FOCUSED);
    });
  }, t.prototype.supportsPressRipple = function() {
    return this.adapter.browserSupportsCssVars();
  }, t.prototype.defaultActivationState = function() {
    return { activationEvent: void 0, hasDeactivationUXRun: !1, isActivated: !1, isProgrammatic: !1, wasActivatedByPointer: !1, wasElementMadeActive: !1 };
  }, t.prototype.registerRootHandlers = function(i) {
    var r, n;
    if (i) {
      try {
        for (var s = js(TI), a = s.next(); !a.done; a = s.next()) {
          var o = a.value;
          this.adapter.registerInteractionHandler(o, this.activateHandler);
        }
      } catch (c) {
        r = { error: c };
      } finally {
        try {
          a && !a.done && (n = s.return) && n.call(s);
        } finally {
          if (r)
            throw r.error;
        }
      }
      this.adapter.isUnbounded() && this.adapter.registerResizeHandler(this.resizeHandler);
    }
    this.adapter.registerInteractionHandler("focus", this.focusHandler), this.adapter.registerInteractionHandler("blur", this.blurHandler);
  }, t.prototype.registerDeactivationHandlers = function(i) {
    var r, n;
    if (i.type === "keydown")
      this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
    else
      try {
        for (var s = js(EI), a = s.next(); !a.done; a = s.next()) {
          var o = a.value;
          this.adapter.registerDocumentInteractionHandler(o, this.deactivateHandler);
        }
      } catch (c) {
        r = { error: c };
      } finally {
        try {
          a && !a.done && (n = s.return) && n.call(s);
        } finally {
          if (r)
            throw r.error;
        }
      }
  }, t.prototype.deregisterRootHandlers = function() {
    var i, r;
    try {
      for (var n = js(TI), s = n.next(); !s.done; s = n.next()) {
        var a = s.value;
        this.adapter.deregisterInteractionHandler(a, this.activateHandler);
      }
    } catch (o) {
      i = { error: o };
    } finally {
      try {
        s && !s.done && (r = n.return) && r.call(n);
      } finally {
        if (i)
          throw i.error;
      }
    }
    this.adapter.deregisterInteractionHandler("focus", this.focusHandler), this.adapter.deregisterInteractionHandler("blur", this.blurHandler), this.adapter.isUnbounded() && this.adapter.deregisterResizeHandler(this.resizeHandler);
  }, t.prototype.deregisterDeactivationHandlers = function() {
    var i, r;
    this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
    try {
      for (var n = js(EI), s = n.next(); !s.done; s = n.next()) {
        var a = s.value;
        this.adapter.deregisterDocumentInteractionHandler(a, this.deactivateHandler);
      }
    } catch (o) {
      i = { error: o };
    } finally {
      try {
        s && !s.done && (r = n.return) && r.call(n);
      } finally {
        if (i)
          throw i.error;
      }
    }
  }, t.prototype.removeCssVars = function() {
    var i = this, r = t.strings;
    Object.keys(r).forEach(function(n) {
      n.indexOf("VAR_") === 0 && i.adapter.updateCssVariable(r[n], null);
    });
  }, t.prototype.activateImpl = function(i) {
    var r = this;
    if (!this.adapter.isSurfaceDisabled()) {
      var n = this.activationState;
      if (!n.isActivated) {
        var s = this.previousActivationEvent;
        s && i !== void 0 && s.type !== i.type || (n.isActivated = !0, n.isProgrammatic = i === void 0, n.activationEvent = i, n.wasActivatedByPointer = !n.isProgrammatic && i !== void 0 && (i.type === "mousedown" || i.type === "touchstart" || i.type === "pointerdown"), i !== void 0 && Lm.length > 0 && Lm.some(function(a) {
          return r.adapter.containsEventTarget(a);
        }) ? this.resetActivationState() : (i !== void 0 && (Lm.push(i.target), this.registerDeactivationHandlers(i)), n.wasElementMadeActive = this.checkElementMadeActive(i), n.wasElementMadeActive && this.animateActivation(), requestAnimationFrame(function() {
          Lm = [], n.wasElementMadeActive || i === void 0 || i.key !== " " && i.keyCode !== 32 || (n.wasElementMadeActive = r.checkElementMadeActive(i), n.wasElementMadeActive && r.animateActivation()), n.wasElementMadeActive || (r.activationState = r.defaultActivationState());
        })));
      }
    }
  }, t.prototype.checkElementMadeActive = function(i) {
    return i === void 0 || i.type !== "keydown" || this.adapter.isSurfaceActive();
  }, t.prototype.animateActivation = function() {
    var i = this, r = t.strings, n = r.VAR_FG_TRANSLATE_START, s = r.VAR_FG_TRANSLATE_END, a = t.cssClasses, o = a.FG_DEACTIVATION, c = a.FG_ACTIVATION, l = t.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal();
    var d = "", u = "";
    if (!this.adapter.isUnbounded()) {
      var h = this.getFgTranslationCoordinates(), p = h.startPoint, m = h.endPoint;
      d = p.x + "px, " + p.y + "px", u = m.x + "px, " + m.y + "px";
    }
    this.adapter.updateCssVariable(n, d), this.adapter.updateCssVariable(s, u), clearTimeout(this.activationTimer), clearTimeout(this.fgDeactivationRemovalTimer), this.rmBoundedActivationClasses(), this.adapter.removeClass(o), this.adapter.computeBoundingRect(), this.adapter.addClass(c), this.activationTimer = setTimeout(function() {
      i.activationTimerCallback();
    }, l);
  }, t.prototype.getFgTranslationCoordinates = function() {
    var i, r = this.activationState, n = r.activationEvent;
    return { startPoint: i = { x: (i = r.wasActivatedByPointer ? I$(n, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect()) : { x: this.frame.width / 2, y: this.frame.height / 2 }).x - this.initialSize / 2, y: i.y - this.initialSize / 2 }, endPoint: { x: this.frame.width / 2 - this.initialSize / 2, y: this.frame.height / 2 - this.initialSize / 2 } };
  }, t.prototype.runDeactivationUXLogicIfReady = function() {
    var i = this, r = t.cssClasses.FG_DEACTIVATION, n = this.activationState, s = n.hasDeactivationUXRun, a = n.isActivated;
    (s || !a) && this.activationAnimationHasEnded && (this.rmBoundedActivationClasses(), this.adapter.addClass(r), this.fgDeactivationRemovalTimer = setTimeout(function() {
      i.adapter.removeClass(r);
    }, AI.FG_DEACTIVATION_MS));
  }, t.prototype.rmBoundedActivationClasses = function() {
    var i = t.cssClasses.FG_ACTIVATION;
    this.adapter.removeClass(i), this.activationAnimationHasEnded = !1, this.adapter.computeBoundingRect();
  }, t.prototype.resetActivationState = function() {
    var i = this;
    this.previousActivationEvent = this.activationState.activationEvent, this.activationState = this.defaultActivationState(), setTimeout(function() {
      return i.previousActivationEvent = void 0;
    }, t.numbers.TAP_DELAY_MS);
  }, t.prototype.deactivateImpl = function() {
    var i = this, r = this.activationState;
    if (r.isActivated) {
      var n = Br({}, r);
      r.isProgrammatic ? (requestAnimationFrame(function() {
        i.animateDeactivation(n);
      }), this.resetActivationState()) : (this.deregisterDeactivationHandlers(), requestAnimationFrame(function() {
        i.activationState.hasDeactivationUXRun = !0, i.animateDeactivation(n), i.resetActivationState();
      }));
    }
  }, t.prototype.animateDeactivation = function(i) {
    var r = i.wasActivatedByPointer, n = i.wasElementMadeActive;
    (r || n) && this.runDeactivationUXLogicIfReady();
  }, t.prototype.layoutInternal = function() {
    var i = this;
    this.frame = this.adapter.computeBoundingRect();
    var r = Math.max(this.frame.height, this.frame.width);
    this.maxRadius = this.adapter.isUnbounded() ? r : Math.sqrt(Math.pow(i.frame.width, 2) + Math.pow(i.frame.height, 2)) + t.numbers.PADDING;
    var n = Math.floor(r * t.numbers.INITIAL_ORIGIN_SCALE);
    this.adapter.isUnbounded() && n % 2 != 0 ? this.initialSize = n - 1 : this.initialSize = n, this.fgScale = "" + this.maxRadius / this.initialSize, this.updateLayoutCssVars();
  }, t.prototype.updateLayoutCssVars = function() {
    var i = t.strings, r = i.VAR_FG_SIZE, n = i.VAR_LEFT, s = i.VAR_TOP, a = i.VAR_FG_SCALE;
    this.adapter.updateCssVariable(r, this.initialSize + "px"), this.adapter.updateCssVariable(a, this.fgScale), this.adapter.isUnbounded() && (this.unboundedCoords = { left: Math.round(this.frame.width / 2 - this.initialSize / 2), top: Math.round(this.frame.height / 2 - this.initialSize / 2) }, this.adapter.updateCssVariable(n, this.unboundedCoords.left + "px"), this.adapter.updateCssVariable(s, this.unboundedCoords.top + "px"));
  }, t;
})(Po);
function A$(e) {
  let t;
  const i = e[11].default, r = dy(i, e, e[13], null);
  return { c() {
    r && r.c();
  }, m(n, s) {
    r && r.m(n, s), t = !0;
  }, p(n, s) {
    r && r.p && (!t || 8192 & s) && hy(r, i, n, n[13], t ? uy(i, n[13], s, null) : fy(n[13]), null);
  }, i(n) {
    t || (Oa(r, n), t = !0);
  }, o(n) {
    Ao(r, n), t = !1;
  }, d(n) {
    r && r.d(n);
  } };
}
function T$(e) {
  let t, i, r;
  const n = [{ tag: e[3] }, { use: [e[8], ...e[0]] }, { class: zg({ [e[1]]: !0, [e[6]]: !0, ...e[5] }) }, e[7], e[9]];
  var s = e[2];
  function a(o) {
    let c = { $$slots: { default: [A$] }, $$scope: { ctx: o } };
    for (let l = 0; l < n.length; l += 1)
      c = ws(c, n[l]);
    return { props: c };
  }
  return s && (t = gI(s, a(e)), e[12](t)), { c() {
    t && _I(t.$$.fragment), i = py();
  }, m(o, c) {
    t && eb(t, o, c), Uc(o, i, c), r = !0;
  }, p(o, [c]) {
    const l = 1003 & c ? vp(n, [8 & c && { tag: o[3] }, 257 & c && { use: [o[8], ...o[0]] }, 98 & c && { class: zg({ [o[1]]: !0, [o[6]]: !0, ...o[5] }) }, 128 & c && vI(o[7]), 512 & c && vI(o[9])]) : {};
    if (8192 & c && (l.$$scope = { dirty: c, ctx: o }), 4 & c && s !== (s = o[2])) {
      if (t) {
        YT();
        const d = t;
        Ao(d.$$.fragment, 1, 0, () => {
          ib(d, 1);
        }), qT();
      }
      s ? (t = gI(s, a(o)), o[12](t), _I(t.$$.fragment), Oa(t.$$.fragment, 1), eb(t, i.parentNode, i)) : t = null;
    } else
      s && t.$set(l);
  }, i(o) {
    r || (t && Oa(t.$$.fragment, o), r = !0);
  }, o(o) {
    t && Ao(t.$$.fragment, o), r = !1;
  }, d(o) {
    e[12](null), o && Ro(i), t && ib(t, o);
  } };
}
const fo = { component: ZT, tag: "div", class: "", classMap: {}, contexts: {}, props: {} };
function E$(e, t, i) {
  const r = ["use", "class", "component", "tag", "getElement"];
  let n, s = Du(t, r), { $$slots: a = {}, $$scope: o } = t, { use: c = [] } = t, { class: l = "" } = t;
  const d = fo.class, u = {}, h = [], p = fo.contexts, m = fo.props;
  let { component: w = fo.component } = t, { tag: C = w === ZT ? fo.tag : void 0 } = t;
  Object.entries(fo.classMap).forEach(([W, et]) => {
    const E = HT(et);
    E && "subscribe" in E && h.push(E.subscribe((Z) => {
      i(5, u[W] = Z, u);
    }));
  });
  const F = A1(Ju());
  for (let W in p)
    p.hasOwnProperty(W) && W7(W, p[W]);
  return H7(() => {
    for (const W of h)
      W();
  }), e.$$set = (W) => {
    t = ws(ws({}, t), b1(W)), i(9, s = Du(t, r)), "use" in W && i(0, c = W.use), "class" in W && i(1, l = W.class), "component" in W && i(2, w = W.component), "tag" in W && i(3, C = W.tag), "$$scope" in W && i(13, o = W.$$scope);
  }, [c, l, w, C, n, u, d, m, F, s, function() {
    return n.getElement();
  }, a, function(W) {
    Fl[W ? "unshift" : "push"](() => {
      n = W, i(4, n);
    });
  }, o];
}
class k$ extends I1 {
  constructor(t) {
    super(), S1(this, t, E$, T$, yp, { use: 0, class: 1, component: 2, tag: 3, getElement: 10 });
  }
  get getElement() {
    return this.$$.ctx[10];
  }
}
const kI = Object.assign({}, fo);
function ja(e) {
  return new Proxy(k$, { construct: function(t, i) {
    return Object.assign(fo, kI, e), new t(...i);
  }, get: function(t, i) {
    return Object.assign(fo, kI, e), t[i];
  } });
}
ja({ class: "mdc-deprecated-list-item__text", tag: "span" });
ja({ class: "mdc-deprecated-list-item__primary-text", tag: "span" });
ja({ class: "mdc-deprecated-list-item__secondary-text", tag: "span" });
ja({ class: "mdc-deprecated-list-item__meta", tag: "span" });
ja({ class: "mdc-deprecated-list-group", tag: "div" });
ja({ class: "mdc-deprecated-list-group__subheader", tag: "h3" });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var C$ = { LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above", LABEL_REQUIRED: "mdc-floating-label--required", LABEL_SHAKE: "mdc-floating-label--shake", ROOT: "mdc-floating-label" };
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.shakeAnimationEndHandler = function() {
      r.handleShakeAnimationEnd();
    }, r;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return C$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, removeClass: function() {
    }, getWidth: function() {
      return 0;
    }, registerInteractionHandler: function() {
    }, deregisterInteractionHandler: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
  }, t.prototype.destroy = function() {
    this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
  }, t.prototype.getWidth = function() {
    return this.adapter.getWidth();
  }, t.prototype.shake = function(i) {
    var r = t.cssClasses.LABEL_SHAKE;
    i ? this.adapter.addClass(r) : this.adapter.removeClass(r);
  }, t.prototype.float = function(i) {
    var r = t.cssClasses, n = r.LABEL_FLOAT_ABOVE, s = r.LABEL_SHAKE;
    i ? this.adapter.addClass(n) : (this.adapter.removeClass(n), this.adapter.removeClass(s));
  }, t.prototype.setRequired = function(i) {
    var r = t.cssClasses.LABEL_REQUIRED;
    i ? this.adapter.addClass(r) : this.adapter.removeClass(r);
  }, t.prototype.handleShakeAnimationEnd = function() {
    var i = t.cssClasses.LABEL_SHAKE;
    this.adapter.removeClass(i);
  }, t;
})(Po);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ll = { LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active", LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating" };
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.transitionEndHandler = function(n) {
      r.handleTransitionEnd(n);
    }, r;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return ll;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, removeClass: function() {
    }, hasClass: function() {
      return !1;
    }, setStyle: function() {
    }, registerEventHandler: function() {
    }, deregisterEventHandler: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
  }, t.prototype.destroy = function() {
    this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
  }, t.prototype.activate = function() {
    this.adapter.removeClass(ll.LINE_RIPPLE_DEACTIVATING), this.adapter.addClass(ll.LINE_RIPPLE_ACTIVE);
  }, t.prototype.setRippleCenter = function(i) {
    this.adapter.setStyle("transform-origin", i + "px center");
  }, t.prototype.deactivate = function() {
    this.adapter.addClass(ll.LINE_RIPPLE_DEACTIVATING);
  }, t.prototype.handleTransitionEnd = function(i) {
    var r = this.adapter.hasClass(ll.LINE_RIPPLE_DEACTIVATING);
    i.propertyName === "opacity" && r && (this.adapter.removeClass(ll.LINE_RIPPLE_ACTIVE), this.adapter.removeClass(ll.LINE_RIPPLE_DEACTIVATING));
  }, t;
})(Po);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var O$ = { NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch" }, CI = { NOTCH_ELEMENT_PADDING: 8 }, D$ = { NO_LABEL: "mdc-notched-outline--no-label", OUTLINE_NOTCHED: "mdc-notched-outline--notched", OUTLINE_UPGRADED: "mdc-notched-outline--upgraded" };
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e) {
  function t(i) {
    return e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
  }
  return Mo(t, e), Object.defineProperty(t, "strings", { get: function() {
    return O$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "cssClasses", { get: function() {
    return D$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return CI;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, removeClass: function() {
    }, setNotchWidthProperty: function() {
    }, removeNotchWidthProperty: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.notch = function(i) {
    var r = t.cssClasses.OUTLINE_NOTCHED;
    i > 0 && (i += CI.NOTCH_ELEMENT_PADDING), this.adapter.setNotchWidthProperty(i), this.adapter.addClass(r);
  }, t.prototype.closeNotch = function() {
    var i = t.cssClasses.OUTLINE_NOTCHED;
    this.adapter.removeClass(i), this.adapter.removeNotchWidthProperty();
  }, t;
})(Po);
ja({ class: "mdc-text-field-helper-line", tag: "div" });
ja({ class: "mdc-text-field__affix mdc-text-field__affix--prefix", tag: "span" });
ja({ class: "mdc-text-field__affix mdc-text-field__affix--suffix", tag: "span" });
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var s_ = { ARIA_CONTROLS: "aria-controls", ARIA_DESCRIBEDBY: "aria-describedby", INPUT_SELECTOR: ".mdc-text-field__input", LABEL_SELECTOR: ".mdc-floating-label", LEADING_ICON_SELECTOR: ".mdc-text-field__icon--leading", LINE_RIPPLE_SELECTOR: ".mdc-line-ripple", OUTLINE_SELECTOR: ".mdc-notched-outline", PREFIX_SELECTOR: ".mdc-text-field__affix--prefix", SUFFIX_SELECTOR: ".mdc-text-field__affix--suffix", TRAILING_ICON_SELECTOR: ".mdc-text-field__icon--trailing" }, N$ = { DISABLED: "mdc-text-field--disabled", FOCUSED: "mdc-text-field--focused", HELPER_LINE: "mdc-text-field-helper-line", INVALID: "mdc-text-field--invalid", LABEL_FLOATING: "mdc-text-field--label-floating", NO_LABEL: "mdc-text-field--no-label", OUTLINED: "mdc-text-field--outlined", ROOT: "mdc-text-field", TEXTAREA: "mdc-text-field--textarea", WITH_LEADING_ICON: "mdc-text-field--with-leading-icon", WITH_TRAILING_ICON: "mdc-text-field--with-trailing-icon", WITH_INTERNAL_COUNTER: "mdc-text-field--with-internal-counter" }, OI = { LABEL_SCALE: 0.75 }, L$ = ["pattern", "min", "max", "required", "step", "minlength", "maxlength"], F$ = ["color", "date", "datetime-local", "month", "range", "time", "week"];
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var DI = ["mousedown", "touchstart"], NI = ["click", "keydown"];
(function(e) {
  function t(i, r) {
    r === void 0 && (r = {});
    var n = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return n.isFocused = !1, n.receivedUserInput = !1, n.valid = !0, n.useNativeValidation = !0, n.validateOnValueChange = !0, n.helperText = r.helperText, n.characterCounter = r.characterCounter, n.leadingIcon = r.leadingIcon, n.trailingIcon = r.trailingIcon, n.inputFocusHandler = function() {
      n.activateFocus();
    }, n.inputBlurHandler = function() {
      n.deactivateFocus();
    }, n.inputInputHandler = function() {
      n.handleInput();
    }, n.setPointerXOffset = function(s) {
      n.setTransformOrigin(s);
    }, n.textFieldInteractionHandler = function() {
      n.handleTextFieldInteraction();
    }, n.validationAttributeChangeHandler = function(s) {
      n.handleValidationAttributeChange(s);
    }, n;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return N$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "strings", { get: function() {
    return s_;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return OI;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "shouldAlwaysFloat", { get: function() {
    var i = this.getNativeInput().type;
    return F$.indexOf(i) >= 0;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "shouldFloat", { get: function() {
    return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() || this.isBadInput();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "shouldShake", { get: function() {
    return !this.isFocused && !this.isValid() && !!this.getValue();
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, removeClass: function() {
    }, hasClass: function() {
      return !0;
    }, setInputAttr: function() {
    }, removeInputAttr: function() {
    }, registerTextFieldInteractionHandler: function() {
    }, deregisterTextFieldInteractionHandler: function() {
    }, registerInputInteractionHandler: function() {
    }, deregisterInputInteractionHandler: function() {
    }, registerValidationAttributeChangeHandler: function() {
      return new MutationObserver(function() {
      });
    }, deregisterValidationAttributeChangeHandler: function() {
    }, getNativeInput: function() {
      return null;
    }, isFocused: function() {
      return !1;
    }, activateLineRipple: function() {
    }, deactivateLineRipple: function() {
    }, setLineRippleTransformOrigin: function() {
    }, shakeLabel: function() {
    }, floatLabel: function() {
    }, setLabelRequired: function() {
    }, hasLabel: function() {
      return !1;
    }, getLabelWidth: function() {
      return 0;
    }, hasOutline: function() {
      return !1;
    }, notchOutline: function() {
    }, closeOutline: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    var i, r, n, s;
    this.adapter.hasLabel() && this.getNativeInput().required && this.adapter.setLabelRequired(!0), this.adapter.isFocused() ? this.inputFocusHandler() : this.adapter.hasLabel() && this.shouldFloat && (this.notchOutline(!0), this.adapter.floatLabel(!0), this.styleFloating(!0)), this.adapter.registerInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.registerInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.registerInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var a = js(DI), o = a.next(); !o.done; o = a.next()) {
        var c = o.value;
        this.adapter.registerInputInteractionHandler(c, this.setPointerXOffset);
      }
    } catch (u) {
      i = { error: u };
    } finally {
      try {
        o && !o.done && (r = a.return) && r.call(a);
      } finally {
        if (i)
          throw i.error;
      }
    }
    try {
      for (var l = js(NI), d = l.next(); !d.done; d = l.next())
        c = d.value, this.adapter.registerTextFieldInteractionHandler(c, this.textFieldInteractionHandler);
    } catch (u) {
      n = { error: u };
    } finally {
      try {
        d && !d.done && (s = l.return) && s.call(l);
      } finally {
        if (n)
          throw n.error;
      }
    }
    this.validationObserver = this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler), this.setcharacterCounter(this.getValue().length);
  }, t.prototype.destroy = function() {
    var i, r, n, s;
    this.adapter.deregisterInputInteractionHandler("focus", this.inputFocusHandler), this.adapter.deregisterInputInteractionHandler("blur", this.inputBlurHandler), this.adapter.deregisterInputInteractionHandler("input", this.inputInputHandler);
    try {
      for (var a = js(DI), o = a.next(); !o.done; o = a.next()) {
        var c = o.value;
        this.adapter.deregisterInputInteractionHandler(c, this.setPointerXOffset);
      }
    } catch (u) {
      i = { error: u };
    } finally {
      try {
        o && !o.done && (r = a.return) && r.call(a);
      } finally {
        if (i)
          throw i.error;
      }
    }
    try {
      for (var l = js(NI), d = l.next(); !d.done; d = l.next())
        c = d.value, this.adapter.deregisterTextFieldInteractionHandler(c, this.textFieldInteractionHandler);
    } catch (u) {
      n = { error: u };
    } finally {
      try {
        d && !d.done && (s = l.return) && s.call(l);
      } finally {
        if (n)
          throw n.error;
      }
    }
    this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
  }, t.prototype.handleTextFieldInteraction = function() {
    var i = this.adapter.getNativeInput();
    i && i.disabled || (this.receivedUserInput = !0);
  }, t.prototype.handleValidationAttributeChange = function(i) {
    var r = this;
    i.some(function(n) {
      return L$.indexOf(n) > -1 && (r.styleValidity(!0), r.adapter.setLabelRequired(r.getNativeInput().required), !0);
    }), i.indexOf("maxlength") > -1 && this.setcharacterCounter(this.getValue().length);
  }, t.prototype.notchOutline = function(i) {
    if (this.adapter.hasOutline() && this.adapter.hasLabel())
      if (i) {
        var r = this.adapter.getLabelWidth() * OI.LABEL_SCALE;
        this.adapter.notchOutline(r);
      } else
        this.adapter.closeOutline();
  }, t.prototype.activateFocus = function() {
    this.isFocused = !0, this.styleFocused(this.isFocused), this.adapter.activateLineRipple(), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), !this.helperText || !this.helperText.isPersistent() && this.helperText.isValidation() && this.valid || this.helperText.showToScreenReader();
  }, t.prototype.setTransformOrigin = function(i) {
    if (!this.isDisabled() && !this.adapter.hasOutline()) {
      var r = i.touches, n = r ? r[0] : i, s = n.target.getBoundingClientRect(), a = n.clientX - s.left;
      this.adapter.setLineRippleTransformOrigin(a);
    }
  }, t.prototype.handleInput = function() {
    this.autoCompleteFocus(), this.setcharacterCounter(this.getValue().length);
  }, t.prototype.autoCompleteFocus = function() {
    this.receivedUserInput || this.activateFocus();
  }, t.prototype.deactivateFocus = function() {
    this.isFocused = !1, this.adapter.deactivateLineRipple();
    var i = this.isValid();
    this.styleValidity(i), this.styleFocused(this.isFocused), this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.adapter.shakeLabel(this.shouldShake)), this.shouldFloat || (this.receivedUserInput = !1);
  }, t.prototype.getValue = function() {
    return this.getNativeInput().value;
  }, t.prototype.setValue = function(i) {
    if (this.getValue() !== i && (this.getNativeInput().value = i), this.setcharacterCounter(i.length), this.validateOnValueChange) {
      var r = this.isValid();
      this.styleValidity(r);
    }
    this.adapter.hasLabel() && (this.notchOutline(this.shouldFloat), this.adapter.floatLabel(this.shouldFloat), this.styleFloating(this.shouldFloat), this.validateOnValueChange && this.adapter.shakeLabel(this.shouldShake));
  }, t.prototype.isValid = function() {
    return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
  }, t.prototype.setValid = function(i) {
    this.valid = i, this.styleValidity(i);
    var r = !i && !this.isFocused && !!this.getValue();
    this.adapter.hasLabel() && this.adapter.shakeLabel(r);
  }, t.prototype.setValidateOnValueChange = function(i) {
    this.validateOnValueChange = i;
  }, t.prototype.getValidateOnValueChange = function() {
    return this.validateOnValueChange;
  }, t.prototype.setUseNativeValidation = function(i) {
    this.useNativeValidation = i;
  }, t.prototype.isDisabled = function() {
    return this.getNativeInput().disabled;
  }, t.prototype.setDisabled = function(i) {
    this.getNativeInput().disabled = i, this.styleDisabled(i);
  }, t.prototype.setHelperTextContent = function(i) {
    this.helperText && this.helperText.setContent(i);
  }, t.prototype.setLeadingIconAriaLabel = function(i) {
    this.leadingIcon && this.leadingIcon.setAriaLabel(i);
  }, t.prototype.setLeadingIconContent = function(i) {
    this.leadingIcon && this.leadingIcon.setContent(i);
  }, t.prototype.setTrailingIconAriaLabel = function(i) {
    this.trailingIcon && this.trailingIcon.setAriaLabel(i);
  }, t.prototype.setTrailingIconContent = function(i) {
    this.trailingIcon && this.trailingIcon.setContent(i);
  }, t.prototype.setcharacterCounter = function(i) {
    if (this.characterCounter) {
      var r = this.getNativeInput().maxLength;
      if (r === -1)
        throw new Error("MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.");
      this.characterCounter.setCounterValue(i, r);
    }
  }, t.prototype.isBadInput = function() {
    return this.getNativeInput().validity.badInput || !1;
  }, t.prototype.isNativeInputValid = function() {
    return this.getNativeInput().validity.valid;
  }, t.prototype.styleValidity = function(i) {
    var r = t.cssClasses.INVALID;
    if (i ? this.adapter.removeClass(r) : this.adapter.addClass(r), this.helperText) {
      if (this.helperText.setValidity(i), !this.helperText.isValidation())
        return;
      var n = this.helperText.isVisible(), s = this.helperText.getId();
      n && s ? this.adapter.setInputAttr(s_.ARIA_DESCRIBEDBY, s) : this.adapter.removeInputAttr(s_.ARIA_DESCRIBEDBY);
    }
  }, t.prototype.styleFocused = function(i) {
    var r = t.cssClasses.FOCUSED;
    i ? this.adapter.addClass(r) : this.adapter.removeClass(r);
  }, t.prototype.styleDisabled = function(i) {
    var r = t.cssClasses, n = r.DISABLED, s = r.INVALID;
    i ? (this.adapter.addClass(n), this.adapter.removeClass(s)) : this.adapter.removeClass(n), this.leadingIcon && this.leadingIcon.setDisabled(i), this.trailingIcon && this.trailingIcon.setDisabled(i);
  }, t.prototype.styleFloating = function(i) {
    var r = t.cssClasses.LABEL_FLOATING;
    i ? this.adapter.addClass(r) : this.adapter.removeClass(r);
  }, t.prototype.getNativeInput = function() {
    return (this.adapter ? this.adapter.getNativeInput() : null) || { disabled: !1, maxLength: -1, required: !1, type: "input", validity: { badInput: !1, valid: !0 }, value: "" };
  }, t;
})(Po);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var LI = { ICON_EVENT: "MDCTextField:icon", ICON_ROLE: "button" }, B$ = { ROOT: "mdc-text-field__icon" };
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var FI = ["click", "keydown"];
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.savedTabIndex = null, r.interactionHandler = function(n) {
      r.handleInteraction(n);
    }, r;
  }
  return Mo(t, e), Object.defineProperty(t, "strings", { get: function() {
    return LI;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "cssClasses", { get: function() {
    return B$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { getAttr: function() {
      return null;
    }, setAttr: function() {
    }, removeAttr: function() {
    }, setContent: function() {
    }, registerInteractionHandler: function() {
    }, deregisterInteractionHandler: function() {
    }, notifyIconAction: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    var i, r;
    this.savedTabIndex = this.adapter.getAttr("tabindex");
    try {
      for (var n = js(FI), s = n.next(); !s.done; s = n.next()) {
        var a = s.value;
        this.adapter.registerInteractionHandler(a, this.interactionHandler);
      }
    } catch (o) {
      i = { error: o };
    } finally {
      try {
        s && !s.done && (r = n.return) && r.call(n);
      } finally {
        if (i)
          throw i.error;
      }
    }
  }, t.prototype.destroy = function() {
    var i, r;
    try {
      for (var n = js(FI), s = n.next(); !s.done; s = n.next()) {
        var a = s.value;
        this.adapter.deregisterInteractionHandler(a, this.interactionHandler);
      }
    } catch (o) {
      i = { error: o };
    } finally {
      try {
        s && !s.done && (r = n.return) && r.call(n);
      } finally {
        if (i)
          throw i.error;
      }
    }
  }, t.prototype.setDisabled = function(i) {
    this.savedTabIndex && (i ? (this.adapter.setAttr("tabindex", "-1"), this.adapter.removeAttr("role")) : (this.adapter.setAttr("tabindex", this.savedTabIndex), this.adapter.setAttr("role", LI.ICON_ROLE)));
  }, t.prototype.setAriaLabel = function(i) {
    this.adapter.setAttr("aria-label", i);
  }, t.prototype.setContent = function(i) {
    this.adapter.setContent(i);
  }, t.prototype.handleInteraction = function(i) {
    var r = i.key === "Enter" || i.keyCode === 13;
    (i.type === "click" || r) && (i.preventDefault(), this.adapter.notifyIconAction());
  }, t;
})(Po);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var Fr, xf, R$ = { ANCHOR: "mdc-menu-surface--anchor", ANIMATING_CLOSED: "mdc-menu-surface--animating-closed", ANIMATING_OPEN: "mdc-menu-surface--animating-open", FIXED: "mdc-menu-surface--fixed", IS_OPEN_BELOW: "mdc-menu-surface--is-open-below", OPEN: "mdc-menu-surface--open", ROOT: "mdc-menu-surface" }, M$ = { CLOSED_EVENT: "MDCMenuSurface:closed", CLOSING_EVENT: "MDCMenuSurface:closing", OPENED_EVENT: "MDCMenuSurface:opened", OPENING_EVENT: "MDCMenuSurface:opening", FOCUSABLE_ELEMENTS: ["button:not(:disabled)", '[href]:not([aria-disabled="true"])', "input:not(:disabled)", "select:not(:disabled)", "textarea:not(:disabled)", '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'].join(", ") }, Uh = { TRANSITION_OPEN_DURATION: 120, TRANSITION_CLOSE_DURATION: 75, MARGIN_TO_EDGE: 32, ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67, TOUCH_EVENT_WAIT_MS: 30 };
(function(e) {
  e[e.BOTTOM = 1] = "BOTTOM", e[e.CENTER = 2] = "CENTER", e[e.RIGHT = 4] = "RIGHT", e[e.FLIP_RTL = 8] = "FLIP_RTL";
})(Fr || (Fr = {})), function(e) {
  e[e.TOP_LEFT = 0] = "TOP_LEFT", e[e.TOP_RIGHT = 4] = "TOP_RIGHT", e[e.BOTTOM_LEFT = 1] = "BOTTOM_LEFT", e[e.BOTTOM_RIGHT = 5] = "BOTTOM_RIGHT", e[e.TOP_START = 8] = "TOP_START", e[e.TOP_END = 12] = "TOP_END", e[e.BOTTOM_START = 9] = "BOTTOM_START", e[e.BOTTOM_END = 13] = "BOTTOM_END";
}(xf || (xf = {}));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var P$ = function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.isSurfaceOpen = !1, r.isQuickOpen = !1, r.isHoistedElement = !1, r.isFixedPosition = !1, r.isHorizontallyCenteredOnViewport = !1, r.maxHeight = 0, r.openBottomBias = 0, r.openAnimationEndTimerId = 0, r.closeAnimationEndTimerId = 0, r.animationRequestId = 0, r.anchorCorner = xf.TOP_START, r.originCorner = xf.TOP_START, r.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 }, r.position = { x: 0, y: 0 }, r;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return R$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "strings", { get: function() {
    return M$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return Uh;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "Corner", { get: function() {
    return xf;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClass: function() {
    }, removeClass: function() {
    }, hasClass: function() {
      return !1;
    }, hasAnchor: function() {
      return !1;
    }, isElementInContainer: function() {
      return !1;
    }, isFocused: function() {
      return !1;
    }, isRtl: function() {
      return !1;
    }, getInnerDimensions: function() {
      return { height: 0, width: 0 };
    }, getAnchorDimensions: function() {
      return null;
    }, getWindowDimensions: function() {
      return { height: 0, width: 0 };
    }, getBodyDimensions: function() {
      return { height: 0, width: 0 };
    }, getWindowScroll: function() {
      return { x: 0, y: 0 };
    }, setPosition: function() {
    }, setMaxHeight: function() {
    }, setTransformOrigin: function() {
    }, saveFocus: function() {
    }, restoreFocus: function() {
    }, notifyClose: function() {
    }, notifyClosing: function() {
    }, notifyOpen: function() {
    }, notifyOpening: function() {
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.init = function() {
    var i = t.cssClasses, r = i.ROOT, n = i.OPEN;
    if (!this.adapter.hasClass(r))
      throw new Error(r + " class required in root element.");
    this.adapter.hasClass(n) && (this.isSurfaceOpen = !0);
  }, t.prototype.destroy = function() {
    clearTimeout(this.openAnimationEndTimerId), clearTimeout(this.closeAnimationEndTimerId), cancelAnimationFrame(this.animationRequestId);
  }, t.prototype.setAnchorCorner = function(i) {
    this.anchorCorner = i;
  }, t.prototype.flipCornerHorizontally = function() {
    this.originCorner = this.originCorner ^ Fr.RIGHT;
  }, t.prototype.setAnchorMargin = function(i) {
    this.anchorMargin.top = i.top || 0, this.anchorMargin.right = i.right || 0, this.anchorMargin.bottom = i.bottom || 0, this.anchorMargin.left = i.left || 0;
  }, t.prototype.setIsHoisted = function(i) {
    this.isHoistedElement = i;
  }, t.prototype.setFixedPosition = function(i) {
    this.isFixedPosition = i;
  }, t.prototype.isFixed = function() {
    return this.isFixedPosition;
  }, t.prototype.setAbsolutePosition = function(i, r) {
    this.position.x = this.isFinite(i) ? i : 0, this.position.y = this.isFinite(r) ? r : 0;
  }, t.prototype.setIsHorizontallyCenteredOnViewport = function(i) {
    this.isHorizontallyCenteredOnViewport = i;
  }, t.prototype.setQuickOpen = function(i) {
    this.isQuickOpen = i;
  }, t.prototype.setMaxHeight = function(i) {
    this.maxHeight = i;
  }, t.prototype.setOpenBottomBias = function(i) {
    this.openBottomBias = i;
  }, t.prototype.isOpen = function() {
    return this.isSurfaceOpen;
  }, t.prototype.open = function() {
    var i = this;
    this.isSurfaceOpen || (this.adapter.notifyOpening(), this.adapter.saveFocus(), this.isQuickOpen ? (this.isSurfaceOpen = !0, this.adapter.addClass(t.cssClasses.OPEN), this.dimensions = this.adapter.getInnerDimensions(), this.autoposition(), this.adapter.notifyOpen()) : (this.adapter.addClass(t.cssClasses.ANIMATING_OPEN), this.animationRequestId = requestAnimationFrame(function() {
      i.dimensions = i.adapter.getInnerDimensions(), i.autoposition(), i.adapter.addClass(t.cssClasses.OPEN), i.openAnimationEndTimerId = setTimeout(function() {
        i.openAnimationEndTimerId = 0, i.adapter.removeClass(t.cssClasses.ANIMATING_OPEN), i.adapter.notifyOpen();
      }, Uh.TRANSITION_OPEN_DURATION);
    }), this.isSurfaceOpen = !0));
  }, t.prototype.close = function(i) {
    var r = this;
    if (i === void 0 && (i = !1), this.isSurfaceOpen) {
      if (this.adapter.notifyClosing(), this.isQuickOpen)
        return this.isSurfaceOpen = !1, i || this.maybeRestoreFocus(), this.adapter.removeClass(t.cssClasses.OPEN), this.adapter.removeClass(t.cssClasses.IS_OPEN_BELOW), void this.adapter.notifyClose();
      this.adapter.addClass(t.cssClasses.ANIMATING_CLOSED), requestAnimationFrame(function() {
        r.adapter.removeClass(t.cssClasses.OPEN), r.adapter.removeClass(t.cssClasses.IS_OPEN_BELOW), r.closeAnimationEndTimerId = setTimeout(function() {
          r.closeAnimationEndTimerId = 0, r.adapter.removeClass(t.cssClasses.ANIMATING_CLOSED), r.adapter.notifyClose();
        }, Uh.TRANSITION_CLOSE_DURATION);
      }), this.isSurfaceOpen = !1, i || this.maybeRestoreFocus();
    }
  }, t.prototype.handleBodyClick = function(i) {
    var r = i.target;
    this.adapter.isElementInContainer(r) || this.close();
  }, t.prototype.handleKeydown = function(i) {
    var r = i.keyCode;
    (i.key === "Escape" || r === 27) && this.close();
  }, t.prototype.autoposition = function() {
    var i;
    this.measurements = this.getAutoLayoutmeasurements();
    var r = this.getoriginCorner(), n = this.getMenuSurfaceMaxHeight(r), s = this.hasBit(r, Fr.BOTTOM) ? "bottom" : "top", a = this.hasBit(r, Fr.RIGHT) ? "right" : "left", o = this.getHorizontalOriginOffset(r), c = this.getVerticalOriginOffset(r), l = this.measurements, d = l.anchorSize, u = l.surfaceSize, h = ((i = {})[a] = o, i[s] = c, i);
    d.width / u.width > Uh.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO && (a = "center"), (this.isHoistedElement || this.isFixedPosition) && this.adjustPositionForHoistedElement(h), this.adapter.setTransformOrigin(a + " " + s), this.adapter.setPosition(h), this.adapter.setMaxHeight(n ? n + "px" : ""), this.hasBit(r, Fr.BOTTOM) || this.adapter.addClass(t.cssClasses.IS_OPEN_BELOW);
  }, t.prototype.getAutoLayoutmeasurements = function() {
    var i = this.adapter.getAnchorDimensions(), r = this.adapter.getBodyDimensions(), n = this.adapter.getWindowDimensions(), s = this.adapter.getWindowScroll();
    return i || (i = { top: this.position.y, right: this.position.x, bottom: this.position.y, left: this.position.x, width: 0, height: 0 }), { anchorSize: i, bodySize: r, surfaceSize: this.dimensions, viewportDistance: { top: i.top, right: n.width - i.right, bottom: n.height - i.bottom, left: i.left }, viewportSize: n, windowScroll: s };
  }, t.prototype.getoriginCorner = function() {
    var i, r, n = this.originCorner, s = this.measurements, a = s.viewportDistance, o = s.anchorSize, c = s.surfaceSize, l = t.numbers.MARGIN_TO_EDGE;
    this.hasBit(this.anchorCorner, Fr.BOTTOM) ? (i = a.top - l + this.anchorMargin.bottom, r = a.bottom - l - this.anchorMargin.bottom) : (i = a.top - l + this.anchorMargin.top, r = a.bottom - l + o.height - this.anchorMargin.top), !(r - c.height > 0) && i > r + this.openBottomBias && (n = this.setBit(n, Fr.BOTTOM));
    var d, u, h = this.adapter.isRtl(), p = this.hasBit(this.anchorCorner, Fr.FLIP_RTL), m = this.hasBit(this.anchorCorner, Fr.RIGHT) || this.hasBit(n, Fr.RIGHT), w = !1;
    (w = h && p ? !m : m) ? (d = a.left + o.width + this.anchorMargin.right, u = a.right - this.anchorMargin.right) : (d = a.left + this.anchorMargin.left, u = a.right + o.width - this.anchorMargin.left);
    var C = d - c.width > 0, F = u - c.width > 0, W = this.hasBit(n, Fr.FLIP_RTL) && this.hasBit(n, Fr.RIGHT);
    return F && W && h || !C && W ? n = this.unsetBit(n, Fr.RIGHT) : (C && w && h || C && !w && m || !F && d >= u) && (n = this.setBit(n, Fr.RIGHT)), n;
  }, t.prototype.getMenuSurfaceMaxHeight = function(i) {
    if (this.maxHeight > 0)
      return this.maxHeight;
    var r = this.measurements.viewportDistance, n = 0, s = this.hasBit(i, Fr.BOTTOM), a = this.hasBit(this.anchorCorner, Fr.BOTTOM), o = t.numbers.MARGIN_TO_EDGE;
    return s ? (n = r.top + this.anchorMargin.top - o, a || (n += this.measurements.anchorSize.height)) : (n = r.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - o, a && (n -= this.measurements.anchorSize.height)), n;
  }, t.prototype.getHorizontalOriginOffset = function(i) {
    var r = this.measurements.anchorSize, n = this.hasBit(i, Fr.RIGHT), s = this.hasBit(this.anchorCorner, Fr.RIGHT);
    if (n) {
      var a = s ? r.width - this.anchorMargin.left : this.anchorMargin.right;
      return this.isHoistedElement || this.isFixedPosition ? a - (this.measurements.viewportSize.width - this.measurements.bodySize.width) : a;
    }
    return s ? r.width - this.anchorMargin.right : this.anchorMargin.left;
  }, t.prototype.getVerticalOriginOffset = function(i) {
    var r = this.measurements.anchorSize, n = this.hasBit(i, Fr.BOTTOM), s = this.hasBit(this.anchorCorner, Fr.BOTTOM);
    return n ? s ? r.height - this.anchorMargin.top : -this.anchorMargin.bottom : s ? r.height + this.anchorMargin.bottom : this.anchorMargin.top;
  }, t.prototype.adjustPositionForHoistedElement = function(i) {
    var r, n, s = this.measurements, a = s.windowScroll, o = s.viewportDistance, c = s.surfaceSize, l = s.viewportSize, d = Object.keys(i);
    try {
      for (var u = js(d), h = u.next(); !h.done; h = u.next()) {
        var p = h.value, m = i[p] || 0;
        !this.isHorizontallyCenteredOnViewport || p !== "left" && p !== "right" ? (m += o[p], this.isFixedPosition || (p === "top" ? m += a.y : p === "bottom" ? m -= a.y : p === "left" ? m += a.x : m -= a.x), i[p] = m) : i[p] = (l.width - c.width) / 2;
      }
    } catch (w) {
      r = { error: w };
    } finally {
      try {
        h && !h.done && (n = u.return) && n.call(u);
      } finally {
        if (r)
          throw r.error;
      }
    }
  }, t.prototype.maybeRestoreFocus = function() {
    var i = this, r = this.adapter.isFocused(), n = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document, s = n.activeElement && this.adapter.isElementInContainer(n.activeElement);
    (r || s) && setTimeout(function() {
      i.adapter.restoreFocus();
    }, Uh.TOUCH_EVENT_WAIT_MS);
  }, t.prototype.hasBit = function(i, r) {
    return !!(i & r);
  }, t.prototype.setBit = function(i, r) {
    return i | r;
  }, t.prototype.unsetBit = function(i, r) {
    return i ^ r;
  }, t.prototype.isFinite = function(i) {
    return typeof i == "number" && isFinite(i);
  }, t;
}(Po);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var eu, a_ = { MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected", MENU_SELECTION_GROUP: "mdc-menu__selection-group", ROOT: "mdc-menu" }, wd = { ARIA_CHECKED_ATTR: "aria-checked", ARIA_DISABLED_ATTR: "aria-disabled", CHECKBOX_SELECTOR: 'input[type="checkbox"]', LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list", SELECTED_EVENT: "MDCMenu:selected", SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus" }, $$ = { FOCUS_ROOT_INDEX: -1 };
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.LIST_ROOT = 1] = "LIST_ROOT", e[e.FIRST_ITEM = 2] = "FIRST_ITEM", e[e.LAST_ITEM = 3] = "LAST_ITEM";
})(eu || (eu = {}));
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(e) {
  function t(i) {
    var r = e.call(this, Br(Br({}, t.defaultAdapter), i)) || this;
    return r.closeAnimationEndTimerId = 0, r.defaultFocusState = eu.LIST_ROOT, r.selectedIndex = -1, r;
  }
  return Mo(t, e), Object.defineProperty(t, "cssClasses", { get: function() {
    return a_;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "strings", { get: function() {
    return wd;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "numbers", { get: function() {
    return $$;
  }, enumerable: !1, configurable: !0 }), Object.defineProperty(t, "defaultAdapter", { get: function() {
    return { addClassToElementAtIndex: function() {
    }, removeClassFromElementAtIndex: function() {
    }, addAttributeToElementAtIndex: function() {
    }, removeAttributeFromElementAtIndex: function() {
    }, getAttributeFromElementAtIndex: function() {
      return null;
    }, elementContainsClass: function() {
      return !1;
    }, closeSurface: function() {
    }, getElementIndex: function() {
      return -1;
    }, notifySelected: function() {
    }, getMenuItemCount: function() {
      return 0;
    }, focusItemAtIndex: function() {
    }, focusListRoot: function() {
    }, getSelectedSiblingOfItemAtIndex: function() {
      return -1;
    }, isSelectableItemAtIndex: function() {
      return !1;
    } };
  }, enumerable: !1, configurable: !0 }), t.prototype.destroy = function() {
    this.closeAnimationEndTimerId && clearTimeout(this.closeAnimationEndTimerId), this.adapter.closeSurface();
  }, t.prototype.handleKeydown = function(i) {
    var r = i.key, n = i.keyCode;
    (r === "Tab" || n === 9) && this.adapter.closeSurface(!0);
  }, t.prototype.handleItemAction = function(i) {
    var r = this, n = this.adapter.getElementIndex(i);
    if (!(n < 0)) {
      this.adapter.notifySelected({ index: n });
      var s = this.adapter.getAttributeFromElementAtIndex(n, wd.SKIP_RESTORE_FOCUS) === "true";
      this.adapter.closeSurface(s), this.closeAnimationEndTimerId = setTimeout(function() {
        var a = r.adapter.getElementIndex(i);
        a >= 0 && r.adapter.isSelectableItemAtIndex(a) && r.setSelectedIndex(a);
      }, P$.numbers.TRANSITION_CLOSE_DURATION);
    }
  }, t.prototype.handleMenuSurfaceOpened = function() {
    switch (this.defaultFocusState) {
      case eu.FIRST_ITEM:
        this.adapter.focusItemAtIndex(0);
        break;
      case eu.LAST_ITEM:
        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
        break;
      case eu.NONE:
        break;
      default:
        this.adapter.focusListRoot();
    }
  }, t.prototype.setDefaultFocusState = function(i) {
    this.defaultFocusState = i;
  }, t.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  }, t.prototype.setSelectedIndex = function(i) {
    if (this.validatedIndex(i), !this.adapter.isSelectableItemAtIndex(i))
      throw new Error("MDCMenuFoundation: No selection group at specified index.");
    var r = this.adapter.getSelectedSiblingOfItemAtIndex(i);
    r >= 0 && (this.adapter.removeAttributeFromElementAtIndex(r, wd.ARIA_CHECKED_ATTR), this.adapter.removeClassFromElementAtIndex(r, a_.MENU_SELECTED_LIST_ITEM)), this.adapter.addClassToElementAtIndex(i, a_.MENU_SELECTED_LIST_ITEM), this.adapter.addAttributeToElementAtIndex(i, wd.ARIA_CHECKED_ATTR, "true"), this.selectedIndex = i;
  }, t.prototype.setEnabled = function(i, r) {
    this.validatedIndex(i), r ? (this.adapter.removeClassFromElementAtIndex(i, pi.LIST_ITEM_DISABLED_CLASS), this.adapter.addAttributeToElementAtIndex(i, wd.ARIA_DISABLED_ATTR, "false")) : (this.adapter.addClassToElementAtIndex(i, pi.LIST_ITEM_DISABLED_CLASS), this.adapter.addAttributeToElementAtIndex(i, wd.ARIA_DISABLED_ATTR, "true"));
  }, t.prototype.validatedIndex = function(i) {
    var r = this.adapter.getMenuItemCount();
    if (!(i >= 0 && i < r))
      throw new Error("MDCMenuFoundation: No list item at specified index.");
  }, t;
})(Po);
function z$(e) {
  let t, i, r, n, s, a;
  const o = e[8].default, c = dy(o, e, e[7], null);
  let l = [{ class: i = zg({ [e[1]]: !0, "mdc-deprecated-list-item__graphic": !0, "mdc-menu__selection-group-icon": e[4] }) }, e[5]], d = {};
  for (let u = 0; u < l.length; u += 1)
    d = ws(d, l[u]);
  return { c() {
    t = x1("span"), c && c.c(), J_(t, d);
  }, m(u, h) {
    Uc(u, t, h), c && c.m(t, null), e[9](t), n = !0, s || (a = [wc(r = my.call(null, t, e[0])), wc(e[3].call(null, t))], s = !0);
  }, p(u, [h]) {
    c && c.p && (!n || 128 & h) && hy(c, o, u, u[7], n ? uy(o, u[7], h, null) : fy(u[7]), null), J_(t, d = vp(l, [(!n || 2 & h && i !== (i = zg({ [u[1]]: !0, "mdc-deprecated-list-item__graphic": !0, "mdc-menu__selection-group-icon": u[4] }))) && { class: i }, 32 & h && u[5]])), r && ql(r.update) && 1 & h && r.update.call(null, u[0]);
  }, i(u) {
    n || (Oa(c, u), n = !0);
  }, o(u) {
    Ao(c, u), n = !1;
  }, d(u) {
    u && Ro(t), c && c.d(u), e[9](null), s = !1, Bo(a);
  } };
}
function U$(e, t, i) {
  const r = ["use", "class", "getElement"];
  let n = Du(t, r), { $$slots: s = {}, $$scope: a } = t;
  const o = A1(Ju());
  let c, { use: l = [] } = t, { class: d = "" } = t, u = HT("SMUI:list:graphic:menu-selection-group");
  return e.$$set = (h) => {
    t = ws(ws({}, t), b1(h)), i(5, n = Du(t, r)), "use" in h && i(0, l = h.use), "class" in h && i(1, d = h.class), "$$scope" in h && i(7, a = h.$$scope);
  }, [l, d, c, o, u, n, function() {
    return c;
  }, a, s, function(h) {
    Fl[h ? "unshift" : "push"](() => {
      c = h, i(2, c);
    });
  }];
}
class V$ extends I1 {
  constructor(t) {
    super(), S1(this, t, U$, z$, yp, { use: 0, class: 1, getElement: 6 });
  }
  get getElement() {
    return this.$$.ctx[6];
  }
}
ja({ class: "mdc-menu__selection-group-icon", component: V$ });
var j$ = '.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:text;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);left:0;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.15rem;overflow:hidden;position:absolute;text-align:left;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);-webkit-transform-origin:left top;transform-origin:left top;transition:transform .15s cubic-bezier(.4,0,.2,1),color .15s cubic-bezier(.4,0,.2,1);white-space:nowrap;will-change:transform}.mdc-floating-label[dir=rtl],[dir=rtl] .mdc-floating-label{left:auto;right:0;text-align:right;-webkit-transform-origin:right top;transform-origin:right top}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:after{content:"*";margin-left:1px;margin-right:0}.mdc-floating-label--required[dir=rtl]:after,[dir=rtl] .mdc-floating-label--required:after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard .25s 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(0) translateY(-106%) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-106%) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-106%) scale(.75)}to{transform:translateX(0) translateY(-106%) scale(.75)}}.smui-floating-label--remove-transition{transition:unset!important}.smui-floating-label--force-size{position:absolute!important;transform:unset!important}.mdc-line-ripple:after,.mdc-line-ripple:before{border-bottom-style:solid;bottom:0;content:"";left:0;position:absolute;width:100%}.mdc-line-ripple:before{border-bottom-width:1px;z-index:1}.mdc-line-ripple:after{border-bottom-width:2px;opacity:0;transform:scaleX(0);transition:transform .18s cubic-bezier(.4,0,.2,1),opacity .18s cubic-bezier(.4,0,.2,1);z-index:2}.mdc-line-ripple--active:after{opacity:1;transform:scaleX(1)}.mdc-line-ripple--deactivating:after{opacity:0}.mdc-deprecated-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87));font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);line-height:1.5rem;list-style-type:none;margin:0;padding:8px 0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-deprecated-list:focus{outline:none}.mdc-deprecated-list-item__secondary-text{color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background,rgba(0,0,0,.54))}.mdc-deprecated-list-item__graphic{background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background,rgba(0,0,0,.38))}.mdc-deprecated-list-item__meta{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__text{opacity:.38}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__secondary-text,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__text{color:#000;color:var(--mdc-theme-on-surface,#000)}.mdc-deprecated-list-item--activated,.mdc-deprecated-list-item--activated .mdc-deprecated-list-item__graphic,.mdc-deprecated-list-item--selected,.mdc-deprecated-list-item--selected .mdc-deprecated-list-item__graphic{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-deprecated-list--dense{font-size:.812rem;padding-bottom:4px;padding-top:4px}.mdc-deprecated-list-item__wrapper{display:block}.mdc-deprecated-list-item{align-items:center;display:flex;height:48px;justify-content:flex-start;overflow:hidden;padding:0 16px;position:relative}.mdc-deprecated-list-item:focus{outline:none}.mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-deprecated-list-item:not(.mdc-deprecated-list-item--selected):focus:before{border:1px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-deprecated-list-item:not(.mdc-deprecated-list-item--selected):focus:before{border-color:CanvasText}}.mdc-deprecated-list-item.mdc-deprecated-list-item--selected:before{border:3px double transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-deprecated-list-item.mdc-deprecated-list-item--selected:before{border-color:CanvasText}}.mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item{height:56px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item{height:72px;padding-left:16px;padding-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-item{padding-left:16px;padding-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item{height:72px;padding-left:0;padding-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-item{padding-left:16px;padding-right:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{height:20px;margin-left:0;margin-right:16px;width:20px}.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list-item__graphic{fill:currentColor;align-items:center;flex-shrink:0;height:24px;justify-content:center;margin-left:0;margin-right:32px;object-fit:cover;width:24px}.mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list-item__graphic{margin-left:32px;margin-right:0}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{height:24px;margin-left:0;margin-right:32px;width:24px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{margin-left:32px;margin-right:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic{border-radius:50%;height:40px;margin-left:0;margin-right:16px;width:40px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic{height:40px;margin-left:0;margin-right:16px;width:40px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic{height:56px;margin-left:0;margin-right:16px;width:56px}.mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic{height:56px;margin-left:0;margin-right:16px;width:100px}.mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}.mdc-deprecated-list .mdc-deprecated-list-item__graphic{display:inline-flex}.mdc-deprecated-list-item__meta{margin-left:auto;margin-right:0}.mdc-deprecated-list-item__meta:not(.material-icons){-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit)}.mdc-deprecated-list-item[dir=rtl] .mdc-deprecated-list-item__meta,[dir=rtl] .mdc-deprecated-list-item .mdc-deprecated-list-item__meta{margin-left:0;margin-right:auto}.mdc-deprecated-list-item__text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mdc-deprecated-list-item__text[for]{pointer-events:none}.mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text:before,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--image-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item__primary-text:after,.mdc-deprecated-list--video-list .mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text:before{content:"";display:inline-block;height:24px;vertical-align:0;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-deprecated-list-item__secondary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-body2-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.875rem;font-size:var(--mdc-typography-body2-font-size,.875rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight,400);letter-spacing:.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing,.0178571429em);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height,1.25rem);line-height:normal;margin-top:0;overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform,inherit);white-space:nowrap}.mdc-deprecated-list-item__secondary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-deprecated-list--dense .mdc-deprecated-list-item__secondary-text{font-size:inherit}.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:40px}.mdc-deprecated-list--two-line .mdc-deprecated-list-item__text{align-self:flex-start}.mdc-deprecated-list--two-line .mdc-deprecated-list-item{height:64px}.mdc-deprecated-list--two-line.mdc-deprecated-list--avatar-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--icon-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--image-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--video-list .mdc-deprecated-list-item{height:72px}.mdc-deprecated-list--two-line.mdc-deprecated-list--icon-list .mdc-deprecated-list-item__graphic{align-self:flex-start;margin-top:16px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item,.mdc-deprecated-list--two-line.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:60px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{height:36px;margin-left:0;margin-right:16px;width:36px}.mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list.mdc-deprecated-list--dense .mdc-deprecated-list-item__graphic{margin-left:16px;margin-right:0}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item{cursor:pointer}a.mdc-deprecated-list-item{color:inherit;text-decoration:none}.mdc-deprecated-list-divider{border:none;border-bottom:1px solid;border-bottom-color:rgba(0,0,0,.12);height:0;margin:0}.mdc-deprecated-list-divider--padded{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list-divider--padded[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--padded{margin-left:0;margin-right:16px}.mdc-deprecated-list-divider--inset{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list-divider--inset[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--inset{margin-left:0;margin-right:72px}.mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded[dir=rtl],[dir=rtl] .mdc-deprecated-list-divider--inset.mdc-deprecated-list-divider--padded{margin-left:0;margin-right:72px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--icon-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--avatar-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading{margin-left:72px;margin-right:0;width:calc(100% - 72px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:72px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:72px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:72px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--thumbnail-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading{margin-left:88px;margin-right:0;width:calc(100% - 88px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:88px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:88px;margin-right:0;width:calc(100% - 104px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:88px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:16px;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:16px;margin-right:0;width:calc(100% - 32px)}.mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--image-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:16px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading{margin-left:116px;margin-right:0;width:calc(100% - 116px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading{margin-left:0;margin-right:116px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-trailing{width:calc(100% - 16px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:116px;margin-right:0;width:calc(100% - 132px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing{margin-left:0;margin-right:116px}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:0;width:100%}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--padding{margin-left:0;margin-right:0}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:0;width:calc(100% - 16px)}.mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding[dir=rtl],[dir=rtl] .mdc-deprecated-list--video-list .mdc-deprecated-list-divider--inset-leading.mdc-deprecated-list-divider--inset-trailing.mdc-deprecated-list-divider--inset-padding{margin-left:0;margin-right:0}.mdc-deprecated-list-group .mdc-deprecated-list{padding:0}.mdc-deprecated-list-group__subheader{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);margin:.75rem 16px;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list-item__primary-text{color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}.mdc-list-item__secondary-text{color:rgba(0,0,0,.54);color:var(--mdc-theme-text-secondary-on-background,rgba(0,0,0,.54))}.mdc-list-item__overline-text{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--with-trailing-icon .mdc-list-item__end{background-color:transparent;color:rgba(0,0,0,.38);color:var(--mdc-theme-text-icon-on-background,rgba(0,0,0,.38))}.mdc-list-item__end{color:rgba(0,0,0,.38);color:var(--mdc-theme-text-hint-on-background,rgba(0,0,0,.38))}.mdc-list-item--disabled .mdc-list-item__content,.mdc-list-item--disabled .mdc-list-item__end,.mdc-list-item--disabled .mdc-list-item__start{opacity:.38}.mdc-list-item--disabled .mdc-list-item__overline-text,.mdc-list-item--disabled .mdc-list-item__primary-text,.mdc-list-item--disabled .mdc-list-item__secondary-text,.mdc-list-item--disabled.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--disabled.mdc-list-item--with-trailing-icon .mdc-list-item__end,.mdc-list-item--disabled.mdc-list-item--with-trailing-meta .mdc-list-item__end{color:#000;color:var(--mdc-theme-on-surface,#000)}.mdc-list-item--activated .mdc-list-item__primary-text,.mdc-list-item--activated.mdc-list-item--with-leading-icon .mdc-list-item__start,.mdc-list-item--selected .mdc-list-item__primary-text,.mdc-list-item--selected.mdc-list-item--with-leading-icon .mdc-list-item__start{color:#6200ee;color:var(--mdc-theme-primary,#6200ee)}.mdc-deprecated-list-group__subheader{color:rgba(0,0,0,.87);color:var(--mdc-theme-text-primary-on-background,rgba(0,0,0,.87))}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-list-divider:after{border-bottom:1px solid #fff;content:"";display:block}}.mdc-list{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);line-height:1.5rem;list-style-type:none;margin:0;padding:8px 0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list:focus{outline:none}.mdc-list-item__wrapper{display:block}.mdc-list-item{align-items:center;align-items:stretch;cursor:pointer;display:flex;justify-content:flex-start;overflow:hidden;padding:0;position:relative}.mdc-list-item:focus{outline:none}.mdc-list-item.mdc-list-item--with-one-line{height:48px}.mdc-list-item.mdc-list-item--with-two-lines{height:64px}.mdc-list-item.mdc-list-item--with-three-lines{height:88px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__start{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__start,.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--with-one-line .mdc-list-item__end,.mdc-list-item.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:center;margin-top:0}.mdc-list-item.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item.mdc-list-item--disabled,.mdc-list-item.mdc-list-item--non-interactive{cursor:auto}.mdc-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-list-item:not(.mdc-list-item--selected):focus:before{border:1px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-ripple-upgraded--background-focused:before,.mdc-list-item:not(.mdc-list-item--selected):focus:before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected:before{border:3px double transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-list-item--selected:before{border-color:CanvasText}}.mdc-list-item.mdc-list-item--selected:focus:before{border:3px solid transparent;border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}@media screen and (forced-colors:active){.mdc-list-item.mdc-list-item--selected:focus:before{border-color:CanvasText}}a.mdc-list-item{color:inherit;text-decoration:none}.mdc-list-item__start{fill:currentColor}.mdc-list-item__end,.mdc-list-item__start{flex-shrink:0;pointer-events:none}.mdc-list-item__content{align-self:center;flex:1;overflow:hidden;pointer-events:none;text-overflow:ellipsis;white-space:nowrap}.mdc-list-item--with-three-lines .mdc-list-item__content,.mdc-list-item--with-two-lines .mdc-list-item__content{align-self:stretch}.mdc-list-item__content[for]{pointer-events:none}.mdc-list-item__primary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);white-space:nowrap}.mdc-list-item--with-three-lines .mdc-list-item__primary-text,.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-three-lines .mdc-list-item__primary-text:before,.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__primary-text:after,.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item__secondary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-body2-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.875rem;font-size:var(--mdc-typography-body2-font-size,.875rem);font-weight:400;font-weight:var(--mdc-typography-body2-font-weight,400);letter-spacing:.0178571429em;letter-spacing:var(--mdc-typography-body2-letter-spacing,.0178571429em);line-height:1.25rem;line-height:var(--mdc-typography-body2-line-height,1.25rem);line-height:normal;margin-top:0;overflow:hidden;text-decoration:inherit;text-decoration:var(--mdc-typography-body2-text-decoration,inherit);text-overflow:ellipsis;text-transform:inherit;text-transform:var(--mdc-typography-body2-text-transform,inherit);white-space:nowrap}.mdc-list-item__secondary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__secondary-text{line-height:20px;white-space:normal}.mdc-list-item--with-overline .mdc-list-item__secondary-text{line-height:auto;white-space:nowrap}.mdc-list-item__overline-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-overline-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-overline-font-size,.75rem);font-weight:500;font-weight:var(--mdc-typography-overline-font-weight,500);letter-spacing:.1666666667em;letter-spacing:var(--mdc-typography-overline-letter-spacing,.1666666667em);line-height:2rem;line-height:var(--mdc-typography-overline-line-height,2rem);overflow:hidden;text-decoration:none;text-decoration:var(--mdc-typography-overline-text-decoration,none);text-overflow:ellipsis;text-transform:uppercase;text-transform:var(--mdc-typography-overline-text-transform,uppercase);white-space:nowrap}.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:24px;vertical-align:0;width:0}.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-three-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-avatar.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-avatar.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-avatar .mdc-list-item__start,.mdc-list-item--with-leading-avatar .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-avatar .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-avatar .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-avatar.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-avatar.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-avatar .mdc-list-item__start{border-radius:50%}.mdc-list-item--with-leading-icon .mdc-list-item__start{height:24px;width:24px}.mdc-list-item--with-leading-icon.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-icon.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-icon.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:16px;margin-right:32px}.mdc-list-item--with-leading-icon .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-icon .mdc-list-item__start{margin-left:32px;margin-right:16px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-icon.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-icon.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-thumbnail.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-thumbnail.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-thumbnail.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-thumbnail .mdc-list-item__start,.mdc-list-item--with-leading-thumbnail .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-thumbnail .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-thumbnail .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-thumbnail.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-image.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-image.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-image.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-image .mdc-list-item__start,.mdc-list-item--with-leading-image .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-image .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-image .mdc-list-item__start{height:56px;width:56px}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-image.mdc-list-item--with-one-line,.mdc-list-item--with-leading-image.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-video.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-video.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-video.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-video .mdc-list-item__start{margin-left:0;margin-right:16px}.mdc-list-item--with-leading-video .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-video .mdc-list-item__start{margin-left:16px;margin-right:0}.mdc-list-item--with-leading-video .mdc-list-item__start{height:56px;width:100px}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-video.mdc-list-item--with-one-line,.mdc-list-item--with-leading-video.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-checkbox.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-checkbox.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-checkbox.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:8px;margin-right:24px}.mdc-list-item--with-leading-checkbox .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-checkbox .mdc-list-item__start{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-checkbox .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-checkbox.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-radio.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-radio.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-radio.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-radio .mdc-list-item__start{margin-left:8px;margin-right:24px}.mdc-list-item--with-leading-radio .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-radio .mdc-list-item__start{margin-left:24px;margin-right:8px}.mdc-list-item--with-leading-radio .mdc-list-item__start{height:40px;width:40px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:8px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-radio.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-radio.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-leading-switch.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-leading-switch.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-switch.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-leading-switch .mdc-list-item__start,.mdc-list-item--with-leading-switch .mdc-list-item__start[dir=rtl],[dir=rtl] .mdc-list-item--with-leading-switch .mdc-list-item__start{margin-left:16px;margin-right:16px}.mdc-list-item--with-leading-switch .mdc-list-item__start{height:20px;width:36px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__start{align-self:flex-start;margin-top:16px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__primary-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text{display:block;line-height:normal;margin-bottom:-20px;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines .mdc-list-item__overline-text:after{content:"";display:inline-block;height:20px;vertical-align:-20px;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines.mdc-list-item--with-trailing-meta .mdc-list-item__end:before{content:"";display:inline-block;height:32px;vertical-align:0;width:0}.mdc-list-item--with-leading-switch.mdc-list-item--with-one-line{height:56px}.mdc-list-item--with-leading-switch.mdc-list-item--with-two-lines{height:72px}.mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-icon.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-icon.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-icon .mdc-list-item__end,.mdc-list-item--with-trailing-icon .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-icon .mdc-list-item__end{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-icon .mdc-list-item__end{height:24px;width:24px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end,.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{align-self:flex-start}.mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-meta.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-meta.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:28px;margin-right:16px}.mdc-list-item--with-trailing-meta .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-meta .mdc-list-item__end{margin-left:16px;margin-right:28px}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-two-lines .mdc-list-item__end:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-trailing-meta.mdc-list-item--with-three-lines .mdc-list-item__end:before{content:"";display:inline-block;height:28px;vertical-align:0;width:0}.mdc-list-item--with-trailing-meta .mdc-list-item__end{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit)}.mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-checkbox.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-checkbox.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:24px;margin-right:8px}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-checkbox .mdc-list-item__end{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-checkbox .mdc-list-item__end{height:40px;width:40px}.mdc-list-item--with-trailing-checkbox.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-radio.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-radio.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-radio.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-radio .mdc-list-item__end{margin-left:24px;margin-right:8px}.mdc-list-item--with-trailing-radio .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-radio .mdc-list-item__end{margin-left:8px;margin-right:24px}.mdc-list-item--with-trailing-radio .mdc-list-item__end{height:40px;width:40px}.mdc-list-item--with-trailing-radio.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:8px}.mdc-list-item--with-trailing-switch.mdc-list-item{padding-left:auto;padding-right:0}.mdc-list-item--with-trailing-switch.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-switch.mdc-list-item{padding-left:0;padding-right:auto}.mdc-list-item--with-trailing-switch .mdc-list-item__end,.mdc-list-item--with-trailing-switch .mdc-list-item__end[dir=rtl],[dir=rtl] .mdc-list-item--with-trailing-switch .mdc-list-item__end{margin-left:16px;margin-right:16px}.mdc-list-item--with-trailing-switch .mdc-list-item__end{height:20px;width:36px}.mdc-list-item--with-trailing-switch.mdc-list-item--with-three-lines .mdc-list-item__end{align-self:flex-start;margin-top:16px}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-overline.mdc-list-item--with-two-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text{display:block;line-height:normal;margin-top:0}.mdc-list-item--with-overline.mdc-list-item--with-three-lines .mdc-list-item__primary-text:before{content:"";display:inline-block;height:20px;vertical-align:0;width:0}.mdc-list-item,.mdc-list-item[dir=rtl],[dir=rtl] .mdc-list-item{padding-left:16px;padding-right:16px}.mdc-list-group .mdc-deprecated-list{padding:0}.mdc-list-group__subheader{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);line-height:1.75rem;line-height:var(--mdc-typography-subtitle1-line-height,1.75rem);margin:.75rem 16px;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit)}.mdc-list-divider{background-clip:content-box;background-color:rgba(0,0,0,.12);height:1px;padding:0}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,.mdc-list-divider.mdc-list-divider--with-leading-inset{padding-left:16px;padding-right:auto}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,.mdc-list-divider.mdc-list-divider--with-leading-inset[dir=rtl],.mdc-list-divider.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-leading-inset,[dir=rtl] .mdc-list-divider.mdc-list-divider--with-leading-inset{padding-left:auto;padding-right:16px}.mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset[dir=rtl],.mdc-list-divider.mdc-list-divider--with-trailing-inset[dir=rtl],[dir=rtl] .mdc-list-divider--with-leading-avatar.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-checkbox.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-icon.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-image.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-radio.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-switch.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-text.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider--with-leading-thumbnail.mdc-list-divider--with-trailing-inset,[dir=rtl] .mdc-list-divider.mdc-list-divider--with-trailing-inset{padding-left:16px;padding-right:auto}.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset{padding-left:0;padding-right:auto}.mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset[dir=rtl],[dir=rtl] .mdc-list-divider--with-leading-video.mdc-list-divider--with-leading-inset{padding-left:auto;padding-right:0}.mdc-list-divider[dir=rtl],[dir=rtl] .mdc-list-divider{padding:0}@keyframes mdc-ripple-fg-radius-in{0%{animation-timing-function:cubic-bezier(.4,0,.2,1);transform:translate(var(--mdc-ripple-fg-translate-start,0)) scale(1)}to{transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}}@keyframes mdc-ripple-fg-opacity-in{0%{animation-timing-function:linear;opacity:0}to{opacity:var(--mdc-ripple-fg-opacity,0)}}@keyframes mdc-ripple-fg-opacity-out{0%{animation-timing-function:linear;opacity:var(--mdc-ripple-fg-opacity,0)}to{opacity:0}}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--unbounded .mdc-deprecated-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-activation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:hover .mdc-deprecated-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:hover .mdc-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-deprecated-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:hover .mdc-deprecated-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:hover .mdc-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.24)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-deprecated-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:hover .mdc-deprecated-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-deprecated-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-deprecated-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:after,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:hover .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.2)}:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-deprecated-list-item__ripple,:not(.mdc-deprecated-list-item--disabled).mdc-deprecated-list-item .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-deprecated-list-item--disabled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-deprecated-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-deprecated-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-deprecated-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:after,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,.mdc-deprecated-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-deprecated-list-item__ripple:before,.mdc-deprecated-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-deprecated-list-item--disabled .mdc-deprecated-list-item__ripple,.mdc-deprecated-list-item--disabled .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}:not(.mdc-list-item--disabled).mdc-list-item{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item:hover .mdc-list-item__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-activated-opacity,.12)}:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item--activated .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--activated:hover .mdc-list-item__ripple:before{opacity:.16;opacity:var(--mdc-ripple-hover-opacity,.16)}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.24;opacity:var(--mdc-ripple-focus-opacity,.24);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item--activated:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.24;opacity:var(--mdc-ripple-press-opacity,.24);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--activated.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.24)}:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:before{opacity:.08;opacity:var(--mdc-ripple-selected-opacity,.08)}:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:after,:not(.mdc-list-item--disabled).mdc-list-item--selected .mdc-list-item__ripple:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-surface--hover .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--selected:hover .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-hover-opacity,.12)}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.2;opacity:var(--mdc-ripple-focus-opacity,.2);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded) .mdc-list-item__ripple:after{transition:opacity .15s linear}:not(.mdc-list-item--disabled).mdc-list-item--selected:not(.mdc-ripple-upgraded):active .mdc-list-item__ripple:after{opacity:.2;opacity:var(--mdc-ripple-press-opacity,.2);transition-duration:75ms}:not(.mdc-list-item--disabled).mdc-list-item--selected.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.2)}:not(.mdc-list-item--disabled).mdc-list-item .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-list-item--disabled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-list-item--disabled .mdc-list-item__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-list-item--disabled .mdc-list-item__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-list-item--disabled.mdc-ripple-upgraded--unbounded .mdc-list-item__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-activation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-list-item--disabled.mdc-ripple-upgraded--foreground-deactivation .mdc-list-item__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-list-item--disabled.mdc-ripple-upgraded .mdc-list-item__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-list-item--disabled .mdc-list-item__ripple:after,.mdc-list-item--disabled .mdc-list-item__ripple:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-list-item--disabled.mdc-ripple-upgraded--background-focused .mdc-list-item__ripple:before,.mdc-list-item--disabled:not(.mdc-ripple-upgraded):focus .mdc-list-item__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-list-item--disabled .mdc-list-item__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-ripple-surface{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:none;overflow:hidden;position:relative;will-change:transform,opacity}.mdc-ripple-surface:after,.mdc-ripple-surface:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-ripple-surface:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-ripple-surface:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-ripple-surface.mdc-ripple-upgraded:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface.mdc-ripple-upgraded:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-ripple-surface.mdc-ripple-upgraded--unbounded:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-activation:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-ripple-surface.mdc-ripple-upgraded--foreground-deactivation:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-ripple-surface:after,.mdc-ripple-surface:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-ripple-surface.mdc-ripple-upgraded:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded],.mdc-ripple-upgraded--unbounded{overflow:visible}.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded]:before,.mdc-ripple-upgraded--unbounded:after,.mdc-ripple-upgraded--unbounded:before{height:100%;left:0;top:0;width:100%}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:before,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:before{height:var(--mdc-ripple-fg-size,100%);left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface[data-mdc-ripple-is-unbounded].mdc-ripple-upgraded:after,.mdc-ripple-upgraded--unbounded.mdc-ripple-upgraded:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-ripple-surface:after,.mdc-ripple-surface:before{background-color:#000;background-color:var(--mdc-ripple-color,#000)}.mdc-ripple-surface.mdc-ripple-surface--hover:before,.mdc-ripple-surface:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.mdc-ripple-surface.mdc-ripple-upgraded--background-focused:before,.mdc-ripple-surface:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-ripple-surface:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.mdc-ripple-surface:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.mdc-ripple-surface.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-ripple-surface--primary:after,.smui-ripple-surface--primary:before{background-color:#6200ee;background-color:var(--mdc-ripple-color,var(--mdc-theme-primary,#6200ee))}.smui-ripple-surface--primary.mdc-ripple-surface--hover:before,.smui-ripple-surface--primary:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.smui-ripple-surface--primary.mdc-ripple-upgraded--background-focused:before,.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-ripple-surface--primary:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.smui-ripple-surface--primary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-ripple-surface--secondary:after,.smui-ripple-surface--secondary:before{background-color:#018786;background-color:var(--mdc-ripple-color,var(--mdc-theme-secondary,#018786))}.smui-ripple-surface--secondary.mdc-ripple-surface--hover:before,.smui-ripple-surface--secondary:hover:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.smui-ripple-surface--secondary.mdc-ripple-upgraded--background-focused:before,.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):focus:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):after{transition:opacity .15s linear}.smui-ripple-surface--secondary:not(.mdc-ripple-upgraded):active:after{opacity:.12;opacity:var(--mdc-ripple-press-opacity,.12);transition-duration:75ms}.smui-ripple-surface--secondary.mdc-ripple-upgraded{--mdc-ripple-fg-opacity:var(--mdc-ripple-press-opacity,0.12)}.smui-list--three-line .mdc-deprecated-list-item__text{align-self:flex-start}.smui-list--three-line .mdc-deprecated-list-item{height:88px}.smui-list--three-line.mdc-deprecated-list--dense .mdc-deprecated-list-item{height:76px}.mdc-deprecated-list-item.smui-menu-item--non-interactive{cursor:auto}.mdc-elevation-overlay{background-color:#fff;background-color:var(--mdc-elevation-overlay-color,#fff);border-radius:inherit;opacity:0;opacity:var(--mdc-elevation-overlay-opacity,0);pointer-events:none;position:absolute;transition:opacity .28s cubic-bezier(.4,0,.2,1)}.mdc-menu{min-width:112px;min-width:var(--mdc-menu-min-width,112px)}.mdc-menu .mdc-deprecated-list-item__graphic,.mdc-menu .mdc-deprecated-list-item__meta{color:rgba(0,0,0,.87)}.mdc-menu .mdc-menu-item--submenu-open .mdc-deprecated-list-item__ripple:before,.mdc-menu .mdc-menu-item--submenu-open .mdc-list-item__ripple:before{opacity:.04}.mdc-menu .mdc-deprecated-list{color:rgba(0,0,0,.87)}.mdc-menu .mdc-deprecated-list,.mdc-menu .mdc-list{position:relative}.mdc-menu .mdc-deprecated-list .mdc-elevation-overlay,.mdc-menu .mdc-list .mdc-elevation-overlay{height:100%;left:0;top:0;width:100%}.mdc-menu .mdc-deprecated-list-divider{margin:8px 0}.mdc-menu .mdc-deprecated-list-item{user-select:none}.mdc-menu .mdc-deprecated-list-item--disabled{cursor:auto}.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__graphic,.mdc-menu a.mdc-deprecated-list-item .mdc-deprecated-list-item__text{pointer-events:none}.mdc-menu__selection-group{fill:currentColor;padding:0}.mdc-menu__selection-group .mdc-deprecated-list-item{padding-left:56px;padding-right:16px}.mdc-menu__selection-group .mdc-deprecated-list-item[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-deprecated-list-item{padding-left:16px;padding-right:56px}.mdc-menu__selection-group .mdc-menu__selection-group-icon{display:none;left:16px;position:absolute;right:auto;top:50%;transform:translateY(-50%)}.mdc-menu__selection-group .mdc-menu__selection-group-icon[dir=rtl],[dir=rtl] .mdc-menu__selection-group .mdc-menu__selection-group-icon{left:auto;right:16px}.mdc-menu-item--selected .mdc-menu__selection-group-icon{display:inline}.mdc-menu-surface{transform-origin-left:top left;transform-origin-right:top right;background-color:#fff;background-color:var(--mdc-theme-surface,#fff);border-radius:4px;border-radius:var(--mdc-shape-medium,4px);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-sizing:border-box;color:#000;color:var(--mdc-theme-on-surface,#000);display:none;margin:0;max-height:calc(100vh - 32px);max-height:var(--mdc-menu-max-height,calc(100vh - 32px));max-width:calc(100vw - 32px);max-width:var(--mdc-menu-max-width,calc(100vw - 32px));opacity:0;overflow:auto;padding:0;position:absolute;transform:scale(1);transform-origin:top left;transition:opacity .03s linear,transform .12s cubic-bezier(0,0,.2,1),height .25s cubic-bezier(0,0,.2,1);will-change:transform,opacity;z-index:8}.mdc-menu-surface:focus{outline:none}.mdc-menu-surface--animating-open{display:inline-block;opacity:0;transform:scale(.8)}.mdc-menu-surface--open{display:inline-block;opacity:1;transform:scale(1)}.mdc-menu-surface--animating-closed{display:inline-block;opacity:0;transition:opacity 75ms linear}.mdc-menu-surface[dir=rtl],[dir=rtl] .mdc-menu-surface{transform-origin-left:top right;transform-origin-right:top left}.mdc-menu-surface--anchor{overflow:visible;position:relative}.mdc-menu-surface--fixed{position:fixed}.mdc-menu-surface--fullwidth{width:100%}.smui-menu-surface--static{display:inline-block;opacity:1;position:static;transform:scale(1);z-index:0}.mdc-menu__selection-group .mdc-list-item__graphic.mdc-menu__selection-group-icon{display:none}.mdc-menu-item--selected .mdc-list-item__graphic.mdc-menu__selection-group-icon{display:inline}.mdc-notched-outline{box-sizing:border-box;display:flex;height:100%;left:0;max-width:100%;pointer-events:none;position:absolute;right:0;text-align:left;top:0;width:100%}.mdc-notched-outline[dir=rtl],[dir=rtl] .mdc-notched-outline{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-bottom:1px solid;border-top:1px solid;box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}.mdc-notched-outline__leading[dir=rtl],.mdc-notched-outline__trailing,[dir=rtl] .mdc-notched-outline__leading{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__trailing[dir=rtl],[dir=rtl] .mdc-notched-outline__trailing{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{flex:0 0 auto;max-width:calc(100% - 24px);width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;max-width:100%;position:relative}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{border-top:none;padding-left:0;padding-right:8px}.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl],[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-text-field--filled{--mdc-ripple-fg-size:0;--mdc-ripple-left:0;--mdc-ripple-top:0;--mdc-ripple-fg-scale:1;--mdc-ripple-fg-translate-end:0;--mdc-ripple-fg-translate-start:0;-webkit-tap-highlight-color:rgba(0,0,0,0);will-change:transform,opacity}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{border-radius:50%;content:"";opacity:0;pointer-events:none;position:absolute}.mdc-text-field--filled .mdc-text-field__ripple:before{transition:opacity 15ms linear,background-color 15ms linear;z-index:1;z-index:var(--mdc-ripple-z-index,1)}.mdc-text-field--filled .mdc-text-field__ripple:after{z-index:0;z-index:var(--mdc-ripple-z-index,0)}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:before{transform:scale(var(--mdc-ripple-fg-scale,1))}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:after{left:0;top:0;transform:scale(0);transform-origin:center center}.mdc-text-field--filled.mdc-ripple-upgraded--unbounded .mdc-text-field__ripple:after{left:var(--mdc-ripple-left,0);top:var(--mdc-ripple-top,0)}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-activation .mdc-text-field__ripple:after{animation:mdc-ripple-fg-radius-in 225ms forwards,mdc-ripple-fg-opacity-in 75ms forwards}.mdc-text-field--filled.mdc-ripple-upgraded--foreground-deactivation .mdc-text-field__ripple:after{animation:mdc-ripple-fg-opacity-out .15s;transform:translate(var(--mdc-ripple-fg-translate-end,0)) scale(var(--mdc-ripple-fg-scale,1))}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{height:200%;left:-50%;top:-50%;width:200%}.mdc-text-field--filled.mdc-ripple-upgraded .mdc-text-field__ripple:after{height:var(--mdc-ripple-fg-size,100%);width:var(--mdc-ripple-fg-size,100%)}.mdc-text-field__ripple{height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.mdc-text-field{align-items:baseline;border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px);box-sizing:border-box;display:inline-flex;overflow:hidden;padding:0 16px;position:relative;will-change:opacity,transform,color}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input{color:rgba(0,0,0,.87)}@media{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:rgba(0,0,0,.54)}}@media{.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.54)}}.mdc-text-field .mdc-text-field__input{caret-color:#6200ee;caret-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field:not(.mdc-text-field--disabled)+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.6)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--leading,.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:rgba(0,0,0,.54)}.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--prefix,.mdc-text-field:not(.mdc-text-field--disabled) .mdc-text-field__affix--suffix{color:rgba(0,0,0,.6)}.mdc-text-field .mdc-floating-label{pointer-events:none;top:50%;transform:translateY(-50%)}.mdc-text-field__input{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;appearance:none;background:none;border:none;border-radius:0;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);height:28px;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);min-width:0;padding:0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;width:100%}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media{.mdc-text-field__input::placeholder{opacity:0;transition:opacity 67ms cubic-bezier(.4,0,.2,1) 0ms}}@media{.mdc-text-field__input:-ms-input-placeholder{opacity:0;transition:opacity 67ms cubic-bezier(.4,0,.2,1) 0ms}}@media{.mdc-text-field--focused .mdc-text-field__input::placeholder,.mdc-text-field--no-label .mdc-text-field__input::placeholder{opacity:1;transition-delay:40ms;transition-duration:.11s}}@media{.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder{opacity:1;transition-delay:40ms;transition-duration:.11s}}.mdc-text-field__affix{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-subtitle1-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:1rem;font-size:var(--mdc-typography-subtitle1-font-size,1rem);font-weight:400;font-weight:var(--mdc-typography-subtitle1-font-weight,400);height:28px;letter-spacing:.009375em;letter-spacing:var(--mdc-typography-subtitle1-letter-spacing,.009375em);opacity:0;text-decoration:inherit;text-decoration:var(--mdc-typography-subtitle1-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-subtitle1-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens:none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}.mdc-text-field__affix--prefix[dir=rtl],[dir=rtl] .mdc-text-field__affix--prefix{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl],.mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix[dir=rtl],[dir=rtl] .mdc-text-field__affix--suffix{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl],[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled .mdc-text-field__ripple:after,.mdc-text-field--filled .mdc-text-field__ripple:before{background-color:rgba(0,0,0,.87);background-color:var(--mdc-ripple-color,rgba(0,0,0,.87))}.mdc-text-field--filled.mdc-ripple-surface--hover .mdc-text-field__ripple:before,.mdc-text-field--filled:hover .mdc-text-field__ripple:before{opacity:.04;opacity:var(--mdc-ripple-hover-opacity,.04)}.mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple:before,.mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple:before{opacity:.12;opacity:var(--mdc-ripple-focus-opacity,.12);transition-duration:75ms}.mdc-text-field--filled:before{content:"";display:inline-block;height:40px;vertical-align:0;width:0}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:#f5f5f5}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.42)}.mdc-text-field--filled:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.87)}.mdc-text-field--filled .mdc-line-ripple:after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field--filled .mdc-floating-label{left:16px;right:auto}.mdc-text-field--filled .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--filled .mdc-floating-label{left:auto;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label,.mdc-text-field--filled.mdc-text-field--no-label:before{display:none}@supports(-webkit-hyphens:none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem;transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem;transform:translateY(-34.75px) scale(.75)}.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(0) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-34.75px) scale(.75)}to{transform:translateX(0) translateY(-34.75px) scale(.75)}}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.38)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.87)}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing{border-color:#6200ee;border-color:var(--mdc-theme-primary,#6200ee)}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small,4px);border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:0}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-bottom-left-radius:0;border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small,4px);border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px)}@supports(top:max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px,var(--mdc-shape-small,4px))}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-bottom-left-radius:0;border-bottom-right-radius:4px;border-bottom-right-radius:var(--mdc-shape-small,4px);border-top-left-radius:0;border-top-right-radius:4px;border-top-right-radius:var(--mdc-shape-small,4px)}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-bottom-left-radius:4px;border-bottom-left-radius:var(--mdc-shape-small,4px);border-bottom-right-radius:0;border-top-left-radius:4px;border-top-left-radius:var(--mdc-shape-small,4px);border-top-right-radius:0}@supports(top:max(0%)){.mdc-text-field--outlined{padding-right:max(16px,var(--mdc-shape-small,4px))}.mdc-text-field--outlined,.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:max(16px,var(--mdc-shape-small,4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:0}@supports(top:max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:max(16px,calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-text-field__ripple:after,.mdc-text-field--outlined .mdc-text-field__ripple:before{background-color:transparent;background-color:var(--mdc-ripple-color,transparent)}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:auto}.mdc-text-field--outlined .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-floating-label{left:auto;right:4px}.mdc-text-field--outlined .mdc-text-field__input{background-color:transparent;border:none!important;display:flex}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{align-items:center;flex-direction:column;height:auto;padding:0;transition:none;width:auto}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{box-sizing:border-box;flex-grow:1;height:auto;line-height:1.5rem;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;padding:0 16px;resize:none}.mdc-text-field--textarea.mdc-text-field--filled:before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled .25s 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(0) translateY(-10.25px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-10.25px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-10.25px) scale(.75)}to{transform:translateX(0) translateY(-10.25px) scale(.75)}}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-bottom:9px;margin-top:23px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-bottom:16px;margin-top:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem;transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem;transform:translateY(-24.75px) scale(.75)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined .25s 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(0) translateY(-24.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(4%) translateY(-24.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(-4%) translateY(-24.75px) scale(.75)}to{transform:translateX(0) translateY(-24.75px) scale(.75)}}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-bottom:16px;margin-top:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter:after{content:"";display:inline-block;height:16px;vertical-align:-16px;width:0}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter:before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input{transform:translateX(1px) translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}.mdc-text-field--with-leading-icon[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{left:48px;max-width:calc(100% - 48px);right:auto}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{left:auto;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 85.33333px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:auto}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:auto;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(32px) scale(.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(-32px) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(calc(4% - 32px)) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(calc(-4% - 32px)) translateY(-34.75px) scale(.75)}to{transform:translateX(-32px) translateY(-34.75px) scale(.75)}}.mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon .25s 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(32px) translateY(-34.75px) scale(.75)}33%{animation-timing-function:cubic-bezier(.5,0,.701732,.495819);transform:translateX(calc(4% + 32px)) translateY(-34.75px) scale(.75)}66%{animation-timing-function:cubic-bezier(.302435,.381352,.55,.956352);transform:translateX(calc(-4% + 32px)) translateY(-34.75px) scale(.75)}to{transform:translateX(32px) translateY(-34.75px) scale(.75)}}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}.mdc-text-field--with-trailing-icon[dir=rtl],[dir=rtl] .mdc-text-field--with-trailing-icon{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 85.33333px)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(133.33333% - 128px)}.mdc-text-field-helper-line{box-sizing:border-box;display:flex;justify-content:space-between}.mdc-text-field+.mdc-text-field-helper-line{padding-left:16px;padding-right:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused:not(.mdc-text-field--disabled) .mdc-floating-label{color:rgba(98,0,238,.87)}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple:after,.mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-floating-label,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{color:#b00020;color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid .mdc-text-field__input{caret-color:#b00020;caret-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__icon--trailing{color:#b00020;color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:#b00020;border-bottom-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-notched-outline__trailing,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline__trailing,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__notch,.mdc-text-field--invalid:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-notched-outline .mdc-notched-outline__trailing{border-color:#b00020;border-color:var(--mdc-theme-error,#b00020)}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}.mdc-text-field--disabled .mdc-text-field__input{color:rgba(0,0,0,.38)}@media{.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:rgba(0,0,0,.38)}}@media{.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:rgba(0,0,0,.38)}}.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-text-field__icon--leading,.mdc-text-field--disabled .mdc-text-field__icon--trailing{color:rgba(0,0,0,.3)}.mdc-text-field--disabled .mdc-text-field__affix--prefix,.mdc-text-field--disabled .mdc-text-field__affix--suffix{color:rgba(0,0,0,.38)}.mdc-text-field--disabled .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.06)}.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:rgba(0,0,0,.06)}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input::placeholder{color:GrayText}}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input:-ms-input-placeholder{color:GrayText}}@media (-ms-high-contrast:active),screen and (forced-colors:active){.mdc-text-field--disabled .mdc-floating-label,.mdc-text-field--disabled .mdc-text-field-character-counter,.mdc-text-field--disabled .mdc-text-field__affix--prefix,.mdc-text-field--disabled .mdc-text-field__affix--suffix,.mdc-text-field--disabled .mdc-text-field__icon--leading,.mdc-text-field--disabled .mdc-text-field__icon--trailing,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-character-counter,.mdc-text-field--disabled+.mdc-text-field-helper-line .mdc-text-field-helper-text{color:GrayText}.mdc-text-field--disabled .mdc-line-ripple:before{border-bottom-color:GrayText}.mdc-text-field--disabled .mdc-notched-outline__leading,.mdc-text-field--disabled .mdc-notched-outline__notch,.mdc-text-field--disabled .mdc-notched-outline__trailing{border-color:GrayText}}@media screen and (forced-colors:active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled{background-color:#fafafa}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl],[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input{text-align:left}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input{direction:ltr}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading{order:1}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix{order:2}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input{order:3}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix{order:4}.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing{order:5}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-right:12px}.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix,[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px}.smui-text-field--standard{height:56px;padding:0}.smui-text-field--standard:before{content:"";display:inline-block;height:40px;vertical-align:0;width:0}.smui-text-field--standard:not(.mdc-text-field--disabled){background-color:transparent}.smui-text-field--standard:not(.mdc-text-field--disabled) .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.42)}.smui-text-field--standard:not(.mdc-text-field--disabled):hover .mdc-line-ripple:before{border-bottom-color:rgba(0,0,0,.87)}.smui-text-field--standard .mdc-line-ripple:after{border-bottom-color:#6200ee;border-bottom-color:var(--mdc-theme-primary,#6200ee)}.smui-text-field--standard .mdc-floating-label{left:0;right:auto}.smui-text-field--standard .mdc-floating-label[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-floating-label{left:auto;right:0}.smui-text-field--standard .mdc-floating-label--float-above{transform:translateY(-106%) scale(.75)}.smui-text-field--standard.mdc-text-field--no-label .mdc-text-field__input{height:100%}.smui-text-field--standard.mdc-text-field--no-label .mdc-floating-label,.smui-text-field--standard.mdc-text-field--no-label:before{display:none}@supports(-webkit-hyphens:none){.smui-text-field--standard.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label{left:32px;max-width:calc(100% - 32px);right:auto}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label[dir=rtl],[dir=rtl] .mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label{left:auto;right:32px}.mdc-text-field--with-leading-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 64px)}.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label{max-width:calc(100% - 36px)}.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 48px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label{max-width:calc(100% - 68px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.smui-text-field--standard .mdc-floating-label--float-above{max-width:calc(133.33333% - 90.66667px)}.mdc-text-field+.mdc-text-field-helper-line{padding-left:0;padding-right:0}.mdc-text-field-character-counter{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);line-height:normal;margin-left:auto;margin-right:0;margin-top:0;padding-left:16px;padding-right:0;text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit);white-space:nowrap}.mdc-text-field-character-counter:before{content:"";display:inline-block;height:16px;vertical-align:0;width:0}.mdc-text-field-character-counter[dir=rtl],[dir=rtl] .mdc-text-field-character-counter{margin-left:0;margin-right:auto;padding-left:0;padding-right:16px}.mdc-text-field-helper-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;font-family:Roboto,sans-serif;font-family:var(--mdc-typography-caption-font-family,var(--mdc-typography-font-family,Roboto,sans-serif));font-size:.75rem;font-size:var(--mdc-typography-caption-font-size,.75rem);font-weight:400;font-weight:var(--mdc-typography-caption-font-weight,400);letter-spacing:.0333333333em;letter-spacing:var(--mdc-typography-caption-letter-spacing,.0333333333em);line-height:1.25rem;line-height:var(--mdc-typography-caption-line-height,1.25rem);line-height:normal;margin:0;opacity:0;text-decoration:inherit;text-decoration:var(--mdc-typography-caption-text-decoration,inherit);text-transform:inherit;text-transform:var(--mdc-typography-caption-text-transform,inherit);transition:opacity .15s cubic-bezier(.4,0,.2,1) 0ms;will-change:opacity}.mdc-text-field-helper-text:before{content:"";display:inline-block;height:16px;vertical-align:0;width:0}.mdc-text-field-helper-text--persistent{opacity:1;transition:none;will-change:auto}.mdc-text-field__icon{align-self:center;cursor:pointer}.mdc-text-field__icon:not([tabindex]),.mdc-text-field__icon[tabindex="-1"]{cursor:default;pointer-events:none}.mdc-text-field__icon svg{display:block}.mdc-text-field__icon--leading{margin-left:16px;margin-right:8px}.mdc-text-field__icon--leading[dir=rtl],[dir=rtl] .mdc-text-field__icon--leading{margin-left:8px;margin-right:16px}.mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding:12px}.mdc-text-field__icon--trailing[dir=rtl],[dir=rtl] .mdc-text-field__icon--trailing{margin-left:0;margin-right:0}.smui-text-field--standard .mdc-text-field__icon--leading{margin-left:0;margin-right:8px}.smui-text-field--standard .mdc-text-field__icon--leading[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-text-field__icon--leading{margin-left:8px;margin-right:0}.smui-text-field--standard .mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding:12px 0 12px 12px}.smui-text-field--standard .mdc-text-field__icon--trailing[dir=rtl],[dir=rtl] .smui-text-field--standard .mdc-text-field__icon--trailing{margin-left:0;margin-right:0;padding-left:0;padding-right:12px}';
gp(j$, {});
var G$ = ":root *{--scrollbar-background:hsla(0,0%,100%,.1);scrollbar-track-color:transparent;scrollbar-face-color:var(--scrollbar-background);scrollbar-color:var(--scrollbar-background) transparent;scrollbar-width:thin;text-underline-offset:.5px}:root ::-webkit-scrollbar{border-radius:.3rem;height:5px;width:5px}:root ::-webkit-scrollbar-track{border-radius:.3rem}:root ::-webkit-scrollbar-corner{background:none!important}:root ::-webkit-scrollbar-thumb{background-color:var(--scrollbar-background);border:3px solid var(--scrollbar-background);border-radius:20px;transition:background-color .5s}";
gp(G$, {});
var H$ = ":root{--cosmograph-search-text-color:#fff;--cosmograph-search-list-background:#222;--cosmograph-search-font-family:inherit;--cosmograph-search-input-background:#222;--cosmograph-search-mark-background:hsla(0,0%,100%,.2);--cosmograph-search-accessor-background:hsla(0,0%,100%,.2);--cosmograph-search-interactive-background:hsla(0,0%,100%,.4);--cosmograph-search-hover-color:hsla(0,0%,100%,.05)}.search-icon.svelte-1xknafk.svelte-1xknafk{color:var(--cosmograph-search-text-color)!important;opacity:.6}.search.svelte-1xknafk .cosmograph-search-accessor{align-content:center;background-color:var(--cosmograph-search-accessor-background);border-radius:10px;color:var(--cosmograph-search-text-color);cursor:pointer;display:flex;display:block;font-size:12px;font-style:normal;justify-content:center;line-height:1;margin-right:.5rem;overflow:hidden;padding:5px 8px;text-overflow:ellipsis;transition:background .15s linear;white-space:nowrap;z-index:1}.search.svelte-1xknafk .cosmograph-search-accessor.active,.search.svelte-1xknafk .cosmograph-search-accessor:hover{background-color:var(--cosmograph-search-interactive-background)}.search.svelte-1xknafk .disabled{cursor:default;pointer-events:none}.search.svelte-1xknafk.svelte-1xknafk{background:var(--cosmograph-search-input-background);display:flex;flex-direction:column;font-family:var(--cosmograph-search-font-family),sans-serif;text-align:left;width:100%}.search.svelte-1xknafk mark{background:var(--cosmograph-search-mark-background);border-radius:2px;color:var(--cosmograph-search-text-color);padding:1px 0}.search.svelte-1xknafk .cosmograph-search-match{-webkit-box-orient:vertical;cursor:pointer;display:-webkit-box;line-height:1.35;overflow:hidden;padding:calc(var(--margin-v)*1px) calc(var(--margin-h)*1px);text-overflow:ellipsis;white-space:normal}.search.svelte-1xknafk .cosmograph-search-match:hover{background:var(--cosmograph-search-hover-color)}.search.svelte-1xknafk .cosmograph-search-result{display:inline;font-size:12px;font-weight:600;text-transform:uppercase}.search.svelte-1xknafk .cosmograph-search-result>span{font-weight:400;letter-spacing:1;margin-left:4px}.search.svelte-1xknafk .cosmograph-search-result>span>t{margin-right:4px}.search.svelte-1xknafk .mdc-menu-surface{background-color:var(--cosmograph-search-list-background)!important;max-height:none!important}.search.svelte-1xknafk .openListUpwards.svelte-1xknafk .mdc-menu-surface{bottom:55px!important;top:unset!important}.search.svelte-1xknafk .mdc-text-field__input{caret-color:var(--cosmograph-search-text-color)!important;height:100%;letter-spacing:-.01em;line-height:2;line-height:2!important;padding-top:15px!important}.search.svelte-1xknafk .mdc-floating-label,.search.svelte-1xknafk .mdc-text-field__input{color:var(--cosmograph-search-text-color)!important;font-family:var(--cosmograph-search-font-family),sans-serif!important}.search.svelte-1xknafk .mdc-floating-label{opacity:.65;pointer-events:none!important}.search.svelte-1xknafk .mdc-line-ripple:after,.search.svelte-1xknafk .mdc-line-ripple:before{border-bottom-color:var(--cosmograph-search-text-color)!important;opacity:.1}.search.svelte-1xknafk .mdc-deprecated-list{background:var(--cosmograph-search-list-background);color:var(--cosmograph-search-text-color)!important;font-size:14px!important;padding-top:4px!important}.search.svelte-1xknafk .mdc-deprecated-list-item{height:28px!important}.search.svelte-1xknafk .mdc-text-field__icon--leading{margin-right:10px!important}.search.svelte-1xknafk .mdc-floating-label--float-above{left:26px!important;pointer-events:none!important}.search.svelte-1xknafk .mdc-text-field__icon--trailing{cursor:default!important;max-width:35%}.search.svelte-1xknafk .cosmograph-search-first-field{font-size:12.5px;font-weight:400;opacity:.8;text-transform:uppercase}";
gp(H$, {});
const W$ = '<svg fill="currentColor" height="11" viewBox="0 0 163 11" width="163" xmlns="http://www.w3.org/2000/svg"><g fill="currentColor"><path d="m2.45674 8-1.925002-5.379h.924002l1.617 4.73h.154l1.617-4.73h.924l-1.925 5.379z"/><path d="m7.02243 8v-5.379h.869v5.379zm.44-6.215c-.19067 0-.352-.06233-.484-.187-.12467-.12467-.187-.28233-.187-.473 0-.198.06233-.359333.187-.484.132-.124667.29333-.187.484-.187.19066 0 .34833.062333.473.187.12466.124667.187.286.187.484 0 .19067-.06234.34833-.187.473-.12467.12467-.28234.187-.473.187z"/><path d="m11.8857 8.154c-.6673 0-1.232-.154-1.694-.462-.45465-.308-.72965-.79567-.82499-1.463l.82499-.187c.0587.352.1687.63067.33.836.1613.198.3593.341.594.429.242.08067.4987.121.77.121.4033 0 .7223-.08067.957-.242s.352-.37767.352-.649c0-.27867-.1137-.473-.341-.583-.22-.11733-.5243-.21267-.913-.286l-.451-.077c-.3447-.05867-.66-.15033-.946-.275s-.5133-.29333-.68199-.506c-.16866-.21267-.25299-.48033-.25299-.803 0-.484.18699-.86167.56098-1.133.374-.27133.869-.407 1.485-.407.6087 0 1.1.13933 1.474.418.3813.27133.627.65633.737 1.155l-.814.209c-.066-.38867-.2237-.66-.473-.814-.2493-.16133-.5573-.242-.924-.242s-.6563.06967-.869.209c-.2127.132-.319.33-.319.594 0 .25667.099.44733.297.572.2053.11733.4767.20533.814.264l.451.077c.3813.066.7223.15767 1.023.275.308.11.55.27133.726.484.1833.21267.275.49133.275.836 0 .528-.198.935-.594 1.221-.3887.286-.913.429-1.573.429z"/><path d="m17.5765 8.099c-.3887 0-.748-.08433-1.078-.253-.3227-.16867-.5793-.418-.77-.748-.1833-.33733-.275-.74433-.275-1.221v-3.256h.869v3.19c0 .53533.132.924.396 1.166.2713.242.6343.363 1.089.363.5133 0 .935-.16867 1.265-.506s.495-.83967.495-1.507v-2.706h.869v5.379h-.847v-.913h-.154c-.1173.25667-.319.49133-.605.704-.286.20533-.704.308-1.254.308z"/><path d="m23.9048 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.6527-.187 1.034-.187h1.815v-.396c0-.38133-.1136-.682-.341-.902-.22-.22-.55-.33-.99-.33-.4326 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.2274-.572.418-.814.1907-.24933.4437-.44733.759-.594.3227-.154.7077-.231 1.155-.231.6894 0 1.2247.17967 1.606.539.3814.352.572.85067.572 1.496v2.431c0 .22.1027.33.308.33h.495v.737h-.759c-.242 0-.4363-.066-.583-.198-.1466-.13933-.22-.32267-.22-.55v-.055h-.132c-.0806.13933-.1906.286-.33.44-.132.14667-.3153.26767-.55.363-.2346.10267-.539.154-.913.154zm.099-.748c.5134 0 .9277-.15033 1.243-.451.3227-.308.484-.737.484-1.287v-.121h-1.782c-.3446 0-.6306.077-.858.231-.22.14667-.33.37033-.33.671s.1137.53533.341.704c.2347.16867.5354.253.902.253z"/><path d="m28.582 8v-7.7h.869v7.7z"/><path d="m31.2783 8v-5.379h.869v5.379zm.44-6.215c-.1907 0-.352-.06233-.484-.187-.1247-.12467-.187-.28233-.187-.473 0-.198.0623-.359333.187-.484.132-.124667.2933-.187.484-.187s.3483.062333.473.187.187.286.187.484c0 .19067-.0623.34833-.187.473s-.2823.187-.473.187z"/><path d="m33.7326 8v-1.122l3.421-3.377v-.121h-3.311v-.759h4.224v1.122l-3.432 3.377v.132h3.52v.748z"/><path d="m41.9601 8.154c-.5427 0-1.0194-.11367-1.43-.341-.4107-.23467-.7297-.561-.957-.979-.2274-.418-.341-.902-.341-1.452v-.132c0-.55733.1136-1.045.341-1.463.2273-.418.5426-.74067.946-.968.4033-.23467.8653-.352 1.386-.352.506 0 .9533.11 1.342.33.3886.21267.693.52067.913.924s.33.87633.33 1.419v.396h-4.389c.022.57933.209 1.034.561 1.364.352.32267.792.484 1.32.484.462 0 .8176-.10633 1.067-.319.2493-.21267.44-.46567.572-.759l.748.363c-.11.22733-.264.45467-.462.682-.1907.22733-.4437.418-.759.572-.308.154-.704.231-1.188.231zm-1.848-3.333h3.498c-.0294-.49867-.2017-.88733-.517-1.166-.308-.27867-.704-.418-1.188-.418-.4914 0-.8947.13933-1.21.418-.3154.27867-.5097.66733-.583 1.166z"/><path d="m48.2828 8.154c-.462 0-.8873-.11-1.276-.33-.3886-.22-.6966-.539-.924-.957-.2273-.418-.341-.913-.341-1.485v-.143c0-.572.1137-1.06333.341-1.474.2274-.418.5317-.737.913-.957.3887-.22733.8177-.341 1.287-.341.374 0 .6894.05133.946.154.264.09533.4767.22.638.374.1614.14667.286.30433.374.473h.154v-3.168h.869v7.7h-.847v-.891h-.154c-.1466.27133-.374.51333-.682.726s-.7406.319-1.298.319zm.231-.77c.5574 0 1.0084-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.3446-.35933-.7956-.539-1.353-.539-.55 0-1.0046.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.3594.352.814.528 1.364.528z"/><path d="m58.8911 8.154c-.5573 0-.9936-.10633-1.309-.319-.308-.21267-.5316-.45467-.671-.726h-.154v.891h-.847v-7.7h.869v3.168h.154c.088-.16867.2127-.32633.374-.473.1614-.154.3704-.27867.627-.374.264-.10267.583-.154.957-.154.4694 0 .8947.11367 1.276.341.3887.22.6967.539.924.957.2274.41067.341.902.341 1.474v.143c0 .572-.1173 1.067-.352 1.485-.2273.418-.5353.737-.924.957-.3813.22-.803.33-1.265.33zm-.231-.77c.5574 0 1.0084-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.3446-.35933-.7956-.539-1.353-.539-.55 0-1.0046.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.3594.352.814.528 1.364.528z"/><path d="m63.6382 10.2v-.77h3.08c.2127 0 .319-.11.319-.33v-1.958h-.154c-.0733.154-.187.308-.341.462-.1466.14667-.341.26767-.583.363-.242.088-.5463.132-.913.132-.3886 0-.748-.08433-1.078-.253-.3226-.16867-.5793-.418-.77-.748-.1833-.33-.275-.73333-.275-1.21v-3.267h.869v3.201c0 .528.132.913.396 1.155.2714.242.6344.363 1.089.363.5134 0 .935-.16867 1.265-.506s.495-.83967.495-1.507v-2.706h.869v6.633c0 .29333-.0843.52433-.253.693-.1613.1687-.3996.253-.715.253z"/><path d="m75.2998 8.154c-.9167 0-1.6464-.264-2.189-.792-.5427-.53533-.814-1.31267-.814-2.332v-1.76c0-1.01933.2713-1.793.814-2.321.5426-.535333 1.2723-.803 2.189-.803.9093 0 1.606.253 2.09.759.4913.506.737 1.199.737 2.079v.055h-.913v-.088c0-.57933-.1577-1.05233-.473-1.419-.308-.374-.7884-.561-1.441-.561-.6527 0-1.1624.20167-1.529.605-.3667.396-.55.95333-.55 1.672v1.804c0 .71867.1833 1.27967.55 1.683.3666.396.8763.594 1.529.594.6526 0 1.133-.18333 1.441-.55.3153-.374.473-.85067.473-1.43v-.176h.913v.143c0 .88-.2457 1.573-.737 2.079-.484.506-1.1807.759-2.09.759z"/><path d="m82.0934 8.154c-.5427 0-1.023-.11367-1.441-.341-.4107-.22733-.7333-.54633-.968-.957-.2273-.418-.341-.90933-.341-1.474v-.143c0-.55733.1137-1.045.341-1.463.2347-.418.5573-.74067.968-.968.418-.22733.8983-.341 1.441-.341s1.0193.11367 1.43.341c.418.22733.7407.55.968.968.2347.418.352.90567.352 1.463v.143c0 .56467-.1173 1.056-.352 1.474-.2273.41067-.55.72967-.968.957-.4107.22733-.8873.341-1.43.341zm0-.781c.572 0 1.0267-.17967 1.364-.539.3447-.36667.517-.858.517-1.474v-.099c0-.616-.1723-1.10367-.517-1.463-.3373-.36667-.792-.55-1.364-.55-.5647 0-1.0193.18333-1.364.55-.3447.35933-.517.847-.517 1.463v.099c0 .616.1723 1.10733.517 1.474.3447.35933.7993.539 1.364.539z"/><path d="m88.5742 8.154c-.6673 0-1.232-.154-1.694-.462-.4547-.308-.7297-.79567-.825-1.463l.825-.187c.0587.352.1687.63067.33.836.1613.198.3593.341.594.429.242.08067.4987.121.77.121.4033 0 .7223-.08067.957-.242s.352-.37767.352-.649c0-.27867-.1137-.473-.341-.583-.22-.11733-.5243-.21267-.913-.286l-.451-.077c-.3447-.05867-.66-.15033-.946-.275s-.5133-.29333-.682-.506-.253-.48033-.253-.803c0-.484.187-.86167.561-1.133s.869-.407 1.485-.407c.6087 0 1.1.13933 1.474.418.3813.27133.627.65633.737 1.155l-.814.209c-.066-.38867-.2237-.66-.473-.814-.2493-.16133-.5573-.242-.924-.242s-.6563.06967-.869.209c-.2127.132-.319.33-.319.594 0 .25667.099.44733.297.572.2053.11733.4767.20533.814.264l.451.077c.3813.066.7223.15767 1.023.275.308.11.55.27133.726.484.1833.21267.275.49133.275.836 0 .528-.198.935-.594 1.221-.3887.286-.913.429-1.573.429z"/><path d="m92.208 8v-5.379h.847v.671h.154c.1026-.19067.2713-.36667.506-.528.2346-.16133.5646-.242.99-.242.418 0 .7553.09167 1.012.275.264.18333.4546.407.572.671h.154c.1246-.264.3116-.48767.561-.671.2566-.18333.6123-.275 1.067-.275.3593 0 .6746.07333.946.22.2713.14667.484.35933.638.638.1613.27133.242.59767.242.979v3.641h-.869v-3.564c0-.35933-.1064-.64167-.319-.847-.2054-.21267-.495-.319-.869-.319-.396 0-.7224.12833-.979.385-.2494.25667-.374.627-.374 1.111v3.234h-.869v-3.564c0-.35933-.1064-.64167-.319-.847-.2054-.21267-.495-.319-.869-.319-.396 0-.7224.12833-.979.385-.2494.25667-.374.627-.374 1.111v3.234z"/><path d="m104.158 8.154c-.543 0-1.023-.11367-1.441-.341-.411-.22733-.733-.54633-.968-.957-.227-.418-.341-.90933-.341-1.474v-.143c0-.55733.114-1.045.341-1.463.235-.418.557-.74067.968-.968.418-.22733.898-.341 1.441-.341s1.019.11367 1.43.341c.418.22733.741.55.968.968.235.418.352.90567.352 1.463v.143c0 .56467-.117 1.056-.352 1.474-.227.41067-.55.72967-.968.957-.411.22733-.887.341-1.43.341zm0-.781c.572 0 1.027-.17967 1.364-.539.345-.36667.517-.858.517-1.474v-.099c0-.616-.172-1.10367-.517-1.463-.337-.36667-.792-.55-1.364-.55-.565 0-1.019.18333-1.364.55-.345.35933-.517.847-.517 1.463v.099c0 .616.172 1.10733.517 1.474.345.35933.799.539 1.364.539z"/><path d="m108.208 5.338v-.154c0-.56467.113-1.04867.341-1.452.227-.40333.535-.715.924-.935.388-.22.814-.33 1.276-.33.564 0 .997.11 1.298.33.308.21267.535.451.682.715h.154v-.891h.825v6.633c0 .29333-.081.52433-.242.693-.162.1687-.396.253-.704.253h-3.652v-.77h3.421c.22 0 .33-.11.33-.33v-2.046h-.154c-.088.16133-.213.319-.374.473-.162.154-.371.28233-.627.385-.257.09533-.576.143-.957.143-.462 0-.888-.11-1.276-.33-.389-.22-.697-.53167-.924-.935-.228-.41067-.341-.89467-.341-1.452zm2.772 1.947c.557 0 1.008-.176 1.353-.528.352-.352.528-.836.528-1.452v-.088c0-.62333-.176-1.10733-.528-1.452-.345-.352-.796-.528-1.353-.528-.55 0-1.005.176-1.364.528-.352.34467-.528.82867-.528 1.452v.088c0 .616.176 1.1.528 1.452.359.352.814.528 1.364.528z"/><path d="m115.529 8v-5.379h.847v.66h.154c.096-.23467.242-.407.44-.517s.459-.165.781-.165h.638v.792h-.693c-.388 0-.704.11-.946.33-.234.21267-.352.54633-.352 1.001v3.278z"/><path d="m121.143 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.653-.187 1.034-.187h1.815v-.396c0-.38133-.114-.682-.341-.902-.22-.22-.55-.33-.99-.33-.433 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.227-.572.418-.814.191-.24933.444-.44733.759-.594.323-.154.708-.231 1.155-.231.689 0 1.225.17967 1.606.539.381.352.572.85067.572 1.496v2.431c0 .22.103.33.308.33h.495v.737h-.759c-.242 0-.436-.066-.583-.198-.147-.13933-.22-.32267-.22-.55v-.055h-.132c-.081.13933-.191.286-.33.44-.132.14667-.315.26767-.55.363-.235.10267-.539.154-.913.154zm.099-.748c.513 0 .928-.15033 1.243-.451.323-.308.484-.737.484-1.287v-.121h-1.782c-.345 0-.631.077-.858.231-.22.14667-.33.37033-.33.671s.114.53533.341.704c.235.16867.535.253.902.253z"/><path d="m125.82 10.2v-7.579h.847v.891h.154c.14-.27133.363-.51333.671-.726.316-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.113 1.067-.341 1.485-.227.418-.535.737-.924.957-.381.22-.806.33-1.276.33-.374 0-.693-.05133-.957-.154-.256-.09533-.465-.22-.627-.374-.161-.154-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.558 0 1.009-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.344-.35933-.795-.539-1.353-.539-.55 0-1.004.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.36.352.814.528 1.364.528z"/><path d="m132.899 8v-7.7h.869v3.179h.154c.074-.16133.184-.31167.33-.451.154-.14667.349-.26767.583-.363.242-.09533.547-.143.913-.143.404 0 .763.088 1.078.264.323.16867.58.418.77.748.191.32267.286.726.286 1.21v3.256h-.869v-3.19c0-.53533-.135-.924-.407-1.166-.264-.242-.623-.363-1.078-.363-.52 0-.946.16867-1.276.506-.322.33733-.484.83967-.484 1.507v2.706z"/><path d="m140.118 8.154c-.212 0-.392-.06967-.539-.209-.139-.13933-.209-.319-.209-.539s.07-.39967.209-.539c.147-.13933.327-.209.539-.209.22 0 .4.06967.539.209.14.13933.209.319.209.539s-.069.39967-.209.539c-.139.13933-.319.209-.539.209z"/><path d="m144.078 8.154c-.374 0-.715-.066-1.023-.198s-.55-.32267-.726-.572-.264-.55367-.264-.913c0-.36667.088-.66733.264-.902.176-.242.418-.42167.726-.539.308-.12467.652-.187 1.034-.187h1.815v-.396c0-.38133-.114-.682-.341-.902-.22-.22-.55-.33-.99-.33-.433 0-.77.10633-1.012.319-.242.20533-.407.484-.495.836l-.814-.264c.088-.30067.227-.572.418-.814.19-.24933.443-.44733.759-.594.322-.154.707-.231 1.155-.231.689 0 1.224.17967 1.606.539.381.352.572.85067.572 1.496v2.431c0 .22.102.33.308.33h.495v.737h-.759c-.242 0-.437-.066-.583-.198-.147-.13933-.22-.32267-.22-.55v-.055h-.132c-.081.13933-.191.286-.33.44-.132.14667-.316.26767-.55.363-.235.10267-.539.154-.913.154zm.099-.748c.513 0 .927-.15033 1.243-.451.322-.308.484-.737.484-1.287v-.121h-1.782c-.345 0-.631.077-.858.231-.22.14667-.33.37033-.33.671s.113.53533.341.704c.234.16867.535.253.902.253z"/><path d="m148.755 10.2v-7.579h.847v.891h.154c.139-.27133.363-.51333.671-.726.315-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.114 1.067-.341 1.485s-.535.737-.924.957c-.381.22-.807.33-1.276.33-.374 0-.693-.05133-.957-.154-.257-.09533-.466-.22-.627-.374s-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.557 0 1.008-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.345-.35933-.796-.539-1.353-.539-.55 0-1.005.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.359.352.814.528 1.364.528z"/><path d="m155.834 10.2v-7.579h.847v.891h.154c.139-.27133.363-.51333.671-.726.315-.21267.752-.319 1.309-.319.462 0 .884.11367 1.265.341.389.22.697.53533.924.946.235.41067.352.90567.352 1.485v.143c0 .572-.114 1.067-.341 1.485s-.535.737-.924.957c-.381.22-.807.33-1.276.33-.374 0-.693-.05133-.957-.154-.257-.09533-.466-.22-.627-.374s-.286-.31167-.374-.473h-.154v3.047zm2.75-2.816c.557 0 1.008-.176 1.353-.528.352-.35933.528-.858.528-1.496v-.099c0-.638-.176-1.133-.528-1.485-.345-.35933-.796-.539-1.353-.539-.55 0-1.005.17967-1.364.539-.352.352-.528.847-.528 1.485v.099c0 .638.176 1.13667.528 1.496.359.352.814.528 1.364.528z"/><path d="m71.6368 9.375h90.3682v.55h-90.3682z"/></g></svg>', Y$ = (e) => {
  let t;
  return e ? t = e : typeof fetch > "u" ? t = (...i) => Promise.resolve().then(() => _p).then(({ default: r }) => r(...i)) : t = fetch, (...i) => t(...i);
};
class T1 extends Error {
  constructor(t, i = "FunctionsError", r) {
    super(t), this.name = i, this.context = r;
  }
}
class q$ extends T1 {
  constructor(t) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", t);
  }
}
class Z$ extends T1 {
  constructor(t) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", t);
  }
}
class X$ extends T1 {
  constructor(t) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", t);
  }
}
var sb;
(function(e) {
  e.Any = "any", e.ApNortheast1 = "ap-northeast-1", e.ApNortheast2 = "ap-northeast-2", e.ApSouth1 = "ap-south-1", e.ApSoutheast1 = "ap-southeast-1", e.ApSoutheast2 = "ap-southeast-2", e.CaCentral1 = "ca-central-1", e.EuCentral1 = "eu-central-1", e.EuWest1 = "eu-west-1", e.EuWest2 = "eu-west-2", e.EuWest3 = "eu-west-3", e.SaEast1 = "sa-east-1", e.UsEast1 = "us-east-1", e.UsWest1 = "us-west-1", e.UsWest2 = "us-west-2";
})(sb || (sb = {}));
var K$ = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class J$ {
  constructor(t, { headers: i = {}, customFetch: r, region: n = sb.Any } = {}) {
    this.url = t, this.headers = i, this.region = n, this.fetch = Y$(r);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(t) {
    this.headers.Authorization = `Bearer ${t}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(t, i = {}) {
    var r;
    return K$(this, void 0, void 0, function* () {
      try {
        const { headers: n, method: s, body: a } = i;
        let o = {}, { region: c } = i;
        c || (c = this.region), c && c !== "any" && (o["x-region"] = c);
        let l;
        a && (n && !Object.prototype.hasOwnProperty.call(n, "Content-Type") || !n) && (typeof Blob < "u" && a instanceof Blob || a instanceof ArrayBuffer ? (o["Content-Type"] = "application/octet-stream", l = a) : typeof a == "string" ? (o["Content-Type"] = "text/plain", l = a) : typeof FormData < "u" && a instanceof FormData ? l = a : (o["Content-Type"] = "application/json", l = JSON.stringify(a)));
        const d = yield this.fetch(`${this.url}/${t}`, {
          method: s || "POST",
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, o), this.headers), n),
          body: l
        }).catch((m) => {
          throw new q$(m);
        }), u = d.headers.get("x-relay-error");
        if (u && u === "true")
          throw new Z$(d);
        if (!d.ok)
          throw new X$(d);
        let h = ((r = d.headers.get("Content-Type")) !== null && r !== void 0 ? r : "text/plain").split(";")[0].trim(), p;
        return h === "application/json" ? p = yield d.json() : h === "application/octet-stream" ? p = yield d.blob() : h === "multipart/form-data" ? p = yield d.formData() : p = yield d.text(), { data: p, error: null };
      } catch (n) {
        return { data: null, error: n };
      }
    });
  }
}
var Q$ = function() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
  throw new Error("unable to locate global object");
}, Nu = Q$();
const tz = Nu.fetch, E1 = Nu.fetch.bind(Nu), JT = Nu.Headers, ez = Nu.Request, iz = Nu.Response, _p = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Headers: JT,
  Request: ez,
  Response: iz,
  default: E1,
  fetch: tz
}, Symbol.toStringTag, { value: "Module" }));
class rz extends Error {
  constructor(t) {
    super(t.message), this.name = "PostgrestError", this.details = t.details, this.hint = t.hint, this.code = t.code;
  }
}
class nz {
  constructor(t) {
    this.shouldThrowOnError = !1, this.method = t.method, this.url = t.url, this.headers = t.headers, this.schema = t.schema, this.body = t.body, this.shouldThrowOnError = t.shouldThrowOnError, this.signal = t.signal, this.isMaybeSingle = t.isMaybeSingle, t.fetch ? this.fetch = t.fetch : typeof fetch > "u" ? this.fetch = E1 : this.fetch = fetch;
  }
  /**
   * If there's an error with the query, throwOnError will reject the promise by
   * throwing the error instead of returning it as part of a successful response.
   *
   * {@link https://github.com/supabase/supabase-js/issues/92}
   */
  throwOnError() {
    return this.shouldThrowOnError = !0, this;
  }
  then(t, i) {
    this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema), this.method !== "GET" && this.method !== "HEAD" && (this.headers["Content-Type"] = "application/json");
    const r = this.fetch;
    let n = r(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async (s) => {
      var a, o, c;
      let l = null, d = null, u = null, h = s.status, p = s.statusText;
      if (s.ok) {
        if (this.method !== "HEAD") {
          const F = await s.text();
          F === "" || (this.headers.Accept === "text/csv" || this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? d = F : d = JSON.parse(F));
        }
        const w = (a = this.headers.Prefer) === null || a === void 0 ? void 0 : a.match(/count=(exact|planned|estimated)/), C = (o = s.headers.get("content-range")) === null || o === void 0 ? void 0 : o.split("/");
        w && C && C.length > 1 && (u = parseInt(C[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(d) && (d.length > 1 ? (l = {
          // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
          code: "PGRST116",
          details: `Results contain ${d.length} rows, application/vnd.pgrst.object+json requires 1 row`,
          hint: null,
          message: "JSON object requested, multiple (or no) rows returned"
        }, d = null, u = null, h = 406, p = "Not Acceptable") : d.length === 1 ? d = d[0] : d = null);
      } else {
        const w = await s.text();
        try {
          l = JSON.parse(w), Array.isArray(l) && s.status === 404 && (d = [], l = null, h = 200, p = "OK");
        } catch {
          s.status === 404 && w === "" ? (h = 204, p = "No Content") : l = {
            message: w
          };
        }
        if (l && this.isMaybeSingle && (!((c = l == null ? void 0 : l.details) === null || c === void 0) && c.includes("0 rows")) && (l = null, h = 200, p = "OK"), l && this.shouldThrowOnError)
          throw new rz(l);
      }
      return {
        error: l,
        data: d,
        count: u,
        status: h,
        statusText: p
      };
    });
    return this.shouldThrowOnError || (n = n.catch((s) => {
      var a, o, c;
      return {
        error: {
          message: `${(a = s == null ? void 0 : s.name) !== null && a !== void 0 ? a : "FetchError"}: ${s == null ? void 0 : s.message}`,
          details: `${(o = s == null ? void 0 : s.stack) !== null && o !== void 0 ? o : ""}`,
          hint: "",
          code: `${(c = s == null ? void 0 : s.code) !== null && c !== void 0 ? c : ""}`
        },
        data: null,
        count: null,
        status: 0,
        statusText: ""
      };
    })), n.then(t, i);
  }
}
class sz extends nz {
  /**
   * Perform a SELECT on the query result.
   *
   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
   * return modified rows. By calling this method, modified rows are returned in
   * `data`.
   *
   * @param columns - The columns to retrieve, separated by commas
   */
  select(t) {
    let i = !1;
    const r = (t ?? "*").split("").map((n) => /\s/.test(n) && !i ? "" : (n === '"' && (i = !i), n)).join("");
    return this.url.searchParams.set("select", r), this.headers.Prefer && (this.headers.Prefer += ","), this.headers.Prefer += "return=representation", this;
  }
  /**
   * Order the query result by `column`.
   *
   * You can call this method multiple times to order by multiple columns.
   *
   * You can order referenced tables, but it only affects the ordering of the
   * parent table if you use `!inner` in the query.
   *
   * @param column - The column to order by
   * @param options - Named parameters
   * @param options.ascending - If `true`, the result will be in ascending order
   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
   * `null`s appear last.
   * @param options.referencedTable - Set this to order a referenced table by
   * its columns
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  order(t, { ascending: i = !0, nullsFirst: r, foreignTable: n, referencedTable: s = n } = {}) {
    const a = s ? `${s}.order` : "order", o = this.url.searchParams.get(a);
    return this.url.searchParams.set(a, `${o ? `${o},` : ""}${t}.${i ? "asc" : "desc"}${r === void 0 ? "" : r ? ".nullsfirst" : ".nullslast"}`), this;
  }
  /**
   * Limit the query result by `count`.
   *
   * @param count - The maximum number of rows to return
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  limit(t, { foreignTable: i, referencedTable: r = i } = {}) {
    const n = typeof r > "u" ? "limit" : `${r}.limit`;
    return this.url.searchParams.set(n, `${t}`), this;
  }
  /**
   * Limit the query result by starting at an offset (`from`) and ending at the offset (`from + to`).
   * Only records within this range are returned.
   * This respects the query order and if there is no order clause the range could behave unexpectedly.
   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
   * and fourth rows of the query.
   *
   * @param from - The starting index from which to limit the result
   * @param to - The last index to which to limit the result
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  range(t, i, { foreignTable: r, referencedTable: n = r } = {}) {
    const s = typeof n > "u" ? "offset" : `${n}.offset`, a = typeof n > "u" ? "limit" : `${n}.limit`;
    return this.url.searchParams.set(s, `${t}`), this.url.searchParams.set(a, `${i - t + 1}`), this;
  }
  /**
   * Set the AbortSignal for the fetch request.
   *
   * @param signal - The AbortSignal to use for the fetch request
   */
  abortSignal(t) {
    return this.signal = t, this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be one row (e.g. using `.limit(1)`), otherwise this
   * returns an error.
   */
  single() {
    return this.headers.Accept = "application/vnd.pgrst.object+json", this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
   * this returns an error.
   */
  maybeSingle() {
    return this.method === "GET" ? this.headers.Accept = "application/json" : this.headers.Accept = "application/vnd.pgrst.object+json", this.isMaybeSingle = !0, this;
  }
  /**
   * Return `data` as a string in CSV format.
   */
  csv() {
    return this.headers.Accept = "text/csv", this;
  }
  /**
   * Return `data` as an object in [GeoJSON](https://geojson.org) format.
   */
  geojson() {
    return this.headers.Accept = "application/geo+json", this;
  }
  /**
   * Return `data` as the EXPLAIN plan for the query.
   *
   * You need to enable the
   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
   * setting before using this method.
   *
   * @param options - Named parameters
   *
   * @param options.analyze - If `true`, the query will be executed and the
   * actual run time will be returned
   *
   * @param options.verbose - If `true`, the query identifier will be returned
   * and `data` will include the output columns of the query
   *
   * @param options.settings - If `true`, include information on configuration
   * parameters that affect query planning
   *
   * @param options.buffers - If `true`, include information on buffer usage
   *
   * @param options.wal - If `true`, include information on WAL record generation
   *
   * @param options.format - The format of the output, can be `"text"` (default)
   * or `"json"`
   */
  explain({ analyze: t = !1, verbose: i = !1, settings: r = !1, buffers: n = !1, wal: s = !1, format: a = "text" } = {}) {
    var o;
    const c = [
      t ? "analyze" : null,
      i ? "verbose" : null,
      r ? "settings" : null,
      n ? "buffers" : null,
      s ? "wal" : null
    ].filter(Boolean).join("|"), l = (o = this.headers.Accept) !== null && o !== void 0 ? o : "application/json";
    return this.headers.Accept = `application/vnd.pgrst.plan+${a}; for="${l}"; options=${c};`, a === "json" ? this : this;
  }
  /**
   * Rollback the query.
   *
   * `data` will still be returned, but the query is not committed.
   */
  rollback() {
    var t;
    return ((t = this.headers.Prefer) !== null && t !== void 0 ? t : "").trim().length > 0 ? this.headers.Prefer += ",tx=rollback" : this.headers.Prefer = "tx=rollback", this;
  }
  /**
   * Override the type of the returned `data`.
   *
   * @typeParam NewResult - The new result type to override with
   */
  returns() {
    return this;
  }
}
class Nd extends sz {
  /**
   * Match only rows where `column` is equal to `value`.
   *
   * To check if the value of `column` is NULL, you should use `.is()` instead.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  eq(t, i) {
    return this.url.searchParams.append(t, `eq.${i}`), this;
  }
  /**
   * Match only rows where `column` is not equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  neq(t, i) {
    return this.url.searchParams.append(t, `neq.${i}`), this;
  }
  /**
   * Match only rows where `column` is greater than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gt(t, i) {
    return this.url.searchParams.append(t, `gt.${i}`), this;
  }
  /**
   * Match only rows where `column` is greater than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gte(t, i) {
    return this.url.searchParams.append(t, `gte.${i}`), this;
  }
  /**
   * Match only rows where `column` is less than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lt(t, i) {
    return this.url.searchParams.append(t, `lt.${i}`), this;
  }
  /**
   * Match only rows where `column` is less than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lte(t, i) {
    return this.url.searchParams.append(t, `lte.${i}`), this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-sensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  like(t, i) {
    return this.url.searchParams.append(t, `like.${i}`), this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAllOf(t, i) {
    return this.url.searchParams.append(t, `like(all).{${i.join(",")}}`), this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAnyOf(t, i) {
    return this.url.searchParams.append(t, `like(any).{${i.join(",")}}`), this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-insensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  ilike(t, i) {
    return this.url.searchParams.append(t, `ilike.${i}`), this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAllOf(t, i) {
    return this.url.searchParams.append(t, `ilike(all).{${i.join(",")}}`), this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAnyOf(t, i) {
    return this.url.searchParams.append(t, `ilike(any).{${i.join(",")}}`), this;
  }
  /**
   * Match only rows where `column` IS `value`.
   *
   * For non-boolean columns, this is only relevant for checking if the value of
   * `column` is NULL by setting `value` to `null`.
   *
   * For boolean columns, you can also set `value` to `true` or `false` and it
   * will behave the same way as `.eq()`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  is(t, i) {
    return this.url.searchParams.append(t, `is.${i}`), this;
  }
  /**
   * Match only rows where `column` is included in the `values` array.
   *
   * @param column - The column to filter on
   * @param values - The values array to filter with
   */
  in(t, i) {
    const r = Array.from(new Set(i)).map((n) => typeof n == "string" && new RegExp("[,()]").test(n) ? `"${n}"` : `${n}`).join(",");
    return this.url.searchParams.append(t, `in.(${r})`), this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * `column` contains every element appearing in `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  contains(t, i) {
    return typeof i == "string" ? this.url.searchParams.append(t, `cs.${i}`) : Array.isArray(i) ? this.url.searchParams.append(t, `cs.{${i.join(",")}}`) : this.url.searchParams.append(t, `cs.${JSON.stringify(i)}`), this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * every element appearing in `column` is contained by `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  containedBy(t, i) {
    return typeof i == "string" ? this.url.searchParams.append(t, `cd.${i}`) : Array.isArray(i) ? this.url.searchParams.append(t, `cd.{${i.join(",")}}`) : this.url.searchParams.append(t, `cd.${JSON.stringify(i)}`), this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is greater than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGt(t, i) {
    return this.url.searchParams.append(t, `sr.${i}`), this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or greater than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGte(t, i) {
    return this.url.searchParams.append(t, `nxl.${i}`), this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is less than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLt(t, i) {
    return this.url.searchParams.append(t, `sl.${i}`), this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or less than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLte(t, i) {
    return this.url.searchParams.append(t, `nxr.${i}`), this;
  }
  /**
   * Only relevant for range columns. Match only rows where `column` is
   * mutually exclusive to `range` and there can be no element between the two
   * ranges.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeAdjacent(t, i) {
    return this.url.searchParams.append(t, `adj.${i}`), this;
  }
  /**
   * Only relevant for array and range columns. Match only rows where
   * `column` and `value` have an element in common.
   *
   * @param column - The array or range column to filter on
   * @param value - The array or range value to filter with
   */
  overlaps(t, i) {
    return typeof i == "string" ? this.url.searchParams.append(t, `ov.${i}`) : this.url.searchParams.append(t, `ov.{${i.join(",")}}`), this;
  }
  /**
   * Only relevant for text and tsvector columns. Match only rows where
   * `column` matches the query string in `query`.
   *
   * @param column - The text or tsvector column to filter on
   * @param query - The query text to match with
   * @param options - Named parameters
   * @param options.config - The text search configuration to use
   * @param options.type - Change how the `query` text is interpreted
   */
  textSearch(t, i, { config: r, type: n } = {}) {
    let s = "";
    n === "plain" ? s = "pl" : n === "phrase" ? s = "ph" : n === "websearch" && (s = "w");
    const a = r === void 0 ? "" : `(${r})`;
    return this.url.searchParams.append(t, `${s}fts${a}.${i}`), this;
  }
  /**
   * Match only rows where each column in `query` keys is equal to its
   * associated value. Shorthand for multiple `.eq()`s.
   *
   * @param query - The object to filter with, with column names as keys mapped
   * to their filter values
   */
  match(t) {
    return Object.entries(t).forEach(([i, r]) => {
      this.url.searchParams.append(i, `eq.${r}`);
    }), this;
  }
  /**
   * Match only rows which doesn't satisfy the filter.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to be negated to filter with, following
   * PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  not(t, i, r) {
    return this.url.searchParams.append(t, `not.${i}.${r}`), this;
  }
  /**
   * Match only rows which satisfy at least one of the filters.
   *
   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure it's properly sanitized.
   *
   * It's currently not possible to do an `.or()` filter across multiple tables.
   *
   * @param filters - The filters to use, following PostgREST syntax
   * @param options - Named parameters
   * @param options.referencedTable - Set this to filter on referenced tables
   * instead of the parent table
   * @param options.foreignTable - Deprecated, use `referencedTable` instead
   */
  or(t, { foreignTable: i, referencedTable: r = i } = {}) {
    const n = r ? `${r}.or` : "or";
    return this.url.searchParams.append(n, `(${t})`), this;
  }
  /**
   * Match only rows which satisfy the filter. This is an escape hatch - you
   * should use the specific filter methods wherever possible.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to filter with, following PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  filter(t, i, r) {
    return this.url.searchParams.append(t, `${i}.${r}`), this;
  }
}
class az {
  constructor(t, { headers: i = {}, schema: r, fetch: n }) {
    this.url = t, this.headers = i, this.schema = r, this.fetch = n;
  }
  /**
   * Perform a SELECT query on the table or view.
   *
   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
   *
   * @param options - Named parameters
   *
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   *
   * @param options.count - Count algorithm to use to count rows in the table or view.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  select(t, { head: i = !1, count: r } = {}) {
    const n = i ? "HEAD" : "GET";
    let s = !1;
    const a = (t ?? "*").split("").map((o) => /\s/.test(o) && !s ? "" : (o === '"' && (s = !s), o)).join("");
    return this.url.searchParams.set("select", a), r && (this.headers.Prefer = `count=${r}`), new Nd({
      method: n,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
  /**
   * Perform an INSERT into the table or view.
   *
   * By default, inserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to insert. Pass an object to insert a single row
   * or an array to insert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count inserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. Only applies for bulk
   * inserts.
   */
  insert(t, { count: i, defaultToNull: r = !0 } = {}) {
    const n = "POST", s = [];
    if (this.headers.Prefer && s.push(this.headers.Prefer), i && s.push(`count=${i}`), r || s.push("missing=default"), this.headers.Prefer = s.join(","), Array.isArray(t)) {
      const a = t.reduce((o, c) => o.concat(Object.keys(c)), []);
      if (a.length > 0) {
        const o = [...new Set(a)].map((c) => `"${c}"`);
        this.url.searchParams.set("columns", o.join(","));
      }
    }
    return new Nd({
      method: n,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: t,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
  /**
   * Perform an UPSERT on the table or view. Depending on the column(s) passed
   * to `onConflict`, `.upsert()` allows you to perform the equivalent of
   * `.insert()` if a row with the corresponding `onConflict` columns doesn't
   * exist, or if it does exist, perform an alternative action depending on
   * `ignoreDuplicates`.
   *
   * By default, upserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to upsert with. Pass an object to upsert a
   * single row or an array to upsert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
   * duplicate rows are determined. Two rows are duplicates if all the
   * `onConflict` columns are equal.
   *
   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
   * `false`, duplicate rows are merged with existing rows.
   *
   * @param options.count - Count algorithm to use to count upserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. This only applies when
   * inserting new rows, not when merging with existing rows under
   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
   */
  upsert(t, { onConflict: i, ignoreDuplicates: r = !1, count: n, defaultToNull: s = !0 } = {}) {
    const a = "POST", o = [`resolution=${r ? "ignore" : "merge"}-duplicates`];
    if (i !== void 0 && this.url.searchParams.set("on_conflict", i), this.headers.Prefer && o.push(this.headers.Prefer), n && o.push(`count=${n}`), s || o.push("missing=default"), this.headers.Prefer = o.join(","), Array.isArray(t)) {
      const c = t.reduce((l, d) => l.concat(Object.keys(d)), []);
      if (c.length > 0) {
        const l = [...new Set(c)].map((d) => `"${d}"`);
        this.url.searchParams.set("columns", l.join(","));
      }
    }
    return new Nd({
      method: a,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: t,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
  /**
   * Perform an UPDATE on the table or view.
   *
   * By default, updated rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param values - The values to update with
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count updated rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  update(t, { count: i } = {}) {
    const r = "PATCH", n = [];
    return this.headers.Prefer && n.push(this.headers.Prefer), i && n.push(`count=${i}`), this.headers.Prefer = n.join(","), new Nd({
      method: r,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: t,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
  /**
   * Perform a DELETE on the table or view.
   *
   * By default, deleted rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count deleted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  delete({ count: t } = {}) {
    const i = "DELETE", r = [];
    return t && r.push(`count=${t}`), this.headers.Prefer && r.unshift(this.headers.Prefer), this.headers.Prefer = r.join(","), new Nd({
      method: i,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
}
const oz = "1.11.0", cz = { "X-Client-Info": `postgrest-js/${oz}` };
class k1 {
  // TODO: Add back shouldThrowOnError once we figure out the typings
  /**
   * Creates a PostgREST client.
   *
   * @param url - URL of the PostgREST endpoint
   * @param options - Named parameters
   * @param options.headers - Custom headers
   * @param options.schema - Postgres schema to switch to
   * @param options.fetch - Custom fetch
   */
  constructor(t, { headers: i = {}, schema: r, fetch: n } = {}) {
    this.url = t, this.headers = Object.assign(Object.assign({}, cz), i), this.schemaName = r, this.fetch = n;
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(t) {
    const i = new URL(`${this.url}/${t}`);
    return new az(i, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    });
  }
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(t) {
    return new k1(this.url, {
      headers: this.headers,
      schema: t,
      fetch: this.fetch
    });
  }
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(t, i = {}, { head: r = !1, count: n } = {}) {
    let s;
    const a = new URL(`${this.url}/rpc/${t}`);
    let o;
    r ? (s = "HEAD", Object.entries(i).forEach(([l, d]) => {
      a.searchParams.append(l, `${d}`);
    })) : (s = "POST", o = i);
    const c = Object.assign({}, this.headers);
    return n && (c.Prefer = `count=${n}`), new Nd({
      method: s,
      url: a,
      headers: c,
      schema: this.schemaName,
      body: o,
      fetch: this.fetch,
      allowEmpty: !1
    });
  }
}
const lz = "2.9.3", dz = { "X-Client-Info": `realtime-js/${lz}` }, uz = "1.0.0", QT = 1e4, hz = 1e3;
var uu;
(function(e) {
  e[e.connecting = 0] = "connecting", e[e.open = 1] = "open", e[e.closing = 2] = "closing", e[e.closed = 3] = "closed";
})(uu || (uu = {}));
var Jn;
(function(e) {
  e.closed = "closed", e.errored = "errored", e.joined = "joined", e.joining = "joining", e.leaving = "leaving";
})(Jn || (Jn = {}));
var Bs;
(function(e) {
  e.close = "phx_close", e.error = "phx_error", e.join = "phx_join", e.reply = "phx_reply", e.leave = "phx_leave", e.access_token = "access_token";
})(Bs || (Bs = {}));
var ab;
(function(e) {
  e.websocket = "websocket";
})(ab || (ab = {}));
var El;
(function(e) {
  e.Connecting = "connecting", e.Open = "open", e.Closing = "closing", e.Closed = "closed";
})(El || (El = {}));
class tE {
  constructor(t, i) {
    this.callback = t, this.timerCalc = i, this.timer = void 0, this.tries = 0, this.callback = t, this.timerCalc = i;
  }
  reset() {
    this.tries = 0, clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.tries = this.tries + 1, this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}
class fz {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(t, i) {
    return t.constructor === ArrayBuffer ? i(this._binaryDecode(t)) : i(typeof t == "string" ? JSON.parse(t) : {});
  }
  _binaryDecode(t) {
    const i = new DataView(t), r = new TextDecoder();
    return this._decodeBroadcast(t, i, r);
  }
  _decodeBroadcast(t, i, r) {
    const n = i.getUint8(1), s = i.getUint8(2);
    let a = this.HEADER_LENGTH + 2;
    const o = r.decode(t.slice(a, a + n));
    a = a + n;
    const c = r.decode(t.slice(a, a + s));
    a = a + s;
    const l = JSON.parse(r.decode(t.slice(a, t.byteLength)));
    return { ref: null, topic: o, event: c, payload: l };
  }
}
class o_ {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(t, i, r = {}, n = QT) {
    this.channel = t, this.event = i, this.payload = r, this.timeout = n, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null;
  }
  resend(t) {
    this.timeout = t, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send();
  }
  send() {
    this._hasReceived("timeout") || (this.startTimeout(), this.sent = !0, this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    }));
  }
  updatePayload(t) {
    this.payload = Object.assign(Object.assign({}, this.payload), t);
  }
  receive(t, i) {
    var r;
    return this._hasReceived(t) && i((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response), this.recHooks.push({ status: t, callback: i }), this;
  }
  startTimeout() {
    if (this.timeoutTimer)
      return;
    this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref);
    const t = (i) => {
      this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = i, this._matchReceive(i);
    };
    this.channel._on(this.refEvent, {}, t), this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {});
    }, this.timeout);
  }
  trigger(t, i) {
    this.refEvent && this.channel._trigger(this.refEvent, { status: t, response: i });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0;
  }
  _matchReceive({ status: t, response: i }) {
    this.recHooks.filter((r) => r.status === t).forEach((r) => r.callback(i));
  }
  _hasReceived(t) {
    return this.receivedResp && this.receivedResp.status === t;
  }
}
var BI;
(function(e) {
  e.SYNC = "sync", e.JOIN = "join", e.LEAVE = "leave";
})(BI || (BI = {}));
class wf {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(t, i) {
    this.channel = t, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.caller = {
      onJoin: () => {
      },
      onLeave: () => {
      },
      onSync: () => {
      }
    };
    const r = (i == null ? void 0 : i.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(r.state, {}, (n) => {
      const { onJoin: s, onLeave: a, onSync: o } = this.caller;
      this.joinRef = this.channel._joinRef(), this.state = wf.syncState(this.state, n, s, a), this.pendingDiffs.forEach((c) => {
        this.state = wf.syncDiff(this.state, c, s, a);
      }), this.pendingDiffs = [], o();
    }), this.channel._on(r.diff, {}, (n) => {
      const { onJoin: s, onLeave: a, onSync: o } = this.caller;
      this.inPendingSyncState() ? this.pendingDiffs.push(n) : (this.state = wf.syncDiff(this.state, n, s, a), o());
    }), this.onJoin((n, s, a) => {
      this.channel._trigger("presence", {
        event: "join",
        key: n,
        currentPresences: s,
        newPresences: a
      });
    }), this.onLeave((n, s, a) => {
      this.channel._trigger("presence", {
        event: "leave",
        key: n,
        currentPresences: s,
        leftPresences: a
      });
    }), this.onSync(() => {
      this.channel._trigger("presence", { event: "sync" });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(t, i, r, n) {
    const s = this.cloneDeep(t), a = this.transformState(i), o = {}, c = {};
    return this.map(s, (l, d) => {
      a[l] || (c[l] = d);
    }), this.map(a, (l, d) => {
      const u = s[l];
      if (u) {
        const h = d.map((C) => C.presence_ref), p = u.map((C) => C.presence_ref), m = d.filter((C) => p.indexOf(C.presence_ref) < 0), w = u.filter((C) => h.indexOf(C.presence_ref) < 0);
        m.length > 0 && (o[l] = m), w.length > 0 && (c[l] = w);
      } else
        o[l] = d;
    }), this.syncDiff(s, { joins: o, leaves: c }, r, n);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(t, i, r, n) {
    const { joins: s, leaves: a } = {
      joins: this.transformState(i.joins),
      leaves: this.transformState(i.leaves)
    };
    return r || (r = () => {
    }), n || (n = () => {
    }), this.map(s, (o, c) => {
      var l;
      const d = (l = t[o]) !== null && l !== void 0 ? l : [];
      if (t[o] = this.cloneDeep(c), d.length > 0) {
        const u = t[o].map((p) => p.presence_ref), h = d.filter((p) => u.indexOf(p.presence_ref) < 0);
        t[o].unshift(...h);
      }
      r(o, d, c);
    }), this.map(a, (o, c) => {
      let l = t[o];
      if (!l)
        return;
      const d = c.map((u) => u.presence_ref);
      l = l.filter((u) => d.indexOf(u.presence_ref) < 0), t[o] = l, n(o, l, c), l.length === 0 && delete t[o];
    }), t;
  }
  /** @internal */
  static map(t, i) {
    return Object.getOwnPropertyNames(t).map((r) => i(r, t[r]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(t) {
    return t = this.cloneDeep(t), Object.getOwnPropertyNames(t).reduce((i, r) => {
      const n = t[r];
      return "metas" in n ? i[r] = n.metas.map((s) => (s.presence_ref = s.phx_ref, delete s.phx_ref, delete s.phx_ref_prev, s)) : i[r] = n, i;
    }, {});
  }
  /** @internal */
  static cloneDeep(t) {
    return JSON.parse(JSON.stringify(t));
  }
  /** @internal */
  onJoin(t) {
    this.caller.onJoin = t;
  }
  /** @internal */
  onLeave(t) {
    this.caller.onLeave = t;
  }
  /** @internal */
  onSync(t) {
    this.caller.onSync = t;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var tr;
(function(e) {
  e.abstime = "abstime", e.bool = "bool", e.date = "date", e.daterange = "daterange", e.float4 = "float4", e.float8 = "float8", e.int2 = "int2", e.int4 = "int4", e.int4range = "int4range", e.int8 = "int8", e.int8range = "int8range", e.json = "json", e.jsonb = "jsonb", e.money = "money", e.numeric = "numeric", e.oid = "oid", e.reltime = "reltime", e.text = "text", e.time = "time", e.timestamp = "timestamp", e.timestamptz = "timestamptz", e.timetz = "timetz", e.tsrange = "tsrange", e.tstzrange = "tstzrange";
})(tr || (tr = {}));
const RI = (e, t, i = {}) => {
  var r;
  const n = (r = i.skipTypes) !== null && r !== void 0 ? r : [];
  return Object.keys(t).reduce((s, a) => (s[a] = pz(a, e, t, n), s), {});
}, pz = (e, t, i, r) => {
  const n = t.find((o) => o.name === e), s = n == null ? void 0 : n.type, a = i[e];
  return s && !r.includes(s) ? eE(s, a) : ob(a);
}, eE = (e, t) => {
  if (e.charAt(0) === "_") {
    const i = e.slice(1, e.length);
    return vz(t, i);
  }
  switch (e) {
    case tr.bool:
      return mz(t);
    case tr.float4:
    case tr.float8:
    case tr.int2:
    case tr.int4:
    case tr.int8:
    case tr.numeric:
    case tr.oid:
      return gz(t);
    case tr.json:
    case tr.jsonb:
      return yz(t);
    case tr.timestamp:
      return _z(t);
    case tr.abstime:
    case tr.date:
    case tr.daterange:
    case tr.int4range:
    case tr.int8range:
    case tr.money:
    case tr.reltime:
    case tr.text:
    case tr.time:
    case tr.timestamptz:
    case tr.timetz:
    case tr.tsrange:
    case tr.tstzrange:
      return ob(t);
    default:
      return ob(t);
  }
}, ob = (e) => e, mz = (e) => {
  switch (e) {
    case "t":
      return !0;
    case "f":
      return !1;
    default:
      return e;
  }
}, gz = (e) => {
  if (typeof e == "string") {
    const t = parseFloat(e);
    if (!Number.isNaN(t))
      return t;
  }
  return e;
}, yz = (e) => {
  if (typeof e == "string")
    try {
      return JSON.parse(e);
    } catch (t) {
      return console.log(`JSON parse error: ${t}`), e;
    }
  return e;
}, vz = (e, t) => {
  if (typeof e != "string")
    return e;
  const i = e.length - 1, r = e[i];
  if (e[0] === "{" && r === "}") {
    let s;
    const a = e.slice(1, i);
    try {
      s = JSON.parse("[" + a + "]");
    } catch {
      s = a ? a.split(",") : [];
    }
    return s.map((o) => eE(t, o));
  }
  return e;
}, _z = (e) => typeof e == "string" ? e.replace(" ", "T") : e;
var MI;
(function(e) {
  e.ALL = "*", e.INSERT = "INSERT", e.UPDATE = "UPDATE", e.DELETE = "DELETE";
})(MI || (MI = {}));
var PI;
(function(e) {
  e.BROADCAST = "broadcast", e.PRESENCE = "presence", e.POSTGRES_CHANGES = "postgres_changes";
})(PI || (PI = {}));
var $I;
(function(e) {
  e.SUBSCRIBED = "SUBSCRIBED", e.TIMED_OUT = "TIMED_OUT", e.CLOSED = "CLOSED", e.CHANNEL_ERROR = "CHANNEL_ERROR";
})($I || ($I = {}));
class C1 {
  constructor(t, i = { config: {} }, r) {
    this.topic = t, this.params = i, this.socket = r, this.bindings = {}, this.state = Jn.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = t.replace(/^realtime:/i, ""), this.params.config = Object.assign({
      broadcast: { ack: !1, self: !1 },
      presence: { key: "" }
    }, i.config), this.timeout = this.socket.timeout, this.joinPush = new o_(this, Bs.join, this.params, this.timeout), this.rejoinTimer = new tE(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
      this.state = Jn.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach((n) => n.send()), this.pushBuffer = [];
    }), this._onClose(() => {
      this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = Jn.closed, this.socket._remove(this);
    }), this._onError((n) => {
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, n), this.state = Jn.errored, this.rejoinTimer.scheduleTimeout());
    }), this.joinPush.receive("timeout", () => {
      this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = Jn.errored, this.rejoinTimer.scheduleTimeout());
    }), this._on(Bs.reply, {}, (n, s) => {
      this._trigger(this._replyEventName(s), n);
    }), this.presence = new wf(this), this.broadcastEndpointURL = this._broadcastEndpointURL();
  }
  /** Subscribe registers your client with the server */
  subscribe(t, i = this.timeout) {
    var r, n;
    if (this.socket.isConnected() || this.socket.connect(), this.joinedOnce)
      throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
    {
      const { config: { broadcast: s, presence: a } } = this.params;
      this._onError((l) => t && t("CHANNEL_ERROR", l)), this._onClose(() => t && t("CLOSED"));
      const o = {}, c = {
        broadcast: s,
        presence: a,
        postgres_changes: (n = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map((l) => l.filter)) !== null && n !== void 0 ? n : []
      };
      this.socket.accessToken && (o.access_token = this.socket.accessToken), this.updateJoinPayload(Object.assign({ config: c }, o)), this.joinedOnce = !0, this._rejoin(i), this.joinPush.receive("ok", ({ postgres_changes: l }) => {
        var d;
        if (this.socket.accessToken && this.socket.setAuth(this.socket.accessToken), l === void 0) {
          t && t("SUBSCRIBED");
          return;
        } else {
          const u = this.bindings.postgres_changes, h = (d = u == null ? void 0 : u.length) !== null && d !== void 0 ? d : 0, p = [];
          for (let m = 0; m < h; m++) {
            const w = u[m], { filter: { event: C, schema: F, table: W, filter: et } } = w, E = l && l[m];
            if (E && E.event === C && E.schema === F && E.table === W && E.filter === et)
              p.push(Object.assign(Object.assign({}, w), { id: E.id }));
            else {
              this.unsubscribe(), t && t("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes"));
              return;
            }
          }
          this.bindings.postgres_changes = p, t && t("SUBSCRIBED");
          return;
        }
      }).receive("error", (l) => {
        t && t("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(l).join(", ") || "error")));
      }).receive("timeout", () => {
        t && t("TIMED_OUT");
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(t, i = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload: t
    }, i.timeout || this.timeout);
  }
  async untrack(t = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, t);
  }
  on(t, i, r) {
    return this._on(t, i, r);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(t, i = {}) {
    var r, n;
    if (!this._canPush() && t.type === "broadcast") {
      const { event: s, payload: a } = t, o = {
        method: "POST",
        headers: {
          apikey: (r = this.socket.apiKey) !== null && r !== void 0 ? r : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [
            { topic: this.subTopic, event: s, payload: a }
          ]
        })
      };
      try {
        return (await this._fetchWithTimeout(this.broadcastEndpointURL, o, (n = i.timeout) !== null && n !== void 0 ? n : this.timeout)).ok ? "ok" : "error";
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((s) => {
        var a, o, c;
        const l = this._push(t.type, t, i.timeout || this.timeout);
        t.type === "broadcast" && !(!((c = (o = (a = this.params) === null || a === void 0 ? void 0 : a.config) === null || o === void 0 ? void 0 : o.broadcast) === null || c === void 0) && c.ack) && s("ok"), l.receive("ok", () => s("ok")), l.receive("timeout", () => s("timed out"));
      });
  }
  updateJoinPayload(t) {
    this.joinPush.updatePayload(t);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(t = this.timeout) {
    this.state = Jn.leaving;
    const i = () => {
      this.socket.log("channel", `leave ${this.topic}`), this._trigger(Bs.close, "leave", this._joinRef());
    };
    return this.rejoinTimer.reset(), this.joinPush.destroy(), new Promise((r) => {
      const n = new o_(this, Bs.leave, {}, t);
      n.receive("ok", () => {
        i(), r("ok");
      }).receive("timeout", () => {
        i(), r("timed out");
      }).receive("error", () => {
        r("error");
      }), n.send(), this._canPush() || n.trigger("ok", {});
    });
  }
  /** @internal */
  _broadcastEndpointURL() {
    let t = this.socket.endPoint;
    return t = t.replace(/^ws/i, "http"), t = t.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), t.replace(/\/+$/, "") + "/api/broadcast";
  }
  async _fetchWithTimeout(t, i, r) {
    const n = new AbortController(), s = setTimeout(() => n.abort(), r), a = await this.socket.fetch(t, Object.assign(Object.assign({}, i), { signal: n.signal }));
    return clearTimeout(s), a;
  }
  /** @internal */
  _push(t, i, r = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${t}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let n = new o_(this, t, i, r);
    return this._canPush() ? n.send() : (n.startTimeout(), this.pushBuffer.push(n)), n;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(t, i, r) {
    return i;
  }
  /** @internal */
  _isMember(t) {
    return this.topic === t;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(t, i, r) {
    var n, s;
    const a = t.toLocaleLowerCase(), { close: o, error: c, leave: l, join: d } = Bs;
    if (r && [o, c, l, d].indexOf(a) >= 0 && r !== this._joinRef())
      return;
    let h = this._onMessage(a, i, r);
    if (i && !h)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(a) ? (n = this.bindings.postgres_changes) === null || n === void 0 || n.filter((p) => {
      var m, w, C;
      return ((m = p.filter) === null || m === void 0 ? void 0 : m.event) === "*" || ((C = (w = p.filter) === null || w === void 0 ? void 0 : w.event) === null || C === void 0 ? void 0 : C.toLocaleLowerCase()) === a;
    }).map((p) => p.callback(h, r)) : (s = this.bindings[a]) === null || s === void 0 || s.filter((p) => {
      var m, w, C, F, W, et;
      if (["broadcast", "presence", "postgres_changes"].includes(a))
        if ("id" in p) {
          const E = p.id, Z = (m = p.filter) === null || m === void 0 ? void 0 : m.event;
          return E && ((w = i.ids) === null || w === void 0 ? void 0 : w.includes(E)) && (Z === "*" || (Z == null ? void 0 : Z.toLocaleLowerCase()) === ((C = i.data) === null || C === void 0 ? void 0 : C.type.toLocaleLowerCase()));
        } else {
          const E = (W = (F = p == null ? void 0 : p.filter) === null || F === void 0 ? void 0 : F.event) === null || W === void 0 ? void 0 : W.toLocaleLowerCase();
          return E === "*" || E === ((et = i == null ? void 0 : i.event) === null || et === void 0 ? void 0 : et.toLocaleLowerCase());
        }
      else
        return p.type.toLocaleLowerCase() === a;
    }).map((p) => {
      if (typeof h == "object" && "ids" in h) {
        const m = h.data, { schema: w, table: C, commit_timestamp: F, type: W, errors: et } = m;
        h = Object.assign(Object.assign({}, {
          schema: w,
          table: C,
          commit_timestamp: F,
          eventType: W,
          new: {},
          old: {},
          errors: et
        }), this._getPayloadRecords(m));
      }
      p.callback(h, r);
    });
  }
  /** @internal */
  _isClosed() {
    return this.state === Jn.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === Jn.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === Jn.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === Jn.leaving;
  }
  /** @internal */
  _replyEventName(t) {
    return `chan_reply_${t}`;
  }
  /** @internal */
  _on(t, i, r) {
    const n = t.toLocaleLowerCase(), s = {
      type: n,
      filter: i,
      callback: r
    };
    return this.bindings[n] ? this.bindings[n].push(s) : this.bindings[n] = [s], this;
  }
  /** @internal */
  _off(t, i) {
    const r = t.toLocaleLowerCase();
    return this.bindings[r] = this.bindings[r].filter((n) => {
      var s;
      return !(((s = n.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && C1.isEqual(n.filter, i));
    }), this;
  }
  /** @internal */
  static isEqual(t, i) {
    if (Object.keys(t).length !== Object.keys(i).length)
      return !1;
    for (const r in t)
      if (t[r] !== i[r])
        return !1;
    return !0;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin();
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(t) {
    this._on(Bs.close, {}, t);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(t) {
    this._on(Bs.error, {}, (i) => t(i));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(t = this.timeout) {
    this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = Jn.joining, this.joinPush.resend(t));
  }
  /** @internal */
  _getPayloadRecords(t) {
    const i = {
      new: {},
      old: {}
    };
    return (t.type === "INSERT" || t.type === "UPDATE") && (i.new = RI(t.columns, t.record)), (t.type === "UPDATE" || t.type === "DELETE") && (i.old = RI(t.columns, t.old_record)), i;
  }
}
const bz = () => {
}, xz = typeof WebSocket < "u";
class wz {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   */
  constructor(t, i) {
    var r;
    this.accessToken = null, this.apiKey = null, this.channels = [], this.endPoint = "", this.headers = dz, this.params = {}, this.timeout = QT, this.heartbeatIntervalMs = 3e4, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.ref = 0, this.logger = bz, this.conn = null, this.sendBuffer = [], this.serializer = new fz(), this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    }, this._resolveFetch = (s) => {
      let a;
      return s ? a = s : typeof fetch > "u" ? a = (...o) => Promise.resolve().then(() => _p).then(({ default: c }) => c(...o)) : a = fetch, (...o) => a(...o);
    }, this.endPoint = `${t}/${ab.websocket}`, i != null && i.transport ? this.transport = i.transport : this.transport = null, i != null && i.params && (this.params = i.params), i != null && i.headers && (this.headers = Object.assign(Object.assign({}, this.headers), i.headers)), i != null && i.timeout && (this.timeout = i.timeout), i != null && i.logger && (this.logger = i.logger), i != null && i.heartbeatIntervalMs && (this.heartbeatIntervalMs = i.heartbeatIntervalMs);
    const n = (r = i == null ? void 0 : i.params) === null || r === void 0 ? void 0 : r.apikey;
    n && (this.accessToken = n, this.apiKey = n), this.reconnectAfterMs = i != null && i.reconnectAfterMs ? i.reconnectAfterMs : (s) => [1e3, 2e3, 5e3, 1e4][s - 1] || 1e4, this.encode = i != null && i.encode ? i.encode : (s, a) => a(JSON.stringify(s)), this.decode = i != null && i.decode ? i.decode : this.serializer.decode.bind(this.serializer), this.reconnectTimer = new tE(async () => {
      this.disconnect(), this.connect();
    }, this.reconnectAfterMs), this.fetch = this._resolveFetch(i == null ? void 0 : i.fetch);
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (!this.conn) {
      if (this.transport) {
        this.conn = new this.transport(this._endPointURL(), void 0, {
          headers: this.headers
        });
        return;
      }
      if (xz) {
        this.conn = new WebSocket(this._endPointURL()), this.setupConnection();
        return;
      }
      this.conn = new Sz(this._endPointURL(), void 0, {
        close: () => {
          this.conn = null;
        }
      }), Promise.resolve().then(() => zQ).then(({ default: t }) => {
        this.conn = new t(this._endPointURL(), void 0, {
          headers: this.headers
        }), this.setupConnection();
      });
    }
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(t, i) {
    this.conn && (this.conn.onclose = function() {
    }, t ? this.conn.close(t, i ?? "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset());
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(t) {
    const i = await t.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), i;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const t = await Promise.all(this.channels.map((i) => i.unsubscribe()));
    return this.disconnect(), t;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(t, i, r) {
    this.logger(t, i, r);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case uu.connecting:
        return El.Connecting;
      case uu.open:
        return El.Open;
      case uu.closing:
        return El.Closing;
      default:
        return El.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === El.Open;
  }
  channel(t, i = { config: {} }) {
    const r = new C1(`realtime:${t}`, i, this);
    return this.channels.push(r), r;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(t) {
    const { topic: i, event: r, payload: n, ref: s } = t, a = () => {
      this.encode(t, (o) => {
        var c;
        (c = this.conn) === null || c === void 0 || c.send(o);
      });
    };
    this.log("push", `${i} ${r} (${s})`, n), this.isConnected() ? a() : this.sendBuffer.push(a);
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * @param token A JWT string.
   */
  setAuth(t) {
    this.accessToken = t, this.channels.forEach((i) => {
      t && i.updateJoinPayload({ access_token: t }), i.joinedOnce && i._isJoined() && i._push(Bs.access_token, { access_token: t });
    });
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let t = this.ref + 1;
    return t === this.ref ? this.ref = 0 : this.ref = t, this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(t) {
    let i = this.channels.find((r) => r.topic === t && (r._isJoined() || r._isJoining()));
    i && (this.log("transport", `leaving duplicate topic "${t}"`), i.unsubscribe());
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(t) {
    this.channels = this.channels.filter((i) => i._joinRef() !== t._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = (t) => this._onConnError(t), this.conn.onmessage = (t) => this._onConnMessage(t), this.conn.onclose = (t) => this._onConnClose(t));
  }
  /**
   * Returns the URL of the websocket.
   *
   * @internal
   */
  _endPointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, { vsn: uz }));
  }
  /** @internal */
  _onConnMessage(t) {
    this.decode(t.data, (i) => {
      let { topic: r, event: n, payload: s, ref: a } = i;
      (a && a === this.pendingHeartbeatRef || n === (s == null ? void 0 : s.type)) && (this.pendingHeartbeatRef = null), this.log("receive", `${s.status || ""} ${r} ${n} ${a && "(" + a + ")" || ""}`, s), this.channels.filter((o) => o._isMember(r)).forEach((o) => o._trigger(n, s, a)), this.stateChangeCallbacks.message.forEach((o) => o(i));
    });
  }
  /** @internal */
  _onConnOpen() {
    this.log("transport", `connected to ${this._endPointURL()}`), this._flushSendBuffer(), this.reconnectTimer.reset(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs), this.stateChangeCallbacks.open.forEach((t) => t());
  }
  /** @internal */
  _onConnClose(t) {
    this.log("transport", "close", t), this._triggerChanError(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach((i) => i(t));
  }
  /** @internal */
  _onConnError(t) {
    this.log("transport", t.message), this._triggerChanError(), this.stateChangeCallbacks.error.forEach((i) => i(t));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach((t) => t._trigger(Bs.error));
  }
  /** @internal */
  _appendParams(t, i) {
    if (Object.keys(i).length === 0)
      return t;
    const r = t.match(/\?/) ? "&" : "?", n = new URLSearchParams(i);
    return `${t}${r}${n}`;
  }
  /** @internal */
  _flushSendBuffer() {
    this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach((t) => t()), this.sendBuffer = []);
  }
  /** @internal */
  _sendHeartbeat() {
    var t;
    if (this.isConnected()) {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), (t = this.conn) === null || t === void 0 || t.close(hz, "hearbeat timeout");
        return;
      }
      this.pendingHeartbeatRef = this._makeRef(), this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      }), this.setAuth(this.accessToken);
    }
  }
}
class Sz {
  constructor(t, i, r) {
    this.binaryType = "arraybuffer", this.onclose = () => {
    }, this.onerror = () => {
    }, this.onmessage = () => {
    }, this.onopen = () => {
    }, this.readyState = uu.connecting, this.send = () => {
    }, this.url = null, this.url = t, this.close = r.close;
  }
}
class O1 extends Error {
  constructor(t) {
    super(t), this.__isStorageError = !0, this.name = "StorageError";
  }
}
function mn(e) {
  return typeof e == "object" && e !== null && "__isStorageError" in e;
}
class Iz extends O1 {
  constructor(t, i) {
    super(t), this.name = "StorageApiError", this.status = i;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
class zI extends O1 {
  constructor(t, i) {
    super(t), this.name = "StorageUnknownError", this.originalError = i;
  }
}
var Az = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const iE = (e) => {
  let t;
  return e ? t = e : typeof fetch > "u" ? t = (...i) => Promise.resolve().then(() => _p).then(({ default: r }) => r(...i)) : t = fetch, (...i) => t(...i);
}, Tz = () => Az(void 0, void 0, void 0, function* () {
  return typeof Response > "u" ? (yield Promise.resolve().then(() => _p)).Response : Response;
});
var Qu = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const c_ = (e) => e.msg || e.message || e.error_description || e.error || JSON.stringify(e), Ez = (e, t) => Qu(void 0, void 0, void 0, function* () {
  const i = yield Tz();
  e instanceof i ? e.json().then((r) => {
    t(new Iz(c_(r), e.status || 500));
  }).catch((r) => {
    t(new zI(c_(r), r));
  }) : t(new zI(c_(e), e));
}), kz = (e, t, i, r) => {
  const n = { method: e, headers: (t == null ? void 0 : t.headers) || {} };
  return e === "GET" ? n : (n.headers = Object.assign({ "Content-Type": "application/json" }, t == null ? void 0 : t.headers), n.body = JSON.stringify(r), Object.assign(Object.assign({}, n), i));
};
function gy(e, t, i, r, n, s) {
  return Qu(this, void 0, void 0, function* () {
    return new Promise((a, o) => {
      e(i, kz(t, r, n, s)).then((c) => {
        if (!c.ok)
          throw c;
        return r != null && r.noResolveJson ? c : c.json();
      }).then((c) => a(c)).catch((c) => Ez(c, o));
    });
  });
}
function cb(e, t, i, r) {
  return Qu(this, void 0, void 0, function* () {
    return gy(e, "GET", t, i, r);
  });
}
function fc(e, t, i, r, n) {
  return Qu(this, void 0, void 0, function* () {
    return gy(e, "POST", t, r, n, i);
  });
}
function Cz(e, t, i, r, n) {
  return Qu(this, void 0, void 0, function* () {
    return gy(e, "PUT", t, r, n, i);
  });
}
function rE(e, t, i, r, n) {
  return Qu(this, void 0, void 0, function* () {
    return gy(e, "DELETE", t, r, n, i);
  });
}
var os = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const Oz = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: "name",
    order: "asc"
  }
}, UI = {
  cacheControl: "3600",
  contentType: "text/plain;charset=UTF-8",
  upsert: !1
};
class Dz {
  constructor(t, i = {}, r, n) {
    this.url = t, this.headers = i, this.bucketId = r, this.fetch = iE(n);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(t, i, r, n) {
    return os(this, void 0, void 0, function* () {
      try {
        let s;
        const a = Object.assign(Object.assign({}, UI), n), o = Object.assign(Object.assign({}, this.headers), t === "POST" && { "x-upsert": String(a.upsert) });
        typeof Blob < "u" && r instanceof Blob ? (s = new FormData(), s.append("cacheControl", a.cacheControl), s.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (s = r, s.append("cacheControl", a.cacheControl)) : (s = r, o["cache-control"] = `max-age=${a.cacheControl}`, o["content-type"] = a.contentType);
        const c = this._removeEmptyFolders(i), l = this._getFinalPath(c), d = yield this.fetch(`${this.url}/object/${l}`, Object.assign({ method: t, body: s, headers: o }, a != null && a.duplex ? { duplex: a.duplex } : {})), u = yield d.json();
        return d.ok ? {
          data: { path: c, id: u.Id, fullPath: u.Key },
          error: null
        } : { data: null, error: u };
      } catch (s) {
        if (mn(s))
          return { data: null, error: s };
        throw s;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(t, i, r) {
    return os(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", t, i, r);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(t, i, r, n) {
    return os(this, void 0, void 0, function* () {
      const s = this._removeEmptyFolders(t), a = this._getFinalPath(s), o = new URL(this.url + `/object/upload/sign/${a}`);
      o.searchParams.set("token", i);
      try {
        let c;
        const l = Object.assign({ upsert: UI.upsert }, n), d = Object.assign(Object.assign({}, this.headers), { "x-upsert": String(l.upsert) });
        typeof Blob < "u" && r instanceof Blob ? (c = new FormData(), c.append("cacheControl", l.cacheControl), c.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (c = r, c.append("cacheControl", l.cacheControl)) : (c = r, d["cache-control"] = `max-age=${l.cacheControl}`, d["content-type"] = l.contentType);
        const u = yield this.fetch(o.toString(), {
          method: "PUT",
          body: c,
          headers: d
        }), h = yield u.json();
        return u.ok ? {
          data: { path: s, fullPath: h.Key },
          error: null
        } : { data: null, error: h };
      } catch (c) {
        if (mn(c))
          return { data: null, error: c };
        throw c;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   */
  createSignedUploadUrl(t) {
    return os(this, void 0, void 0, function* () {
      try {
        let i = this._getFinalPath(t);
        const r = yield fc(this.fetch, `${this.url}/object/upload/sign/${i}`, {}, { headers: this.headers }), n = new URL(this.url + r.url), s = n.searchParams.get("token");
        if (!s)
          throw new O1("No token returned by API");
        return { data: { signedUrl: n.toString(), path: t, token: s }, error: null };
      } catch (i) {
        if (mn(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(t, i, r) {
    return os(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", t, i, r);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   */
  move(t, i) {
    return os(this, void 0, void 0, function* () {
      try {
        return { data: yield fc(this.fetch, `${this.url}/object/move`, { bucketId: this.bucketId, sourceKey: t, destinationKey: i }, { headers: this.headers }), error: null };
      } catch (r) {
        if (mn(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   */
  copy(t, i) {
    return os(this, void 0, void 0, function* () {
      try {
        return { data: { path: (yield fc(this.fetch, `${this.url}/object/copy`, { bucketId: this.bucketId, sourceKey: t, destinationKey: i }, { headers: this.headers })).Key }, error: null };
      } catch (r) {
        if (mn(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(t, i, r) {
    return os(this, void 0, void 0, function* () {
      try {
        let n = this._getFinalPath(t), s = yield fc(this.fetch, `${this.url}/object/sign/${n}`, Object.assign({ expiresIn: i }, r != null && r.transform ? { transform: r.transform } : {}), { headers: this.headers });
        const a = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
        return s = { signedUrl: encodeURI(`${this.url}${s.signedURL}${a}`) }, { data: s, error: null };
      } catch (n) {
        if (mn(n))
          return { data: null, error: n };
        throw n;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(t, i, r) {
    return os(this, void 0, void 0, function* () {
      try {
        const n = yield fc(this.fetch, `${this.url}/object/sign/${this.bucketId}`, { expiresIn: i, paths: t }, { headers: this.headers }), s = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
        return {
          data: n.map((a) => Object.assign(Object.assign({}, a), { signedUrl: a.signedURL ? encodeURI(`${this.url}${a.signedURL}${s}`) : null })),
          error: null
        };
      } catch (n) {
        if (mn(n))
          return { data: null, error: n };
        throw n;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(t, i) {
    return os(this, void 0, void 0, function* () {
      const n = typeof (i == null ? void 0 : i.transform) < "u" ? "render/image/authenticated" : "object", s = this.transformOptsToQueryString((i == null ? void 0 : i.transform) || {}), a = s ? `?${s}` : "";
      try {
        const o = this._getFinalPath(t);
        return { data: yield (yield cb(this.fetch, `${this.url}/${n}/${o}${a}`, {
          headers: this.headers,
          noResolveJson: !0
        })).blob(), error: null };
      } catch (o) {
        if (mn(o))
          return { data: null, error: o };
        throw o;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(t, i) {
    const r = this._getFinalPath(t), n = [], s = i != null && i.download ? `download=${i.download === !0 ? "" : i.download}` : "";
    s !== "" && n.push(s);
    const o = typeof (i == null ? void 0 : i.transform) < "u" ? "render/image" : "object", c = this.transformOptsToQueryString((i == null ? void 0 : i.transform) || {});
    c !== "" && n.push(c);
    let l = n.join("&");
    return l !== "" && (l = `?${l}`), {
      data: { publicUrl: encodeURI(`${this.url}/${o}/public/${r}${l}`) }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(t) {
    return os(this, void 0, void 0, function* () {
      try {
        return { data: yield rE(this.fetch, `${this.url}/object/${this.bucketId}`, { prefixes: t }, { headers: this.headers }), error: null };
      } catch (i) {
        if (mn(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(t, i, r) {
    return os(this, void 0, void 0, function* () {
      try {
        const n = Object.assign(Object.assign(Object.assign({}, Oz), i), { prefix: t || "" });
        return { data: yield fc(this.fetch, `${this.url}/object/list/${this.bucketId}`, n, { headers: this.headers }, r), error: null };
      } catch (n) {
        if (mn(n))
          return { data: null, error: n };
        throw n;
      }
    });
  }
  _getFinalPath(t) {
    return `${this.bucketId}/${t}`;
  }
  _removeEmptyFolders(t) {
    return t.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(t) {
    const i = [];
    return t.width && i.push(`width=${t.width}`), t.height && i.push(`height=${t.height}`), t.resize && i.push(`resize=${t.resize}`), t.format && i.push(`format=${t.format}`), t.quality && i.push(`quality=${t.quality}`), i.join("&");
  }
}
const Nz = "2.5.5", Lz = { "X-Client-Info": `storage-js/${Nz}` };
var Sd = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class Fz {
  constructor(t, i = {}, r) {
    this.url = t, this.headers = Object.assign(Object.assign({}, Lz), i), this.fetch = iE(r);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield cb(this.fetch, `${this.url}/bucket`, { headers: this.headers }), error: null };
      } catch (t) {
        if (mn(t))
          return { data: null, error: t };
        throw t;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(t) {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield cb(this.fetch, `${this.url}/bucket/${t}`, { headers: this.headers }), error: null };
      } catch (i) {
        if (mn(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(t, i = {
    public: !1
  }) {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield fc(this.fetch, `${this.url}/bucket`, {
          id: t,
          name: t,
          public: i.public,
          file_size_limit: i.fileSizeLimit,
          allowed_mime_types: i.allowedMimeTypes
        }, { headers: this.headers }), error: null };
      } catch (r) {
        if (mn(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(t, i) {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield Cz(this.fetch, `${this.url}/bucket/${t}`, {
          id: t,
          name: t,
          public: i.public,
          file_size_limit: i.fileSizeLimit,
          allowed_mime_types: i.allowedMimeTypes
        }, { headers: this.headers }), error: null };
      } catch (r) {
        if (mn(r))
          return { data: null, error: r };
        throw r;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(t) {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield fc(this.fetch, `${this.url}/bucket/${t}/empty`, {}, { headers: this.headers }), error: null };
      } catch (i) {
        if (mn(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(t) {
    return Sd(this, void 0, void 0, function* () {
      try {
        return { data: yield rE(this.fetch, `${this.url}/bucket/${t}`, {}, { headers: this.headers }), error: null };
      } catch (i) {
        if (mn(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
}
class Bz extends Fz {
  constructor(t, i = {}, r) {
    super(t, i, r);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(t) {
    return new Dz(this.url, this.headers, t, this.fetch);
  }
}
const Rz = "2.39.3";
let Qh = "";
typeof Deno < "u" ? Qh = "deno" : typeof document < "u" ? Qh = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Qh = "react-native" : Qh = "node";
const Mz = { "X-Client-Info": `supabase-js-${Qh}/${Rz}` };
var Pz = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const $z = (e) => {
  let t;
  return e ? t = e : typeof fetch > "u" ? t = E1 : t = fetch, (...i) => t(...i);
}, zz = () => typeof Headers > "u" ? JT : Headers, Uz = (e, t, i) => {
  const r = $z(i), n = zz();
  return (s, a) => Pz(void 0, void 0, void 0, function* () {
    var o;
    const c = (o = yield t()) !== null && o !== void 0 ? o : e;
    let l = new n(a == null ? void 0 : a.headers);
    return l.has("apikey") || l.set("apikey", e), l.has("Authorization") || l.set("Authorization", `Bearer ${c}`), r(s, Object.assign(Object.assign({}, a), { headers: l }));
  });
};
function Vz(e) {
  return e.replace(/\/$/, "");
}
function jz(e, t) {
  const { db: i, auth: r, realtime: n, global: s } = e, { db: a, auth: o, realtime: c, global: l } = t;
  return {
    db: Object.assign(Object.assign({}, a), i),
    auth: Object.assign(Object.assign({}, o), r),
    realtime: Object.assign(Object.assign({}, c), n),
    global: Object.assign(Object.assign({}, l), s)
  };
}
function Gz(e) {
  return Math.round(Date.now() / 1e3) + e;
}
function Hz() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    const t = Math.random() * 16 | 0;
    return (e == "x" ? t : t & 3 | 8).toString(16);
  });
}
const Ns = () => typeof document < "u", dl = {
  tested: !1,
  writable: !1
}, Sf = () => {
  if (!Ns())
    return !1;
  try {
    if (typeof globalThis.localStorage != "object")
      return !1;
  } catch {
    return !1;
  }
  if (dl.tested)
    return dl.writable;
  const e = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(e, e), globalThis.localStorage.removeItem(e), dl.tested = !0, dl.writable = !0;
  } catch {
    dl.tested = !0, dl.writable = !1;
  }
  return dl.writable;
};
function l_(e) {
  const t = {}, i = new URL(e);
  if (i.hash && i.hash[0] === "#")
    try {
      new URLSearchParams(i.hash.substring(1)).forEach((n, s) => {
        t[s] = n;
      });
    } catch {
    }
  return i.searchParams.forEach((r, n) => {
    t[n] = r;
  }), t;
}
const nE = (e) => {
  let t;
  return e ? t = e : typeof fetch > "u" ? t = (...i) => Promise.resolve().then(() => _p).then(({ default: r }) => r(...i)) : t = fetch, (...i) => t(...i);
}, Wz = (e) => typeof e == "object" && e !== null && "status" in e && "ok" in e && "json" in e && typeof e.json == "function", ul = async (e, t, i) => {
  await e.setItem(t, JSON.stringify(i));
}, Fm = async (e, t) => {
  const i = await e.getItem(t);
  if (!i)
    return null;
  try {
    return JSON.parse(i);
  } catch {
    return i;
  }
}, d_ = async (e, t) => {
  await e.removeItem(t);
};
function Yz(e) {
  const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let i = "", r, n, s, a, o, c, l, d = 0;
  for (e = e.replace("-", "+").replace("_", "/"); d < e.length; )
    a = t.indexOf(e.charAt(d++)), o = t.indexOf(e.charAt(d++)), c = t.indexOf(e.charAt(d++)), l = t.indexOf(e.charAt(d++)), r = a << 2 | o >> 4, n = (o & 15) << 4 | c >> 2, s = (c & 3) << 6 | l, i = i + String.fromCharCode(r), c != 64 && n != 0 && (i = i + String.fromCharCode(n)), l != 64 && s != 0 && (i = i + String.fromCharCode(s));
  return i;
}
class yy {
  constructor() {
    this.promise = new yy.promiseConstructor((t, i) => {
      this.resolve = t, this.reject = i;
    });
  }
}
yy.promiseConstructor = Promise;
function VI(e) {
  const t = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i, i = e.split(".");
  if (i.length !== 3)
    throw new Error("JWT is not valid: not a JWT structure");
  if (!t.test(i[1]))
    throw new Error("JWT is not valid: payload is not in base64url format");
  const r = i[1];
  return JSON.parse(Yz(r));
}
async function qz(e) {
  return await new Promise((t) => {
    setTimeout(() => t(null), e);
  });
}
function Zz(e, t) {
  return new Promise((r, n) => {
    (async () => {
      for (let s = 0; s < 1 / 0; s++)
        try {
          const a = await e(s);
          if (!t(s, null, a)) {
            r(a);
            return;
          }
        } catch (a) {
          if (!t(s, a)) {
            n(a);
            return;
          }
        }
    })();
  });
}
function Xz(e) {
  return ("0" + e.toString(16)).substr(-2);
}
function Id() {
  const t = new Uint32Array(56);
  if (typeof crypto > "u") {
    const i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~", r = i.length;
    let n = "";
    for (let s = 0; s < 56; s++)
      n += i.charAt(Math.floor(Math.random() * r));
    return n;
  }
  return crypto.getRandomValues(t), Array.from(t, Xz).join("");
}
async function Kz(e) {
  const i = new TextEncoder().encode(e), r = await crypto.subtle.digest("SHA-256", i), n = new Uint8Array(r);
  return Array.from(n).map((s) => String.fromCharCode(s)).join("");
}
function Jz(e) {
  return btoa(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function Ad(e) {
  if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
    return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), e;
  const i = await Kz(e);
  return Jz(i);
}
class D1 extends Error {
  constructor(t, i) {
    super(t), this.__isAuthError = !0, this.name = "AuthError", this.status = i;
  }
}
function fi(e) {
  return typeof e == "object" && e !== null && "__isAuthError" in e;
}
class Qz extends D1 {
  constructor(t, i) {
    super(t, i), this.name = "AuthApiError", this.status = i;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
function tU(e) {
  return fi(e) && e.name === "AuthApiError";
}
class sE extends D1 {
  constructor(t, i) {
    super(t), this.name = "AuthUnknownError", this.originalError = i;
  }
}
class Zl extends D1 {
  constructor(t, i, r) {
    super(t), this.name = i, this.status = r;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
class Td extends Zl {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400);
  }
}
class u_ extends Zl {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500);
  }
}
class Bm extends Zl {
  constructor(t) {
    super(t, "AuthInvalidCredentialsError", 400);
  }
}
class Rm extends Zl {
  constructor(t, i = null) {
    super(t, "AuthImplicitGrantRedirectError", 500), this.details = null, this.details = i;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class jI extends Zl {
  constructor(t, i = null) {
    super(t, "AuthPKCEGrantCodeExchangeError", 500), this.details = null, this.details = i;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class lb extends Zl {
  constructor(t, i) {
    super(t, "AuthRetryableFetchError", i);
  }
}
function h_(e) {
  return fi(e) && e.name === "AuthRetryableFetchError";
}
class eU extends Zl {
  constructor(t, i, r) {
    super(t, "AuthWeakPasswordError", i), this.reasons = r;
  }
}
var iU = function(e, t) {
  var i = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (i[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(e); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[n]) && (i[r[n]] = e[r[n]]);
  return i;
};
const Ld = (e) => e.msg || e.message || e.error_description || e.error || JSON.stringify(e), rU = [502, 503, 504];
async function GI(e) {
  if (!Wz(e))
    throw new lb(Ld(e), 0);
  if (rU.includes(e.status))
    throw new lb(Ld(e), e.status);
  let t;
  try {
    t = await e.json();
  } catch (i) {
    throw new sE(Ld(i), i);
  }
  throw typeof t == "object" && t && typeof t.weak_password == "object" && t.weak_password && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.reasons.reduce((i, r) => i && typeof r == "string", !0) ? new eU(Ld(t), e.status, t.weak_password.reasons) : new Qz(Ld(t), e.status || 500);
}
const nU = (e, t, i, r) => {
  const n = { method: e, headers: (t == null ? void 0 : t.headers) || {} };
  return e === "GET" ? n : (n.headers = Object.assign({ "Content-Type": "application/json;charset=UTF-8" }, t == null ? void 0 : t.headers), n.body = JSON.stringify(r), Object.assign(Object.assign({}, n), i));
};
async function vi(e, t, i, r) {
  var n;
  const s = Object.assign({}, r == null ? void 0 : r.headers);
  r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`);
  const a = (n = r == null ? void 0 : r.query) !== null && n !== void 0 ? n : {};
  r != null && r.redirectTo && (a.redirect_to = r.redirectTo);
  const o = Object.keys(a).length ? "?" + new URLSearchParams(a).toString() : "", c = await sU(e, t, i + o, { headers: s, noResolveJson: r == null ? void 0 : r.noResolveJson }, {}, r == null ? void 0 : r.body);
  return r != null && r.xform ? r == null ? void 0 : r.xform(c) : { data: Object.assign({}, c), error: null };
}
async function sU(e, t, i, r, n, s) {
  const a = nU(t, r, n, s);
  let o;
  try {
    o = await e(i, a);
  } catch (c) {
    throw console.error(c), new lb(Ld(c), 0);
  }
  if (o.ok || await GI(o), r != null && r.noResolveJson)
    return o;
  try {
    return await o.json();
  } catch (c) {
    await GI(c);
  }
}
function ml(e) {
  var t;
  let i = null;
  lU(e) && (i = Object.assign({}, e), e.expires_at || (i.expires_at = Gz(e.expires_in)));
  const r = (t = e.user) !== null && t !== void 0 ? t : e;
  return { data: { session: i, user: r }, error: null };
}
function HI(e) {
  const t = ml(e);
  return !t.error && e.weak_password && typeof e.weak_password == "object" && Array.isArray(e.weak_password.reasons) && e.weak_password.reasons.length && e.weak_password.message && typeof e.weak_password.message == "string" && e.weak_password.reasons.reduce((i, r) => i && typeof r == "string", !0) && (t.data.weak_password = e.weak_password), t;
}
function gc(e) {
  var t;
  return { data: { user: (t = e.user) !== null && t !== void 0 ? t : e }, error: null };
}
function aU(e) {
  return { data: e, error: null };
}
function oU(e) {
  const { action_link: t, email_otp: i, hashed_token: r, redirect_to: n, verification_type: s } = e, a = iU(e, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), o = {
    action_link: t,
    email_otp: i,
    hashed_token: r,
    redirect_to: n,
    verification_type: s
  }, c = Object.assign({}, a);
  return {
    data: {
      properties: o,
      user: c
    },
    error: null
  };
}
function cU(e) {
  return e;
}
function lU(e) {
  return e.access_token && e.refresh_token && e.expires_in;
}
var dU = function(e, t) {
  var i = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (i[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, r = Object.getOwnPropertySymbols(e); n < r.length; n++)
      t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[n]) && (i[r[n]] = e[r[n]]);
  return i;
};
class uU {
  constructor({ url: t = "", headers: i = {}, fetch: r }) {
    this.url = t, this.headers = i, this.fetch = nE(r), this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(t, i = "global") {
    try {
      return await vi(this.fetch, "POST", `${this.url}/logout?scope=${i}`, {
        headers: this.headers,
        jwt: t,
        noResolveJson: !0
      }), { data: null, error: null };
    } catch (r) {
      if (fi(r))
        return { data: null, error: r };
      throw r;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(t, i = {}) {
    try {
      return await vi(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: t, data: i.data },
        headers: this.headers,
        redirectTo: i.redirectTo,
        xform: gc
      });
    } catch (r) {
      if (fi(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(t) {
    try {
      const { options: i } = t, r = dU(t, ["options"]), n = Object.assign(Object.assign({}, r), i);
      return "newEmail" in r && (n.new_email = r == null ? void 0 : r.newEmail, delete n.newEmail), await vi(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body: n,
        headers: this.headers,
        xform: oU,
        redirectTo: i == null ? void 0 : i.redirectTo
      });
    } catch (i) {
      if (fi(i))
        return {
          data: {
            properties: null,
            user: null
          },
          error: i
        };
      throw i;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(t) {
    try {
      return await vi(this.fetch, "POST", `${this.url}/admin/users`, {
        body: t,
        headers: this.headers,
        xform: gc
      });
    } catch (i) {
      if (fi(i))
        return { data: { user: null }, error: i };
      throw i;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(t) {
    var i, r, n, s, a, o, c;
    try {
      const l = { nextPage: null, lastPage: 0, total: 0 }, d = await vi(this.fetch, "GET", `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: !0,
        query: {
          page: (r = (i = t == null ? void 0 : t.page) === null || i === void 0 ? void 0 : i.toString()) !== null && r !== void 0 ? r : "",
          per_page: (s = (n = t == null ? void 0 : t.perPage) === null || n === void 0 ? void 0 : n.toString()) !== null && s !== void 0 ? s : ""
        },
        xform: cU
      });
      if (d.error)
        throw d.error;
      const u = await d.json(), h = (a = d.headers.get("x-total-count")) !== null && a !== void 0 ? a : 0, p = (c = (o = d.headers.get("link")) === null || o === void 0 ? void 0 : o.split(",")) !== null && c !== void 0 ? c : [];
      return p.length > 0 && (p.forEach((m) => {
        const w = parseInt(m.split(";")[0].split("=")[1].substring(0, 1)), C = JSON.parse(m.split(";")[1].split("=")[1]);
        l[`${C}Page`] = w;
      }), l.total = parseInt(h)), { data: Object.assign(Object.assign({}, u), l), error: null };
    } catch (l) {
      if (fi(l))
        return { data: { users: [] }, error: l };
      throw l;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(t) {
    try {
      return await vi(this.fetch, "GET", `${this.url}/admin/users/${t}`, {
        headers: this.headers,
        xform: gc
      });
    } catch (i) {
      if (fi(i))
        return { data: { user: null }, error: i };
      throw i;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(t, i) {
    try {
      return await vi(this.fetch, "PUT", `${this.url}/admin/users/${t}`, {
        body: i,
        headers: this.headers,
        xform: gc
      });
    } catch (r) {
      if (fi(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted (setting `deleted_at` to the current timestamp and disabling their account while preserving their data) from the auth schema.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(t, i = !1) {
    try {
      return await vi(this.fetch, "DELETE", `${this.url}/admin/users/${t}`, {
        headers: this.headers,
        body: {
          should_soft_delete: i
        },
        xform: gc
      });
    } catch (r) {
      if (fi(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  async _listFactors(t) {
    try {
      const { data: i, error: r } = await vi(this.fetch, "GET", `${this.url}/admin/users/${t.userId}/factors`, {
        headers: this.headers,
        xform: (n) => ({ data: { factors: n }, error: null })
      });
      return { data: i, error: r };
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
  async _deleteFactor(t) {
    try {
      return { data: await vi(this.fetch, "DELETE", `${this.url}/admin/users/${t.userId}/factors/${t.id}`, {
        headers: this.headers
      }), error: null };
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
}
const aE = "0.0.0", hU = "http://localhost:9999", fU = "supabase.auth.token", pU = { "X-Client-Info": `gotrue-js/${aE}` }, WI = 10, mU = {
  getItem: (e) => Sf() ? globalThis.localStorage.getItem(e) : null,
  setItem: (e, t) => {
    Sf() && globalThis.localStorage.setItem(e, t);
  },
  removeItem: (e) => {
    Sf() && globalThis.localStorage.removeItem(e);
  }
};
function YI(e = {}) {
  return {
    getItem: (t) => e[t] || null,
    setItem: (t, i) => {
      e[t] = i;
    },
    removeItem: (t) => {
      delete e[t];
    }
  };
}
function gU() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function() {
          return this;
        },
        configurable: !0
      }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
const Ed = {
  /**
   * @experimental
   */
  debug: !!(globalThis && Sf() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class oE extends Error {
  constructor(t) {
    super(t), this.isAcquireTimeout = !0;
  }
}
class yU extends oE {
}
async function vU(e, t, i) {
  Ed.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", e, t);
  const r = new globalThis.AbortController();
  return t > 0 && setTimeout(() => {
    r.abort(), Ed.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", e);
  }, t), await globalThis.navigator.locks.request(e, t === 0 ? {
    mode: "exclusive",
    ifAvailable: !0
  } : {
    mode: "exclusive",
    signal: r.signal
  }, async (n) => {
    if (n) {
      Ed.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", e, n.name);
      try {
        return await i();
      } finally {
        Ed.debug && console.log("@supabase/gotrue-js: navigatorLock: released", e, n.name);
      }
    } else {
      if (t === 0)
        throw Ed.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", e), new yU(`Acquiring an exclusive Navigator LockManager lock "${e}" immediately failed`);
      if (Ed.debug)
        try {
          const s = await globalThis.navigator.locks.query();
          console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(s, null, "  "));
        } catch (s) {
          console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", s);
        }
      return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"), await i();
    }
  });
}
gU();
const _U = {
  url: hU,
  storageKey: fU,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: pU,
  flowType: "implicit",
  debug: !1
}, Vh = 30 * 1e3, qI = 3;
async function ZI(e, t, i) {
  return await i();
}
class Ff {
  /**
   * Create a new client for use in the browser.
   */
  constructor(t) {
    var i, r;
    this.memoryStorage = null, this.stateChangeEmitters = /* @__PURE__ */ new Map(), this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Ff.nextInstanceID, Ff.nextInstanceID += 1, this.instanceID > 0 && Ns() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    const n = Object.assign(Object.assign({}, _U), t);
    if (this.logDebugMessages = !!n.debug, typeof n.debug == "function" && (this.logger = n.debug), this.persistSession = n.persistSession, this.storageKey = n.storageKey, this.autoRefreshToken = n.autoRefreshToken, this.admin = new uU({
      url: n.url,
      headers: n.headers,
      fetch: n.fetch
    }), this.url = n.url, this.headers = n.headers, this.fetch = nE(n.fetch), this.lock = n.lock || ZI, this.detectSessionInUrl = n.detectSessionInUrl, this.flowType = n.flowType, n.lock ? this.lock = n.lock : Ns() && (!((i = globalThis == null ? void 0 : globalThis.navigator) === null || i === void 0) && i.locks) ? this.lock = vU : this.lock = ZI, this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    }, this.persistSession ? n.storage ? this.storage = n.storage : Sf() ? this.storage = mU : (this.memoryStorage = {}, this.storage = YI(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = YI(this.memoryStorage)), Ns() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (s) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", s);
      }
      (r = this.broadcastChannel) === null || r === void 0 || r.addEventListener("message", async (s) => {
        this._debug("received broadcast notification from other tab or client", s), await this._notifyAllSubscribers(s.data.event, s.data.session, !1);
      });
    }
    this.initialize();
  }
  _debug(...t) {
    return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${aE}) ${(/* @__PURE__ */ new Date()).toISOString()}`, ...t), this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise);
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    try {
      const t = Ns() ? await this._isPKCEFlow() : !1;
      if (this._debug("#_initialize()", "begin", "is PKCE flow", t), t || this.detectSessionInUrl && this._isImplicitGrantFlow()) {
        const { data: i, error: r } = await this._getSessionFromURL(t);
        if (r)
          return this._debug("#_initialize()", "error detecting session from URL", r), (r == null ? void 0 : r.message) === "Identity is already linked" || (r == null ? void 0 : r.message) === "Identity is already linked to another user" ? { error: r } : (await this._removeSession(), { error: r });
        const { session: n, redirectType: s } = i;
        return this._debug("#_initialize()", "detected session in URL", n, "redirect type", s), await this._saveSession(n), setTimeout(async () => {
          s === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", n) : await this._notifyAllSubscribers("SIGNED_IN", n);
        }, 0), { error: null };
      }
      return await this._recoverAndRefresh(), { error: null };
    } catch (t) {
      return fi(t) ? { error: t } : {
        error: new sE("Unexpected error during initialization", t)
      };
    } finally {
      await this._handleVisibilityChange(), this._debug("#_initialize()", "end");
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(t) {
    var i, r, n;
    try {
      await this._removeSession();
      let s;
      if ("email" in t) {
        const { email: d, password: u, options: h } = t;
        let p = null, m = null;
        if (this.flowType === "pkce") {
          const w = Id();
          await ul(this.storage, `${this.storageKey}-code-verifier`, w), p = await Ad(w), m = w === p ? "plain" : "s256";
        }
        s = await vi(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: h == null ? void 0 : h.emailRedirectTo,
          body: {
            email: d,
            password: u,
            data: (i = h == null ? void 0 : h.data) !== null && i !== void 0 ? i : {},
            gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken },
            code_challenge: p,
            code_challenge_method: m
          },
          xform: ml
        });
      } else if ("phone" in t) {
        const { phone: d, password: u, options: h } = t;
        s = await vi(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: d,
            password: u,
            data: (r = h == null ? void 0 : h.data) !== null && r !== void 0 ? r : {},
            channel: (n = h == null ? void 0 : h.channel) !== null && n !== void 0 ? n : "sms",
            gotrue_meta_security: { captcha_token: h == null ? void 0 : h.captchaToken }
          },
          xform: ml
        });
      } else
        throw new Bm("You must provide either an email or phone number and a password");
      const { data: a, error: o } = s;
      if (o || !a)
        return { data: { user: null, session: null }, error: o };
      const c = a.session, l = a.user;
      return a.session && (await this._saveSession(a.session), await this._notifyAllSubscribers("SIGNED_IN", c)), { data: { user: l, session: c }, error: null };
    } catch (s) {
      if (fi(s))
        return { data: { user: null, session: null }, error: s };
      throw s;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(t) {
    try {
      await this._removeSession();
      let i;
      if ("email" in t) {
        const { email: s, password: a, options: o } = t;
        i = await vi(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email: s,
            password: a,
            gotrue_meta_security: { captcha_token: o == null ? void 0 : o.captchaToken }
          },
          xform: HI
        });
      } else if ("phone" in t) {
        const { phone: s, password: a, options: o } = t;
        i = await vi(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone: s,
            password: a,
            gotrue_meta_security: { captcha_token: o == null ? void 0 : o.captchaToken }
          },
          xform: HI
        });
      } else
        throw new Bm("You must provide either an email or phone number and a password");
      const { data: r, error: n } = i;
      return n ? { data: { user: null, session: null }, error: n } : !r || !r.session || !r.user ? { data: { user: null, session: null }, error: new u_() } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), {
        data: Object.assign({ user: r.user, session: r.session }, r.weak_password ? { weakPassword: r.weak_password } : null),
        error: n
      });
    } catch (i) {
      if (fi(i))
        return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(t) {
    var i, r, n, s;
    return await this._removeSession(), await this._handleProviderSignIn(t.provider, {
      redirectTo: (i = t.options) === null || i === void 0 ? void 0 : i.redirectTo,
      scopes: (r = t.options) === null || r === void 0 ? void 0 : r.scopes,
      queryParams: (n = t.options) === null || n === void 0 ? void 0 : n.queryParams,
      skipBrowserRedirect: (s = t.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(t) {
    return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(t));
  }
  async _exchangeCodeForSession(t) {
    const i = await Fm(this.storage, `${this.storageKey}-code-verifier`), [r, n] = (i ?? "").split("/"), { data: s, error: a } = await vi(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
      headers: this.headers,
      body: {
        auth_code: t,
        code_verifier: r
      },
      xform: ml
    });
    return await d_(this.storage, `${this.storageKey}-code-verifier`), a ? { data: { user: null, session: null, redirectType: null }, error: a } : !s || !s.session || !s.user ? {
      data: { user: null, session: null, redirectType: null },
      error: new u_()
    } : (s.session && (await this._saveSession(s.session), await this._notifyAllSubscribers("SIGNED_IN", s.session)), { data: Object.assign(Object.assign({}, s), { redirectType: n ?? null }), error: a });
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(t) {
    await this._removeSession();
    try {
      const { options: i, provider: r, token: n, access_token: s, nonce: a } = t, o = await vi(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider: r,
          id_token: n,
          access_token: s,
          nonce: a,
          gotrue_meta_security: { captcha_token: i == null ? void 0 : i.captchaToken }
        },
        xform: ml
      }), { data: c, error: l } = o;
      return l ? { data: { user: null, session: null }, error: l } : !c || !c.session || !c.user ? {
        data: { user: null, session: null },
        error: new u_()
      } : (c.session && (await this._saveSession(c.session), await this._notifyAllSubscribers("SIGNED_IN", c.session)), { data: c, error: l });
    } catch (i) {
      if (fi(i))
        return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(t) {
    var i, r, n, s, a;
    try {
      if (await this._removeSession(), "email" in t) {
        const { email: o, options: c } = t;
        let l = null, d = null;
        if (this.flowType === "pkce") {
          const h = Id();
          await ul(this.storage, `${this.storageKey}-code-verifier`, h), l = await Ad(h), d = h === l ? "plain" : "s256";
        }
        const { error: u } = await vi(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: o,
            data: (i = c == null ? void 0 : c.data) !== null && i !== void 0 ? i : {},
            create_user: (r = c == null ? void 0 : c.shouldCreateUser) !== null && r !== void 0 ? r : !0,
            gotrue_meta_security: { captcha_token: c == null ? void 0 : c.captchaToken },
            code_challenge: l,
            code_challenge_method: d
          },
          redirectTo: c == null ? void 0 : c.emailRedirectTo
        });
        return { data: { user: null, session: null }, error: u };
      }
      if ("phone" in t) {
        const { phone: o, options: c } = t, { data: l, error: d } = await vi(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone: o,
            data: (n = c == null ? void 0 : c.data) !== null && n !== void 0 ? n : {},
            create_user: (s = c == null ? void 0 : c.shouldCreateUser) !== null && s !== void 0 ? s : !0,
            gotrue_meta_security: { captcha_token: c == null ? void 0 : c.captchaToken },
            channel: (a = c == null ? void 0 : c.channel) !== null && a !== void 0 ? a : "sms"
          }
        });
        return { data: { user: null, session: null, messageId: l == null ? void 0 : l.message_id }, error: d };
      }
      throw new Bm("You must provide either an email or phone number.");
    } catch (o) {
      if (fi(o))
        return { data: { user: null, session: null }, error: o };
      throw o;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(t) {
    var i, r;
    try {
      t.type !== "email_change" && t.type !== "phone_change" && await this._removeSession();
      let n, s;
      "options" in t && (n = (i = t.options) === null || i === void 0 ? void 0 : i.redirectTo, s = (r = t.options) === null || r === void 0 ? void 0 : r.captchaToken);
      const { data: a, error: o } = await vi(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, t), { gotrue_meta_security: { captcha_token: s } }),
        redirectTo: n,
        xform: ml
      });
      if (o)
        throw o;
      if (!a)
        throw new Error("An error occurred on token verification.");
      const c = a.session, l = a.user;
      return c != null && c.access_token && (await this._saveSession(c), await this._notifyAllSubscribers(t.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", c)), { data: { user: l, session: c }, error: null };
    } catch (n) {
      if (fi(n))
        return { data: { user: null, session: null }, error: n };
      throw n;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(t) {
    var i, r, n;
    try {
      await this._removeSession();
      let s = null, a = null;
      if (this.flowType === "pkce") {
        const o = Id();
        await ul(this.storage, `${this.storageKey}-code-verifier`, o), s = await Ad(o), a = o === s ? "plain" : "s256";
      }
      return await vi(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in t ? { provider_id: t.providerId } : null), "domain" in t ? { domain: t.domain } : null), { redirect_to: (r = (i = t.options) === null || i === void 0 ? void 0 : i.redirectTo) !== null && r !== void 0 ? r : void 0 }), !((n = t == null ? void 0 : t.options) === null || n === void 0) && n.captchaToken ? { gotrue_meta_security: { captcha_token: t.options.captchaToken } } : null), { skip_http_redirect: !0, code_challenge: s, code_challenge_method: a }),
        headers: this.headers,
        xform: aU
      });
    } catch (s) {
      if (fi(s))
        return { data: null, error: s };
      throw s;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate());
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (t) => {
        const { data: { session: i }, error: r } = t;
        if (r)
          throw r;
        if (!i)
          throw new Td();
        const { error: n } = await vi(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: i.access_token
        });
        return { data: { user: null, session: null }, error: n };
      });
    } catch (t) {
      if (fi(t))
        return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(t) {
    try {
      t.type != "email_change" && t.type != "phone_change" && await this._removeSession();
      const i = `${this.url}/resend`;
      if ("email" in t) {
        const { email: r, type: n, options: s } = t, { error: a } = await vi(this.fetch, "POST", i, {
          headers: this.headers,
          body: {
            email: r,
            type: n,
            gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken }
          },
          redirectTo: s == null ? void 0 : s.emailRedirectTo
        });
        return { data: { user: null, session: null }, error: a };
      } else if ("phone" in t) {
        const { phone: r, type: n, options: s } = t, { data: a, error: o } = await vi(this.fetch, "POST", i, {
          headers: this.headers,
          body: {
            phone: r,
            type: n,
            gotrue_meta_security: { captcha_token: s == null ? void 0 : s.captchaToken }
          }
        });
        return { data: { user: null, session: null, messageId: a == null ? void 0 : a.message_id }, error: o };
      }
      throw new Bm("You must provide either an email or phone number and a type");
    } catch (i) {
      if (fi(i))
        return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   */
  async getSession() {
    return await this.initializePromise, this._acquireLock(-1, async () => this._useSession(async (t) => t));
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(t, i) {
    this._debug("#_acquireLock", "begin", t);
    try {
      if (this.lockAcquired) {
        const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(), n = (async () => (await r, await i()))();
        return this.pendingInLock.push((async () => {
          try {
            await n;
          } catch {
          }
        })()), n;
      }
      return await this.lock(`lock:${this.storageKey}`, t, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = !0;
          const r = i();
          for (this.pendingInLock.push((async () => {
            try {
              await r;
            } catch {
            }
          })()), await r; this.pendingInLock.length; ) {
            const n = [...this.pendingInLock];
            await Promise.all(n), this.pendingInLock.splice(0, n.length);
          }
          return await r;
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1;
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(t) {
    this._debug("#_useSession", "begin");
    try {
      const i = await this.__loadSession();
      return await t(i);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    try {
      let t = null;
      const i = await Fm(this.storage, this.storageKey);
      if (this._debug("#getSession()", "session from storage", i), i !== null && (this._isValidSession(i) ? t = i : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !t)
        return { data: { session: null }, error: null };
      const r = t.expires_at ? t.expires_at <= Date.now() / 1e3 : !1;
      if (this._debug("#__loadSession()", `session has${r ? "" : " not"} expired`, "expires_at", t.expires_at), !r)
        return { data: { session: t }, error: null };
      const { session: n, error: s } = await this._callRefreshToken(t.refresh_token);
      return s ? { data: { session: null }, error: s } : { data: { session: n }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  /**
   * Gets the current user details if there is an existing session.
   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.
   */
  async getUser(t) {
    return t ? await this._getUser(t) : (await this.initializePromise, this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(t) {
    try {
      return t ? await vi(this.fetch, "GET", `${this.url}/user`, {
        headers: this.headers,
        jwt: t,
        xform: gc
      }) : await this._useSession(async (i) => {
        var r, n;
        const { data: s, error: a } = i;
        if (a)
          throw a;
        return await vi(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (n = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && n !== void 0 ? n : void 0,
          xform: gc
        });
      });
    } catch (i) {
      if (fi(i))
        return { data: { user: null }, error: i };
      throw i;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(t, i = {}) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(t, i));
  }
  async _updateUser(t, i = {}) {
    try {
      return await this._useSession(async (r) => {
        const { data: n, error: s } = r;
        if (s)
          throw s;
        if (!n.session)
          throw new Td();
        const a = n.session;
        let o = null, c = null;
        if (this.flowType === "pkce" && t.email != null) {
          const u = Id();
          await ul(this.storage, `${this.storageKey}-code-verifier`, u), o = await Ad(u), c = u === o ? "plain" : "s256";
        }
        const { data: l, error: d } = await vi(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: i == null ? void 0 : i.emailRedirectTo,
          body: Object.assign(Object.assign({}, t), { code_challenge: o, code_challenge_method: c }),
          jwt: a.access_token,
          xform: gc
        });
        if (d)
          throw d;
        return a.user = l.user, await this._saveSession(a), await this._notifyAllSubscribers("USER_UPDATED", a), { data: { user: a.user }, error: null };
      });
    } catch (r) {
      if (fi(r))
        return { data: { user: null }, error: r };
      throw r;
    }
  }
  /**
   * Decodes a JWT (without performing any validation).
   */
  _decodeJWT(t) {
    return VI(t);
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(t) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(t));
  }
  async _setSession(t) {
    try {
      if (!t.access_token || !t.refresh_token)
        throw new Td();
      const i = Date.now() / 1e3;
      let r = i, n = !0, s = null;
      const a = VI(t.access_token);
      if (a.exp && (r = a.exp, n = r <= i), n) {
        const { session: o, error: c } = await this._callRefreshToken(t.refresh_token);
        if (c)
          return { data: { user: null, session: null }, error: c };
        if (!o)
          return { data: { user: null, session: null }, error: null };
        s = o;
      } else {
        const { data: o, error: c } = await this._getUser(t.access_token);
        if (c)
          throw c;
        s = {
          access_token: t.access_token,
          refresh_token: t.refresh_token,
          user: o.user,
          token_type: "bearer",
          expires_in: r - i,
          expires_at: r
        }, await this._saveSession(s), await this._notifyAllSubscribers("SIGNED_IN", s);
      }
      return { data: { user: s.user, session: s }, error: null };
    } catch (i) {
      if (fi(i))
        return { data: { session: null, user: null }, error: i };
      throw i;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(t) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(t));
  }
  async _refreshSession(t) {
    try {
      return await this._useSession(async (i) => {
        var r;
        if (!t) {
          const { data: a, error: o } = i;
          if (o)
            throw o;
          t = (r = a.session) !== null && r !== void 0 ? r : void 0;
        }
        if (!(t != null && t.refresh_token))
          throw new Td();
        const { session: n, error: s } = await this._callRefreshToken(t.refresh_token);
        return s ? { data: { user: null, session: null }, error: s } : n ? { data: { user: n.user, session: n }, error: null } : { data: { user: null, session: null }, error: null };
      });
    } catch (i) {
      if (fi(i))
        return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(t) {
    try {
      if (!Ns())
        throw new Rm("No browser detected.");
      if (this.flowType === "implicit" && !this._isImplicitGrantFlow())
        throw new Rm("Not a valid implicit grant flow url.");
      if (this.flowType == "pkce" && !t)
        throw new jI("Not a valid PKCE flow url.");
      const i = l_(window.location.href);
      if (t) {
        if (!i.code)
          throw new jI("No code detected.");
        const { data: W, error: et } = await this._exchangeCodeForSession(i.code);
        if (et)
          throw et;
        const E = new URL(window.location.href);
        return E.searchParams.delete("code"), window.history.replaceState(window.history.state, "", E.toString()), { data: { session: W.session, redirectType: null }, error: null };
      }
      if (i.error || i.error_description || i.error_code)
        throw new Rm(i.error_description || "Error in URL with unspecified error_description", {
          error: i.error || "unspecified_error",
          code: i.error_code || "unspecified_code"
        });
      const { provider_token: r, provider_refresh_token: n, access_token: s, refresh_token: a, expires_in: o, expires_at: c, token_type: l } = i;
      if (!s || !o || !a || !l)
        throw new Rm("No session defined in URL");
      const d = Math.round(Date.now() / 1e3), u = parseInt(o);
      let h = d + u;
      c && (h = parseInt(c));
      const p = h - d;
      p * 1e3 <= Vh && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${p}s, should have been closer to ${u}s`);
      const m = h - u;
      d - m >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", m, h, d) : d - m < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew", m, h, d);
      const { data: w, error: C } = await this._getUser(s);
      if (C)
        throw C;
      const F = {
        provider_token: r,
        provider_refresh_token: n,
        access_token: s,
        expires_in: u,
        expires_at: h,
        refresh_token: a,
        token_type: l,
        user: w.user
      };
      return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), { data: { session: F, redirectType: i.type }, error: null };
    } catch (i) {
      if (fi(i))
        return { data: { session: null, redirectType: null }, error: i };
      throw i;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantFlow() {
    const t = l_(window.location.href);
    return !!(Ns() && (t.access_token || t.error_description));
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCEFlow() {
    const t = l_(window.location.href), i = await Fm(this.storage, `${this.storageKey}-code-verifier`);
    return !!(t.code && i);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(t = { scope: "global" }) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(t));
  }
  async _signOut({ scope: t } = { scope: "global" }) {
    return await this._useSession(async (i) => {
      var r;
      const { data: n, error: s } = i;
      if (s)
        return { error: s };
      const a = (r = n.session) === null || r === void 0 ? void 0 : r.access_token;
      if (a) {
        const { error: o } = await this.admin.signOut(a, t);
        if (o && !(tU(o) && (o.status === 404 || o.status === 401)))
          return { error: o };
      }
      return t !== "others" && (await this._removeSession(), await d_(this.storage, `${this.storageKey}-code-verifier`), await this._notifyAllSubscribers("SIGNED_OUT", null)), { error: null };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(t) {
    const i = Hz(), r = {
      id: i,
      callback: t,
      unsubscribe: () => {
        this._debug("#unsubscribe()", "state change callback with id removed", i), this.stateChangeEmitters.delete(i);
      }
    };
    return this._debug("#onAuthStateChange()", "registered callback with id", i), this.stateChangeEmitters.set(i, r), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => {
      this._emitInitialSession(i);
    })))(), { data: { subscription: r } };
  }
  async _emitInitialSession(t) {
    return await this._useSession(async (i) => {
      var r, n;
      try {
        const { data: { session: s }, error: a } = i;
        if (a)
          throw a;
        await ((r = this.stateChangeEmitters.get(t)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", s)), this._debug("INITIAL_SESSION", "callback id", t, "session", s);
      } catch (s) {
        await ((n = this.stateChangeEmitters.get(t)) === null || n === void 0 ? void 0 : n.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", t, "error", s), console.error(s);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(t, i = {}) {
    let r = null, n = null;
    if (this.flowType === "pkce") {
      const s = Id();
      await ul(this.storage, `${this.storageKey}-code-verifier`, `${s}/PASSWORD_RECOVERY`), r = await Ad(s), n = s === r ? "plain" : "s256";
    }
    try {
      return await vi(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: t,
          code_challenge: r,
          code_challenge_method: n,
          gotrue_meta_security: { captcha_token: i.captchaToken }
        },
        headers: this.headers,
        redirectTo: i.redirectTo
      });
    } catch (s) {
      if (fi(s))
        return { data: null, error: s };
      throw s;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var t;
    try {
      const { data: i, error: r } = await this.getUser();
      if (r)
        throw r;
      return { data: { identities: (t = i.user.identities) !== null && t !== void 0 ? t : [] }, error: null };
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(t) {
    var i;
    try {
      const { data: r, error: n } = await this._useSession(async (s) => {
        var a, o, c, l, d;
        const { data: u, error: h } = s;
        if (h)
          throw h;
        const p = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, t.provider, {
          redirectTo: (a = t.options) === null || a === void 0 ? void 0 : a.redirectTo,
          scopes: (o = t.options) === null || o === void 0 ? void 0 : o.scopes,
          queryParams: (c = t.options) === null || c === void 0 ? void 0 : c.queryParams,
          skipBrowserRedirect: !0
        });
        return await vi(this.fetch, "GET", p, {
          headers: this.headers,
          jwt: (d = (l = u.session) === null || l === void 0 ? void 0 : l.access_token) !== null && d !== void 0 ? d : void 0
        });
      });
      if (n)
        throw n;
      return Ns() && !(!((i = t.options) === null || i === void 0) && i.skipBrowserRedirect) && window.location.assign(r == null ? void 0 : r.url), { data: { provider: t.provider, url: r == null ? void 0 : r.url }, error: null };
    } catch (r) {
      if (fi(r))
        return { data: { provider: t.provider, url: null }, error: r };
      throw r;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(t) {
    try {
      return await this._useSession(async (i) => {
        var r, n;
        const { data: s, error: a } = i;
        if (a)
          throw a;
        return await vi(this.fetch, "DELETE", `${this.url}/user/identities/${t.identity_id}`, {
          headers: this.headers,
          jwt: (n = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && n !== void 0 ? n : void 0
        });
      });
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(t) {
    const i = `#_refreshAccessToken(${t.substring(0, 5)}...)`;
    this._debug(i, "begin");
    try {
      const r = Date.now();
      return await Zz(async (n) => (await qz(n * 200), this._debug(i, "refreshing attempt", n), await vi(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
        body: { refresh_token: t },
        headers: this.headers,
        xform: ml
      })), (n, s, a) => a && a.error && h_(a.error) && // retryable only if the request can be sent before the backoff overflows the tick duration
      Date.now() + (n + 1) * 200 - r < Vh);
    } catch (r) {
      if (this._debug(i, "error", r), fi(r))
        return { data: { session: null, user: null }, error: r };
      throw r;
    } finally {
      this._debug(i, "end");
    }
  }
  _isValidSession(t) {
    return typeof t == "object" && t !== null && "access_token" in t && "refresh_token" in t && "expires_at" in t;
  }
  async _handleProviderSignIn(t, i) {
    const r = await this._getUrlForProvider(`${this.url}/authorize`, t, {
      redirectTo: i.redirectTo,
      scopes: i.scopes,
      queryParams: i.queryParams
    });
    return this._debug("#_handleProviderSignIn()", "provider", t, "options", i, "url", r), Ns() && !i.skipBrowserRedirect && window.location.assign(r), { data: { provider: t, url: r }, error: null };
  }
  /**
   * Recovers the session from LocalStorage and refreshes
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var t;
    const i = "#_recoverAndRefresh()";
    this._debug(i, "begin");
    try {
      const r = await Fm(this.storage, this.storageKey);
      if (this._debug(i, "session from storage", r), !this._isValidSession(r)) {
        this._debug(i, "session is not valid"), r !== null && await this._removeSession();
        return;
      }
      const n = Math.round(Date.now() / 1e3), s = ((t = r.expires_at) !== null && t !== void 0 ? t : 1 / 0) < n + WI;
      if (this._debug(i, `session has${s ? "" : " not"} expired with margin of ${WI}s`), s) {
        if (this.autoRefreshToken && r.refresh_token) {
          const { error: a } = await this._callRefreshToken(r.refresh_token);
          a && (console.error(a), h_(a) || (this._debug(i, "refresh failed with a non-retryable error, removing the session", a), await this._removeSession()));
        }
      } else
        await this._notifyAllSubscribers("SIGNED_IN", r);
    } catch (r) {
      this._debug(i, "error", r), console.error(r);
      return;
    } finally {
      this._debug(i, "end");
    }
  }
  async _callRefreshToken(t) {
    var i, r;
    if (!t)
      throw new Td();
    if (this.refreshingDeferred)
      return this.refreshingDeferred.promise;
    const n = `#_callRefreshToken(${t.substring(0, 5)}...)`;
    this._debug(n, "begin");
    try {
      this.refreshingDeferred = new yy();
      const { data: s, error: a } = await this._refreshAccessToken(t);
      if (a)
        throw a;
      if (!s.session)
        throw new Td();
      await this._saveSession(s.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
      const o = { session: s.session, error: null };
      return this.refreshingDeferred.resolve(o), o;
    } catch (s) {
      if (this._debug(n, "error", s), fi(s)) {
        const a = { session: null, error: s };
        return h_(s) || (await this._removeSession(), await this._notifyAllSubscribers("SIGNED_OUT", null)), (i = this.refreshingDeferred) === null || i === void 0 || i.resolve(a), a;
      }
      throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(s), s;
    } finally {
      this.refreshingDeferred = null, this._debug(n, "end");
    }
  }
  async _notifyAllSubscribers(t, i, r = !0) {
    const n = `#_notifyAllSubscribers(${t})`;
    this._debug(n, "begin", i, `broadcast = ${r}`);
    try {
      this.broadcastChannel && r && this.broadcastChannel.postMessage({ event: t, session: i });
      const s = [], a = Array.from(this.stateChangeEmitters.values()).map(async (o) => {
        try {
          await o.callback(t, i);
        } catch (c) {
          s.push(c);
        }
      });
      if (await Promise.all(a), s.length > 0) {
        for (let o = 0; o < s.length; o += 1)
          console.error(s[o]);
        throw s[0];
      }
    } finally {
      this._debug(n, "end");
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(t) {
    this._debug("#_saveSession()", t), await ul(this.storage, this.storageKey, t);
  }
  async _removeSession() {
    this._debug("#_removeSession()"), await d_(this.storage, this.storageKey);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const t = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      t && Ns() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", t);
    } catch (i) {
      console.error("removing visibilitychange callback failed", i);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const t = setInterval(() => this._autoRefreshTokenTick(), Vh);
    this.autoRefreshTicker = t, t && typeof t == "object" && typeof t.unref == "function" ? t.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(t), setTimeout(async () => {
      await this.initializePromise, await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const t = this.autoRefreshTicker;
    this.autoRefreshTicker = null, t && clearInterval(t);
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const t = Date.now();
          try {
            return await this._useSession(async (i) => {
              const { data: { session: r } } = i;
              if (!r || !r.refresh_token || !r.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const n = Math.floor((r.expires_at * 1e3 - t) / Vh);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${n} ticks, a tick lasts ${Vh}ms, refresh threshold is ${qI} ticks`), n <= qI && await this._callRefreshToken(r.refresh_token);
            });
          } catch (i) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", i);
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (t) {
      if (t.isAcquireTimeout || t instanceof oE)
        this._debug("auto refresh token tick lock not available");
      else
        throw t;
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    if (this._debug("#_handleVisibilityChange()"), !Ns() || !(window != null && window.addEventListener))
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0);
    } catch (t) {
      console.error("_handleVisibilityChange", t);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(t) {
    const i = `#_onVisibilityChanged(${t})`;
    this._debug(i, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), t || (await this.initializePromise, await this._acquireLock(-1, async () => {
      if (document.visibilityState !== "visible") {
        this._debug(i, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
        return;
      }
      await this._recoverAndRefresh();
    }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh();
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(t, i, r) {
    const n = [`provider=${encodeURIComponent(i)}`];
    if (r != null && r.redirectTo && n.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`), r != null && r.scopes && n.push(`scopes=${encodeURIComponent(r.scopes)}`), this.flowType === "pkce") {
      const s = Id();
      await ul(this.storage, `${this.storageKey}-code-verifier`, s);
      const a = await Ad(s), o = s === a ? "plain" : "s256";
      this._debug("PKCE", "code verifier", `${s.substring(0, 5)}...`, "code challenge", a, "method", o);
      const c = new URLSearchParams({
        code_challenge: `${encodeURIComponent(a)}`,
        code_challenge_method: `${encodeURIComponent(o)}`
      });
      n.push(c.toString());
    }
    if (r != null && r.queryParams) {
      const s = new URLSearchParams(r.queryParams);
      n.push(s.toString());
    }
    return r != null && r.skipBrowserRedirect && n.push(`skip_http_redirect=${r.skipBrowserRedirect}`), `${t}?${n.join("&")}`;
  }
  async _unenroll(t) {
    try {
      return await this._useSession(async (i) => {
        var r;
        const { data: n, error: s } = i;
        return s ? { data: null, error: s } : await vi(this.fetch, "DELETE", `${this.url}/factors/${t.factorId}`, {
          headers: this.headers,
          jwt: (r = n == null ? void 0 : n.session) === null || r === void 0 ? void 0 : r.access_token
        });
      });
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
  /**
   * {@see GoTrueMFAApi#enroll}
   */
  async _enroll(t) {
    try {
      return await this._useSession(async (i) => {
        var r, n;
        const { data: s, error: a } = i;
        if (a)
          return { data: null, error: a };
        const { data: o, error: c } = await vi(this.fetch, "POST", `${this.url}/factors`, {
          body: {
            friendly_name: t.friendlyName,
            factor_type: t.factorType,
            issuer: t.issuer
          },
          headers: this.headers,
          jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token
        });
        return c ? { data: null, error: c } : (!((n = o == null ? void 0 : o.totp) === null || n === void 0) && n.qr_code && (o.totp.qr_code = `data:image/svg+xml;utf-8,${o.totp.qr_code}`), { data: o, error: null });
      });
    } catch (i) {
      if (fi(i))
        return { data: null, error: i };
      throw i;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(t) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (i) => {
          var r;
          const { data: n, error: s } = i;
          if (s)
            return { data: null, error: s };
          const { data: a, error: o } = await vi(this.fetch, "POST", `${this.url}/factors/${t.factorId}/verify`, {
            body: { code: t.code, challenge_id: t.challengeId },
            headers: this.headers,
            jwt: (r = n == null ? void 0 : n.session) === null || r === void 0 ? void 0 : r.access_token
          });
          return o ? { data: null, error: o } : (await this._saveSession(Object.assign({ expires_at: Math.round(Date.now() / 1e3) + a.expires_in }, a)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a), { data: a, error: o });
        });
      } catch (i) {
        if (fi(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(t) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (i) => {
          var r;
          const { data: n, error: s } = i;
          return s ? { data: null, error: s } : await vi(this.fetch, "POST", `${this.url}/factors/${t.factorId}/challenge`, {
            headers: this.headers,
            jwt: (r = n == null ? void 0 : n.session) === null || r === void 0 ? void 0 : r.access_token
          });
        });
      } catch (i) {
        if (fi(i))
          return { data: null, error: i };
        throw i;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(t) {
    const { data: i, error: r } = await this._challenge({
      factorId: t.factorId
    });
    return r ? { data: null, error: r } : await this._verify({
      factorId: t.factorId,
      challengeId: i.id,
      code: t.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    const { data: { user: t }, error: i } = await this.getUser();
    if (i)
      return { data: null, error: i };
    const r = (t == null ? void 0 : t.factors) || [], n = r.filter((s) => s.factor_type === "totp" && s.status === "verified");
    return {
      data: {
        all: r,
        totp: n
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => await this._useSession(async (t) => {
      var i, r;
      const { data: { session: n }, error: s } = t;
      if (s)
        return { data: null, error: s };
      if (!n)
        return {
          data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },
          error: null
        };
      const a = this._decodeJWT(n.access_token);
      let o = null;
      a.aal && (o = a.aal);
      let c = o;
      ((r = (i = n.user.factors) === null || i === void 0 ? void 0 : i.filter((u) => u.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (c = "aal2");
      const d = a.amr || [];
      return { data: { currentLevel: o, nextLevel: c, currentAuthenticationMethods: d }, error: null };
    }));
  }
}
Ff.nextInstanceID = 0;
class bU extends Ff {
  constructor(t) {
    super(t);
  }
}
var xU = function(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const wU = {
  headers: Mz
}, SU = {
  schema: "public"
}, IU = {
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  flowType: "implicit"
}, AU = {};
class TU {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(t, i, r) {
    var n, s, a, o, c, l, d, u;
    if (this.supabaseUrl = t, this.supabaseKey = i, this.from = (C) => this.rest.from(C), this.schema = (C) => this.rest.schema(C), this.rpc = (C, F = {}, W) => this.rest.rpc(C, F, W), !t)
      throw new Error("supabaseUrl is required.");
    if (!i)
      throw new Error("supabaseKey is required.");
    const h = Vz(t);
    this.realtimeUrl = `${h}/realtime/v1`.replace(/^http/i, "ws"), this.authUrl = `${h}/auth/v1`, this.storageUrl = `${h}/storage/v1`, this.functionsUrl = `${h}/functions/v1`;
    const p = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`, m = {
      db: SU,
      realtime: AU,
      auth: Object.assign(Object.assign({}, IU), { storageKey: p }),
      global: wU
    }, w = jz(r ?? {}, m);
    this.storageKey = (s = (n = w.auth) === null || n === void 0 ? void 0 : n.storageKey) !== null && s !== void 0 ? s : "", this.headers = (o = (a = w.global) === null || a === void 0 ? void 0 : a.headers) !== null && o !== void 0 ? o : {}, this.auth = this._initSupabaseAuthClient((c = w.auth) !== null && c !== void 0 ? c : {}, this.headers, (l = w.global) === null || l === void 0 ? void 0 : l.fetch), this.fetch = Uz(i, this._getAccessToken.bind(this), (d = w.global) === null || d === void 0 ? void 0 : d.fetch), this.realtime = this._initRealtimeClient(Object.assign({ headers: this.headers }, w.realtime)), this.rest = new k1(`${h}/rest/v1`, {
      headers: this.headers,
      schema: (u = w.db) === null || u === void 0 ? void 0 : u.schema,
      fetch: this.fetch
    }), this._listenForAuthEvents();
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new J$(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new Bz(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(t, i = { config: {} }) {
    return this.realtime.channel(t, i);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(t) {
    return this.realtime.removeChannel(t);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var t, i;
    return xU(this, void 0, void 0, function* () {
      const { data: r } = yield this.auth.getSession();
      return (i = (t = r.session) === null || t === void 0 ? void 0 : t.access_token) !== null && i !== void 0 ? i : null;
    });
  }
  _initSupabaseAuthClient({ autoRefreshToken: t, persistSession: i, detectSessionInUrl: r, storage: n, storageKey: s, flowType: a, debug: o }, c, l) {
    const d = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new bU({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, d), c),
      storageKey: s,
      autoRefreshToken: t,
      persistSession: i,
      detectSessionInUrl: r,
      storage: n,
      flowType: a,
      debug: o,
      fetch: l
    });
  }
  _initRealtimeClient(t) {
    return new wz(this.realtimeUrl, Object.assign(Object.assign({}, t), { params: Object.assign({ apikey: this.supabaseKey }, t == null ? void 0 : t.params) }));
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((i, r) => {
      this._handleTokenChanged(i, "CLIENT", r == null ? void 0 : r.access_token);
    });
  }
  _handleTokenChanged(t, i, r) {
    (t === "TOKEN_REFRESHED" || t === "SIGNED_IN") && this.changedAccessToken !== r ? (this.realtime.setAuth(r ?? null), this.changedAccessToken = r) : t === "SIGNED_OUT" && (this.realtime.setAuth(this.supabaseKey), i == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0);
  }
}
const EU = (e, t, i) => new TU(e, t, i), kU = EU("https://xovkkfhojasbjinfslpx.supabase.co", "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhvdmtrZmhvamFzYmppbmZzbHB4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2OTM1ODQ0ODAsImV4cCI6MjAwOTE2MDQ4MH0.L3-X0p_un0oSTNubPwtfGo0D8g2bkPIfz7CaZ-iRYXY");
async function CU(e) {
  const { error: t } = await kU.from("metrics").insert(e);
  return t;
}
var XI = [], jh = [];
function OU(e, t) {
  if (e && typeof document < "u") {
    var i, r = t.prepend === !0 ? "prepend" : "append", n = t.singleTag === !0, s = typeof t.container == "string" ? document.querySelector(t.container) : document.getElementsByTagName("head")[0];
    if (n) {
      var a = XI.indexOf(s);
      a === -1 && (a = XI.push(s) - 1, jh[a] = {}), i = jh[a] && jh[a][r] ? jh[a][r] : jh[a][r] = o();
    } else
      i = o();
    e.charCodeAt(0) === 65279 && (e = e.substring(1)), i.styleSheet ? i.styleSheet.cssText += e : i.appendChild(document.createTextNode(e));
  }
  function o() {
    var c = document.createElement("style");
    if (c.setAttribute("type", "text/css"), t.attributes)
      for (var l = Object.keys(t.attributes), d = 0; d < l.length; d++)
        c.setAttribute(l[d], t.attributes[l[d]]);
    var u = r === "prepend" ? "afterbegin" : "beforeend";
    return s.insertAdjacentElement(u, c), c;
  }
}
var DU = ":root{--cosmograph-watermark-color:#fff}.style_module_watermark__6b4371ae{bottom:0;color:var(--cosmograph-watermark-color);cursor:pointer;line-height:0;margin:0 .6rem .6rem 0;position:absolute;right:0;user-select:none}.style_module_cosmograph__6b4371ae{display:flex;height:100%;overflow:hidden;position:relative;width:100%}.style_module_cosmographShowLabelsFor__6b4371ae{opacity:1}.style_module_cosmographShowTopLabels__6b4371ae{opacity:.9}.style_module_cosmographShowDynamicLabels__6b4371ae{opacity:.7}", Gh = { watermark: "style_module_watermark__6b4371ae", cosmograph: "style_module_cosmograph__6b4371ae", cosmographShowLabelsFor: "style_module_cosmographShowLabelsFor__6b4371ae", cosmographShowTopLabels: "style_module_cosmographShowTopLabels__6b4371ae", cosmographShowDynamicLabels: "style_module_cosmographShowDynamicLabels__6b4371ae" };
OU(DU, {});
const KI = { disableSimulation: null, showDynamicLabels: !0, showTopLabels: !1, showTopLabelsLimit: 100, showTopLabelsValueKey: void 0, showLabelsFor: void 0, showHoveredNodeLabel: !0, nodeLabelAccessor: (e) => e.id, nodeLabelClassName: void 0, nodeLabelColor: void 0, hoveredNodeLabelClassName: void 0, hoveredNodeLabelColor: void 0, onSetData: void 0, onNodesFiltered: void 0, onLinksFiltered: void 0, onLabelClick: void 0 };
let N1 = hu, JI = hu, QI = hu, cE = dE, lE = uE;
typeof Uint8Array < "u" && (N1 = function(e) {
  return new Uint8Array(e);
}, JI = function(e) {
  return new Uint16Array(e);
}, QI = function(e) {
  return new Uint32Array(e);
}, cE = function(e, t) {
  if (e.length >= t)
    return e;
  var i = new e.constructor(t);
  return i.set(e), i;
}, lE = function(e, t) {
  var i;
  switch (t) {
    case 16:
      i = JI(e.length);
      break;
    case 32:
      i = QI(e.length);
      break;
    default:
      throw new Error("invalid array width!");
  }
  return i.set(e), i;
});
function hu(e) {
  for (var t = new Array(e), i = -1; ++i < e; )
    t[i] = 0;
  return t;
}
function dE(e, t) {
  for (var i = e.length; i < t; )
    e[i++] = 0;
  return e;
}
function uE(e, t) {
  if (t > 32)
    throw new Error("invalid array width!");
  return e;
}
function Ga(e) {
  this.length = e, this.subarrays = 1, this.width = 8, this.masks = {
    0: 0
  }, this[0] = N1(e);
}
Ga.prototype.lengthen = function(e) {
  var t, i;
  for (t = 0, i = this.subarrays; t < i; ++t)
    this[t] = cE(this[t], e);
  this.length = e;
};
Ga.prototype.add = function() {
  var e, t, i, r, n;
  for (r = 0, n = this.subarrays; r < n; ++r)
    if (e = this.masks[r], t = this.width - 32 * r, i = (~e & e + 1) >>> 0, !(t >= 32 && !i))
      return t < 32 && i & 1 << t && (this[r] = lE(this[r], t <<= 1), this.width = 32 * r + t), this.masks[r] |= i, {
        offset: r,
        one: i
      };
  return this[this.subarrays] = N1(this.length), this.masks[this.subarrays] = 1, this.width += 8, {
    offset: this.subarrays++,
    one: 1
  };
};
Ga.prototype.copy = function(e, t) {
  var i, r;
  for (i = 0, r = this.subarrays; i < r; ++i)
    this[i][e] = this[i][t];
};
Ga.prototype.truncate = function(e) {
  var t, i;
  for (t = 0, i = this.subarrays; t < i; ++t)
    for (var r = this.length - 1; r >= e; r--)
      this[t][r] = 0;
  this.length = e;
};
Ga.prototype.zero = function(e) {
  var t, i;
  for (t = 0, i = this.subarrays; t < i; ++t)
    if (this[t][e])
      return !1;
  return !0;
};
Ga.prototype.zeroExcept = function(e, t, i) {
  var r, n;
  for (r = 0, n = this.subarrays; r < n; ++r)
    if (r === t ? this[r][e] & i : this[r][e])
      return !1;
  return !0;
};
Ga.prototype.zeroExceptMask = function(e, t) {
  var i, r;
  for (i = 0, r = this.subarrays; i < r; ++i)
    if (this[i][e] & t[i])
      return !1;
  return !0;
};
Ga.prototype.only = function(e, t, i) {
  var r, n;
  for (r = 0, n = this.subarrays; r < n; ++r)
    if (this[r][e] != (r === t ? i : 0))
      return !1;
  return !0;
};
Ga.prototype.onlyExcept = function(e, t, i, r, n) {
  var s, a, o;
  for (a = 0, o = this.subarrays; a < o; ++a)
    if (s = this[a][e], a === t && (s = (s & i) >>> 0), s != (a === r ? n : 0))
      return !1;
  return !0;
};
const yc = {
  array8: hu,
  array16: hu,
  array32: hu,
  arrayLengthen: dE,
  arrayWiden: uE,
  bitarray: Ga
}, NU = (e, t) => function(i) {
  var r = i.length;
  return [e.left(i, t, 0, r), e.right(i, t, 0, r)];
}, LU = (e, t) => {
  var i = t[0], r = t[1];
  return function(n) {
    var s = n.length;
    return [e.left(n, i, 0, s), e.left(n, r, 0, s)];
  };
}, FU = (e) => [0, e.length], kd = {
  filterExact: NU,
  filterRange: LU,
  filterAll: FU
}, Bf = (e) => e, ua = () => null, Mm = () => 0;
function hE(e) {
  function t(n, s, a) {
    for (var o = a - s, c = (o >>> 1) + 1; --c > 0; )
      r(n, c, o, s);
    return n;
  }
  function i(n, s, a) {
    for (var o = a - s, c; --o > 0; )
      c = n[s], n[s] = n[s + o], n[s + o] = c, r(n, 1, o, s);
    return n;
  }
  function r(n, s, a, o) {
    for (var c = n[--o + s], l = e(c), d; (d = s << 1) <= a && (d < a && e(n[o + d]) > e(n[o + d + 1]) && d++, !(l <= e(n[o + d]))); )
      n[o + s] = n[o + d], s = d;
    n[o + s] = c;
  }
  return t.sort = i, t;
}
const vy = hE(Bf);
vy.by = hE;
function fE(e) {
  var t = vy.by(e);
  function i(r, n, s, a) {
    var o = new Array(a = Math.min(s - n, a)), c, l, d;
    for (l = 0; l < a; ++l)
      o[l] = r[n++];
    if (t(o, 0, a), n < s) {
      c = e(o[0]);
      do
        e(d = r[n]) > c && (o[0] = d, c = e(t(o, 0, a)[0]));
      while (++n < s);
    }
    return o;
  }
  return i;
}
const L1 = fE(Bf);
L1.by = fE;
function pE(e) {
  function t(r, n, s, a) {
    for (; s < a; ) {
      var o = s + a >>> 1;
      e(r[o]) < n ? s = o + 1 : a = o;
    }
    return s;
  }
  function i(r, n, s, a) {
    for (; s < a; ) {
      var o = s + a >>> 1;
      n < e(r[o]) ? a = o : s = o + 1;
    }
    return s;
  }
  return i.right = i, i.left = t, i;
}
const Ug = pE(Bf);
Ug.by = pE;
const Qm = (e, t, i) => {
  for (var r = 0, n = t.length, s = i ? JSON.parse(JSON.stringify(e)) : new Array(n); r < n; ++r)
    s[r] = e[t[r]];
  return s;
}, BU = (e) => e + 1, RU = (e) => e - 1, MU = (e) => function(t, i) {
  return t + +e(i);
}, PU = (e) => function(t, i) {
  return t - e(i);
}, sc = {
  reduceIncrement: BU,
  reduceDecrement: RU,
  reduceAdd: MU,
  reduceSubtract: PU
};
function $U(e, t, i, r, n) {
  for (n in r = (i = i.split(".")).splice(-1, 1), i)
    t = t[i[n]] = t[i[n]] || {};
  return e(t, r);
}
const zU = (e, t) => {
  const i = e[t];
  return typeof i == "function" ? i.call(e) : i;
}, UU = /\[([\w\d]+)\]/g, VU = (e, t) => $U(zU, e, t.replace(UU, ".$1"));
var ac = -1;
bp.heap = vy;
bp.heapselect = L1;
bp.bisect = Ug;
bp.permute = Qm;
function bp() {
  var e = {
    add: c,
    remove: l,
    dimension: h,
    groupAll: p,
    size: m,
    all: w,
    allFiltered: C,
    onChange: F,
    isElementFiltered: u
  }, t = [], i = 0, r, n = [], s = [], a = [], o = [];
  r = new yc.bitarray(0);
  function c(et) {
    var E = i, Z = et.length;
    return Z && (t = t.concat(et), r.lengthen(i += Z), s.forEach(function(yt) {
      yt(et, E, Z);
    }), W("dataAdded")), e;
  }
  function l(et) {
    for (var E = new Array(i), Z = [], yt = typeof et == "function", bt = function(le) {
      return yt ? et(t[le], le) : r.zero(le);
    }, Ct = 0, Mt = 0; Ct < i; ++Ct)
      bt(Ct) ? (Z.push(Ct), E[Ct] = ac) : E[Ct] = Mt++;
    n.forEach(function(le) {
      le(-1, -1, [], Z, !0);
    }), a.forEach(function(le) {
      le(E);
    });
    for (var Me = 0, kt = 0; Me < i; ++Me)
      E[Me] !== ac && (Me !== kt && (r.copy(kt, Me), t[kt] = t[Me]), ++kt);
    t.length = i = kt, r.truncate(kt), W("dataRemoved");
  }
  function d(et) {
    var E, Z, yt, bt, Ct = Array(r.subarrays);
    for (E = 0; E < r.subarrays; E++)
      Ct[E] = -1;
    for (Z = 0, yt = et.length; Z < yt; Z++)
      bt = et[Z].id(), Ct[bt >> 7] &= ~(1 << (bt & 63));
    return Ct;
  }
  function u(et, E) {
    var Z = d(E || []);
    return r.zeroExceptMask(et, Z);
  }
  function h(et, E) {
    if (typeof et == "string") {
      var Z = et;
      et = function(jt) {
        return VU(jt, Z);
      };
    }
    var yt = {
      filter: Di,
      filterExact: Gr,
      filterRange: Hr,
      filterFunction: Wr,
      filterAll: Zn,
      currentFilter: Ql,
      hasCurrentFilter: Hy,
      top: Wy,
      bottom: _,
      group: Vp,
      groupAll: Yy,
      dispose: jp,
      remove: jp,
      // for backwards-compatibility
      accessor: et,
      id: function() {
        return Me;
      }
    }, bt, Ct, Mt, Me, kt, le, ye, V, Bt, at, vt = [], oe = function(jt) {
      return f_(jt).sort(function(Wt, ot) {
        var X = ye[Wt], Pe = ye[ot];
        return X < Pe ? -1 : X > Pe ? 1 : Wt - ot;
      });
    }, Yt = kd.filterAll, pe, ei, ii, cr = [], Oi = [], Ri = 0, Zi = 0, hr = 0, br;
    s.unshift(Ze), s.push(ai), a.push(It);
    var qt = r.add();
    Mt = qt.offset, bt = qt.one, Ct = ~bt, Me = Mt << 7 | Math.log(bt) / Math.log(2), Ze(t, 0, i), ai(t, 0, i);
    function Ze(jt, Wt, ot) {
      var X, Pe;
      if (E) {
        hr = 0, on = 0, br = [];
        for (var te = 0; te < jt.length; te++)
          for (on = 0, br = et(jt[te]); on < br.length; on++)
            hr++;
        ye = [], X = f_(jt.length), Pe = gl(hr, 1);
        for (var ee = f_(hr), Ui = 0, Ii = 0; Ii < jt.length; Ii++) {
          if (br = et(jt[Ii]), !br.length) {
            X[Ii] = 0, vt.push(Ii + Wt);
            continue;
          }
          for (X[Ii] = br.length, on = 0; on < br.length; on++)
            ye.push(br[on]), ee[Ui] = Ii, Ui++;
        }
        var xr = oe(hr);
        ye = Qm(ye, xr), V = Qm(ee, xr);
      } else
        ye = jt.map(et), V = oe(ot), ye = Qm(ye, V);
      var fr = Yt(ye), pn = fr[0], lr = fr[1], Vi, Mr, xn;
      if (E)
        if (ot = hr, pe)
          for (Vi = 0; Vi < ot; ++Vi)
            pe(ye[Vi], Vi) || (--X[V[Vi]] === 0 && (r[Mt][V[Vi] + Wt] |= bt), Pe[Vi] = 1);
        else {
          for (Mr = 0; Mr < pn; ++Mr)
            --X[V[Mr]] === 0 && (r[Mt][V[Mr] + Wt] |= bt), Pe[Mr] = 1;
          for (xn = lr; xn < ot; ++xn)
            --X[V[xn]] === 0 && (r[Mt][V[xn] + Wt] |= bt), Pe[xn] = 1;
        }
      else if (pe)
        for (Vi = 0; Vi < ot; ++Vi)
          pe(ye[Vi], Vi) || (r[Mt][V[Vi] + Wt] |= bt);
      else {
        for (Mr = 0; Mr < pn; ++Mr)
          r[Mt][V[Mr] + Wt] |= bt;
        for (xn = lr; xn < ot; ++xn)
          r[Mt][V[xn] + Wt] |= bt;
      }
      if (!Wt) {
        kt = ye, le = V, Bt = X, at = Pe, Ri = pn, Zi = lr;
        return;
      }
      var ks = kt, Ya = le, Wc = at, Yo, Xi = 0;
      if (te = 0, E && (Yo = Wt, Wt = ks.length, ot = hr), kt = E ? new Array(Wt + ot) : new Array(i), le = E ? new Array(Wt + ot) : gl(i, i), E && (at = gl(Wt + ot, 1)), E) {
        var Yc = Bt.length;
        Bt = yc.arrayLengthen(Bt, i);
        for (var on = 0; on + Yc < i; on++)
          Bt[on + Yc] = X[on];
      }
      for (var Pr = 0; te < Wt && Xi < ot; ++Pr)
        ks[te] < ye[Xi] ? (kt[Pr] = ks[te], E && (at[Pr] = Wc[te]), le[Pr] = Ya[te++]) : (kt[Pr] = ye[Xi], E && (at[Pr] = Pe[Xi]), le[Pr] = V[Xi++] + (E ? Yo : Wt));
      for (; te < Wt; ++te, ++Pr)
        kt[Pr] = ks[te], E && (at[Pr] = Wc[te]), le[Pr] = Ya[te];
      for (; Xi < ot; ++Xi, ++Pr)
        kt[Pr] = ye[Xi], E && (at[Pr] = Pe[Xi]), le[Pr] = V[Xi] + (E ? Yo : Wt);
      fr = Yt(kt), Ri = fr[0], Zi = fr[1];
    }
    function ai(jt, Wt, ot) {
      cr.forEach(function(X) {
        X(ye, V, Wt, ot);
      }), ye = V = null;
    }
    function It(jt) {
      if (E) {
        for (var Wt = 0, ot = 0; Wt < vt.length; Wt++)
          jt[vt[Wt]] !== ac && (vt[ot] = jt[vt[Wt]], ot++);
        for (vt.length = ot, Wt = 0, ot = 0; Wt < i; Wt++)
          jt[Wt] !== ac && (ot !== Wt && (Bt[ot] = Bt[Wt]), ot++);
        Bt = Bt.slice(0, ot);
      }
      for (var X = kt.length, Pe = 0, te = 0, ee; Pe < X; ++Pe)
        ee = le[Pe], jt[ee] !== ac && (Pe !== te && (kt[te] = kt[Pe]), le[te] = jt[ee], E && (at[te] = at[Pe]), ++te);
      for (kt.length = te, E && (at = at.slice(0, te)); te < X; )
        le[te++] = 0;
      var Ui = Yt(kt);
      Ri = Ui[0], Zi = Ui[1];
    }
    function Er(jt) {
      var Wt = jt[0], ot = jt[1];
      if (pe)
        return pe = null, fh(function(lr, Vi) {
          return Wt <= Vi && Vi < ot;
        }, jt[0] === 0 && jt[1] === kt.length), Ri = Wt, Zi = ot, yt;
      var X, Pe, te, ee = [], Ui = [], Ii = [], xr = [];
      if (Wt < Ri)
        for (X = Wt, Pe = Math.min(Ri, ot); X < Pe; ++X)
          ee.push(le[X]), Ii.push(X);
      else if (Wt > Ri)
        for (X = Ri, Pe = Math.min(Wt, Zi); X < Pe; ++X)
          Ui.push(le[X]), xr.push(X);
      if (ot > Zi)
        for (X = Math.max(Wt, Zi), Pe = ot; X < Pe; ++X)
          ee.push(le[X]), Ii.push(X);
      else if (ot < Zi)
        for (X = Math.max(Ri, ot), Pe = Zi; X < Pe; ++X)
          Ui.push(le[X]), xr.push(X);
      if (E) {
        var fr = [], pn = [];
        for (X = 0; X < ee.length; X++)
          Bt[ee[X]]++, at[Ii[X]] = 0, Bt[ee[X]] === 1 && (r[Mt][ee[X]] ^= bt, fr.push(ee[X]));
        for (X = 0; X < Ui.length; X++)
          Bt[Ui[X]]--, at[xr[X]] = 1, Bt[Ui[X]] === 0 && (r[Mt][Ui[X]] ^= bt, pn.push(Ui[X]));
        if (ee = fr, Ui = pn, Yt === kd.filterAll)
          for (X = 0; X < vt.length; X++)
            r[Mt][te = vt[X]] & bt && (r[Mt][te] ^= bt, ee.push(te));
        else
          for (X = 0; X < vt.length; X++)
            r[Mt][te = vt[X]] & bt || (r[Mt][te] ^= bt, Ui.push(te));
      } else {
        for (X = 0; X < ee.length; X++)
          r[Mt][ee[X]] ^= bt;
        for (X = 0; X < Ui.length; X++)
          r[Mt][Ui[X]] ^= bt;
      }
      return Ri = Wt, Zi = ot, n.forEach(function(lr) {
        lr(bt, Mt, ee, Ui);
      }), W("filtered"), yt;
    }
    function Di(jt) {
      return jt == null ? Zn() : Array.isArray(jt) ? Hr(jt) : typeof jt == "function" ? Wr(jt) : Gr(jt);
    }
    function Gr(jt) {
      return ei = jt, ii = !0, Er((Yt = kd.filterExact(Ug, jt))(kt));
    }
    function Hr(jt) {
      return ei = jt, ii = !0, Er((Yt = kd.filterRange(Ug, jt))(kt));
    }
    function Zn() {
      return ei = void 0, ii = !1, Er((Yt = kd.filterAll)(kt));
    }
    function Wr(jt) {
      ei = jt, ii = !0, pe = jt, Yt = kd.filterAll, fh(jt, !1);
      var Wt = Yt(kt);
      return Ri = Wt[0], Zi = Wt[1], yt;
    }
    function fh(jt, Wt) {
      var ot, X, Pe, te = [], ee = [], Ui = [], Ii = [], xr = kt.length;
      if (!E)
        for (ot = 0; ot < xr; ++ot)
          !(r[Mt][X = le[ot]] & bt) ^ !!(Pe = jt(kt[ot], ot)) && (Pe ? te.push(X) : ee.push(X));
      if (E)
        for (ot = 0; ot < xr; ++ot)
          jt(kt[ot], ot) ? (te.push(le[ot]), Ui.push(ot)) : (ee.push(le[ot]), Ii.push(ot));
      if (E) {
        var fr = [], pn = [];
        for (ot = 0; ot < te.length; ot++)
          at[Ui[ot]] === 1 && (Bt[te[ot]]++, at[Ui[ot]] = 0, Bt[te[ot]] === 1 && (r[Mt][te[ot]] ^= bt, fr.push(te[ot])));
        for (ot = 0; ot < ee.length; ot++)
          at[Ii[ot]] === 0 && (Bt[ee[ot]]--, at[Ii[ot]] = 1, Bt[ee[ot]] === 0 && (r[Mt][ee[ot]] ^= bt, pn.push(ee[ot])));
        if (te = fr, ee = pn, Wt)
          for (ot = 0; ot < vt.length; ot++)
            r[Mt][X = vt[ot]] & bt && (r[Mt][X] ^= bt, te.push(X));
        else
          for (ot = 0; ot < vt.length; ot++)
            r[Mt][X = vt[ot]] & bt || (r[Mt][X] ^= bt, ee.push(X));
      } else {
        for (ot = 0; ot < te.length; ot++)
          r[Mt][te[ot]] & bt && (r[Mt][te[ot]] &= Ct);
        for (ot = 0; ot < ee.length; ot++)
          r[Mt][ee[ot]] & bt || (r[Mt][ee[ot]] |= bt);
      }
      n.forEach(function(lr) {
        lr(bt, Mt, te, ee);
      }), W("filtered");
    }
    function Ql() {
      return ei;
    }
    function Hy() {
      return ii;
    }
    function Wy(jt, Wt) {
      var ot = [], X = Zi, Pe, te = 0;
      for (Wt && Wt > 0 && (te = Wt); --X >= Ri && jt > 0; )
        r.zero(Pe = le[X]) && (te > 0 ? --te : (ot.push(t[Pe]), --jt));
      if (E)
        for (X = 0; X < vt.length && jt > 0; X++)
          r.zero(Pe = vt[X]) && (te > 0 ? --te : (ot.push(t[Pe]), --jt));
      return ot;
    }
    function _(jt, Wt) {
      var ot = [], X, Pe, te = 0;
      if (Wt && Wt > 0 && (te = Wt), E)
        for (X = 0; X < vt.length && jt > 0; X++)
          r.zero(Pe = vt[X]) && (te > 0 ? --te : (ot.push(t[Pe]), --jt));
      for (X = Ri; X < Zi && jt > 0; )
        r.zero(Pe = le[X]) && (te > 0 ? --te : (ot.push(t[Pe]), --jt)), X++;
      return ot;
    }
    function Vp(jt) {
      var Wt = {
        top: qy,
        all: Pr,
        reduce: ph,
        reduceCount: Gp,
        reduceSum: Zy,
        order: Hp,
        orderNatural: Wp,
        size: Yp,
        dispose: nr,
        remove: nr
        // for backwards-compatibility
      };
      Oi.push(Wt);
      var ot, X, Pe = 8, te = tA(Pe), ee = 0, Ui, Ii, xr, fr, pn, lr = ua, Vi = ua, Mr = !0, xn = jt === ua, ks;
      arguments.length < 1 && (jt = Bf), n.push(lr), cr.push(Ya), a.push(Wc), Ya(kt, le, 0, i);
      function Ya(Gt, si, xi, kr) {
        E && (ks = xi, xi = kt.length - Gt.length, kr = Gt.length);
        var oi = ot, We = E ? [] : gl(ee, te), Ai = xr, ji = fr, $r = pn, Yr = ee, qr = 0, qa = 0, ns, qo, td, Za, Xa, mh;
        for (Mr && (Ai = $r = ua), Mr && (ji = $r = ua), ot = new Array(ee), ee = 0, E ? X = Yr ? X : [] : X = Yr > 1 ? yc.arrayLengthen(X, i) : gl(i, te), Yr && (td = (qo = oi[0]).key); qa < kr && !((Za = jt(Gt[qa])) >= Za); )
          ++qa;
        for (; qa < kr; ) {
          for (qo && td <= Za ? (Xa = qo, mh = td, We[qr] = ee, qo = oi[++qr], qo && (td = qo.key)) : (Xa = { key: Za, value: $r() }, mh = Za), ot[ee] = Xa; Za <= mh && (ns = si[qa] + (E ? ks : xi), E ? X[ns] ? X[ns].push(ee) : X[ns] = [ee] : X[ns] = ee, Xa.value = Ai(Xa.value, t[ns], !0), r.zeroExcept(ns, Mt, Ct) || (Xa.value = ji(Xa.value, t[ns], !1)), !(++qa >= kr)); )
            Za = jt(Gt[qa]);
          qp();
        }
        for (; qr < Yr; )
          ot[We[qr] = ee] = oi[qr++], qp();
        if (E)
          for (var Cs = 0; Cs < i; Cs++)
            X[Cs] || (X[Cs] = []);
        if (ee > qr)
          if (E)
            for (qr = 0; qr < ks; ++qr)
              for (Cs = 0; Cs < X[qr].length; Cs++)
                X[qr][Cs] = We[X[qr][Cs]];
          else
            for (qr = 0; qr < xi; ++qr)
              X[qr] = We[X[qr]];
        ns = n.indexOf(lr), ee > 1 || E ? (lr = Yo, Vi = Yc) : (!ee && xn && (ee = 1, ot = [{ key: null, value: $r() }]), ee === 1 ? (lr = Xi, Vi = on) : (lr = ua, Vi = ua), X = null), n[ns] = lr;
        function qp() {
          if (E) {
            ee++;
            return;
          }
          ++ee === te && (We = yc.arrayWiden(We, Pe <<= 1), X = yc.arrayWiden(X, Pe), te = tA(Pe));
        }
      }
      function Wc(Gt) {
        if (ee > 1 || E) {
          var si = ee, xi = ot, kr = gl(si, si), oi, We, Ai;
          if (E) {
            for (oi = 0, Ai = 0; oi < i; ++oi)
              if (Gt[oi] !== ac) {
                for (X[Ai] = X[oi], We = 0; We < X[Ai].length; We++)
                  kr[X[Ai][We]] = 1;
                ++Ai;
              }
            X = X.slice(0, Ai);
          } else
            for (oi = 0, Ai = 0; oi < i; ++oi)
              Gt[oi] !== ac && (kr[X[Ai] = X[oi]] = 1, ++Ai);
          for (ot = [], ee = 0, oi = 0; oi < si; ++oi)
            kr[oi] && (kr[oi] = ee++, ot.push(xi[oi]));
          if (ee > 1 || E)
            if (E)
              for (oi = 0; oi < Ai; ++oi)
                for (We = 0; We < X[oi].length; ++We)
                  X[oi][We] = kr[X[oi][We]];
            else
              for (oi = 0; oi < Ai; ++oi)
                X[oi] = kr[X[oi]];
          else
            X = null;
          n[n.indexOf(lr)] = ee > 1 || E ? (Vi = Yc, lr = Yo) : ee === 1 ? (Vi = on, lr = Xi) : Vi = lr = ua;
        } else if (ee === 1) {
          if (xn)
            return;
          for (var ji = 0; ji < i; ++ji)
            if (Gt[ji] !== ac)
              return;
          ot = [], ee = 0, n[n.indexOf(lr)] = lr = Vi = ua;
        }
      }
      function Yo(Gt, si, xi, kr, oi) {
        if (!(Gt === bt && si === Mt || Mr)) {
          var We, Ai, ji, $r, Yr;
          if (E) {
            for (We = 0, $r = xi.length; We < $r; ++We)
              if (r.zeroExcept(ji = xi[We], Mt, Ct))
                for (Ai = 0; Ai < X[ji].length; Ai++)
                  Yr = ot[X[ji][Ai]], Yr.value = xr(Yr.value, t[ji], !1, Ai);
            for (We = 0, $r = kr.length; We < $r; ++We)
              if (r.onlyExcept(ji = kr[We], Mt, Ct, si, Gt))
                for (Ai = 0; Ai < X[ji].length; Ai++)
                  Yr = ot[X[ji][Ai]], Yr.value = fr(Yr.value, t[ji], oi, Ai);
            return;
          }
          for (We = 0, $r = xi.length; We < $r; ++We)
            r.zeroExcept(ji = xi[We], Mt, Ct) && (Yr = ot[X[ji]], Yr.value = xr(Yr.value, t[ji], !1));
          for (We = 0, $r = kr.length; We < $r; ++We)
            r.onlyExcept(ji = kr[We], Mt, Ct, si, Gt) && (Yr = ot[X[ji]], Yr.value = fr(Yr.value, t[ji], oi));
        }
      }
      function Xi(Gt, si, xi, kr, oi) {
        if (!(Gt === bt && si === Mt || Mr)) {
          var We, Ai, ji, $r = ot[0];
          for (We = 0, ji = xi.length; We < ji; ++We)
            r.zeroExcept(Ai = xi[We], Mt, Ct) && ($r.value = xr($r.value, t[Ai], !1));
          for (We = 0, ji = kr.length; We < ji; ++We)
            r.onlyExcept(Ai = kr[We], Mt, Ct, si, Gt) && ($r.value = fr($r.value, t[Ai], oi));
        }
      }
      function Yc() {
        var Gt, si, xi;
        for (Gt = 0; Gt < ee; ++Gt)
          ot[Gt].value = pn();
        if (E) {
          for (Gt = 0; Gt < i; ++Gt)
            for (si = 0; si < X[Gt].length; si++)
              xi = ot[X[Gt][si]], xi.value = xr(xi.value, t[Gt], !0, si);
          for (Gt = 0; Gt < i; ++Gt)
            if (!r.zeroExcept(Gt, Mt, Ct))
              for (si = 0; si < X[Gt].length; si++)
                xi = ot[X[Gt][si]], xi.value = fr(xi.value, t[Gt], !1, si);
          return;
        }
        for (Gt = 0; Gt < i; ++Gt)
          xi = ot[X[Gt]], xi.value = xr(xi.value, t[Gt], !0);
        for (Gt = 0; Gt < i; ++Gt)
          r.zeroExcept(Gt, Mt, Ct) || (xi = ot[X[Gt]], xi.value = fr(xi.value, t[Gt], !1));
      }
      function on() {
        var Gt, si = ot[0];
        for (si.value = pn(), Gt = 0; Gt < i; ++Gt)
          si.value = xr(si.value, t[Gt], !0);
        for (Gt = 0; Gt < i; ++Gt)
          r.zeroExcept(Gt, Mt, Ct) || (si.value = fr(si.value, t[Gt], !1));
      }
      function Pr() {
        return Mr && (Vi(), Mr = !1), ot;
      }
      function qy(Gt) {
        var si = Ui(Pr(), 0, ot.length, Gt);
        return Ii.sort(si, 0, si.length);
      }
      function ph(Gt, si, xi) {
        return xr = Gt, fr = si, pn = xi, Mr = !0, Wt;
      }
      function Gp() {
        return ph(sc.reduceIncrement, sc.reduceDecrement, Mm);
      }
      function Zy(Gt) {
        return ph(sc.reduceAdd(Gt), sc.reduceSubtract(Gt), Mm);
      }
      function Hp(Gt) {
        Ui = L1.by(si), Ii = vy.by(si);
        function si(xi) {
          return Gt(xi.value);
        }
        return Wt;
      }
      function Wp() {
        return Hp(Bf);
      }
      function Yp() {
        return ee;
      }
      function nr() {
        var Gt = n.indexOf(lr);
        return Gt >= 0 && n.splice(Gt, 1), Gt = cr.indexOf(Ya), Gt >= 0 && cr.splice(Gt, 1), Gt = a.indexOf(Wc), Gt >= 0 && a.splice(Gt, 1), Gt = Oi.indexOf(Wt), Gt >= 0 && Oi.splice(Gt, 1), Wt;
      }
      return Gp().orderNatural();
    }
    function Yy() {
      var jt = Vp(ua), Wt = jt.all;
      return delete jt.all, delete jt.top, delete jt.order, delete jt.orderNatural, delete jt.size, jt.value = function() {
        return Wt()[0].value;
      }, jt;
    }
    function jp() {
      Oi.forEach(function(Wt) {
        Wt.dispose();
      });
      var jt = s.indexOf(Ze);
      return jt >= 0 && s.splice(jt, 1), jt = s.indexOf(ai), jt >= 0 && s.splice(jt, 1), jt = a.indexOf(It), jt >= 0 && a.splice(jt, 1), r.masks[Mt] &= Ct, Zn();
    }
    return yt;
  }
  function p() {
    var et = {
      reduce: le,
      reduceCount: ye,
      reduceSum: V,
      value: Bt,
      dispose: at,
      remove: at
      // for backwards-compatibility
    }, E, Z, yt, bt, Ct = !0;
    n.push(Me), s.push(Mt), Mt(t, 0);
    function Mt(vt, oe) {
      var Yt;
      if (!Ct)
        for (Yt = oe; Yt < i; ++Yt)
          E = Z(E, t[Yt], !0), r.zero(Yt) || (E = yt(E, t[Yt], !1));
    }
    function Me(vt, oe, Yt, pe, ei) {
      var ii, cr, Oi;
      if (!Ct) {
        for (ii = 0, Oi = Yt.length; ii < Oi; ++ii)
          r.zero(cr = Yt[ii]) && (E = Z(E, t[cr], ei));
        for (ii = 0, Oi = pe.length; ii < Oi; ++ii)
          r.only(cr = pe[ii], oe, vt) && (E = yt(E, t[cr], ei));
      }
    }
    function kt() {
      var vt;
      for (E = bt(), vt = 0; vt < i; ++vt)
        E = Z(E, t[vt], !0), r.zero(vt) || (E = yt(E, t[vt], !1));
    }
    function le(vt, oe, Yt) {
      return Z = vt, yt = oe, bt = Yt, Ct = !0, et;
    }
    function ye() {
      return le(sc.reduceIncrement, sc.reduceDecrement, Mm);
    }
    function V(vt) {
      return le(sc.reduceAdd(vt), sc.reduceSubtract(vt), Mm);
    }
    function Bt() {
      return Ct && (kt(), Ct = !1), E;
    }
    function at() {
      var vt = n.indexOf(Me);
      return vt >= 0 && n.splice(vt, 1), vt = s.indexOf(Mt), vt >= 0 && s.splice(vt, 1), et;
    }
    return ye();
  }
  function m() {
    return i;
  }
  function w() {
    return t;
  }
  function C(et) {
    var E = [], Z = 0, yt = d(et || []);
    for (Z = 0; Z < i; Z++)
      r.zeroExceptMask(Z, yt) && E.push(t[Z]);
    return E;
  }
  function F(et) {
    if (typeof et != "function") {
      console.warn("onChange callback parameter must be a function!");
      return;
    }
    return o.push(et), function() {
      o.splice(o.indexOf(et), 1);
    };
  }
  function W(et) {
    for (var E = 0; E < o.length; E++)
      o[E](et);
  }
  return arguments.length ? c(arguments[0]) : e;
}
function gl(e, t) {
  return (t < 257 ? yc.array8 : t < 65537 ? yc.array16 : yc.array32)(e);
}
function f_(e) {
  for (var t = gl(e, e), i = -1; ++i < e; )
    t[i] = i;
  return t;
}
function tA(e) {
  return e === 8 ? 256 : e === 16 ? 65536 : 4294967296;
}
let jU = class {
  constructor(t, i, r) {
    this._crossfilter = t, this._selfRemove = i, this._syncUp = r;
  }
  setAccessor(t) {
    const { _crossfilter: i } = this;
    this.dispose(), this._dimension = i.dimension(t);
  }
  applyFilter(t) {
    var i, r;
    (i = this._dimension) === null || i === void 0 || i.filter(t), (r = this._syncUp) === null || r === void 0 || r.call(this);
  }
  clear() {
    var t, i;
    (t = this._dimension) === null || t === void 0 || t.filterAll(), (i = this._syncUp) === null || i === void 0 || i.call(this);
  }
  getAllValues() {
    const { _crossfilter: t, _dimension: i } = this;
    if (i)
      return t.all().map(i.accessor);
  }
  getFilteredValues() {
    const { _crossfilter: t, _dimension: i } = this;
    if (i)
      return t.allFiltered().map(i.accessor);
  }
  getFilteredRecords() {
    return this._crossfilter.allFiltered([this._dimension]);
  }
  isActive() {
    var t;
    return ((t = this._dimension) === null || t === void 0 ? void 0 : t.hasCurrentFilter()) || !1;
  }
  dispose() {
    var t;
    (t = this._dimension) === null || t === void 0 || t.dispose();
  }
  remove() {
    this.dispose(), this._selfRemove();
  }
};
class eA {
  constructor(t) {
    this._crossfilter = bp(), this._filters = /* @__PURE__ */ new Set(), this._syncUpFunction = t, this._crossfilter.onChange((i) => {
      var r, n, s;
      switch (i) {
        case "filtered":
          (r = this.onFiltered) === null || r === void 0 || r.call(this), this._filters.forEach((a) => {
            var o;
            (o = a.onFiltered) === null || o === void 0 || o.call(a);
          });
          break;
        case "dataAdded":
          (n = this.onDataAdded) === null || n === void 0 || n.call(this), this._filters.forEach((a) => {
            var o;
            (o = a.onDataAdded) === null || o === void 0 || o.call(a);
          });
          break;
        case "dataRemoved":
          (s = this.onDataRemoved) === null || s === void 0 || s.call(this), this._filters.forEach((a) => {
            var o;
            (o = a.onDataRemoved) === null || o === void 0 || o.call(a);
          });
      }
    });
  }
  addRecords(t) {
    const { _crossfilter: i } = this;
    this._records = t, i.remove(), i.add(t);
  }
  getFilteredRecords(t) {
    const { _crossfilter: i } = this;
    return (t == null ? void 0 : t.getFilteredRecords()) || i.allFiltered();
  }
  addFilter(t = !0) {
    const i = new jU(this._crossfilter, () => {
      this._filters.delete(i);
    }, t ? this._syncUpFunction : void 0);
    return this._filters.add(i), i;
  }
  clearFilters() {
    this._filters.forEach((t) => {
      t.clear();
    });
  }
  isAnyFiltersActive(t) {
    for (const i of this._filters.values())
      if (i !== t && i.isActive())
        return !0;
    return !1;
  }
  getAllRecords() {
    return this._records;
  }
}
class GU {
  constructor(t, i) {
    var r;
    this._data = { nodes: [], links: [] }, this._previousData = { nodes: [], links: [] }, this._cosmographConfig = {}, this._cosmosConfig = {}, this._nodesForTopLabels = /* @__PURE__ */ new Set(), this._nodesForForcedLabels = /* @__PURE__ */ new Set(), this._trackedNodeToLabel = /* @__PURE__ */ new Map(), this._isLabelsDestroyed = !1, this._svgParser = new DOMParser(), this._nodesCrossfilter = new eA(this._applyLinksFilter.bind(this)), this._linksCrossfilter = new eA(this._applyNodesFilter.bind(this)), this._nodesFilter = this._nodesCrossfilter.addFilter(!1), this._linksFilter = this._linksCrossfilter.addFilter(!1), this._selectedNodesFilter = this._nodesCrossfilter.addFilter(), this._isDataDifferent = () => {
      const s = JSON.stringify(this._data.nodes), a = JSON.stringify(this._previousData.nodes), o = JSON.stringify(this._data.links), c = JSON.stringify(this._previousData.links);
      return s !== a || o !== c;
    }, this._onClick = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onClick) === null || o === void 0 || o.call(a, ...s);
    }, this._onLabelClick = (s, a) => {
      var o, c, l;
      const d = (o = this._cosmos) === null || o === void 0 ? void 0 : o.graph.getNodeById(a.id);
      d && ((l = (c = this._cosmographConfig).onLabelClick) === null || l === void 0 || l.call(c, d, s));
    }, this._onHoveredNodeClick = (s) => {
      var a, o;
      this._hoveredNode && ((o = (a = this._cosmographConfig).onLabelClick) === null || o === void 0 || o.call(a, this._hoveredNode, s));
    }, this._onNodeMouseOver = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onNodeMouseOver) === null || o === void 0 || o.call(a, ...s);
      const [c, , l] = s;
      this._hoveredNode = c, this._renderLabelForHovered(c, l);
    }, this._onNodeMouseOut = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onNodeMouseOut) === null || o === void 0 || o.call(a, ...s), this._renderLabelForHovered();
    }, this._onMouseMove = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onMouseMove) === null || o === void 0 || o.call(a, ...s);
      const [c, , l] = s;
      this._renderLabelForHovered(c, l);
    }, this._onZoomStart = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onZoomStart) === null || o === void 0 || o.call(a, ...s);
    }, this._onZoom = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onZoom) === null || o === void 0 || o.call(a, ...s), this._renderLabelForHovered(), this._renderLabels();
    }, this._onZoomEnd = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onZoomEnd) === null || o === void 0 || o.call(a, ...s);
    }, this._onStart = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onSimulationStart) === null || o === void 0 || o.call(a, ...s);
    }, this._onTick = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onSimulationTick) === null || o === void 0 || o.call(a, ...s), this._renderLabels();
    }, this._onEnd = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onSimulationEnd) === null || o === void 0 || o.call(a, ...s);
    }, this._onPause = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onSimulationPause) === null || o === void 0 || o.call(a, ...s);
    }, this._onRestart = (...s) => {
      var a, o;
      (o = (a = this._cosmographConfig).onSimulationRestart) === null || o === void 0 || o.call(a, ...s);
    }, this._containerNode = t, this._containerNode.classList.add(Gh.cosmograph), this._cosmographConfig = K_(KI, i ?? {}), this._cosmosConfig = this._createCosmosConfig(i), this._canvasElement = document.createElement("canvas"), this._labelsDivElement = document.createElement("div"), this._watermarkDivElement = document.createElement("div"), this._watermarkDivElement.classList.add(Gh.watermark), this._watermarkDivElement.onclick = () => {
      var s;
      return (s = window.open("https://cosmograph.app/", "_blank")) === null || s === void 0 ? void 0 : s.focus();
    }, t.appendChild(this._canvasElement), t.appendChild(this._labelsDivElement), t.appendChild(this._watermarkDivElement), this._cssLabelsRenderer = new O7(this._labelsDivElement, { dispatchWheelEventElement: this._canvasElement, pointerEvents: "all", onLabelClick: this._onLabelClick.bind(this) }), this._hoveredCssLabel = new UT(this._labelsDivElement), this._hoveredCssLabel.setPointerEvents("all"), this._hoveredCssLabel.element.addEventListener("click", this._onHoveredNodeClick.bind(this)), this._linksFilter.setAccessor((s) => [s.source, s.target]), this._nodesFilter.setAccessor((s) => s.id), this._selectedNodesFilter.setAccessor((s) => s.id), this._nodesCrossfilter.onFiltered = () => {
      var s, a, o, c;
      let l;
      this._nodesCrossfilter.isAnyFiltersActive() ? (l = this._nodesCrossfilter.getFilteredRecords(), (s = this._cosmos) === null || s === void 0 || s.selectNodesByIds(l.map((d) => d.id))) : (a = this._cosmos) === null || a === void 0 || a.unselectNodes(), this._updateSelectedNodesSet(l), (c = (o = this._cosmographConfig).onNodesFiltered) === null || c === void 0 || c.call(o, l);
    }, this._linksCrossfilter.onFiltered = () => {
      var s, a;
      let o;
      this._linksCrossfilter.isAnyFiltersActive() && (o = this._linksCrossfilter.getFilteredRecords()), (a = (s = this._cosmographConfig).onLinksFiltered) === null || a === void 0 || a.call(s, o);
    };
    const n = this._svgParser.parseFromString(W$, "image/svg+xml").firstChild;
    (r = this._watermarkDivElement) === null || r === void 0 || r.appendChild(n);
  }
  get data() {
    return this._data;
  }
  get progress() {
    var t;
    return (t = this._cosmos) === null || t === void 0 ? void 0 : t.progress;
  }
  get isSimulationRunning() {
    var t;
    return (t = this._cosmos) === null || t === void 0 ? void 0 : t.isSimulationRunning;
  }
  get maxPointSize() {
    var t;
    return (t = this._cosmos) === null || t === void 0 ? void 0 : t.maxPointSize;
  }
  setData(t, i) {
    var r, n, s, a;
    const { _cosmographConfig: o } = this;
    this._data = { nodes: t, links: i };
    const c = o.disableSimulation === null ? !i.length : o.disableSimulation;
    this._cosmos || (this._disableSimulation = c, this._cosmosConfig.disableSimulation = this._disableSimulation, this._cosmos = new T7(this._canvasElement, this._cosmosConfig), this.cosmos = this._cosmos), this._disableSimulation !== c && console.warn(`The \`disableSimulation\` was initialized to \`${this._disableSimulation}\` during initialization and will not be modified.`), this._cosmos.setData(t, i), this._nodesCrossfilter.addRecords(t), this._linksCrossfilter.addRecords(i), this._updateLabels(), (n = (r = this._cosmographConfig).onSetData) === null || n === void 0 || n.call(r, t, i), this._isDataDifferent() && (["cosmograph.app"].includes(window.location.hostname) || CU({ browser: navigator.userAgent, hostname: window.location.hostname, mode: null, is_library_metric: !0, links_count: i.length, links_have_time: null, links_raw_columns: i.length && (s = Object.keys(i == null ? void 0 : i[0]).length) !== null && s !== void 0 ? s : 0, links_raw_lines: null, nodes_count: t.length, nodes_have_time: null, nodes_raw_columns: t.length && (a = Object.keys(t == null ? void 0 : t[0]).length) !== null && a !== void 0 ? a : 0, nodes_raw_lines: null })), this._previousData = { nodes: t, links: i };
  }
  setConfig(t) {
    var i, r;
    if (this._cosmographConfig = K_(KI, t ?? {}), this._cosmosConfig = this._createCosmosConfig(t), (i = this._cosmos) === null || i === void 0 || i.setConfig(this._cosmosConfig), t == null ? void 0 : t.backgroundColor) {
      const n = (r = So(t == null ? void 0 : t.backgroundColor)) === null || r === void 0 ? void 0 : r.formatHex();
      if (n) {
        const s = this._checkBrightness(n), a = document.querySelector(":root");
        s > 0.65 ? a == null || a.style.setProperty("--cosmograph-watermark-color", "#000000") : a == null || a.style.setProperty("--cosmograph-watermark-color", "#ffffff");
      }
    }
    this._updateLabels();
  }
  addNodesFilter() {
    return this._nodesCrossfilter.addFilter();
  }
  addLinksFilter() {
    return this._linksCrossfilter.addFilter();
  }
  selectNodesInRange(t) {
    var i;
    if (!this._cosmos)
      return;
    this._cosmos.selectNodesInRange(t);
    const r = new Set(((i = this.getSelectedNodes()) !== null && i !== void 0 ? i : []).map((n) => n.id));
    this._selectedNodesFilter.applyFilter((n) => r.has(n));
  }
  selectNodes(t) {
    if (!this._cosmos)
      return;
    const i = new Set(t.map((r) => r.id));
    this._selectedNodesFilter.applyFilter((r) => i.has(r));
  }
  selectNode(t, i = !1) {
    if (!this._cosmos)
      return;
    const r = new Set([t, ...i && this._cosmos.getAdjacentNodes(t.id) || []].map((n) => n.id));
    this._selectedNodesFilter.applyFilter((n) => r.has(n));
  }
  unselectNodes() {
    this._cosmos && this._selectedNodesFilter.clear();
  }
  getSelectedNodes() {
    if (this._cosmos)
      return this._cosmos.getSelectedNodes();
  }
  zoomToNode(t) {
    this._cosmos && this._cosmos.zoomToNodeById(t.id);
  }
  setZoomLevel(t, i = 0) {
    this._cosmos && this._cosmos.setZoomLevel(t, i);
  }
  getZoomLevel() {
    if (this._cosmos)
      return this._cosmos.getZoomLevel();
  }
  getNodePositions() {
    if (this._cosmos)
      return this._cosmos.getNodePositions();
  }
  getNodePositionsMap() {
    if (this._cosmos)
      return this._cosmos.getNodePositionsMap();
  }
  getNodePositionsArray() {
    if (this._cosmos)
      return this._cosmos.getNodePositionsArray();
  }
  fitView(t = 250) {
    this._cosmos && this._cosmos.fitView(t);
  }
  fitViewByNodeIds(t, i = 250) {
    this._cosmos && this._cosmos.fitViewByNodeIds(t, i);
  }
  focusNode(t) {
    this._cosmos && this._cosmos.setFocusedNodeById(t == null ? void 0 : t.id);
  }
  getAdjacentNodes(t) {
    if (this._cosmos)
      return this._cosmos.getAdjacentNodes(t);
  }
  spaceToScreenPosition(t) {
    if (this._cosmos)
      return this._cosmos.spaceToScreenPosition(t);
  }
  spaceToScreenRadius(t) {
    if (this._cosmos)
      return this._cosmos.spaceToScreenRadius(t);
  }
  getNodeRadiusByIndex(t) {
    if (this._cosmos)
      return this._cosmos.getNodeRadiusByIndex(t);
  }
  getNodeRadiusById(t) {
    if (this._cosmos)
      return this._cosmos.getNodeRadiusById(t);
  }
  getSampledNodePositionsMap() {
    if (this._cosmos)
      return this._cosmos.getSampledNodePositionsMap();
  }
  start(t = 1) {
    this._cosmos && this._cosmos.start(t);
  }
  pause() {
    this._cosmos && this._cosmos.pause();
  }
  restart() {
    this._cosmos && this._cosmos.restart();
  }
  step() {
    this._cosmos && this._cosmos.step();
  }
  remove() {
    var t;
    (t = this._cosmos) === null || t === void 0 || t.destroy(), this._isLabelsDestroyed || (this._containerNode.innerHTML = "", this._isLabelsDestroyed = !0, this._hoveredCssLabel.element.removeEventListener("click", this._onHoveredNodeClick.bind(this)), this._hoveredCssLabel.destroy(), this._cssLabelsRenderer.destroy());
  }
  create() {
    this._cosmos && this._cosmos.create();
  }
  getNodeDegrees() {
    if (this._cosmos)
      return this._cosmos.graph.degree;
  }
  _createCosmosConfig(t) {
    const i = { ...t, simulation: { ...Object.keys(t ?? {}).filter((r) => r.indexOf("simulation") !== -1).reduce((r, n) => {
      const s = n.replace("simulation", "");
      return r[s.charAt(0).toLowerCase() + s.slice(1)] = t == null ? void 0 : t[n], r;
    }, {}), onStart: this._onStart.bind(this), onTick: this._onTick.bind(this), onEnd: this._onEnd.bind(this), onPause: this._onPause.bind(this), onRestart: this._onRestart.bind(this) }, events: { onClick: this._onClick.bind(this), onNodeMouseOver: this._onNodeMouseOver.bind(this), onNodeMouseOut: this._onNodeMouseOut.bind(this), onMouseMove: this._onMouseMove.bind(this), onZoomStart: this._onZoomStart.bind(this), onZoom: this._onZoom.bind(this), onZoomEnd: this._onZoomEnd.bind(this) } };
    return delete i.disableSimulation, i;
  }
  _updateLabels() {
    if (this._isLabelsDestroyed || !this._cosmos)
      return;
    const { _cosmos: t, data: { nodes: i }, _cosmographConfig: { showTopLabels: r, showTopLabelsLimit: n, showLabelsFor: s, showTopLabelsValueKey: a, nodeLabelAccessor: o } } = this;
    if (this._nodesForTopLabels.clear(), r && n) {
      let c;
      c = a ? [...i].sort((l, d) => {
        const u = l[a], h = d[a];
        return typeof u == "number" && typeof h == "number" ? h - u : 0;
      }) : Object.entries(t.graph.degree).sort((l, d) => d[1] - l[1]).slice(0, n).map((l) => t.graph.getNodeByIndex(+l[0]));
      for (let l = 0; l < n && !(l >= i.length); l++) {
        const d = c[l];
        d && this._nodesForTopLabels.add(d);
      }
    }
    this._nodesForForcedLabels.clear(), s == null || s.forEach(this._nodesForForcedLabels.add, this._nodesForForcedLabels), this._trackedNodeToLabel.clear(), t.trackNodePositionsByIds([...r ? this._nodesForTopLabels : [], ...this._nodesForForcedLabels].map((c) => {
      var l;
      return this._trackedNodeToLabel.set(c, (l = o == null ? void 0 : o(c)) !== null && l !== void 0 ? l : c.id), c.id;
    })), this._renderLabels();
  }
  _updateSelectedNodesSet(t) {
    this._isLabelsDestroyed || (t ? (this._selectedNodesSet = /* @__PURE__ */ new Set(), t == null || t.forEach(this._selectedNodesSet.add, this._selectedNodesSet)) : this._selectedNodesSet = void 0, this._renderLabels());
  }
  _renderLabels() {
    if (this._isLabelsDestroyed || !this._cosmos)
      return;
    const { _cosmos: t, _selectedNodesSet: i, _cosmographConfig: { showDynamicLabels: r, nodeLabelAccessor: n, nodeLabelColor: s, nodeLabelClassName: a } } = this;
    let o = [];
    const c = t.getTrackedNodePositionsMap(), l = /* @__PURE__ */ new Map();
    if (r) {
      const d = this.getSampledNodePositionsMap();
      d == null || d.forEach((u, h) => {
        var p;
        const m = t.graph.getNodeById(h);
        m && l.set(m, [(p = n == null ? void 0 : n(m)) !== null && p !== void 0 ? p : m.id, u, Gh.cosmographShowDynamicLabels, 0.7]);
      });
    }
    this._nodesForTopLabels.forEach((d) => {
      l.set(d, [this._trackedNodeToLabel.get(d), c.get(d.id), Gh.cosmographShowTopLabels, 0.9]);
    }), this._nodesForForcedLabels.forEach((d) => {
      l.set(d, [this._trackedNodeToLabel.get(d), c.get(d.id), Gh.cosmographShowLabelsFor, 1]);
    }), o = [...l.entries()].map(([d, [u, h, p, m]]) => {
      var w, C, F;
      const W = this.spaceToScreenPosition([(w = h == null ? void 0 : h[0]) !== null && w !== void 0 ? w : 0, (C = h == null ? void 0 : h[1]) !== null && C !== void 0 ? C : 0]), et = this.spaceToScreenRadius(t.config.nodeSizeScale * this.getNodeRadiusById(d.id)), E = !!i, Z = i == null ? void 0 : i.has(d);
      return { id: d.id, text: u ?? "", x: W[0], y: W[1] - (et + 2), weight: E && !Z ? 0.1 : m, shouldBeShown: this._nodesForForcedLabels.has(d), style: E && !Z ? "opacity: 0.1;" : "", color: s && (typeof s == "string" ? s : s == null ? void 0 : s(d)), className: (F = typeof a == "string" ? a : a == null ? void 0 : a(d)) !== null && F !== void 0 ? F : p };
    }), this._cssLabelsRenderer.setLabels(o), this._cssLabelsRenderer.draw(!0);
  }
  _renderLabelForHovered(t, i) {
    var r, n;
    if (!this._cosmos)
      return;
    const { _cosmographConfig: { showHoveredNodeLabel: s, nodeLabelAccessor: a, hoveredNodeLabelClassName: o, hoveredNodeLabelColor: c } } = this;
    if (!this._isLabelsDestroyed) {
      if (s && t && i) {
        const l = this.spaceToScreenPosition(i), d = this.spaceToScreenRadius(this.getNodeRadiusById(t.id));
        this._hoveredCssLabel.setText((r = a == null ? void 0 : a(t)) !== null && r !== void 0 ? r : t.id), this._hoveredCssLabel.setVisibility(!0), this._hoveredCssLabel.setPosition(l[0], l[1] - (d + 2)), this._hoveredCssLabel.setClassName(typeof o == "string" ? o : (n = o == null ? void 0 : o(t)) !== null && n !== void 0 ? n : "");
        const u = c && (typeof c == "string" ? c : c == null ? void 0 : c(t));
        u && this._hoveredCssLabel.setColor(u);
      } else
        this._hoveredCssLabel.setVisibility(!1);
      this._hoveredCssLabel.draw();
    }
  }
  _applyLinksFilter() {
    if (this._nodesCrossfilter.isAnyFiltersActive(this._nodesFilter)) {
      const t = this._nodesCrossfilter.getFilteredRecords(this._nodesFilter), i = new Set(t.map((r) => r.id));
      this._linksFilter.applyFilter((r) => {
        const n = r == null ? void 0 : r[0], s = r == null ? void 0 : r[1];
        return i.has(n) && i.has(s);
      });
    } else
      this._linksFilter.clear();
  }
  _applyNodesFilter() {
    if (this._linksCrossfilter.isAnyFiltersActive(this._linksFilter)) {
      const t = this._linksCrossfilter.getFilteredRecords(this._linksFilter), i = new Set(t.map((r) => [r.source, r.target]).flat());
      this._nodesFilter.applyFilter((r) => i.has(r));
    } else
      this._nodesFilter.clear();
  }
  _checkBrightness(t) {
    const i = ((r) => {
      const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(r);
      return n ? { r: parseInt((n[1] || 0).toString(), 16), g: parseInt((n[2] || 0).toString(), 16), b: parseInt((n[3] || 0).toString(), 16) } : { r: 0, g: 0, b: 0 };
    })(t);
    return (0.2126 * i.r + 0.7152 * i.g + 0.0722 * i.b) / 255;
  }
}
var Vg;
(function(e) {
  e.Nodes = "nodes", e.Links = "links";
})(Vg || (Vg = {}));
Vg.Links;
Vg.Nodes;
const Ei = Array.isArray;
function Un(e) {
  return e != null ? Ei(e) ? e : [e] : [];
}
function HU(e = 0, t = 1 / 0) {
  return `${iA(e)} < row_number() && row_number() <= ${iA(t)}`;
}
function iA(e) {
  return e < 0 ? `count() + ${e}` : e;
}
class mE {
  /**
   * Instantiate a new Transformable instance.
   * @param {Params} [params] The parameter values.
   */
  constructor(t) {
    t && (this._params = t);
  }
  /**
   * Get or set table expression parameter values.
   * If called with no arguments, returns the current parameter values
   * as an object. Otherwise, adds the provided parameters to this
   * table's parameter set and returns the table. Any prior parameters
   * with names matching the input parameters are overridden.
   * @param {Params} [values] The parameter values.
   * @return {this|Params} The current parameters values (if called with
   *  no arguments) or this table.
   */
  params(t) {
    return arguments.length ? (t && (this._params = { ...this._params, ...t }), this) : this._params;
  }
  /**
   * Create a new fully-materialized instance of this table.
   * All filter and orderby settings are removed from the new table.
   * Instead, the backing data itself is filtered and ordered as needed.
   * @param {number[]} [indices] Ordered row indices to materialize.
   *  If unspecified, all rows passing the table filter are used.
   * @return {this} A reified table.
   */
  reify(t) {
    return this.__reify(this, t);
  }
  // -- Transformation Verbs ------------------------------------------------
  /**
   * Count the number of values in a group. This method is a shorthand
   * for {@link Transformable#rollup} with a count aggregate function.
   * @param {CountOptions} [options] Options for the count.
   * @return {this} A new table with groupby and count columns.
   * @example table.groupby('colA').count()
   * @example table.groupby('colA').count({ as: 'num' })
   */
  count(t) {
    return this.__count(this, t);
  }
  /**
   * Derive new column values based on the provided expressions. By default,
   * new columns are added after (higher indices than) existing columns. Use
   * the before or after options to place new columns elsewhere.
   * @param {ExprObject} values Object of name-value pairs defining the
   *  columns to derive. The input object should have output column
   *  names for keys and table expressions for values.
   * @param {DeriveOptions} [options] Options for dropping or relocating
   *  derived columns. Use either a before or after property to indicate
   *  where to place derived columns. Specifying both before and after is an
   *  error. Unlike the relocate verb, this option affects only new columns;
   *  updated columns with existing names are excluded from relocation.
   * @return {this} A new table with derived columns added.
   * @example table.derive({ sumXY: d => d.x + d.y })
   * @example table.derive({ z: d => d.x * d.y }, { before: 'x' })
   */
  derive(t, i) {
    return this.__derive(this, t, i);
  }
  /**
   * Filter a table to a subset of rows based on the input criteria.
   * The resulting table provides a filtered view over the original data; no
   * data copy is made. To create a table that copies only filtered data to
   * new data structures, call {@link Transformable#reify} on the output table.
   * @param {TableExpr} criteria Filter criteria as a table expression.
   *  Both aggregate and window functions are permitted, taking into account
   *  {@link Transformable#groupby} or {@link Transformable#orderby} settings.
   * @return {this} A new table with filtered rows.
   * @example table.filter(d => abs(d.value) < 5)
   */
  filter(t) {
    return this.__filter(this, t);
  }
  /**
   * Extract rows with indices from start to end (end not included), where
   * start and end represent per-group ordered row numbers in the table.
   * @param {number} [start] Zero-based index at which to start extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If start is undefined, slice starts from the index 0.
   * @param {number} [end] Zero-based index before which to end extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If end is omitted, slice extracts through the end of the group.
   * @return {this} A new table with sliced rows.
   * @example table.slice(1, -1)
   */
  slice(t, i) {
    return this.filter(HU(t, i)).reify();
  }
  /**
   * Group table rows based on a set of column values.
   * Subsequent operations that are sensitive to grouping (such as
   * aggregate functions) will operate over the grouped rows.
   * To undo grouping, use {@link Transformable#ungroup}.
   * @param  {...ExprList} keys Key column values to group by.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @return {this} A new table with grouped rows.
   * @example table.groupby('colA', 'colB')
   * @example table.groupby({ key: d => d.colA + d.colB })
   */
  groupby(...t) {
    return this.__groupby(this, t.flat());
  }
  /**
   * Order table rows based on a set of column values.
   * Subsequent operations sensitive to ordering (such as window functions)
   * will operate over sorted values.
   * The resulting table provides an view over the original data, without
   * any copying. To create a table with sorted data copied to new data
   * strucures, call {@link Transformable#reify} on the result of this method.
   * To undo ordering, use {@link Transformable#unorder}.
   * @param  {...OrderKeys} keys Key values to sort by, in precedence order.
   *  By default, sorting is done in ascending order.
   *  To sort in descending order, wrap values using {@link desc}.
   *  If a string, order by the column with that name.
   *  If a number, order by the column with that index.
   *  If a function, must be a valid table expression; aggregate functions
   *  are permitted, but window functions are not.
   *  If an object, object values must be valid values parameters
   *  with output column names for keys and table expressions
   *  for values (the output names will be ignored).
   *  If an array, array values must be valid key parameters.
   * @return {this} A new ordered table.
   * @example table.orderby('a', desc('b'))
   * @example table.orderby({ a: 'a', b: desc('b') )})
   * @example table.orderby(desc(d => d.a))
   */
  orderby(...t) {
    return this.__orderby(this, t.flat());
  }
  /**
   * Relocate a subset of columns to change their positions, also
   * potentially renaming them.
   * @param {Selection} columns An ordered selection of columns to relocate.
   *  The input may consist of column name strings, column integer indices,
   *  rename objects with current column names as keys and new column names
   *  as values, or functions that take a table as input and returns a valid
   *  selection parameter (typically the output of selection helper functions
   *  such as {@link all}, {@link not}, or {@link range}).
   * @param {RelocateOptions} options Options for relocating. Must include
   *  either the before or after property to indicate where to place the
   *  relocated columns. Specifying both before and after is an error.
   * @return {this} A new table with relocated columns.
   * @example table.relocate(['colY', 'colZ'], { after: 'colX' })
   * @example table.relocate(not('colB', 'colC'), { before: 'colA' })
   * @example table.relocate({ colA: 'newA', colB: 'newB' }, { after: 'colC' })
   */
  relocate(t, i) {
    return this.__relocate(this, Un(t), i);
  }
  /**
   * Rename one or more columns, preserving column order.
   * @param {...Select} columns One or more rename objects with current
   *  column names as keys and new column names as values.
   * @return {this} A new table with renamed columns.
   * @example table.rename({ oldName: 'newName' })
   * @example table.rename({ a: 'a2', b: 'b2' })
   */
  rename(...t) {
    return this.__rename(this, t.flat());
  }
  /**
   * Rollup a table to produce an aggregate summary.
   * Often used in conjunction with {@link Transformable#groupby}.
   * To produce counts only, {@link Transformable#count} is a shortcut.
   * @param {ExprObject} [values] Object of name-value pairs defining aggregate
   *  output columns. The input object should have output column names for
   *  keys and table expressions for values. The expressions must be valid
   *  aggregate expressions: window functions are not allowed and column
   *  references must be arguments to aggregate functions.
   * @return {this} A new table of aggregate summary values.
   * @example table.groupby('colA').rollup({ mean: d => mean(d.colB) })
   * @example table.groupby('colA').rollup({ mean: op.median('colB') })
   */
  rollup(t) {
    return this.__rollup(this, t);
  }
  /**
   * Generate a table from a random sample of rows.
   * If the table is grouped, performs a stratified sample by
   * sampling from each group separately.
   * @param {number|TableExpr} size The number of samples to draw per group.
   *  If number-valued, the same sample size is used for each group.
   *  If function-valued, the input should be an aggregate table
   *  expression compatible with {@link Transformable#rollup}.
   * @param {SampleOptions} [options] Options for sampling.
   * @return {this} A new table with sampled rows.
   * @example table.sample(50)
   * @example table.sample(100, { replace: true })
   * @example table.groupby('colA').sample(() => op.floor(0.5 * op.count()))
   */
  sample(t, i) {
    return this.__sample(this, t, i);
  }
  /**
   * Select a subset of columns into a new table, potentially renaming them.
   * @param {...Select} columns An ordered selection of columns.
   *  The input may consist of column name strings, column integer indices,
   *  rename objects with current column names as keys and new column names
   *  as values, or functions that take a table as input and returns a valid
   *  selection parameter (typically the output of selection helper functions
   *  such as {@link all}, {@link not}, or {@link range}).
   * @return {this} A new table of selected columns.
   * @example table.select('colA', 'colB')
   * @example table.select(not('colB', 'colC'))
   * @example table.select({ colA: 'newA', colB: 'newB' })
   */
  select(...t) {
    return this.__select(this, t.flat());
  }
  /**
   * Ungroup a table, removing any grouping criteria.
   * Undoes the effects of {@link Transformable#groupby}.
   * @return {this} A new ungrouped table, or this table if not grouped.
   * @example table.ungroup()
   */
  ungroup() {
    return this.__ungroup(this);
  }
  /**
   * Unorder a table, removing any sorting criteria.
   * Undoes the effects of {@link Transformable#orderby}.
   * @return {this} A new unordered table, or this table if not ordered.
   * @example table.unorder()
   */
  unorder() {
    return this.__unorder(this);
  }
  // -- Cleaning Verbs ------------------------------------------------------
  /**
   * De-duplicate table rows by removing repeated row values.
   * @param {...ExprList} keys Key columns to check for duplicates.
   *  Two rows are considered duplicates if they have matching values for
   *  all keys. If keys are unspecified, all columns are used.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @return {this} A new de-duplicated table.
   * @example table.dedupe()
   * @example table.dedupe('a', 'b')
   * @example table.dedupe({ abs: d => op.abs(d.a) })
   */
  dedupe(...t) {
    return this.__dedupe(this, t.flat());
  }
  /**
   * Impute missing values or rows. Accepts a set of column-expression pairs
   * and evaluates the expressions to replace any missing (null, undefined,
   * or NaN) values in the original column.
   * If the expand option is specified, imputes new rows for missing
   * combinations of values. All combinations of key values (a full cross
   * product) are considered for each level of grouping (specified by
   * {@link Transformable#groupby}). New rows will be added for any combination
   * of key and groupby values not already contained in the table. For all
   * non-key and non-group columns the new rows are populated with imputation
   * values (first argument) if specified, otherwise undefined.
   * If the expand option is specified, any filter or orderby settings are
   * removed from the output table, but groupby settings persist.
   * @param {ExprObject} values Object of name-value pairs for the column values
   *  to impute. The input object should have existing column names for keys
   *  and table expressions for values. The expressions will be evaluated to
   *  determine replacements for any missing values.
   * @param {ImputeOptions} [options] Imputation options. The expand
   *  property specifies a set of column values to consider for imputing
   *  missing rows. All combinations of expanded values are considered, and
   *  new rows are added for each combination that does not appear in the
   *  input table.
   * @return {this} A new table with imputed values and/or rows.
   * @example table.impute({ v: () => 0 })
   * @example table.impute({ v: d => op.mean(d.v) })
   * @example table.impute({ v: () => 0 }, { expand: ['x', 'y'] })
   */
  impute(t, i) {
    return this.__impute(this, t, i);
  }
  // -- Reshaping Verbs -----------------------------------------------------
  /**
   * Fold one or more columns into two key-value pair columns.
   * The fold transform is an inverse of the {@link Transformable#pivot} transform.
   * The resulting table has two new columns, one containing the column
   * names (named "key") and the other the column values (named "value").
   * The number of output rows equals the original row count multiplied
   * by the number of folded columns.
   * @param {ExprList} values The columns to fold.
   *  The columns may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {FoldOptions} [options] Options for folding.
   * @return {this} A new folded table.
   * @example table.fold('colA')
   * @example table.fold(['colA', 'colB'])
   * @example table.fold(range(5, 8))
   */
  fold(t, i) {
    return this.__fold(this, t, i);
  }
  /**
   * Pivot columns into a cross-tabulation.
   * The pivot transform is an inverse of the {@link Transformable#fold} transform.
   * The resulting table has new columns for each unique combination
   * of the provided *keys*, populated with the provided *values*.
   * The provided *values* must be aggregates, as a single set of keys may
   * include more than one row. If string-valued, the *any* aggregate is used.
   * If only one *values* column is defined, the new pivoted columns will
   * be named using key values directly. Otherwise, input value column names
   * will be included as a component of the output column names.
   * @param {ExprList} keys Key values to map to new column names.
   *  The keys may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {ExprList} values Output values for pivoted columns.
   *  Column references will be wrapped in an *any* aggregate.
   *  If object-valued, the input object should have output value
   *  names for keys and aggregate table expressions for values.
   * @param {PivotOptions} [options] Options for pivoting.
   * @return {this} A new pivoted table.
   * @example table.pivot('key', 'value')
   * @example table.pivot(['keyA', 'keyB'], ['valueA', 'valueB'])
   * @example table.pivot({ key: d => d.key }, { value: d => sum(d.value) })
   */
  pivot(t, i, r) {
    return this.__pivot(this, t, i, r);
  }
  /**
   * Spread array elements into a set of new columns.
   * Output columns are named based on the value key and array index.
   * @param {ExprList} values The column values to spread.
   *  The values may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {SpreadOptions} [options] Options for spreading.
   * @return {this} A new table with the spread columns added.
   * @example table.spread({ a: split(d.text, '') })
   * @example table.spread('arrayCol', { limit: 100 })
   */
  spread(t, i) {
    return this.__spread(this, t, i);
  }
  /**
   * Unroll one or more array-valued columns into new rows.
   * If more than one array value is used, the number of new rows
   * is the smaller of the limit and the largest length.
   * Values for all other columns are copied over.
   * @param {ExprList} values The column values to unroll.
   *  The values may be specified using column name strings, column index
   *  numbers, value objects with output column names for keys and table
   *  expressions for values, or selection helper functions.
   * @param {UnrollOptions} [options] Options for unrolling.
   * @return {this} A new unrolled table.
   * @example table.unroll('colA', { limit: 1000 })
   */
  unroll(t, i) {
    return this.__unroll(this, t, i);
  }
  // -- Joins ---------------------------------------------------------------
  /**
   * Lookup values from a secondary table and add them as new columns.
   * A lookup occurs upon matching key values for rows in both tables.
   * If the secondary table has multiple rows with the same key, only
   * the last observed instance will be considered in the lookup.
   * Lookup is similar to {@link Transformable#join_left}, but with a simpler
   * syntax and the added constraint of allowing at most one match only.
   * @param {TableRef} other The secondary table to look up values from.
   * @param {JoinKeys} [on] Lookup keys (column name strings or table
   *  expressions) for this table and the secondary table, respectively.
   * @param {...ExprList} values The column values to add from the
   *  secondary table. Can be column name strings or objects with column
   *  names as keys and table expressions as values.
   * @return {this} A new table with lookup values added.
   * @example table.lookup(other, ['key1', 'key2'], 'value1', 'value2')
   */
  lookup(t, i, ...r) {
    return this.__lookup(this, t, i, r.flat());
  }
  /**
   * Join two tables, extending the columns of one table with
   * values from the other table. The current table is considered
   * the "left" table in the join, and the new table input is
   * considered the "right" table in the join. By default an inner
   * join is performed, removing all rows that do not match the
   * join criteria. To perform left, right, or full outer joins, use
   * the {@link Transformable#join_left}, {@link Transformable#join_right}, or
   * {@link Transformable#join_full} methods, or provide an options argument.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join.
   * @return {this} A new joined table.
   * @example table.join(other, ['keyL', 'keyR'])
   * @example table.join(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join(t, i, r, n) {
    return this.__join(this, t, i, r, n);
  }
  /**
   * Perform a left outer join on two tables. Rows in the left table
   * that do not match a row in the right table will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: true, right: false}.
   * @return {this} A new joined table.
   * @example table.join_left(other, ['keyL', 'keyR'])
   * @example table.join_left(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_left(t, i, r, n) {
    const s = { ...n, left: !0, right: !1 };
    return this.__join(this, t, i, r, s);
  }
  /**
   * Perform a right outer join on two tables. Rows in the right table
   * that do not match a row in the left table will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: false, right: true}.
   * @return {this} A new joined table.
   * @example table.join_right(other, ['keyL', 'keyR'])
   * @example table.join_right(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_right(t, i, r, n) {
    const s = { ...n, left: !1, right: !0 };
    return this.__join(this, t, i, r, s);
  }
  /**
   * Perform a full outer join on two tables. Rows in either the left or
   * right table that do not match a row in the other will be preserved.
   * This is a convenience method with fixed options for {@link Transformable#join}.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @param {JoinValues} [values] The columns to include in the join output.
   *  If unspecified, all columns from both tables are included; paired
   *  join keys sharing the same column name are included only once.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join. With this method,
   *  any options will be overridden with {left: true, right: true}.
   * @return {this} A new joined table.
   * @example table.join_full(other, ['keyL', 'keyR'])
   * @example table.join_full(other, (a, b) => equal(a.keyL, b.keyR))
   */
  join_full(t, i, r, n) {
    const s = { ...n, left: !0, right: !0 };
    return this.__join(this, t, i, r, s);
  }
  /**
   * Produce the Cartesian cross product of two tables. The output table
   * has one row for every pair of input table rows. Beware that outputs
   * may be quite large, as the number of output rows is the product of
   * the input row counts.
   * This is a convenience method for {@link Transformable#join} in which the
   * join criteria is always true.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinValues} [values] The columns to include in the output.
   *  If unspecified, all columns from both tables are included.
   *  If array-valued, a two element array should be provided, containing
   *  the columns to include for the left and right tables, respectively.
   *  Array input may consist of column name strings, objects with output
   *  names as keys and single-table table expressions as values, or the
   *  selection helper functions {@link all}, {@link not}, or {@link range}.
   *  If object-valued, specifies the key-value pairs for each output,
   *  defined using two-table table expressions.
   * @param {JoinOptions} [options] Options for the join.
   * @return {this} A new joined table.
   * @example table.cross(other)
   * @example table.cross(other, [['leftKey', 'leftVal'], ['rightVal']])
   */
  cross(t, i, r) {
    return this.__cross(this, t, i, r);
  }
  /**
   * Perform a semi-join, filtering the left table to only rows that
   * match a row in the right table.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @return {this} A new filtered table.
   * @example table.semijoin(other)
   * @example table.semijoin(other, ['keyL', 'keyR'])
   * @example table.semijoin(other, (a, b) => equal(a.keyL, b.keyR))
   */
  semijoin(t, i) {
    return this.__semijoin(this, t, i);
  }
  /**
   * Perform an anti-join, filtering the left table to only rows that
   * do *not* match a row in the right table.
   * @param {TableRef} other The other (right) table to join with.
   * @param {JoinPredicate} [on] The join criteria for matching table rows.
   *  If unspecified, the values of all columns with matching names
   *  are compared.
   *  If array-valued, a two-element array should be provided, containing
   *  the columns to compare for the left and right tables, respectively.
   *  If a one-element array or a string value is provided, the same
   *  column names will be drawn from both tables.
   *  If function-valued, should be a two-table table expression that
   *  returns a boolean value. When providing a custom predicate, note that
   *  join key values can be arrays or objects, and that normal join
   *  semantics do not consider null or undefined values to be equal (that is,
   *  null !== null). Use the op.equal function to handle these cases.
   * @return {this} A new filtered table.
   * @example table.antijoin(other)
   * @example table.antijoin(other, ['keyL', 'keyR'])
   * @example table.antijoin(other, (a, b) => equal(a.keyL, b.keyR))
   */
  antijoin(t, i) {
    return this.__antijoin(this, t, i);
  }
  // -- Set Operations ------------------------------------------------------
  /**
   * Concatenate multiple tables into a single table, preserving all rows.
   * This transformation mirrors the UNION_ALL operation in SQL.
   * Only named columns in this table are included in the output.
   * @see Transformable#union
   * @param  {...TableRef} tables A list of tables to concatenate.
   * @return {this} A new concatenated table.
   * @example table.concat(other)
   * @example table.concat(other1, other2)
   * @example table.concat([other1, other2])
   */
  concat(...t) {
    return this.__concat(this, t.flat());
  }
  /**
   * Union multiple tables into a single table, deduplicating all rows.
   * This transformation mirrors the UNION operation in SQL. It is
   * similar to {@link Transformable#concat} but suppresses duplicate rows with
   * values identical to another row.
   * Only named columns in this table are included in the output.
   * @see Transformable#concat
   * @param  {...TableRef} tables A list of tables to union.
   * @return {this} A new unioned table.
   * @example table.union(other)
   * @example table.union(other1, other2)
   * @example table.union([other1, other2])
   */
  union(...t) {
    return this.__union(this, t.flat());
  }
  /**
   * Intersect multiple tables, keeping only rows whose with identical
   * values for all columns in all tables, and deduplicates the rows.
   * This transformation is similar to a series of {@link Transformable#semijoin}
   * calls, but additionally suppresses duplicate rows.
   * @see Transformable#semijoin
   * @param  {...TableRef} tables A list of tables to intersect.
   * @return {this} A new filtered table.
   * @example table.intersect(other)
   * @example table.intersect(other1, other2)
   * @example table.intersect([other1, other2])
   */
  intersect(...t) {
    return this.__intersect(this, t.flat());
  }
  /**
   * Compute the set difference with multiple tables, keeping only rows in
   * this table that whose values do not occur in the other tables.
   * This transformation is similar to a series of {@link Transformable#antijoin}
   * calls, but additionally suppresses duplicate rows.
   * @see Transformable#antijoin
   * @param  {...TableRef} tables A list of tables to difference.
   * @return {this} A new filtered table.
   * @example table.except(other)
   * @example table.except(other1, other2)
   * @example table.except([other1, other2])
   */
  except(...t) {
    return this.__except(this, t.flat());
  }
}
function Qe(e) {
  throw Error(e);
}
function Tn(e) {
  return typeof e == "number";
}
function or(e) {
  return typeof e == "function";
}
function xp(e, t) {
  const i = Array(e);
  if (or(t))
    for (let r = 0; r < e; ++r)
      i[r] = t(r);
  else
    i.fill(t);
  return i;
}
let WU = class extends mE {
  /**
   * Instantiate a new Table instance.
   * @param {string[]} names An ordered list of column names.
   * @param {number} nrows The number of rows.
   * @param {TableData} data The backing data, which can vary by implementation.
   * @param {BitSet} [filter] A bit mask for which rows to include.
   * @param {GroupBySpec} [groups] A groupby specification for grouping ows.
   * @param {RowComparator} [order] A comparator function for sorting rows.
   * @param {Params} [params] Parameter values for table expressions.
   */
  constructor(t, i, r, n, s, a, o) {
    super(o), this._names = Object.freeze(t), this._data = r, this._total = i, this._nrows = n ? n.count() : i, this._mask = i !== this._nrows && n || null, this._group = s || null, this._order = a || null;
  }
  /**
   * Create a new table with the same type as this table.
   * The new table may have different data, filter, grouping, or ordering
   * based on the values of the optional configuration argument. If a
   * setting is not specified, it is inherited from the current table.
   * @param {CreateOptions} [options] Creation options for the new table.
   * @return {this} A newly created table.
   */
  create(t) {
    Qe("Not implemented");
  }
  /**
   * Provide an informative object string tag.
   */
  get [Symbol.toStringTag]() {
    if (!this._names)
      return "Object";
    const t = this.numRows() + " row" + (this.numRows() !== 1 ? "s" : "");
    return `Table: ${this.numCols() + " col" + (this.numCols() !== 1 ? "s" : "")} x ${t}` + (this.isFiltered() ? ` (${this.totalRows()} backing)` : "") + (this.isGrouped() ? `, ${this._group.size} groups` : "") + (this.isOrdered() ? ", ordered" : "");
  }
  /**
   * Indicates if the table has a filter applied.
   * @return {boolean} True if filtered, false otherwise.
   */
  isFiltered() {
    return !!this._mask;
  }
  /**
   * Indicates if the table has a groupby specification.
   * @return {boolean} True if grouped, false otherwise.
   */
  isGrouped() {
    return !!this._group;
  }
  /**
   * Indicates if the table has a row order comparator.
   * @return {boolean} True if ordered, false otherwise.
   */
  isOrdered() {
    return !!this._order;
  }
  /**
   * Returns the internal table storage data structure.
   * @return {TableData} The backing table storage data structure.
   */
  data() {
    return this._data;
  }
  /**
   * Returns the filter bitset mask, if defined.
   * @return {BitSet} The filter bitset mask.
   */
  mask() {
    return this._mask;
  }
  /**
   * Returns the groupby specification, if defined.
   * @return {GroupBySpec} The groupby specification.
   */
  groups() {
    return this._group;
  }
  /**
   * Returns the row order comparator function, if specified.
   * @return {RowComparator} The row order comparator function.
   */
  comparator() {
    return this._order;
  }
  /**
   * The total number of rows in this table, counting both
   * filtered and unfiltered rows.
   * @return {number} The number of total rows.
   */
  totalRows() {
    return this._total;
  }
  /**
   * The number of active rows in this table. This number may be
   * less than the total rows if the table has been filtered.
   * @see Table.totalRows
   * @return {number} The number of rows.
   */
  numRows() {
    return this._nrows;
  }
  /**
   * The number of active rows in this table. This number may be
   * less than the total rows if the table has been filtered.
   * @see Table.totalRows
   * @return {number} The number of rows.
   */
  get size() {
    return this._nrows;
  }
  /**
   * The number of columns in this table.
   * @return {number} The number of columns.
   */
  numCols() {
    return this._names.length;
  }
  /**
   * Filter function invoked for each column name.
   * @callback NameFilter
   * @param {string} name The column name.
   * @param {number} index The column index.
   * @param {string[]} array The array of names.
   * @return {boolean} Returns true to retain the column name.
   */
  /**
   * The table column names, optionally filtered.
   * @param {NameFilter} [filter] An optional filter function.
   *  If unspecified, all column names are returned.
   * @return {string[]} An array of matching column names.
   */
  columnNames(t) {
    return t ? this._names.filter(t) : this._names.slice();
  }
  /**
   * The column name at the given index.
   * @param {number} index The column index.
   * @return {string} The column name,
   *  or undefined if the index is out of range.
   */
  columnName(t) {
    return this._names[t];
  }
  /**
   * The column index for the given name.
   * @param {string} name The column name.
   * @return {number} The column index, or -1 if the name is not found.
   */
  columnIndex(t) {
    return this._names.indexOf(t);
  }
  /**
   * Deprecated alias for the table array() method: use table.array()
   * instead. Get an array of values contained in a column. The resulting
   * array respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {DataValue[]|TypedArray} The array of column values.
   */
  columnArray(t, i) {
    return this.array(t, i);
  }
  /**
   * Get an array of values contained in a column. The resulting array
   * respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {DataValue[]|TypedArray} The array of column values.
   */
  array(t, i) {
    Qe("Not implemented");
  }
  /**
   * Returns an iterator over column values.
   * @return {Iterator<object>} An iterator over row objects.
   */
  *values(t) {
    const i = this.getter(t), r = this.numRows();
    for (let n = 0; n < r; ++n)
      yield i(n);
  }
  /**
   * Get the value for the given column and row.
   * @param {string} name The column name.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {DataValue} The data value at (column, row).
   */
  get(t, i = 0) {
    Qe("Not implemented");
  }
  /**
   * Returns an accessor ("getter") function for a column. The returned
   * function takes a row index as its single argument and returns the
   * corresponding column value.
   * @param {string} name The column name.
   * @return {ColumnGetter} The column getter function.
   */
  getter(t) {
    Qe("Not implemented");
  }
  /**
   * Returns an array of objects representing table rows.
   * @param {ObjectsOptions} [options] The options for row object generation.
   * @return {RowObject[]} An array of row objects.
   */
  objects(t) {
    Qe("Not implemented");
  }
  /**
   * Returns an object representing a table row.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {object} A row object with named properties for each column.
   */
  object(t) {
    Qe("Not implemented");
  }
  /**
   * Returns an iterator over objects representing table rows.
   * @return {Iterator<object>} An iterator over row objects.
   */
  [Symbol.iterator]() {
    Qe("Not implemented");
  }
  /**
   * Print the contents of this table using the console.table() method.
   * @param {PrintOptions|number} options The options for row object
   *  generation, determining which rows and columns are printed. If
   *  number-valued, specifies the row limit.
   * @return {this} The table instance.
   */
  print(t = {}) {
    Tn(t) ? t = { limit: t } : t.limit == null && (t.limit = 10);
    const i = this.objects({ ...t, grouped: !1 }), r = `${this[Symbol.toStringTag]}. Showing ${i.length} rows.`;
    return console.log(r), console.table(i), this;
  }
  /**
   * Returns an array of indices for all rows passing the table filter.
   * @param {boolean} [order=true] A flag indicating if the returned
   *  indices should be sorted if this table is ordered. If false, the
   *  returned indices may or may not be sorted.
   * @return {Uint32Array} An array of row indices.
   */
  indices(t = !0) {
    if (this._index)
      return this._index;
    const i = this.numRows(), r = new Uint32Array(i), n = this.isOrdered(), s = this.mask();
    let a = -1;
    if (s)
      for (let o = s.next(0); o >= 0; o = s.next(o + 1))
        r[++a] = o;
    else
      for (let o = 0; o < i; ++o)
        r[++a] = o;
    if (t && n) {
      const o = this._order, c = this._data;
      r.sort((l, d) => o(l, d, c));
    }
    return (t || !n) && (this._index = r), r;
  }
  /**
   * Returns an array of indices for each group in the table.
   * If the table is not grouped, the result is the same as
   * {@link indices}, but wrapped within an array.
   * @param {boolean} [order=true] A flag indicating if the returned
   *  indices should be sorted if this table is ordered. If false, the
   *  returned indices may or may not be sorted.
   * @return {number[][]} An array of row index arrays, one per group.
   *  The indices will be filtered if the table is filtered.
   */
  partitions(t = !0) {
    if (this._partitions)
      return this._partitions;
    if (!this.isGrouped())
      return [this.indices(t)];
    const { keys: i, size: r } = this._group, n = xp(r, () => []), s = this._index, a = this.mask(), o = this.numRows();
    if (s && this.isOrdered())
      for (let c = 0, l; c < o; ++c)
        l = s[c], n[i[l]].push(l);
    else if (a)
      for (let c = a.next(0); c >= 0; c = a.next(c + 1))
        n[i[c]].push(c);
    else
      for (let c = 0; c < o; ++c)
        n[i[c]].push(c);
    if (t && !s && this.isOrdered()) {
      const c = this._order, l = this._data;
      for (let d = 0; d < r; ++d)
        n[d].sort((u, h) => c(u, h, l));
    }
    return (t || !this.isOrdered()) && (this._partitions = n), n;
  }
  /**
   * Callback function to cancel a table scan.
   * @callback ScanStop
   * @return {void}
   */
  /**
   * Callback function invoked for each row of a table scan.
   * @callback ScanVisitor
   * @param {number} [row] The table row index.
   * @param {TableData} [data] The backing table data store.
   * @param {ScanStop} [stop] Function to stop the scan early.
   *  Callees can invoke this function to prevent future calls.
   * @return {void}
   */
  /**
   * Perform a table scan, visiting each row of the table.
   * If this table is filtered, only rows passing the filter are visited.
   * @param {ScanVisitor} fn Callback invoked for each row of the table.
   * @param {boolean} [order=false] Indicates if the table should be
   *  scanned in the order determined by {@link Table#orderby}. This
   *  argument has no effect if the table is unordered.
   * @property {number} [limit=Infinity] The maximum number of objects to create.
   * @property {number} [offset=0] The row offset indicating how many initial rows to skip.
   */
  scan(t, i, r = 1 / 0, n = 0) {
    const s = this._mask, a = this._nrows, o = this._data;
    let c = n || 0;
    if (c > a)
      return;
    const l = Math.min(a, c + r), d = () => c = this._total;
    if (i && this.isOrdered() || s && this._index) {
      const u = this.indices(), h = this._data;
      for (; c < l; ++c)
        t(u[c], h, d);
    } else if (s) {
      let u = l - c + 1;
      for (c = s.nth(c); --u && c > -1; c = s.next(c + 1))
        t(c, o, d);
    } else
      for (; c < l; ++c)
        t(c, o, d);
  }
  /**
   * Extract rows with indices from start to end (end not included), where
   * start and end represent per-group ordered row numbers in the table.
   * @param {number} [start] Zero-based index at which to start extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If start is undefined, slice starts from the index 0.
   * @param {number} [end] Zero-based index before which to end extraction.
   *  A negative index indicates an offset from the end of the group.
   *  If end is omitted, slice extracts through the end of the group.
   * @return {this} A new table with sliced rows.
   * @example table.slice(1, -1)
   */
  slice(t = 0, i = 1 / 0) {
    if (this.isGrouped())
      return super.slice(t, i);
    const r = [], n = this.numRows();
    return t = Math.max(0, t + (t < 0 ? n : 0)), i = Math.min(n, Math.max(0, i + (i < 0 ? n : 0))), this.scan((s) => r.push(s), !0, i - t, t), this.reify(r);
  }
  /**
   * Reduce a table, processing all rows to produce a new table.
   * To produce standard aggregate summaries, use {@link rollup}.
   * This method allows the use of custom reducer implementations,
   * for example to produce multiple rows for an aggregate.
   * @param {Reducer} reducer The reducer to apply.
   * @return {Table} A new table of reducer outputs.
   */
  reduce(t) {
    return this.__reduce(this, t);
  }
}, YU = class {
  /**
   * Create a new column instance.
   * @param {Array} data The backing array (or array-like object)
   *  containing the column data.
   */
  constructor(t) {
    this.data = t;
  }
  /**
   * Get the length (number of rows) of the column.
   * @return {number} The length of the column array.
   */
  get length() {
    return this.data.length;
  }
  /**
   * Get the column value at the given row index.
   * @param {number} row The row index of the value to retrieve.
   * @return {import('./table').DataValue} The column value.
   */
  get(t) {
    return this.data[t];
  }
  /**
   * Returns an iterator over the column values.
   * @return {Iterator<object>} An iterator over column values.
   */
  [Symbol.iterator]() {
    return this.data[Symbol.iterator]();
  }
}, qU = function(e) {
  return e && or(e.get) ? e : new YU(e);
};
function To(e) {
  return e instanceof Date;
}
function _n(e) {
  return e === Object(e);
}
function jg(e) {
  return e instanceof RegExp;
}
function fn(e) {
  return typeof e == "string";
}
function ZU(e, t) {
  const i = (r) => Qe(`Illegal argument type: ${r || typeof e}`);
  return e instanceof Map ? rA(e.entries(), t) : To(e) ? i("Date") : jg(e) ? i("RegExp") : fn(e) ? i() : Ei(e) ? XU(e, t) : or(e[Symbol.iterator]) ? KU(e, t) : _n(e) ? rA(Object.entries(e), t) : i();
}
function rA(e, t = ["key", "value"]) {
  const i = [], r = [];
  for (const [s, a] of e)
    i.push(s), r.push(a);
  const n = {};
  return t[0] && (n[t[0]] = i), t[1] && (n[t[1]] = r), n;
}
function XU(e, t) {
  const i = e.length, r = {}, n = (s) => r[s] = Array(i);
  if (i) {
    t = t || Object.keys(e[0]);
    const s = t.map(n), a = s.length;
    for (let o = 0; o < i; ++o) {
      const c = e[o];
      for (let l = 0; l < a; ++l)
        s[l][o] = c[t[l]];
    }
  } else
    t && t.forEach(n);
  return r;
}
function KU(e, t) {
  const i = {}, r = (a) => i[a] = [];
  let n, s;
  for (const a of e) {
    n || (t = t || Object.keys(a), n = t.map(r), s = n.length);
    for (let o = 0; o < s; ++o)
      n[o].push(a[t[o]]);
  }
  return !n && t && t.forEach(r), i;
}
const { hasOwnProperty: JU } = Object.prototype;
function Xs(e, t) {
  return JU.call(e, t);
}
function Yn(e) {
  return e ? new nA({ ...e.data() }, e.columnNames()) : new nA();
}
class nA {
  constructor(t, i) {
    this.data = t || {}, this.names = i || [];
  }
  add(t, i) {
    return this.has(t) || this.names.push(t + ""), this.data[t] = i;
  }
  has(t) {
    return Xs(this.data, t);
  }
  new() {
    return this.filter = null, this.groups = this.groups || null, this.order = null, this;
  }
  groupby(t) {
    return this.groups = t, this;
  }
}
const Si = void 0, QU = Object.getPrototypeOf(Int8Array);
function wp(e) {
  return e instanceof QU;
}
function Dl(e) {
  return Ei(e) || wp(e);
}
function Gs(e) {
  return e != null && e === e;
}
const Hh = (e) => Dl(e) || fn(e), t9 = {
  compact: (e) => Dl(e) ? e.filter((t) => Gs(t)) : e,
  concat: (...e) => [].concat(...e),
  includes: (e, t, i) => Hh(e) ? e.includes(t, i) : !1,
  indexof: (e, t) => Hh(e) ? e.indexOf(t) : -1,
  join: (e, t) => Dl(e) ? e.join(t) : Si,
  lastindexof: (e, t) => Hh(e) ? e.lastIndexOf(t) : -1,
  length: (e) => Hh(e) ? e.length : 0,
  pluck: (e, t) => Dl(e) ? e.map((i) => Gs(i) ? i[t] : Si) : Si,
  reverse: (e) => Dl(e) ? e.slice().reverse() : fn(e) ? e.split("").reverse().join("") : Si,
  slice: (e, t, i) => Hh(e) ? e.slice(t, i) : Si
};
function e9(e, t, i, r, n) {
  return e == null ? null : e < t ? -1 / 0 : e > i ? 1 / 0 : (e = Math.max(t, Math.min(e, i)), t + r * Math.floor(1e-14 + (e - t) / r + (n || 0)));
}
function tg(e, t, i = "0") {
  const r = e + "", n = r.length;
  return n < t ? Array(t - n + 1).join(i) + r : r;
}
const ha = (e) => (e < 10 ? "0" : "") + e, i9 = (e) => e < 0 ? "-" + tg(-e, 6) : e > 9999 ? "+" + tg(e, 6) : tg(e, 4);
function gE(e, t, i, r, n, s, a, o, c) {
  const l = o ? "Z" : "";
  return i9(e) + "-" + ha(t + 1) + "-" + ha(i) + (!c || a ? "T" + ha(r) + ":" + ha(n) + ":" + ha(s) + "." + tg(a, 3) + l : s ? "T" + ha(r) + ":" + ha(n) + ":" + ha(s) + l : n || r || !o ? "T" + ha(r) + ":" + ha(n) + l : "");
}
function yE(e, t) {
  return isNaN(e) ? "Invalid Date" : gE(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds(),
    !1,
    t
  );
}
function _y(e, t) {
  return isNaN(e) ? "Invalid Date" : gE(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds(),
    e.getUTCMilliseconds(),
    !0,
    t
  );
}
const r9 = /^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/;
function n9(e) {
  return e.match(r9) && !isNaN(Date.parse(e));
}
function s9(e, t = Date.parse) {
  return n9(e) ? t(e) : e;
}
const vE = 6e4, _E = 864e5, bE = 6048e5, Ar = /* @__PURE__ */ new Date(), Tr = /* @__PURE__ */ new Date(), Nr = (e) => (Ar.setTime(typeof e == "string" ? s9(e) : e), Ar);
function a9(e, t, i, r, n, s, a) {
  return arguments.length ? new Date(
    e,
    t || 0,
    i ?? 1,
    r || 0,
    n || 0,
    s || 0,
    a || 0
  ) : new Date(Date.now());
}
function o9(e, t, i, r, n, s, a) {
  return arguments.length ? new Date(Date.UTC(
    e,
    t || 0,
    i ?? 1,
    r || 0,
    n || 0,
    s || 0,
    a || 0
  )) : new Date(Date.now());
}
function c9(e) {
  Tr.setTime(+e), Tr.setHours(0, 0, 0, 0), Ar.setTime(+Tr), Ar.setMonth(0), Ar.setDate(1);
  const t = (Tr.getTimezoneOffset() - Ar.getTimezoneOffset()) * vE;
  return Math.floor(1 + (Tr - Ar - t) / _E);
}
function l9(e) {
  Tr.setTime(+e), Tr.setUTCHours(0, 0, 0, 0);
  const t = Date.UTC(Tr.getUTCFullYear(), 0, 1);
  return Math.floor(1 + (Tr - t) / _E);
}
function d9(e, t) {
  const i = t || 0;
  Tr.setTime(+e), Tr.setDate(Tr.getDate() - (Tr.getDay() + 7 - i) % 7), Tr.setHours(0, 0, 0, 0), Ar.setTime(+e), Ar.setMonth(0), Ar.setDate(1), Ar.setDate(1 - (Ar.getDay() + 7 - i) % 7), Ar.setHours(0, 0, 0, 0);
  const r = (Tr.getTimezoneOffset() - Ar.getTimezoneOffset()) * vE;
  return Math.floor((1 + (Tr - Ar) - r) / bE);
}
function u9(e, t) {
  const i = t || 0;
  return Tr.setTime(+e), Tr.setUTCDate(Tr.getUTCDate() - (Tr.getUTCDay() + 7 - i) % 7), Tr.setUTCHours(0, 0, 0, 0), Ar.setTime(+e), Ar.setUTCMonth(0), Ar.setUTCDate(1), Ar.setUTCDate(1 - (Ar.getUTCDay() + 7 - i) % 7), Ar.setUTCHours(0, 0, 0, 0), Math.floor((1 + (Tr - Ar)) / bE);
}
const h9 = {
  format_date: (e, t) => yE(Nr(e), !t),
  format_utcdate: (e, t) => _y(Nr(e), !t),
  timestamp: (e) => +Nr(e),
  year: (e) => Nr(e).getFullYear(),
  quarter: (e) => Math.floor(Nr(e).getMonth() / 3),
  month: (e) => Nr(e).getMonth(),
  date: (e) => Nr(e).getDate(),
  dayofweek: (e) => Nr(e).getDay(),
  hours: (e) => Nr(e).getHours(),
  minutes: (e) => Nr(e).getMinutes(),
  seconds: (e) => Nr(e).getSeconds(),
  milliseconds: (e) => Nr(e).getMilliseconds(),
  utcyear: (e) => Nr(e).getUTCFullYear(),
  utcquarter: (e) => Math.floor(Nr(e).getUTCMonth() / 3),
  utcmonth: (e) => Nr(e).getUTCMonth(),
  utcdate: (e) => Nr(e).getUTCDate(),
  utcdayofweek: (e) => Nr(e).getUTCDay(),
  utchours: (e) => Nr(e).getUTCHours(),
  utcminutes: (e) => Nr(e).getUTCMinutes(),
  utcseconds: (e) => Nr(e).getUTCSeconds(),
  utcmilliseconds: (e) => Nr(e).getUTCMilliseconds(),
  datetime: a9,
  dayofyear: c9,
  week: d9,
  utcdatetime: o9,
  utcdayofyear: l9,
  utcweek: u9,
  now: Date.now
};
function F1(e, t) {
  return e == null || t == null || e !== e || t !== t ? !1 : e === t ? !0 : To(e) || To(t) ? +e == +t : jg(e) && jg(t) ? e + "" == t + "" : _n(e) && _n(t) ? f9(e, t) : !1;
}
function f9(e, t) {
  if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t))
    return !1;
  if (e.length || t.length)
    return sA(e, t);
  const i = Object.keys(e), r = Object.keys(t);
  if (i.length !== r.length || (i.sort(), r.sort(), !sA(i, r, (s, a) => s === a)))
    return !1;
  const n = i.length;
  for (let s = 0; s < n; ++s) {
    const a = i[s];
    if (!F1(e[a], t[a]))
      return !1;
  }
  return !0;
}
function sA(e, t, i = F1) {
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; ++n)
    if (!i(e[n], t[n]))
      return !1;
  return !0;
}
const p9 = {
  parse_json: (e) => JSON.parse(e),
  to_json: (e) => JSON.stringify(e)
};
let m9 = Math.random;
function th() {
  return m9();
}
const g9 = {
  random: th,
  is_nan: Number.isNaN,
  is_finite: Number.isFinite,
  abs: Math.abs,
  cbrt: Math.cbrt,
  ceil: Math.ceil,
  clz32: Math.clz32,
  exp: Math.exp,
  expm1: Math.expm1,
  floor: Math.floor,
  fround: Math.fround,
  greatest: Math.max,
  least: Math.min,
  log: Math.log,
  log10: Math.log10,
  log1p: Math.log1p,
  log2: Math.log2,
  pow: Math.pow,
  round: Math.round,
  sign: Math.sign,
  sqrt: Math.sqrt,
  trunc: Math.trunc,
  degrees: (e) => 180 * e / Math.PI,
  radians: (e) => Math.PI * e / 180,
  acos: Math.acos,
  acosh: Math.acosh,
  asin: Math.asin,
  asinh: Math.asinh,
  atan: Math.atan,
  atan2: Math.atan2,
  atanh: Math.atanh,
  cos: Math.cos,
  cosh: Math.cosh,
  sin: Math.sin,
  sinh: Math.sinh,
  tan: Math.tan,
  tanh: Math.tanh
};
function B1(e) {
  return e instanceof Map;
}
function y9(e) {
  return e instanceof Set;
}
function eg(e) {
  return B1(e) || y9(e);
}
function p_(e) {
  return Array.from(e);
}
const v9 = {
  has: (e, t) => eg(e) ? e.has(t) : e != null ? Xs(e, t) : !1,
  keys: (e) => B1(e) ? p_(e.keys()) : e != null ? Object.keys(e) : [],
  values: (e) => eg(e) ? p_(e.values()) : e != null ? Object.values(e) : [],
  entries: (e) => eg(e) ? p_(e.entries()) : e != null ? Object.entries(e) : [],
  object: (e) => e ? Object.fromEntries(e) : Si
};
function _9(e, t, i) {
  if (t instanceof Map) {
    if (t.has(e))
      return t.get(e);
  } else if (Xs(t, e))
    return t[e];
  return i !== void 0 ? i : e;
}
function xE(e, t, i) {
  let r = arguments.length;
  e = +e, t = +t, i = r < 2 ? (t = e, e = 0, 1) : r < 3 ? 1 : +i, r = Math.max(0, Math.ceil((t - e) / i)) | 0;
  const n = new Array(r);
  for (let s = 0; s < r; ++s)
    n[s] = e + s * i;
  return n;
}
const b9 = {
  parse_date: (e) => e == null ? e : new Date(e),
  parse_float: (e) => e == null ? e : Number.parseFloat(e),
  parse_int: (e, t) => e == null ? e : Number.parseInt(e, t),
  endswith: (e, t, i) => e == null ? !1 : String(e).endsWith(t, i),
  match: (e, t, i) => {
    const r = e == null ? e : String(e).match(t);
    return i == null || r == null ? r : typeof i == "number" ? r[i] : r.groups ? r.groups[i] : null;
  },
  normalize: (e, t) => e == null ? e : String(e).normalize(t),
  padend: (e, t, i) => e == null ? e : String(e).padEnd(t, i),
  padstart: (e, t, i) => e == null ? e : String(e).padStart(t, i),
  upper: (e) => e == null ? e : String(e).toUpperCase(),
  lower: (e) => e == null ? e : String(e).toLowerCase(),
  repeat: (e, t) => e == null ? e : String(e).repeat(t),
  replace: (e, t, i) => e == null ? e : String(e).replace(t, String(i)),
  substring: (e, t, i) => e == null ? e : String(e).substring(t, i),
  split: (e, t, i) => e == null ? [] : String(e).split(t, i),
  startswith: (e, t, i) => e == null ? !1 : String(e).startsWith(t, i),
  trim: (e) => e == null ? e : String(e).trim()
}, iu = {
  bin: e9,
  equal: F1,
  recode: _9,
  sequence: xE,
  ...t9,
  ...h9,
  ...p9,
  ...g9,
  ...v9,
  ...b9
};
function Rf(e) {
  return typeof e == "bigint";
}
function Ss(e) {
  return e === void 0 ? e + "" : Rf(e) ? e + "n" : JSON.stringify(e);
}
function Xe(e, t = [], i = []) {
  return new x9(e, Un(t), Un(i));
}
let x9 = class {
  constructor(t, i, r) {
    this.name = t, this.fields = i, this.params = r;
  }
  toString() {
    const t = [
      ...this.fields.map((i) => `d[${Ss(i)}]`),
      ...this.params.map(Ss)
    ];
    return `d => op.${this.name}(${t})`;
  }
  toObject() {
    return { expr: this.toString(), func: !0 };
  }
};
const wE = (e) => Xe("any", e), SE = () => Xe("count"), IE = (e) => Xe("array_agg", e), AE = (e) => Xe("array_agg_distinct", e), TE = (e, t) => Xe("map_agg", [e, t]), EE = (e, t) => Xe("object_agg", [e, t]), kE = (e, t) => Xe("entries_agg", [e, t]);
({
  ...iu
});
function w9(e, t) {
  e = eg(e) ? e : new Set(e);
  let i = t, r = 0;
  for (; e.has(i); )
    i = t + ++r;
  return i;
}
function S9(e, t) {
  if (!e || !t)
    return e;
  const { keys: i, rows: r, size: n } = e, s = new Int32Array(n);
  t.scan((d) => s[i[d]] = 1);
  const a = s.reduce((d, u) => d + u, 0);
  if (a === n)
    return e;
  const o = Array(a);
  let c = 0;
  for (let d = 0; d < n; ++d)
    s[d] && (o[s[d] = c++] = r[d]);
  const l = new Uint32Array(i.length);
  return t.scan((d) => l[d] = s[i[d]]), { ...e, keys: l, rows: o, size: c };
}
function I9(e, t, i, r) {
  const { keys: n, rows: s, size: a } = e;
  let o = s, c = a, l = null;
  if (i) {
    l = new Int32Array(a), t((m) => l[n[m]] = 1);
    const p = l.reduce((m, w) => m + w, 0);
    if (p !== a) {
      o = Array(p), c = 0;
      for (let m = 0; m < a; ++m)
        l[m] && (o[l[m] = c++] = s[m]);
    }
  }
  let d = -1;
  const u = new Uint32Array(r);
  return t(c !== a ? (p) => u[++d] = l[n[p]] : (p) => u[++d] = n[p]), { ...e, keys: u, rows: o, size: c };
}
function A9(e, t, i, r) {
  const n = r === "map" || r === !0 ? TE : r === "entries" ? kE : r === "object" ? EE : Qe('groups option must be "map", "entries", or "object".'), { names: s } = e.groups(), a = w9(e.columnNames(), "_");
  let o = e.select().reify(t).create({ data: { [a]: i } }).rollup({ [a]: IE(a) });
  for (let c = s.length; --c >= 0; )
    o = o.groupby(s.slice(0, c)).rollup({ [a]: n(s[c], a) });
  return o.get(a);
}
const T9 = "ArrayPattern", E9 = "ArrowFunctionExpression", k9 = "FunctionExpression", bc = "Identifier", eh = "Literal", CE = "MemberExpression", C9 = "ObjectExpression", OE = "ObjectPattern", DE = "Property", Sp = "Column", O9 = "Constant", D9 = "Dictionary", N9 = "Function", L9 = "Parameter", NE = "Op", ir = (e, t) => {
  const i = F9[e.type];
  return i ? i(e, t) : Qe(`Unsupported expression construct: ${e.type}`);
}, m_ = (e, t) => "(" + ir(e.left, t) + " " + e.operator + " " + ir(e.right, t) + ")", g_ = (e, t) => "(" + ga(e.params, t) + ")=>" + ir(e.body, t), aA = (e, t) => ir(e.callee, t) + "(" + ga(e.arguments, t) + ")", ga = (e, t, i = ",") => e.map((r) => ir(r, t)).join(i), LE = (e) => e.computed ? `[${Ss(e.name)}]` : `.${e.name}`, oA = (e, t, i) => {
  const r = e.table || "";
  return `data${r}${LE(e)}.${i}(${t.index}${r})`;
}, F9 = {
  Constant: (e) => e.raw,
  Column: (e, t) => oA(e, t, "get"),
  Dictionary: (e, t) => oA(e, t, "key"),
  Function: (e) => `fn.${e.name}`,
  Parameter: (e) => `$${LE(e)}`,
  Op: (e, t) => `op(${Ss(e.name)},${t.op || t.index})`,
  Literal: (e) => e.raw,
  Identifier: (e) => e.name,
  TemplateLiteral: (e, t) => {
    const { quasis: i, expressions: r } = e, n = r.length;
    let s = i[0].value.raw;
    for (let a = 0; a < n; )
      s += "${" + ir(r[a], t) + "}" + i[++a].value.raw;
    return "`" + s + "`";
  },
  MemberExpression: (e, t) => {
    const i = !e.computed, r = ir(e.object, t), n = ir(e.property, t);
    return r + (i ? "." + n : "[" + n + "]");
  },
  CallExpression: aA,
  NewExpression: (e, t) => "new " + aA(e, t),
  ArrayExpression: (e, t) => "[" + ga(e.elements, t) + "]",
  AssignmentExpression: m_,
  BinaryExpression: m_,
  LogicalExpression: m_,
  UnaryExpression: (e, t) => "(" + e.operator + ir(e.argument, t) + ")",
  ConditionalExpression: (e, t) => "(" + ir(e.test, t) + "?" + ir(e.consequent, t) + ":" + ir(e.alternate, t) + ")",
  ObjectExpression: (e, t) => "({" + ga(e.properties, t) + "})",
  Property: (e, t) => {
    const i = ir(e.key, t);
    return (e.computed ? `[${i}]` : i) + ":" + ir(e.value, t);
  },
  ArrowFunctionExpression: g_,
  FunctionExpression: g_,
  FunctionDeclaration: g_,
  ArrayPattern: (e, t) => "[" + ga(e.elements, t) + "]",
  ObjectPattern: (e, t) => "{" + ga(e.properties, t) + "}",
  VariableDeclaration: (e, t) => e.kind + " " + ga(e.declarations, t, ","),
  VariableDeclarator: (e, t) => ir(e.id, t) + "=" + ir(e.init, t),
  SpreadElement: (e, t) => "..." + ir(e.argument, t),
  BlockStatement: (e, t) => "{" + ga(e.body, t, ";") + ";}",
  BreakStatement: () => "break",
  ExpressionStatement: (e, t) => ir(e.expression, t),
  IfStatement: (e, t) => "if (" + ir(e.test, t) + ")" + ir(e.consequent, t) + (e.alternate ? " else " + ir(e.alternate, t) : ""),
  SwitchStatement: (e, t) => "switch (" + ir(e.discriminant, t) + ") {" + ga(e.cases, t, "") + "}",
  SwitchCase: (e, t) => (e.test ? "case " + ir(e.test, t) : "default") + ": " + ga(e.consequent, t, ";") + ";",
  ReturnStatement: (e, t) => "return " + ir(e.argument, t),
  Program: (e, t) => ir(e.body[0], t)
};
function Gg(e, t = { index: "row" }) {
  return ir(e, t);
}
function B9(e, t, i = 15, r = !0, n = 0, s) {
  const o = Math.LN10;
  if (s == null) {
    const c = Math.ceil(Math.log(i) / o), l = t - e || Math.abs(e) || 1, d = [5, 2];
    for (s = Math.max(
      n,
      Math.pow(10, Math.round(Math.log(l) / o) - c)
    ); Math.ceil(l / s) > i; )
      s *= 10;
    const u = d.length;
    for (let h = 0; h < u; ++h) {
      const p = s / d[h];
      p >= n && l / p <= i && (s = p);
    }
  }
  if (r) {
    let c = Math.log(s);
    const l = c >= 0 ? 0 : ~~(-c / o) + 1, d = Math.pow(10, -l - 1);
    c = Math.floor(e / s + d) * s, e = e < c ? c - s : c, t = Math.ceil(t / s) * s;
  }
  return [
    e,
    t === e ? e + s : t,
    s
  ];
}
function Lu(e) {
  const t = typeof e;
  return t === "string" ? `"${e}"` : t !== "object" || !e ? e : To(e) ? +e : Ei(e) || wp(e) ? `[${e.map(Lu)}]` : jg(e) ? e + "" : R9(e);
}
function R9(e) {
  let t = "{", i = -1;
  for (const r in e)
    ++i > 0 && (t += ","), t += `"${r}":${Lu(e[r])}`;
  return t += "}", t;
}
function Hg(e, t) {
  const i = e.length;
  return i === 1 ? (r, n) => Lu(e[0](r, n)) : (r, n) => {
    let s = "";
    for (let a = 0; a < i; ++a) {
      a > 0 && (s += "|");
      const o = e[a](r, n);
      if (t && (o == null || o !== o))
        return null;
      s += Lu(o);
    }
    return s;
  };
}
function M9() {
  const e = /* @__PURE__ */ new Map();
  return {
    count() {
      return e.size;
    },
    values() {
      return Array.from(e.values(), (t) => t.v);
    },
    increment(t) {
      const i = Lu(t), r = e.get(i);
      r ? ++r.n : e.set(i, { v: t, n: 1 });
    },
    decrement(t) {
      const i = Lu(t), r = e.get(i);
      r.n === 1 ? e.delete(i) : --r.n;
    },
    forEach(t) {
      e.forEach(({ v: i, n: r }) => t(i, r));
    }
  };
}
function po() {
}
function P9(e, t = 0, i = e.length) {
  let r = e[t++];
  for (let n = t; n < i; ++n)
    r *= e[n];
  return r;
}
function Xr(e) {
  return e.init = e.init || po, e.add = e.add || po, e.rem = e.rem || po, e;
}
function cA(e, t) {
  return e.product_v = !1, e.product = t;
}
const FE = {
  /** @type {AggregateDef} */
  count: {
    create: () => Xr({
      value: (e) => e.count
    }),
    param: []
  },
  /** @type {AggregateDef} */
  array_agg: {
    create: () => Xr({
      init: (e) => e.values = !0,
      value: (e) => e.list.values(e.stream)
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  object_agg: {
    create: () => Xr({
      init: (e) => e.values = !0,
      value: (e) => Object.fromEntries(e.list.values())
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  map_agg: {
    create: () => Xr({
      init: (e) => e.values = !0,
      value: (e) => new Map(e.list.values())
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  entries_agg: {
    create: () => Xr({
      init: (e) => e.values = !0,
      value: (e) => e.list.values(e.stream)
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  any: {
    create: () => Xr({
      add: (e, t) => {
        e.any == null && (e.any = t);
      },
      value: (e) => e.valid ? e.any : Si
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  valid: {
    create: () => Xr({
      value: (e) => e.valid
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  invalid: {
    create: () => Xr({
      value: (e) => e.count - e.valid
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  distinct: {
    create: () => ({
      init: (e) => e.distinct = M9(),
      value: (e) => e.distinct.count() + (e.valid === e.count ? 0 : 1),
      add: (e, t) => e.distinct.increment(t),
      rem: (e, t) => e.distinct.decrement(t)
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  array_agg_distinct: {
    create: () => Xr({
      value: (e) => e.distinct.values()
    }),
    param: [1],
    req: ["distinct"]
  },
  /** @type {AggregateDef} */
  mode: {
    create: () => Xr({
      value: (e) => {
        let t = Si, i = 0;
        return e.distinct.forEach((r, n) => {
          n > i && (i = n, t = r);
        }), t;
      }
    }),
    param: [1],
    req: ["distinct"]
  },
  /** @type {AggregateDef} */
  sum: {
    create: () => ({
      init: (e) => e.sum = 0,
      value: (e) => e.valid ? e.sum : Si,
      add: (e, t) => Rf(t) ? e.sum === 0 ? e.sum = t : e.sum += t : e.sum += +t,
      rem: (e, t) => e.sum -= t
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  product: {
    create: () => ({
      init: (e) => cA(e, 1),
      value: (e) => e.valid ? e.product_v ? cA(e, P9(e.list.values())) : e.product : void 0,
      add: (e, t) => Rf(t) && e.product === 1 ? e.product = t : e.product *= t,
      rem: (e, t) => t == 0 || t === 1 / 0 || t === -1 / 0 ? e.product_v = !0 : e.product /= t
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  mean: {
    create: () => ({
      init: (e) => e.mean = 0,
      value: (e) => e.valid ? e.mean : Si,
      add: (e, t) => {
        e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid;
      },
      rem: (e, t) => {
        e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean;
      }
    }),
    param: [1]
  },
  /** @type {AggregateDef} */
  average: {
    create: () => Xr({
      value: (e) => e.valid ? e.mean : Si
    }),
    param: [1],
    req: ["mean"]
  },
  /** @type {AggregateDef} */
  variance: {
    create: () => ({
      init: (e) => e.dev = 0,
      value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : Si,
      add: (e, t) => e.dev += e.mean_d * (t - e.mean),
      rem: (e, t) => e.dev -= e.mean_d * (t - e.mean)
    }),
    param: [1],
    req: ["mean"]
  },
  /** @type {AggregateDef} */
  variancep: {
    create: () => Xr({
      value: (e) => e.valid > 1 ? e.dev / e.valid : Si
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  stdev: {
    create: () => Xr({
      value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : Si
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  stdevp: {
    create: () => Xr({
      value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : Si
    }),
    param: [1],
    req: ["variance"]
  },
  /** @type {AggregateDef} */
  min: {
    create: () => ({
      init: (e) => e.min = Si,
      value: (e) => e.min = Number.isNaN(e.min) ? e.list.min() : e.min,
      add: (e, t) => {
        (t < e.min || e.min === Si) && (e.min = t);
      },
      rem: (e, t) => {
        t <= e.min && (e.min = NaN);
      }
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  max: {
    create: () => ({
      init: (e) => e.max = Si,
      value: (e) => e.max = Number.isNaN(e.max) ? e.list.max() : e.max,
      add: (e, t) => {
        (t > e.max || e.max === Si) && (e.max = t);
      },
      rem: (e, t) => {
        t >= e.max && (e.max = NaN);
      }
    }),
    param: [1],
    stream: ["array_agg"]
  },
  /** @type {AggregateDef} */
  quantile: {
    create: (e) => Xr({
      value: (t) => t.list.quantile(e)
    }),
    param: [1, 1],
    req: ["array_agg"]
  },
  /** @type {AggregateDef} */
  median: {
    create: () => Xr({
      value: (e) => e.list.quantile(0.5)
    }),
    param: [1],
    req: ["array_agg"]
  },
  /** @type {AggregateDef} */
  covariance: {
    create: () => ({
      init: (e) => {
        e.cov = e.mean_x = e.mean_y = e.dev_x = e.dev_y = 0;
      },
      value: (e) => e.valid > 1 ? e.cov / (e.valid - 1) : Si,
      add: (e, t, i) => {
        const r = t - e.mean_x, n = i - e.mean_y;
        e.mean_x += r / e.valid, e.mean_y += n / e.valid;
        const s = i - e.mean_y;
        e.dev_x += r * (t - e.mean_x), e.dev_y += n * s, e.cov += r * s;
      },
      rem: (e, t, i) => {
        const r = t - e.mean_x, n = i - e.mean_y;
        e.mean_x -= e.valid ? r / e.valid : e.mean_x, e.mean_y -= e.valid ? n / e.valid : e.mean_y;
        const s = i - e.mean_y;
        e.dev_x -= r * (t - e.mean_x), e.dev_y -= n * s, e.cov -= r * s;
      }
    }),
    param: [2]
  },
  /** @type {AggregateDef} */
  covariancep: {
    create: () => Xr({
      value: (e) => e.valid > 1 ? e.cov / e.valid : Si
    }),
    param: [2],
    req: ["covariance"]
  },
  /** @type {AggregateDef} */
  corr: {
    create: () => Xr({
      value: (e) => e.valid > 1 ? e.cov / (Math.sqrt(e.dev_x) * Math.sqrt(e.dev_y)) : Si
    }),
    param: [2],
    req: ["covariance"]
  },
  /** @type {AggregateDef} */
  bins: {
    create: (e, t, i, r) => Xr({
      value: (n) => B9(n.min, n.max, e, t, i, r)
    }),
    param: [1, 4],
    req: ["min", "max"]
  }
}, lA = {
  create() {
    let e;
    return {
      init: () => e = 1,
      value: (t) => {
        const i = t.index;
        return i && !t.peer(i) ? e = i + 1 : e;
      }
    };
  },
  param: []
}, dA = {
  create() {
    let e;
    return {
      init: () => e = 0,
      value: (t) => {
        const { index: i, peer: r, size: n } = t;
        let s = i;
        if (e < s) {
          for (; s + 1 < n && r(s + 1); )
            ++s;
          e = s;
        }
        return (1 + e) / n;
      }
    };
  },
  param: []
}, BE = {
  /** @type {WindowDef} */
  row_number: {
    create() {
      return {
        init: po,
        value: (e) => e.index + 1
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  rank: lA,
  /** @type {WindowDef} */
  avg_rank: {
    create() {
      let e, t;
      return {
        init: () => (e = -1, t = 1),
        value: (i) => {
          const r = i.index;
          if (r >= e) {
            for (t = e = r + 1; i.peer(e); t += ++e)
              ;
            t /= e - r;
          }
          return t;
        }
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  dense_rank: {
    create() {
      let e;
      return {
        init: () => e = 1,
        value: (t) => {
          const i = t.index;
          return i && !t.peer(i) ? ++e : e;
        }
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  percent_rank: {
    create() {
      const { init: e, value: t } = lA.create();
      return {
        init: e,
        value: (i) => (t(i) - 1) / (i.size - 1)
      };
    },
    param: []
  },
  /** @type {WindowDef} */
  cume_dist: dA,
  /** @type {WindowDef} */
  ntile: {
    create(e) {
      e = +e, e > 0 || Qe("ntile num must be greater than zero.");
      const { init: t, value: i } = dA.create();
      return {
        init: t,
        value: (r) => Math.ceil(e * i(r))
      };
    },
    param: [0, 1]
  },
  /** @type {WindowDef} */
  lag: {
    create(e, t = Si) {
      return e = +e || 1, {
        init: po,
        value: (i, r) => {
          const n = i.index - e;
          return n >= 0 ? i.value(n, r) : t;
        }
      };
    },
    param: [1, 2]
  },
  /** @type {WindowDef} */
  lead: {
    create(e, t = Si) {
      return e = +e || 1, {
        init: po,
        value: (i, r) => {
          const n = i.index + e;
          return n < i.size ? i.value(n, r) : t;
        }
      };
    },
    param: [1, 2]
  },
  /** @type {WindowDef} */
  first_value: {
    create() {
      return {
        init: po,
        value: (e, t) => e.value(e.i0, t)
      };
    },
    param: [1]
  },
  /** @type {WindowDef} */
  last_value: {
    create() {
      return {
        init: po,
        value: (e, t) => e.value(e.i1 - 1, t)
      };
    },
    param: [1]
  },
  /** @type {WindowDef} */
  nth_value: {
    create(e) {
      return e = +e, e > 0 || Qe("nth_value nth must be greater than zero."), {
        init: po,
        value: (t, i) => {
          const r = t.i0 + (e - 1);
          return r < t.i1 ? t.value(r, i) : Si;
        }
      };
    },
    param: [1, 1]
  },
  /** @type {WindowDef} */
  fill_down: {
    create(e = Si) {
      let t;
      return {
        init: () => t = e,
        value: (i, r) => {
          const n = i.value(i.index, r);
          return Gs(n) ? t = n : t;
        }
      };
    },
    param: [1, 1]
  },
  /** @type {WindowDef} */
  fill_up: {
    create(e = Si) {
      let t, i;
      return {
        init: () => (t = e, i = -1),
        value: (r, n) => r.index <= i ? t : (i = $9(r, n, r.index)) >= 0 ? t = r.value(i, n) : (i = r.size, t = e)
      };
    },
    param: [1, 1]
  }
};
function $9(e, t, i) {
  for (const r = e.size; i < r; ++i)
    if (Gs(e.value(i, t)))
      return i;
  return -1;
}
function R1(e) {
  return Xs(FE, e);
}
function M1(e) {
  return Xs(BE, e);
}
function RE(e) {
  return Xs(iu, e) || e === "row_object";
}
function ME(e) {
  return R1(e) && FE[e];
}
function PE(e) {
  return M1(e) && BE[e];
}
function Wh(e, t, i) {
  return e = `"use strict"; return ${e};`, Function("fn", "$", e)(t, i);
}
const P1 = {
  escape: (e, t, i) => Wh(e, t, i),
  expr: (e, t) => Wh(`(row,data,op)=>${e}`, iu, t),
  expr2: (e, t) => Wh(`(row0,data0,row,data)=>${e}`, iu, t),
  join: (e, t) => Wh(`(row1,data1,row2,data2)=>${e}`, iu, t),
  param: (e, t) => Wh(e, iu, t)
}, z9 = {
  "==": 1,
  "!=": 1,
  "===": 1,
  "!==": 1
};
function $E(e, t, i = 0, r, n) {
  if (e.type = Sp, e.name = t, e.table = i, n && r && or(r.keyFor)) {
    const s = z9[n.operator] ? n.left === e ? n.right : n.left : n.callee && n.callee.name === "equal" ? n.arguments[n.arguments[0] === e ? 1 : 0] : null;
    s && s.type === eh && U9(n, e, s, r.keyFor(s.value));
  }
  return e;
}
function U9(e, t, i, r) {
  return r < 0 ? (e.type = eh, e.value = !1, e.raw = "false") : (t.type = D9, i.value = r, i.raw = r + ""), !0;
}
function by(e) {
  return Ei(e) ? e : B1(e) ? e.entries() : e ? Object.entries(e) : [];
}
const zE = "row_object";
function UE(e, t) {
  e.type = C9;
  const i = e.properties = [];
  for (const r of by(t)) {
    const [n, s] = Ei(r) ? r : [r, r];
    i.push({
      type: DE,
      key: { type: eh, raw: Ss(s) },
      value: $E({ computed: !0 }, n)
    });
  }
  return e;
}
function VE(e) {
  return Gg(UE({}, e));
}
function jE(e) {
  return P1.expr(VE(e));
}
function Dt(e, t, i, r) {
  function n(s) {
    return s instanceof i ? s : new i(function(a) {
      a(s);
    });
  }
  return new (i || (i = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (u) {
        a(u);
      }
    }
    function c(d) {
      try {
        l(r.throw(d));
      } catch (u) {
        a(u);
      }
    }
    function l(d) {
      d.done ? s(d.value) : n(d.value).then(o, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function uA(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, i = t && e[t], r = 0;
  if (i)
    return i.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Vt(e) {
  return this instanceof Vt ? (this.v = e, this) : new Vt(e);
}
function jr(e, t, i) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = i.apply(e, t || []), n, s = [];
  return n = {}, a("next"), a("throw"), a("return"), n[Symbol.asyncIterator] = function() {
    return this;
  }, n;
  function a(h) {
    r[h] && (n[h] = function(p) {
      return new Promise(function(m, w) {
        s.push([h, p, m, w]) > 1 || o(h, p);
      });
    });
  }
  function o(h, p) {
    try {
      c(r[h](p));
    } catch (m) {
      u(s[0][3], m);
    }
  }
  function c(h) {
    h.value instanceof Vt ? Promise.resolve(h.value.v).then(l, d) : u(s[0][2], h);
  }
  function l(h) {
    o("next", h);
  }
  function d(h) {
    o("throw", h);
  }
  function u(h, p) {
    h(p), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
function xc(e) {
  var t, i;
  return t = {}, r("next"), r("throw", function(n) {
    throw n;
  }), r("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function r(n, s) {
    t[n] = e[n] ? function(a) {
      return (i = !i) ? { value: Vt(e[n](a)), done: !1 } : s ? s(a) : a;
    } : s;
  }
}
function es(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], i;
  return t ? t.call(e) : (e = typeof uA == "function" ? uA(e) : e[Symbol.iterator](), i = {}, r("next"), r("throw"), r("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function r(s) {
    i[s] = e[s] && function(a) {
      return new Promise(function(o, c) {
        a = e[s](a), n(o, c, a.done, a.value);
      });
    };
  }
  function n(s, a, o, c) {
    Promise.resolve(c).then(function(l) {
      s({ value: l, done: o });
    }, a);
  }
}
const V9 = new TextDecoder("utf-8"), db = (e) => V9.decode(e), j9 = new TextEncoder(), xy = (e) => j9.encode(e), G9 = (e) => typeof e == "number", GE = (e) => typeof e == "boolean", Kr = (e) => typeof e == "function", Vn = (e) => e != null && Object(e) === e, Sc = (e) => Vn(e) && Kr(e.then), Ip = (e) => Vn(e) && Kr(e[Symbol.iterator]), ih = (e) => Vn(e) && Kr(e[Symbol.asyncIterator]), ub = (e) => Vn(e) && Vn(e.schema), HE = (e) => Vn(e) && "done" in e && "value" in e, WE = (e) => Vn(e) && Kr(e.stat) && G9(e.fd), YE = (e) => Vn(e) && $1(e.body), wy = (e) => "_getDOMStream" in e && "_getNodeStream" in e, H9 = (e) => Vn(e) && Kr(e.abort) && Kr(e.getWriter) && !wy(e), $1 = (e) => Vn(e) && Kr(e.cancel) && Kr(e.getReader) && !wy(e), W9 = (e) => Vn(e) && Kr(e.end) && Kr(e.write) && GE(e.writable) && !wy(e), qE = (e) => Vn(e) && Kr(e.read) && Kr(e.pipe) && GE(e.readable) && !wy(e), Y9 = (e) => Vn(e) && Kr(e.clear) && Kr(e.bytes) && Kr(e.position) && Kr(e.setPosition) && Kr(e.capacity) && Kr(e.getBufferIdentifier) && Kr(e.createLong), z1 = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
function q9(e) {
  const t = e[0] ? [e[0]] : [];
  let i, r, n, s;
  for (let a, o, c = 0, l = 0, d = e.length; ++c < d; ) {
    if (a = t[l], o = e[c], !a || !o || a.buffer !== o.buffer || o.byteOffset < a.byteOffset) {
      o && (t[++l] = o);
      continue;
    }
    if ({ byteOffset: i, byteLength: n } = a, { byteOffset: r, byteLength: s } = o, i + n < r || r + s < i) {
      o && (t[++l] = o);
      continue;
    }
    t[l] = new Uint8Array(a.buffer, i, r - i + s);
  }
  return t;
}
function Wg(e, t, i = 0, r = t.byteLength) {
  const n = e.byteLength, s = new Uint8Array(e.buffer, e.byteOffset, n), a = new Uint8Array(t.buffer, t.byteOffset, Math.min(r, n));
  return s.set(a, i), e;
}
function Da(e, t) {
  const i = q9(e), r = i.reduce((d, u) => d + u.byteLength, 0);
  let n, s, a, o = 0, c = -1;
  const l = Math.min(t || Number.POSITIVE_INFINITY, r);
  for (const d = i.length; ++c < d; ) {
    if (n = i[c], s = n.subarray(0, Math.min(n.length, l - o)), l <= o + s.length) {
      s.length < n.length ? i[c] = n.subarray(s.length) : s.length === n.length && c++, a ? Wg(a, s, o) : a = s;
      break;
    }
    Wg(a || (a = new Uint8Array(l)), s, o), o += s.length;
  }
  return [a || new Uint8Array(0), i.slice(c), r - (a ? a.byteLength : 0)];
}
function Wi(e, t) {
  let i = HE(t) ? t.value : t;
  return i instanceof e ? e === Uint8Array ? new e(i.buffer, i.byteOffset, i.byteLength) : i : i ? (typeof i == "string" && (i = xy(i)), i instanceof ArrayBuffer ? new e(i) : i instanceof z1 ? new e(i) : Y9(i) ? Wi(e, i.bytes()) : ArrayBuffer.isView(i) ? i.byteLength <= 0 ? new e(0) : new e(i.buffer, i.byteOffset, i.byteLength / e.BYTES_PER_ELEMENT) : e.from(i)) : new e(0);
}
const Yh = (e) => Wi(Int32Array, e), Ti = (e) => Wi(Uint8Array, e), hb = (e) => (e.next(), e);
function* Z9(e, t) {
  const i = function* (n) {
    yield n;
  }, r = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof z1 ? i(t) : Ip(t) ? t : i(t);
  return yield* hb(function* (n) {
    let s = null;
    do
      s = n.next(yield Wi(e, s));
    while (!s.done);
  }(r[Symbol.iterator]())), new e();
}
const X9 = (e) => Z9(Uint8Array, e);
function ZE(e, t) {
  return jr(this, arguments, function* () {
    if (Sc(t))
      return yield Vt(yield Vt(yield* xc(es(ZE(e, yield Vt(t))))));
    const r = function(a) {
      return jr(this, arguments, function* () {
        yield yield Vt(yield Vt(a));
      });
    }, n = function(a) {
      return jr(this, arguments, function* () {
        yield Vt(yield* xc(es(hb(function* (o) {
          let c = null;
          do
            c = o.next(yield c == null ? void 0 : c.value);
          while (!c.done);
        }(a[Symbol.iterator]())))));
      });
    }, s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof z1 ? r(t) : Ip(t) ? n(t) : ih(t) ? t : r(t);
    return yield Vt(
      // otherwise if AsyncIterable, use it
      yield* xc(es(hb(function(a) {
        return jr(this, arguments, function* () {
          let o = null;
          do
            o = yield Vt(a.next(yield yield Vt(Wi(e, o))));
          while (!o.done);
        });
      }(s[Symbol.asyncIterator]()))))
    ), yield Vt(new e());
  });
}
const K9 = (e) => ZE(Uint8Array, e);
function XE(e, t, i) {
  if (e !== 0) {
    i = i.slice(0, t);
    for (let r = -1, n = i.length; ++r < n; )
      i[r] += e;
  }
  return i.subarray(0, t);
}
function J9(e, t) {
  let i = 0;
  const r = e.length;
  if (r !== t.length)
    return !1;
  if (r > 0)
    do
      if (e[i] !== t[i])
        return !1;
    while (++i < r);
  return !0;
}
const ps = {
  fromIterable(e) {
    return Pm(Q9(e));
  },
  fromAsyncIterable(e) {
    return Pm(tV(e));
  },
  fromDOMStream(e) {
    return Pm(eV(e));
  },
  fromNodeStream(e) {
    return Pm(rV(e));
  },
  // @ts-ignore
  toDOMStream(e, t) {
    throw new Error('"toDOMStream" not available in this environment');
  },
  // @ts-ignore
  toNodeStream(e, t) {
    throw new Error('"toNodeStream" not available in this environment');
  }
}, Pm = (e) => (e.next(), e);
function* Q9(e) {
  let t, i = !1, r = [], n, s, a, o = 0;
  function c() {
    return s === "peek" ? Da(r, a)[0] : ([n, r, o] = Da(r, a), n);
  }
  ({ cmd: s, size: a } = yield null);
  const l = X9(e)[Symbol.iterator]();
  try {
    do
      if ({ done: t, value: n } = Number.isNaN(a - o) ? l.next() : l.next(a - o), !t && n.byteLength > 0 && (r.push(n), o += n.byteLength), t || a <= o)
        do
          ({ cmd: s, size: a } = yield c());
        while (a < o);
    while (!t);
  } catch (d) {
    (i = !0) && typeof l.throw == "function" && l.throw(d);
  } finally {
    i === !1 && typeof l.return == "function" && l.return(null);
  }
  return null;
}
function tV(e) {
  return jr(this, arguments, function* () {
    let i, r = !1, n = [], s, a, o, c = 0;
    function l() {
      return a === "peek" ? Da(n, o)[0] : ([s, n, c] = Da(n, o), s);
    }
    ({ cmd: a, size: o } = yield yield Vt(null));
    const d = K9(e)[Symbol.asyncIterator]();
    try {
      do
        if ({ done: i, value: s } = Number.isNaN(o - c) ? yield Vt(d.next()) : yield Vt(d.next(o - c)), !i && s.byteLength > 0 && (n.push(s), c += s.byteLength), i || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(l()));
          while (o < c);
      while (!i);
    } catch (u) {
      (r = !0) && typeof d.throw == "function" && (yield Vt(d.throw(u)));
    } finally {
      r === !1 && typeof d.return == "function" && (yield Vt(d.return(new Uint8Array(0))));
    }
    return yield Vt(null);
  });
}
function eV(e) {
  return jr(this, arguments, function* () {
    let i = !1, r = !1, n = [], s, a, o, c = 0;
    function l() {
      return a === "peek" ? Da(n, o)[0] : ([s, n, c] = Da(n, o), s);
    }
    ({ cmd: a, size: o } = yield yield Vt(null));
    const d = new iV(e);
    try {
      do
        if ({ done: i, value: s } = Number.isNaN(o - c) ? yield Vt(d.read()) : yield Vt(d.read(o - c)), !i && s.byteLength > 0 && (n.push(Ti(s)), c += s.byteLength), i || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(l()));
          while (o < c);
      while (!i);
    } catch (u) {
      (r = !0) && (yield Vt(d.cancel(u)));
    } finally {
      r === !1 ? yield Vt(d.cancel()) : e.locked && d.releaseLock();
    }
    return yield Vt(null);
  });
}
let iV = class {
  constructor(t) {
    this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader.closed.catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    this.reader && this.reader.releaseLock(), this.reader = null;
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      const { reader: i, source: r } = this;
      i && (yield i.cancel(t).catch(() => {
      })), r && r.locked && this.releaseLock();
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      if (t === 0)
        return { done: this.reader == null, value: new Uint8Array(0) };
      const i = yield this.reader.read();
      return !i.done && (i.value = Ti(i)), i;
    });
  }
};
const y_ = (e, t) => {
  const i = (n) => r([t, n]);
  let r;
  return [t, i, new Promise((n) => (r = n) && e.once(t, i))];
};
function rV(e) {
  return jr(this, arguments, function* () {
    const i = [];
    let r = "error", n = !1, s = null, a, o, c = 0, l = [], d;
    function u() {
      return a === "peek" ? Da(l, o)[0] : ([d, l, c] = Da(l, o), d);
    }
    if ({ cmd: a, size: o } = yield yield Vt(null), e.isTTY)
      return yield yield Vt(new Uint8Array(0)), yield Vt(null);
    try {
      i[0] = y_(e, "end"), i[1] = y_(e, "error");
      do {
        if (i[2] = y_(e, "readable"), [r, s] = yield Vt(Promise.race(i.map((p) => p[2]))), r === "error")
          break;
        if ((n = r === "end") || (Number.isFinite(o - c) ? (d = Ti(e.read(o - c)), d.byteLength < o - c && (d = Ti(e.read()))) : d = Ti(e.read()), d.byteLength > 0 && (l.push(d), c += d.byteLength)), n || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(u()));
          while (o < c);
      } while (!n);
    } finally {
      yield Vt(h(i, r === "error" ? s : null));
    }
    return yield Vt(null);
    function h(p, m) {
      return d = l = null, new Promise((w, C) => {
        for (const [F, W] of p)
          e.off(F, W);
        try {
          const F = e.destroy;
          F && F.call(e, m), m = void 0;
        } catch (F) {
          m = F || m;
        } finally {
          m != null ? C(m) : w();
        }
      });
    }
  });
}
var dn;
(function(e) {
  e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
})(dn || (dn = {}));
var En;
(function(e) {
  e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
})(En || (En = {}));
var hn;
(function(e) {
  e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
})(hn || (hn = {}));
var Ks;
(function(e) {
  e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
})(Ks || (Ks = {}));
var ke;
(function(e) {
  e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
})(ke || (ke = {}));
var Na;
(function(e) {
  e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
})(Na || (Na = {}));
var Li;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
})(Li || (Li = {}));
var O;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
})(O || (O = {}));
var oo;
(function(e) {
  e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
})(oo || (oo = {}));
const nV = void 0;
function $l(e) {
  if (e === null)
    return "null";
  if (e === nV)
    return "undefined";
  switch (typeof e) {
    case "number":
      return `${e}`;
    case "bigint":
      return `${e}`;
    case "string":
      return `"${e}"`;
  }
  return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => $l(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, i) => typeof i == "bigint" ? `${i}` : i);
}
const sV = Symbol.for("isArrowBigNum");
function sa(e, ...t) {
  return t.length === 0 ? Object.setPrototypeOf(Wi(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
}
sa.prototype[sV] = !0;
sa.prototype.toJSON = function() {
  return `"${Pf(this)}"`;
};
sa.prototype.valueOf = function() {
  return KE(this);
};
sa.prototype.toString = function() {
  return Pf(this);
};
sa.prototype[Symbol.toPrimitive] = function(e = "default") {
  switch (e) {
    case "number":
      return KE(this);
    case "string":
      return Pf(this);
    case "default":
      return aV(this);
  }
  return Pf(this);
};
function fu(...e) {
  return sa.apply(this, e);
}
function pu(...e) {
  return sa.apply(this, e);
}
function Mf(...e) {
  return sa.apply(this, e);
}
Object.setPrototypeOf(fu.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(pu.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(Mf.prototype, Object.create(Uint32Array.prototype));
Object.assign(fu.prototype, sa.prototype, { constructor: fu, signed: !0, TypedArray: Int32Array, BigIntArray: BigInt64Array });
Object.assign(pu.prototype, sa.prototype, { constructor: pu, signed: !1, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
Object.assign(Mf.prototype, sa.prototype, { constructor: Mf, signed: !0, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
function KE(e) {
  const { buffer: t, byteOffset: i, length: r, signed: n } = e, s = new BigUint64Array(t, i, r), a = n && s.at(-1) & BigInt(1) << BigInt(63);
  let o = BigInt(a ? 1 : 0), c = BigInt(0);
  if (a) {
    for (const l of s)
      o += ~l * (BigInt(1) << BigInt(32) * c++);
    o *= BigInt(-1);
  } else
    for (const l of s)
      o += l * (BigInt(1) << BigInt(32) * c++);
  return o;
}
const Pf = (e) => {
  if (e.byteLength === 8)
    return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
  if (!e.signed)
    return v_(e);
  let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  if (new Int16Array([t.at(-1)])[0] >= 0)
    return v_(e);
  t = t.slice();
  let r = 1;
  for (let s = 0; s < t.length; s++) {
    const a = t[s], o = ~a + r;
    t[s] = o, r &= a === 0 ? 1 : 0;
  }
  return `-${v_(t)}`;
}, aV = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : Pf(e);
function v_(e) {
  let t = "";
  const i = new Uint32Array(2);
  let r = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  const n = new Uint32Array((r = new Uint16Array(r).reverse()).buffer);
  let s = -1;
  const a = r.length - 1;
  do {
    for (i[0] = r[s = 0]; s < a; )
      r[s++] = i[1] = i[0] / 10, i[0] = (i[0] - i[1] * 10 << 16) + r[s];
    r[s] = i[1] = i[0] / 10, i[0] = i[0] - i[1] * 10, t = `${i[0]}${t}`;
  } while (n[0] || n[1] || n[2] || n[3]);
  return t ?? "0";
}
let oV = class JE {
  /** @nocollapse */
  static new(t, i) {
    switch (i) {
      case !0:
        return new fu(t);
      case !1:
        return new pu(t);
    }
    switch (t.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new fu(t);
    }
    return t.byteLength === 16 ? new Mf(t) : new pu(t);
  }
  /** @nocollapse */
  static signed(t) {
    return new fu(t);
  }
  /** @nocollapse */
  static unsigned(t) {
    return new pu(t);
  }
  /** @nocollapse */
  static decimal(t) {
    return new Mf(t);
  }
  constructor(t, i) {
    return JE.new(t, i);
  }
};
function Js(e) {
  if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
    throw new TypeError(`${e} is not safe to convert to a number.`);
  return Number(e);
}
var QE, tk, ek, ik, rk, nk, sk, ak, ok, ck, lk, dk, uk, hk, fk, pk, mk, gk, yk, vk;
let Ie = class fb {
  /** @nocollapse */
  static isNull(t) {
    return (t == null ? void 0 : t.typeId) === O.Null;
  }
  /** @nocollapse */
  static isInt(t) {
    return (t == null ? void 0 : t.typeId) === O.Int;
  }
  /** @nocollapse */
  static isFloat(t) {
    return (t == null ? void 0 : t.typeId) === O.Float;
  }
  /** @nocollapse */
  static isBinary(t) {
    return (t == null ? void 0 : t.typeId) === O.Binary;
  }
  /** @nocollapse */
  static isUtf8(t) {
    return (t == null ? void 0 : t.typeId) === O.Utf8;
  }
  /** @nocollapse */
  static isBool(t) {
    return (t == null ? void 0 : t.typeId) === O.Bool;
  }
  /** @nocollapse */
  static isDecimal(t) {
    return (t == null ? void 0 : t.typeId) === O.Decimal;
  }
  /** @nocollapse */
  static isDate(t) {
    return (t == null ? void 0 : t.typeId) === O.Date;
  }
  /** @nocollapse */
  static isTime(t) {
    return (t == null ? void 0 : t.typeId) === O.Time;
  }
  /** @nocollapse */
  static isTimestamp(t) {
    return (t == null ? void 0 : t.typeId) === O.Timestamp;
  }
  /** @nocollapse */
  static isInterval(t) {
    return (t == null ? void 0 : t.typeId) === O.Interval;
  }
  /** @nocollapse */
  static isDuration(t) {
    return (t == null ? void 0 : t.typeId) === O.Duration;
  }
  /** @nocollapse */
  static isList(t) {
    return (t == null ? void 0 : t.typeId) === O.List;
  }
  /** @nocollapse */
  static isStruct(t) {
    return (t == null ? void 0 : t.typeId) === O.Struct;
  }
  /** @nocollapse */
  static isUnion(t) {
    return (t == null ? void 0 : t.typeId) === O.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(t) {
    return (t == null ? void 0 : t.typeId) === O.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(t) {
    return (t == null ? void 0 : t.typeId) === O.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(t) {
    return (t == null ? void 0 : t.typeId) === O.Map;
  }
  /** @nocollapse */
  static isDictionary(t) {
    return (t == null ? void 0 : t.typeId) === O.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(t) {
    return fb.isUnion(t) && t.mode === En.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(t) {
    return fb.isUnion(t) && t.mode === En.Sparse;
  }
  get typeId() {
    return O.NONE;
  }
};
QE = Symbol.toStringTag;
Ie[QE] = ((e) => (e.children = null, e.ArrayType = Array, e[Symbol.toStringTag] = "DataType"))(Ie.prototype);
let Eo = class extends Ie {
  toString() {
    return "Null";
  }
  get typeId() {
    return O.Null;
  }
};
tk = Symbol.toStringTag;
Eo[tk] = ((e) => e[Symbol.toStringTag] = "Null")(Eo.prototype);
let kn = class extends Ie {
  constructor(t, i) {
    super(), this.isSigned = t, this.bitWidth = i;
  }
  get typeId() {
    return O.Int;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
  }
};
ek = Symbol.toStringTag;
kn[ek] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(kn.prototype);
class U1 extends kn {
  constructor() {
    super(!0, 8);
  }
  get ArrayType() {
    return Int8Array;
  }
}
class V1 extends kn {
  constructor() {
    super(!0, 16);
  }
  get ArrayType() {
    return Int16Array;
  }
}
let Ic = class extends kn {
  constructor() {
    super(!0, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
}, j1 = class extends kn {
  constructor() {
    super(!0, 64);
  }
  get ArrayType() {
    return BigInt64Array;
  }
};
class G1 extends kn {
  constructor() {
    super(!1, 8);
  }
  get ArrayType() {
    return Uint8Array;
  }
}
class H1 extends kn {
  constructor() {
    super(!1, 16);
  }
  get ArrayType() {
    return Uint16Array;
  }
}
class W1 extends kn {
  constructor() {
    super(!1, 32);
  }
  get ArrayType() {
    return Uint32Array;
  }
}
let Y1 = class extends kn {
  constructor() {
    super(!1, 64);
  }
  get ArrayType() {
    return BigUint64Array;
  }
};
Object.defineProperty(U1.prototype, "ArrayType", { value: Int8Array });
Object.defineProperty(V1.prototype, "ArrayType", { value: Int16Array });
Object.defineProperty(Ic.prototype, "ArrayType", { value: Int32Array });
Object.defineProperty(j1.prototype, "ArrayType", { value: BigInt64Array });
Object.defineProperty(G1.prototype, "ArrayType", { value: Uint8Array });
Object.defineProperty(H1.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(W1.prototype, "ArrayType", { value: Uint32Array });
Object.defineProperty(Y1.prototype, "ArrayType", { value: BigUint64Array });
let Ac = class extends Ie {
  constructor(t) {
    super(), this.precision = t;
  }
  get typeId() {
    return O.Float;
  }
  get ArrayType() {
    switch (this.precision) {
      case hn.HALF:
        return Uint16Array;
      case hn.SINGLE:
        return Float32Array;
      case hn.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
};
ik = Symbol.toStringTag;
Ac[ik] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(Ac.prototype);
class _k extends Ac {
  constructor() {
    super(hn.HALF);
  }
}
class q1 extends Ac {
  constructor() {
    super(hn.SINGLE);
  }
}
class Z1 extends Ac {
  constructor() {
    super(hn.DOUBLE);
  }
}
Object.defineProperty(_k.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(q1.prototype, "ArrayType", { value: Float32Array });
Object.defineProperty(Z1.prototype, "ArrayType", { value: Float64Array });
let $f = class extends Ie {
  constructor() {
    super();
  }
  get typeId() {
    return O.Binary;
  }
  toString() {
    return "Binary";
  }
};
rk = Symbol.toStringTag;
$f[rk] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))($f.prototype);
let Fu = class extends Ie {
  constructor() {
    super();
  }
  get typeId() {
    return O.Utf8;
  }
  toString() {
    return "Utf8";
  }
};
nk = Symbol.toStringTag;
Fu[nk] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(Fu.prototype);
let zf = class extends Ie {
  constructor() {
    super();
  }
  get typeId() {
    return O.Bool;
  }
  toString() {
    return "Bool";
  }
};
sk = Symbol.toStringTag;
zf[sk] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(zf.prototype);
let Yg = class extends Ie {
  constructor(t, i, r = 128) {
    super(), this.scale = t, this.precision = i, this.bitWidth = r;
  }
  get typeId() {
    return O.Decimal;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
  }
};
ak = Symbol.toStringTag;
Yg[ak] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(Yg.prototype);
let Bu = class extends Ie {
  constructor(t) {
    super(), this.unit = t;
  }
  get typeId() {
    return O.Date;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${Ks[this.unit]}>`;
  }
};
ok = Symbol.toStringTag;
Bu[ok] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(Bu.prototype);
class cV extends Bu {
  constructor() {
    super(Ks.DAY);
  }
}
class lV extends Bu {
  constructor() {
    super(Ks.MILLISECOND);
  }
}
let ko = class extends Ie {
  constructor(t, i) {
    super(), this.unit = t, this.bitWidth = i;
  }
  get typeId() {
    return O.Time;
  }
  toString() {
    return `Time${this.bitWidth}<${ke[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
};
ck = Symbol.toStringTag;
ko[ck] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(ko.prototype);
class dV extends ko {
  constructor() {
    super(ke.SECOND, 32);
  }
}
class uV extends ko {
  constructor() {
    super(ke.MILLISECOND, 32);
  }
}
class hV extends ko {
  constructor() {
    super(ke.MICROSECOND, 64);
  }
}
class fV extends ko {
  constructor() {
    super(ke.NANOSECOND, 64);
  }
}
let qg = class extends Ie {
  constructor(t, i) {
    super(), this.unit = t, this.timezone = i;
  }
  get typeId() {
    return O.Timestamp;
  }
  toString() {
    return `Timestamp<${ke[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
  }
};
lk = Symbol.toStringTag;
qg[lk] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(qg.prototype);
let Ru = class extends Ie {
  constructor(t) {
    super(), this.unit = t;
  }
  get typeId() {
    return O.Interval;
  }
  toString() {
    return `Interval<${Na[this.unit]}>`;
  }
};
dk = Symbol.toStringTag;
Ru[dk] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(Ru.prototype);
class pV extends Ru {
  constructor() {
    super(Na.DAY_TIME);
  }
}
class mV extends Ru {
  constructor() {
    super(Na.YEAR_MONTH);
  }
}
let Zg = class extends Ie {
  constructor(t) {
    super(), this.unit = t;
  }
  get typeId() {
    return O.Duration;
  }
  toString() {
    return `Duration<${ke[this.unit]}>`;
  }
};
uk = Symbol.toStringTag;
Zg[uk] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(Zg.prototype);
let Mu = class extends Ie {
  constructor(t) {
    super(), this.children = [t];
  }
  get typeId() {
    return O.List;
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
};
hk = Symbol.toStringTag;
Mu[hk] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(Mu.prototype);
let un = class extends Ie {
  constructor(t) {
    super(), this.children = t;
  }
  get typeId() {
    return O.Struct;
  }
  toString() {
    return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
};
fk = Symbol.toStringTag;
un[fk] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(un.prototype);
let Uf = class extends Ie {
  constructor(t, i, r) {
    super(), this.mode = t, this.children = r, this.typeIds = i = Int32Array.from(i), this.typeIdToChildIndex = i.reduce((n, s, a) => (n[s] = a) && n || n, /* @__PURE__ */ Object.create(null));
  }
  get typeId() {
    return O.Union;
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
  }
};
pk = Symbol.toStringTag;
Uf[pk] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(Uf.prototype);
let Xg = class extends Ie {
  constructor(t) {
    super(), this.byteWidth = t;
  }
  get typeId() {
    return O.FixedSizeBinary;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
};
mk = Symbol.toStringTag;
Xg[mk] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(Xg.prototype);
let Pu = class extends Ie {
  constructor(t, i) {
    super(), this.listSize = t, this.children = [i];
  }
  get typeId() {
    return O.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
};
gk = Symbol.toStringTag;
Pu[gk] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(Pu.prototype);
let Vf = class extends Ie {
  constructor(t, i = !1) {
    var r, n, s;
    if (super(), this.children = [t], this.keysSorted = i, t && (t.name = "entries", !((r = t == null ? void 0 : t.type) === null || r === void 0) && r.children)) {
      const a = (n = t == null ? void 0 : t.type) === null || n === void 0 ? void 0 : n.children[0];
      a && (a.name = "key");
      const o = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
      o && (o.name = "value");
    }
  }
  get typeId() {
    return O.Map;
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
};
yk = Symbol.toStringTag;
Vf[yk] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))(Vf.prototype);
const gV = /* @__PURE__ */ ((e) => () => ++e)(-1);
let Tc = class extends Ie {
  constructor(t, i, r, n) {
    super(), this.indices = i, this.dictionary = t, this.isOrdered = n || !1, this.id = r == null ? gV() : Js(r);
  }
  get typeId() {
    return O.Dictionary;
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
};
vk = Symbol.toStringTag;
Tc[vk] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Tc.prototype);
function xa(e) {
  const t = e;
  switch (e.typeId) {
    case O.Decimal:
      return e.bitWidth / 32;
    case O.Timestamp:
      return 2;
    case O.Date:
      return 1 + t.unit;
    case O.Interval:
      return 1 + t.unit;
    case O.FixedSizeList:
      return t.listSize;
    case O.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}
let ti = class {
  visitMany(t, ...i) {
    return t.map((r, n) => this.visit(r, ...i.map((s) => s[n])));
  }
  visit(...t) {
    return this.getVisitFn(t[0], !1).apply(this, t);
  }
  getVisitFn(t, i = !0) {
    return yV(this, t, i);
  }
  getVisitFnByTypeId(t, i = !0) {
    return Fd(this, t, i);
  }
  visitNull(t, ...i) {
    return null;
  }
  visitBool(t, ...i) {
    return null;
  }
  visitInt(t, ...i) {
    return null;
  }
  visitFloat(t, ...i) {
    return null;
  }
  visitUtf8(t, ...i) {
    return null;
  }
  visitBinary(t, ...i) {
    return null;
  }
  visitFixedSizeBinary(t, ...i) {
    return null;
  }
  visitDate(t, ...i) {
    return null;
  }
  visitTimestamp(t, ...i) {
    return null;
  }
  visitTime(t, ...i) {
    return null;
  }
  visitDecimal(t, ...i) {
    return null;
  }
  visitList(t, ...i) {
    return null;
  }
  visitStruct(t, ...i) {
    return null;
  }
  visitUnion(t, ...i) {
    return null;
  }
  visitDictionary(t, ...i) {
    return null;
  }
  visitInterval(t, ...i) {
    return null;
  }
  visitDuration(t, ...i) {
    return null;
  }
  visitFixedSizeList(t, ...i) {
    return null;
  }
  visitMap(t, ...i) {
    return null;
  }
};
function yV(e, t, i = !0) {
  return typeof t == "number" ? Fd(e, t, i) : typeof t == "string" && t in O ? Fd(e, O[t], i) : t && t instanceof Ie ? Fd(e, hA(t), i) : t != null && t.type && t.type instanceof Ie ? Fd(e, hA(t.type), i) : Fd(e, O.NONE, i);
}
function Fd(e, t, i = !0) {
  let r = null;
  switch (t) {
    case O.Null:
      r = e.visitNull;
      break;
    case O.Bool:
      r = e.visitBool;
      break;
    case O.Int:
      r = e.visitInt;
      break;
    case O.Int8:
      r = e.visitInt8 || e.visitInt;
      break;
    case O.Int16:
      r = e.visitInt16 || e.visitInt;
      break;
    case O.Int32:
      r = e.visitInt32 || e.visitInt;
      break;
    case O.Int64:
      r = e.visitInt64 || e.visitInt;
      break;
    case O.Uint8:
      r = e.visitUint8 || e.visitInt;
      break;
    case O.Uint16:
      r = e.visitUint16 || e.visitInt;
      break;
    case O.Uint32:
      r = e.visitUint32 || e.visitInt;
      break;
    case O.Uint64:
      r = e.visitUint64 || e.visitInt;
      break;
    case O.Float:
      r = e.visitFloat;
      break;
    case O.Float16:
      r = e.visitFloat16 || e.visitFloat;
      break;
    case O.Float32:
      r = e.visitFloat32 || e.visitFloat;
      break;
    case O.Float64:
      r = e.visitFloat64 || e.visitFloat;
      break;
    case O.Utf8:
      r = e.visitUtf8;
      break;
    case O.Binary:
      r = e.visitBinary;
      break;
    case O.FixedSizeBinary:
      r = e.visitFixedSizeBinary;
      break;
    case O.Date:
      r = e.visitDate;
      break;
    case O.DateDay:
      r = e.visitDateDay || e.visitDate;
      break;
    case O.DateMillisecond:
      r = e.visitDateMillisecond || e.visitDate;
      break;
    case O.Timestamp:
      r = e.visitTimestamp;
      break;
    case O.TimestampSecond:
      r = e.visitTimestampSecond || e.visitTimestamp;
      break;
    case O.TimestampMillisecond:
      r = e.visitTimestampMillisecond || e.visitTimestamp;
      break;
    case O.TimestampMicrosecond:
      r = e.visitTimestampMicrosecond || e.visitTimestamp;
      break;
    case O.TimestampNanosecond:
      r = e.visitTimestampNanosecond || e.visitTimestamp;
      break;
    case O.Time:
      r = e.visitTime;
      break;
    case O.TimeSecond:
      r = e.visitTimeSecond || e.visitTime;
      break;
    case O.TimeMillisecond:
      r = e.visitTimeMillisecond || e.visitTime;
      break;
    case O.TimeMicrosecond:
      r = e.visitTimeMicrosecond || e.visitTime;
      break;
    case O.TimeNanosecond:
      r = e.visitTimeNanosecond || e.visitTime;
      break;
    case O.Decimal:
      r = e.visitDecimal;
      break;
    case O.List:
      r = e.visitList;
      break;
    case O.Struct:
      r = e.visitStruct;
      break;
    case O.Union:
      r = e.visitUnion;
      break;
    case O.DenseUnion:
      r = e.visitDenseUnion || e.visitUnion;
      break;
    case O.SparseUnion:
      r = e.visitSparseUnion || e.visitUnion;
      break;
    case O.Dictionary:
      r = e.visitDictionary;
      break;
    case O.Interval:
      r = e.visitInterval;
      break;
    case O.IntervalDayTime:
      r = e.visitIntervalDayTime || e.visitInterval;
      break;
    case O.IntervalYearMonth:
      r = e.visitIntervalYearMonth || e.visitInterval;
      break;
    case O.Duration:
      r = e.visitDuration;
      break;
    case O.DurationSecond:
      r = e.visitDurationSecond || e.visitDuration;
      break;
    case O.DurationMillisecond:
      r = e.visitDurationMillisecond || e.visitDuration;
      break;
    case O.DurationMicrosecond:
      r = e.visitDurationMicrosecond || e.visitDuration;
      break;
    case O.DurationNanosecond:
      r = e.visitDurationNanosecond || e.visitDuration;
      break;
    case O.FixedSizeList:
      r = e.visitFixedSizeList;
      break;
    case O.Map:
      r = e.visitMap;
      break;
  }
  if (typeof r == "function")
    return r;
  if (!i)
    return () => null;
  throw new Error(`Unrecognized type '${O[t]}'`);
}
function hA(e) {
  switch (e.typeId) {
    case O.Null:
      return O.Null;
    case O.Int: {
      const { bitWidth: t, isSigned: i } = e;
      switch (t) {
        case 8:
          return i ? O.Int8 : O.Uint8;
        case 16:
          return i ? O.Int16 : O.Uint16;
        case 32:
          return i ? O.Int32 : O.Uint32;
        case 64:
          return i ? O.Int64 : O.Uint64;
      }
      return O.Int;
    }
    case O.Float:
      switch (e.precision) {
        case hn.HALF:
          return O.Float16;
        case hn.SINGLE:
          return O.Float32;
        case hn.DOUBLE:
          return O.Float64;
      }
      return O.Float;
    case O.Binary:
      return O.Binary;
    case O.Utf8:
      return O.Utf8;
    case O.Bool:
      return O.Bool;
    case O.Decimal:
      return O.Decimal;
    case O.Time:
      switch (e.unit) {
        case ke.SECOND:
          return O.TimeSecond;
        case ke.MILLISECOND:
          return O.TimeMillisecond;
        case ke.MICROSECOND:
          return O.TimeMicrosecond;
        case ke.NANOSECOND:
          return O.TimeNanosecond;
      }
      return O.Time;
    case O.Timestamp:
      switch (e.unit) {
        case ke.SECOND:
          return O.TimestampSecond;
        case ke.MILLISECOND:
          return O.TimestampMillisecond;
        case ke.MICROSECOND:
          return O.TimestampMicrosecond;
        case ke.NANOSECOND:
          return O.TimestampNanosecond;
      }
      return O.Timestamp;
    case O.Date:
      switch (e.unit) {
        case Ks.DAY:
          return O.DateDay;
        case Ks.MILLISECOND:
          return O.DateMillisecond;
      }
      return O.Date;
    case O.Interval:
      switch (e.unit) {
        case Na.DAY_TIME:
          return O.IntervalDayTime;
        case Na.YEAR_MONTH:
          return O.IntervalYearMonth;
      }
      return O.Interval;
    case O.Duration:
      switch (e.unit) {
        case ke.SECOND:
          return O.DurationSecond;
        case ke.MILLISECOND:
          return O.DurationMillisecond;
        case ke.MICROSECOND:
          return O.DurationMicrosecond;
        case ke.NANOSECOND:
          return O.DurationNanosecond;
      }
      return O.Duration;
    case O.Map:
      return O.Map;
    case O.List:
      return O.List;
    case O.Struct:
      return O.Struct;
    case O.Union:
      switch (e.mode) {
        case En.Dense:
          return O.DenseUnion;
        case En.Sparse:
          return O.SparseUnion;
      }
      return O.Union;
    case O.FixedSizeBinary:
      return O.FixedSizeBinary;
    case O.FixedSizeList:
      return O.FixedSizeList;
    case O.Dictionary:
      return O.Dictionary;
  }
  throw new Error(`Unrecognized type '${O[e.typeId]}'`);
}
ti.prototype.visitInt8 = null;
ti.prototype.visitInt16 = null;
ti.prototype.visitInt32 = null;
ti.prototype.visitInt64 = null;
ti.prototype.visitUint8 = null;
ti.prototype.visitUint16 = null;
ti.prototype.visitUint32 = null;
ti.prototype.visitUint64 = null;
ti.prototype.visitFloat16 = null;
ti.prototype.visitFloat32 = null;
ti.prototype.visitFloat64 = null;
ti.prototype.visitDateDay = null;
ti.prototype.visitDateMillisecond = null;
ti.prototype.visitTimestampSecond = null;
ti.prototype.visitTimestampMillisecond = null;
ti.prototype.visitTimestampMicrosecond = null;
ti.prototype.visitTimestampNanosecond = null;
ti.prototype.visitTimeSecond = null;
ti.prototype.visitTimeMillisecond = null;
ti.prototype.visitTimeMicrosecond = null;
ti.prototype.visitTimeNanosecond = null;
ti.prototype.visitDenseUnion = null;
ti.prototype.visitSparseUnion = null;
ti.prototype.visitIntervalDayTime = null;
ti.prototype.visitIntervalYearMonth = null;
ti.prototype.visitDuration = null;
ti.prototype.visitDurationSecond = null;
ti.prototype.visitDurationMillisecond = null;
ti.prototype.visitDurationMicrosecond = null;
ti.prototype.visitDurationNanosecond = null;
const bk = new Float64Array(1), Cd = new Uint32Array(bk.buffer);
function xk(e) {
  const t = (e & 31744) >> 10, i = (e & 1023) / 1024, r = Math.pow(-1, (e & 32768) >> 15);
  switch (t) {
    case 31:
      return r * (i ? Number.NaN : 1 / 0);
    case 0:
      return r * (i ? 6103515625e-14 * i : 0);
  }
  return r * Math.pow(2, t - 15) * (1 + i);
}
function wk(e) {
  if (e !== e)
    return 32256;
  bk[0] = e;
  const t = (Cd[1] & 2147483648) >> 16 & 65535;
  let i = Cd[1] & 2146435072, r = 0;
  return i >= 1089470464 ? Cd[0] > 0 ? i = 31744 : (i = (i & 2080374784) >> 16, r = (Cd[1] & 1048575) >> 10) : i <= 1056964608 ? (r = 1048576 + (Cd[1] & 1048575), r = 1048576 + (r << (i >> 20) - 998) >> 21, i = 0) : (i = i - 1056964608 >> 10, r = (Cd[1] & 1048575) + 512 >> 10), t | i | r & 65535;
}
let Fe = class extends ti {
};
function $e(e) {
  return (t, i, r) => {
    if (t.setValid(i, r != null))
      return e(t, i, r);
  };
}
const vV = (e, t, i) => {
  e[t] = Math.trunc(i / 864e5);
}, X1 = (e, t, i) => {
  e[t] = Math.trunc(i % 4294967296), e[t + 1] = Math.trunc(i / 4294967296);
}, _V = (e, t, i) => {
  e[t] = Math.trunc(i * 1e3 % 4294967296), e[t + 1] = Math.trunc(i * 1e3 / 4294967296);
}, bV = (e, t, i) => {
  e[t] = Math.trunc(i * 1e6 % 4294967296), e[t + 1] = Math.trunc(i * 1e6 / 4294967296);
}, Sk = (e, t, i, r) => {
  if (i + 1 < t.length) {
    const { [i]: n, [i + 1]: s } = t;
    e.set(r.subarray(0, s - n), n);
  }
}, xV = ({ offset: e, values: t }, i, r) => {
  const n = e + i;
  r ? t[n >> 3] |= 1 << n % 8 : t[n >> 3] &= ~(1 << n % 8);
}, $o = ({ values: e }, t, i) => {
  e[t] = i;
}, K1 = ({ values: e }, t, i) => {
  e[t] = i;
}, Ik = ({ values: e }, t, i) => {
  e[t] = wk(i);
}, wV = (e, t, i) => {
  switch (e.type.precision) {
    case hn.HALF:
      return Ik(e, t, i);
    case hn.SINGLE:
    case hn.DOUBLE:
      return K1(e, t, i);
  }
}, J1 = ({ values: e }, t, i) => {
  vV(e, t, i.valueOf());
}, Q1 = ({ values: e }, t, i) => {
  X1(e, t * 2, i.valueOf());
}, Ak = ({ stride: e, values: t }, i, r) => {
  t.set(r.subarray(0, e), e * i);
}, SV = ({ values: e, valueOffsets: t }, i, r) => Sk(e, t, i, r), IV = ({ values: e, valueOffsets: t }, i, r) => {
  Sk(e, t, i, xy(r));
}, Tk = (e, t, i) => {
  e.type.unit === Ks.DAY ? J1(e, t, i) : Q1(e, t, i);
}, tx = ({ values: e }, t, i) => X1(e, t * 2, i / 1e3), ex = ({ values: e }, t, i) => X1(e, t * 2, i), ix = ({ values: e }, t, i) => _V(e, t * 2, i), rx = ({ values: e }, t, i) => bV(e, t * 2, i), Ek = (e, t, i) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return tx(e, t, i);
    case ke.MILLISECOND:
      return ex(e, t, i);
    case ke.MICROSECOND:
      return ix(e, t, i);
    case ke.NANOSECOND:
      return rx(e, t, i);
  }
}, nx = ({ values: e }, t, i) => {
  e[t] = i;
}, sx = ({ values: e }, t, i) => {
  e[t] = i;
}, ax = ({ values: e }, t, i) => {
  e[t] = i;
}, ox = ({ values: e }, t, i) => {
  e[t] = i;
}, kk = (e, t, i) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return nx(e, t, i);
    case ke.MILLISECOND:
      return sx(e, t, i);
    case ke.MICROSECOND:
      return ax(e, t, i);
    case ke.NANOSECOND:
      return ox(e, t, i);
  }
}, Ck = ({ values: e, stride: t }, i, r) => {
  e.set(r.subarray(0, t), t * i);
}, AV = (e, t, i) => {
  const r = e.children[0], n = e.valueOffsets, s = Is.getVisitFn(r);
  if (Array.isArray(i))
    for (let a = -1, o = n[t], c = n[t + 1]; o < c; )
      s(r, o++, i[++a]);
  else
    for (let a = -1, o = n[t], c = n[t + 1]; o < c; )
      s(r, o++, i.get(++a));
}, TV = (e, t, i) => {
  const r = e.children[0], { valueOffsets: n } = e, s = Is.getVisitFn(r);
  let { [t]: a, [t + 1]: o } = n;
  const c = i instanceof Map ? i.entries() : Object.entries(i);
  for (const l of c)
    if (s(r, a, l), ++a >= o)
      break;
}, EV = (e, t) => (i, r, n, s) => r && i(r, e, t[s]), kV = (e, t) => (i, r, n, s) => r && i(r, e, t.get(s)), CV = (e, t) => (i, r, n, s) => r && i(r, e, t.get(n.name)), OV = (e, t) => (i, r, n, s) => r && i(r, e, t[n.name]), DV = (e, t, i) => {
  const r = e.type.children.map((s) => Is.getVisitFn(s.type)), n = i instanceof Map ? CV(t, i) : i instanceof Ki ? kV(t, i) : Array.isArray(i) ? EV(t, i) : OV(t, i);
  e.type.children.forEach((s, a) => n(r[a], e.children[a], s, a));
}, NV = (e, t, i) => {
  e.type.mode === En.Dense ? Ok(e, t, i) : Dk(e, t, i);
}, Ok = (e, t, i) => {
  const r = e.type.typeIdToChildIndex[e.typeIds[t]], n = e.children[r];
  Is.visit(n, e.valueOffsets[t], i);
}, Dk = (e, t, i) => {
  const r = e.type.typeIdToChildIndex[e.typeIds[t]], n = e.children[r];
  Is.visit(n, t, i);
}, LV = (e, t, i) => {
  var r;
  (r = e.dictionary) === null || r === void 0 || r.set(e.values[t], i);
}, Nk = (e, t, i) => {
  e.type.unit === Na.DAY_TIME ? cx(e, t, i) : lx(e, t, i);
}, cx = ({ values: e }, t, i) => {
  e.set(i.subarray(0, 2), 2 * t);
}, lx = ({ values: e }, t, i) => {
  e[t] = i[0] * 12 + i[1] % 12;
}, dx = ({ values: e }, t, i) => {
  e[t] = i;
}, ux = ({ values: e }, t, i) => {
  e[t] = i;
}, hx = ({ values: e }, t, i) => {
  e[t] = i;
}, fx = ({ values: e }, t, i) => {
  e[t] = i;
}, Lk = (e, t, i) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return dx(e, t, i);
    case ke.MILLISECOND:
      return ux(e, t, i);
    case ke.MICROSECOND:
      return hx(e, t, i);
    case ke.NANOSECOND:
      return fx(e, t, i);
  }
}, FV = (e, t, i) => {
  const { stride: r } = e, n = e.children[0], s = Is.getVisitFn(n);
  if (Array.isArray(i))
    for (let a = -1, o = t * r; ++a < r; )
      s(n, o + a, i[a]);
  else
    for (let a = -1, o = t * r; ++a < r; )
      s(n, o + a, i.get(a));
};
Fe.prototype.visitBool = $e(xV);
Fe.prototype.visitInt = $e($o);
Fe.prototype.visitInt8 = $e($o);
Fe.prototype.visitInt16 = $e($o);
Fe.prototype.visitInt32 = $e($o);
Fe.prototype.visitInt64 = $e($o);
Fe.prototype.visitUint8 = $e($o);
Fe.prototype.visitUint16 = $e($o);
Fe.prototype.visitUint32 = $e($o);
Fe.prototype.visitUint64 = $e($o);
Fe.prototype.visitFloat = $e(wV);
Fe.prototype.visitFloat16 = $e(Ik);
Fe.prototype.visitFloat32 = $e(K1);
Fe.prototype.visitFloat64 = $e(K1);
Fe.prototype.visitUtf8 = $e(IV);
Fe.prototype.visitBinary = $e(SV);
Fe.prototype.visitFixedSizeBinary = $e(Ak);
Fe.prototype.visitDate = $e(Tk);
Fe.prototype.visitDateDay = $e(J1);
Fe.prototype.visitDateMillisecond = $e(Q1);
Fe.prototype.visitTimestamp = $e(Ek);
Fe.prototype.visitTimestampSecond = $e(tx);
Fe.prototype.visitTimestampMillisecond = $e(ex);
Fe.prototype.visitTimestampMicrosecond = $e(ix);
Fe.prototype.visitTimestampNanosecond = $e(rx);
Fe.prototype.visitTime = $e(kk);
Fe.prototype.visitTimeSecond = $e(nx);
Fe.prototype.visitTimeMillisecond = $e(sx);
Fe.prototype.visitTimeMicrosecond = $e(ax);
Fe.prototype.visitTimeNanosecond = $e(ox);
Fe.prototype.visitDecimal = $e(Ck);
Fe.prototype.visitList = $e(AV);
Fe.prototype.visitStruct = $e(DV);
Fe.prototype.visitUnion = $e(NV);
Fe.prototype.visitDenseUnion = $e(Ok);
Fe.prototype.visitSparseUnion = $e(Dk);
Fe.prototype.visitDictionary = $e(LV);
Fe.prototype.visitInterval = $e(Nk);
Fe.prototype.visitIntervalDayTime = $e(cx);
Fe.prototype.visitIntervalYearMonth = $e(lx);
Fe.prototype.visitDuration = $e(Lk);
Fe.prototype.visitDurationSecond = $e(dx);
Fe.prototype.visitDurationMillisecond = $e(ux);
Fe.prototype.visitDurationMicrosecond = $e(hx);
Fe.prototype.visitDurationNanosecond = $e(fx);
Fe.prototype.visitFixedSizeList = $e(FV);
Fe.prototype.visitMap = $e(TV);
const Is = new Fe(), Rs = Symbol.for("parent"), mu = Symbol.for("rowIndex");
let px = class {
  constructor(t, i) {
    return this[Rs] = t, this[mu] = i, new Proxy(this, new RV());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[mu], i = this[Rs], r = i.type.children, n = {};
    for (let s = -1, a = r.length; ++s < a; )
      n[r[s].name] = jn.visit(i.children[s], t);
    return n;
  }
  toString() {
    return `{${[...this].map(([t, i]) => `${$l(t)}: ${$l(i)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new BV(this[Rs], this[mu]);
  }
}, BV = class {
  constructor(t, i) {
    this.childIndex = 0, this.children = t.children, this.rowIndex = i, this.childFields = t.type.children, this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.childIndex;
    return t < this.numChildren ? (this.childIndex = t + 1, {
      done: !1,
      value: [
        this.childFields[t].name,
        jn.visit(this.children[t], this.rowIndex)
      ]
    }) : { done: !0, value: null };
  }
};
Object.defineProperties(px.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [Rs]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [mu]: { writable: !0, enumerable: !1, configurable: !1, value: -1 }
});
let RV = class {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[Rs].type.children.map((i) => i.name);
  }
  has(t, i) {
    return t[Rs].type.children.findIndex((r) => r.name === i) !== -1;
  }
  getOwnPropertyDescriptor(t, i) {
    if (t[Rs].type.children.findIndex((r) => r.name === i) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, i) {
    if (Reflect.has(t, i))
      return t[i];
    const r = t[Rs].type.children.findIndex((n) => n.name === i);
    if (r !== -1) {
      const n = jn.visit(t[Rs].children[r], t[mu]);
      return Reflect.set(t, i, n), n;
    }
  }
  set(t, i, r) {
    const n = t[Rs].type.children.findIndex((s) => s.name === i);
    return n !== -1 ? (Is.visit(t[Rs].children[n], t[mu], r), Reflect.set(t, i, r)) : Reflect.has(t, i) || typeof i == "symbol" ? Reflect.set(t, i, r) : !1;
  }
}, Ce = class extends ti {
};
function Be(e) {
  return (t, i) => t.getValid(i) ? e(t, i) : null;
}
const MV = (e, t) => 864e5 * e[t], mx = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0), PV = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3, $V = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6, Fk = (e) => new Date(e), zV = (e, t) => Fk(MV(e, t)), UV = (e, t) => Fk(mx(e, t)), VV = (e, t) => null, Bk = (e, t, i) => {
  if (i + 1 >= t.length)
    return null;
  const r = t[i], n = t[i + 1];
  return e.subarray(r, n);
}, jV = ({ offset: e, values: t }, i) => {
  const r = e + i;
  return (t[r >> 3] & 1 << r % 8) !== 0;
}, Rk = ({ values: e }, t) => zV(e, t), Mk = ({ values: e }, t) => UV(e, t * 2), Vc = ({ stride: e, values: t }, i) => t[e * i], GV = ({ stride: e, values: t }, i) => xk(t[e * i]), Pk = ({ values: e }, t) => e[t], HV = ({ stride: e, values: t }, i) => t.subarray(e * i, e * (i + 1)), WV = ({ values: e, valueOffsets: t }, i) => Bk(e, t, i), YV = ({ values: e, valueOffsets: t }, i) => {
  const r = Bk(e, t, i);
  return r !== null ? db(r) : null;
}, qV = ({ values: e }, t) => e[t], ZV = ({ type: e, values: t }, i) => e.precision !== hn.HALF ? t[i] : xk(t[i]), XV = (e, t) => e.type.unit === Ks.DAY ? Rk(e, t) : Mk(e, t), $k = ({ values: e }, t) => 1e3 * mx(e, t * 2), zk = ({ values: e }, t) => mx(e, t * 2), Uk = ({ values: e }, t) => PV(e, t * 2), Vk = ({ values: e }, t) => $V(e, t * 2), KV = (e, t) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return $k(e, t);
    case ke.MILLISECOND:
      return zk(e, t);
    case ke.MICROSECOND:
      return Uk(e, t);
    case ke.NANOSECOND:
      return Vk(e, t);
  }
}, jk = ({ values: e }, t) => e[t], Gk = ({ values: e }, t) => e[t], Hk = ({ values: e }, t) => e[t], Wk = ({ values: e }, t) => e[t], JV = (e, t) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return jk(e, t);
    case ke.MILLISECOND:
      return Gk(e, t);
    case ke.MICROSECOND:
      return Hk(e, t);
    case ke.NANOSECOND:
      return Wk(e, t);
  }
}, QV = ({ values: e, stride: t }, i) => oV.decimal(e.subarray(t * i, t * (i + 1))), tj = (e, t) => {
  const { valueOffsets: i, stride: r, children: n } = e, { [t * r]: s, [t * r + 1]: a } = i, c = n[0].slice(s, a - s);
  return new Ki([c]);
}, ej = (e, t) => {
  const { valueOffsets: i, children: r } = e, { [t]: n, [t + 1]: s } = i, a = r[0];
  return new Sy(a.slice(n, s - n));
}, ij = (e, t) => new px(e, t), rj = (e, t) => e.type.mode === En.Dense ? Yk(e, t) : qk(e, t), Yk = (e, t) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  return jn.visit(r, e.valueOffsets[t]);
}, qk = (e, t) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  return jn.visit(r, t);
}, nj = (e, t) => {
  var i;
  return (i = e.dictionary) === null || i === void 0 ? void 0 : i.get(e.values[t]);
}, sj = (e, t) => e.type.unit === Na.DAY_TIME ? Zk(e, t) : Xk(e, t), Zk = ({ values: e }, t) => e.subarray(2 * t, 2 * (t + 1)), Xk = ({ values: e }, t) => {
  const i = e[t], r = new Int32Array(2);
  return r[0] = Math.trunc(i / 12), r[1] = Math.trunc(i % 12), r;
}, Kk = ({ values: e }, t) => e[t], Jk = ({ values: e }, t) => e[t], Qk = ({ values: e }, t) => e[t], tC = ({ values: e }, t) => e[t], aj = (e, t) => {
  switch (e.type.unit) {
    case ke.SECOND:
      return Kk(e, t);
    case ke.MILLISECOND:
      return Jk(e, t);
    case ke.MICROSECOND:
      return Qk(e, t);
    case ke.NANOSECOND:
      return tC(e, t);
  }
}, oj = (e, t) => {
  const { stride: i, children: r } = e, s = r[0].slice(t * i, i);
  return new Ki([s]);
};
Ce.prototype.visitNull = Be(VV);
Ce.prototype.visitBool = Be(jV);
Ce.prototype.visitInt = Be(qV);
Ce.prototype.visitInt8 = Be(Vc);
Ce.prototype.visitInt16 = Be(Vc);
Ce.prototype.visitInt32 = Be(Vc);
Ce.prototype.visitInt64 = Be(Pk);
Ce.prototype.visitUint8 = Be(Vc);
Ce.prototype.visitUint16 = Be(Vc);
Ce.prototype.visitUint32 = Be(Vc);
Ce.prototype.visitUint64 = Be(Pk);
Ce.prototype.visitFloat = Be(ZV);
Ce.prototype.visitFloat16 = Be(GV);
Ce.prototype.visitFloat32 = Be(Vc);
Ce.prototype.visitFloat64 = Be(Vc);
Ce.prototype.visitUtf8 = Be(YV);
Ce.prototype.visitBinary = Be(WV);
Ce.prototype.visitFixedSizeBinary = Be(HV);
Ce.prototype.visitDate = Be(XV);
Ce.prototype.visitDateDay = Be(Rk);
Ce.prototype.visitDateMillisecond = Be(Mk);
Ce.prototype.visitTimestamp = Be(KV);
Ce.prototype.visitTimestampSecond = Be($k);
Ce.prototype.visitTimestampMillisecond = Be(zk);
Ce.prototype.visitTimestampMicrosecond = Be(Uk);
Ce.prototype.visitTimestampNanosecond = Be(Vk);
Ce.prototype.visitTime = Be(JV);
Ce.prototype.visitTimeSecond = Be(jk);
Ce.prototype.visitTimeMillisecond = Be(Gk);
Ce.prototype.visitTimeMicrosecond = Be(Hk);
Ce.prototype.visitTimeNanosecond = Be(Wk);
Ce.prototype.visitDecimal = Be(QV);
Ce.prototype.visitList = Be(tj);
Ce.prototype.visitStruct = Be(ij);
Ce.prototype.visitUnion = Be(rj);
Ce.prototype.visitDenseUnion = Be(Yk);
Ce.prototype.visitSparseUnion = Be(qk);
Ce.prototype.visitDictionary = Be(nj);
Ce.prototype.visitInterval = Be(sj);
Ce.prototype.visitIntervalDayTime = Be(Zk);
Ce.prototype.visitIntervalYearMonth = Be(Xk);
Ce.prototype.visitDuration = Be(aj);
Ce.prototype.visitDurationSecond = Be(Kk);
Ce.prototype.visitDurationMillisecond = Be(Jk);
Ce.prototype.visitDurationMicrosecond = Be(Qk);
Ce.prototype.visitDurationNanosecond = Be(tC);
Ce.prototype.visitFixedSizeList = Be(oj);
Ce.prototype.visitMap = Be(ej);
const jn = new Ce(), Us = Symbol.for("keys"), gu = Symbol.for("vals");
let Sy = class {
  constructor(t) {
    return this[Us] = new Ki([t.children[0]]).memoize(), this[gu] = t.children[1], new Proxy(this, new lj());
  }
  [Symbol.iterator]() {
    return new cj(this[Us], this[gu]);
  }
  get size() {
    return this[Us].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[Us], i = this[gu], r = {};
    for (let n = -1, s = t.length; ++n < s; )
      r[t.get(n)] = jn.visit(i, n);
    return r;
  }
  toString() {
    return `{${[...this].map(([t, i]) => `${$l(t)}: ${$l(i)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}, cj = class {
  constructor(t, i) {
    this.keys = t, this.vals = i, this.keyIndex = 0, this.numKeys = t.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.keyIndex;
    return t === this.numKeys ? { done: !0, value: null } : (this.keyIndex++, {
      done: !1,
      value: [
        this.keys.get(t),
        jn.visit(this.vals, t)
      ]
    });
  }
}, lj = class {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[Us].toArray().map(String);
  }
  has(t, i) {
    return t[Us].includes(i);
  }
  getOwnPropertyDescriptor(t, i) {
    if (t[Us].indexOf(i) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, i) {
    if (Reflect.has(t, i))
      return t[i];
    const r = t[Us].indexOf(i);
    if (r !== -1) {
      const n = jn.visit(Reflect.get(t, gu), r);
      return Reflect.set(t, i, n), n;
    }
  }
  set(t, i, r) {
    const n = t[Us].indexOf(i);
    return n !== -1 ? (Is.visit(Reflect.get(t, gu), n, r), Reflect.set(t, i, r)) : Reflect.has(t, i) ? Reflect.set(t, i, r) : !1;
  }
};
Object.defineProperties(Sy.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [Us]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [gu]: { writable: !0, enumerable: !1, configurable: !1, value: null }
});
let fA;
function eC(e, t, i, r) {
  const { length: n = 0 } = e;
  let s = typeof t != "number" ? 0 : t, a = typeof i != "number" ? n : i;
  return s < 0 && (s = (s % n + n) % n), a < 0 && (a = (a % n + n) % n), a < s && (fA = s, s = a, a = fA), a > n && (a = n), r ? r(e, s, a) : [s, a];
}
const pA = (e) => e !== e;
function rh(e) {
  if (typeof e !== "object" || e === null)
    return pA(e) ? pA : (i) => i === e;
  if (e instanceof Date) {
    const i = e.valueOf();
    return (r) => r instanceof Date ? r.valueOf() === i : !1;
  }
  return ArrayBuffer.isView(e) ? (i) => i ? J9(e, i) : !1 : e instanceof Map ? uj(e) : Array.isArray(e) ? dj(e) : e instanceof Ki ? hj(e) : fj(e, !0);
}
function dj(e) {
  const t = [];
  for (let i = -1, r = e.length; ++i < r; )
    t[i] = rh(e[i]);
  return Iy(t);
}
function uj(e) {
  let t = -1;
  const i = [];
  for (const r of e.values())
    i[++t] = rh(r);
  return Iy(i);
}
function hj(e) {
  const t = [];
  for (let i = -1, r = e.length; ++i < r; )
    t[i] = rh(e.get(i));
  return Iy(t);
}
function fj(e, t = !1) {
  const i = Object.keys(e);
  if (!t && i.length === 0)
    return () => !1;
  const r = [];
  for (let n = -1, s = i.length; ++n < s; )
    r[n] = rh(e[i[n]]);
  return Iy(r, i);
}
function Iy(e, t) {
  return (i) => {
    if (!i || typeof i != "object")
      return !1;
    switch (i.constructor) {
      case Array:
        return pj(e, i);
      case Map:
        return mA(e, i, i.keys());
      case Sy:
      case px:
      case Object:
      case void 0:
        return mA(e, i, t || Object.keys(i));
    }
    return i instanceof Ki ? mj(e, i) : !1;
  };
}
function pj(e, t) {
  const i = e.length;
  if (t.length !== i)
    return !1;
  for (let r = -1; ++r < i; )
    if (!e[r](t[r]))
      return !1;
  return !0;
}
function mj(e, t) {
  const i = e.length;
  if (t.length !== i)
    return !1;
  for (let r = -1; ++r < i; )
    if (!e[r](t.get(r)))
      return !1;
  return !0;
}
function mA(e, t, i) {
  const r = i[Symbol.iterator](), n = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](), s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
  let a = 0;
  const o = e.length;
  let c = s.next(), l = r.next(), d = n.next();
  for (; a < o && !l.done && !d.done && !c.done && !(l.value !== d.value || !e[a](c.value)); ++a, l = r.next(), d = n.next(), c = s.next())
    ;
  return a === o && l.done && d.done && c.done ? !0 : (r.return && r.return(), n.return && n.return(), s.return && s.return(), !1);
}
function iC(e, t, i, r) {
  return (i & 1 << r) !== 0;
}
function gj(e, t, i, r) {
  return (i & 1 << r) >> r;
}
function Kg(e, t, i) {
  const r = i.byteLength + 7 & -8;
  if (e > 0 || i.byteLength < r) {
    const n = new Uint8Array(r);
    return n.set(e % 8 === 0 ? i.subarray(e >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      Jg(new gx(i, e, t, null, iC)).subarray(0, r)
    )), n;
  }
  return i;
}
function Jg(e) {
  const t = [];
  let i = 0, r = 0, n = 0;
  for (const a of e)
    a && (n |= 1 << r), ++r === 8 && (t[i++] = n, n = r = 0);
  (i === 0 || r > 0) && (t[i++] = n);
  const s = new Uint8Array(t.length + 7 & -8);
  return s.set(t), s;
}
let gx = class {
  constructor(t, i, r, n, s) {
    this.bytes = t, this.length = r, this.context = n, this.get = s, this.bit = i % 8, this.byteIndex = i >> 3, this.byte = t[this.byteIndex++], this.index = 0;
  }
  next() {
    return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
      value: this.get(this.context, this.index++, this.byte, this.bit++)
    }) : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function pb(e, t, i) {
  if (i - t <= 0)
    return 0;
  if (i - t < 8) {
    let s = 0;
    for (const a of new gx(e, t, i - t, e, gj))
      s += a;
    return s;
  }
  const r = i >> 3 << 3, n = t + (t % 8 === 0 ? 0 : 8 - t % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    pb(e, t, n) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    pb(e, r, i) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    yj(e, n >> 3, r - n >> 3)
  );
}
function yj(e, t, i) {
  let r = 0, n = Math.trunc(t);
  const s = new DataView(e.buffer, e.byteOffset, e.byteLength), a = i === void 0 ? e.byteLength : n + i;
  for (; a - n >= 4; )
    r += __(s.getUint32(n)), n += 4;
  for (; a - n >= 2; )
    r += __(s.getUint16(n)), n += 2;
  for (; a - n >= 1; )
    r += __(s.getUint8(n)), n += 1;
  return r;
}
function __(e) {
  let t = Math.trunc(e);
  return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
}
const vj = -1;
let rr = class mb {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: t } = this;
      return Ie.isSparseUnion(t) ? this.children.some((i) => i.nullable) : Ie.isDenseUnion(t) ? this.children.some((i) => i.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return !0;
  }
  get byteLength() {
    let t = 0;
    const { valueOffsets: i, values: r, nullBitmap: n, typeIds: s } = this;
    return i && (t += i.byteLength), r && (t += r.byteLength), n && (t += n.byteLength), s && (t += s.byteLength), this.children.reduce((a, o) => a + o.byteLength, t);
  }
  get nullCount() {
    if (Ie.isUnion(this.type))
      return this.children.reduce((r, n) => r + n.nullCount, 0);
    let t = this._nullCount, i;
    return t <= vj && (i = this.nullBitmap) && (this._nullCount = t = this.length - pb(i, this.offset, this.offset + this.length)), t;
  }
  constructor(t, i, r, n, s, a = [], o) {
    this.type = t, this.children = a, this.dictionary = o, this.offset = Math.floor(Math.max(i || 0, 0)), this.length = Math.floor(Math.max(r || 0, 0)), this._nullCount = Math.floor(Math.max(n || 0, -1));
    let c;
    s instanceof mb ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = xa(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
  }
  getValid(t) {
    const { type: i } = this;
    if (Ie.isUnion(i)) {
      const r = i, n = this.children[r.typeIdToChildIndex[this.typeIds[t]]], s = r.mode === En.Dense ? this.valueOffsets[t] : t;
      return n.getValid(s);
    }
    if (this.nullable && this.nullCount > 0) {
      const r = this.offset + t;
      return (this.nullBitmap[r >> 3] & 1 << r % 8) !== 0;
    }
    return !0;
  }
  setValid(t, i) {
    let r;
    const { type: n } = this;
    if (Ie.isUnion(n)) {
      const s = n, a = this.children[s.typeIdToChildIndex[this.typeIds[t]]], o = s.mode === En.Dense ? this.valueOffsets[t] : t;
      r = a.getValid(o), a.setValid(o, i);
    } else {
      let { nullBitmap: s } = this;
      const { offset: a, length: o } = this, c = a + t, l = 1 << c % 8, d = c >> 3;
      (!s || s.byteLength <= d) && (s = new Uint8Array((a + o + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(Kg(a, o, this.nullBitmap), 0), Object.assign(this, { nullBitmap: s, _nullCount: -1 }));
      const u = s[d];
      r = (u & l) !== 0, i ? s[d] = u | l : s[d] = u & ~l;
    }
    return r !== !!i && (this._nullCount = this.nullCount + (i ? -1 : 1)), i;
  }
  clone(t = this.type, i = this.offset, r = this.length, n = this._nullCount, s = this, a = this.children) {
    return new mb(t, i, r, n, s, a, this.dictionary);
  }
  slice(t, i) {
    const { stride: r, typeId: n, children: s } = this, a = +(this._nullCount === 0) - 1, o = n === 16 ? r : 1, c = this._sliceBuffers(t, i, r, n);
    return this.clone(
      this.type,
      this.offset + t,
      i,
      a,
      c,
      // Don't slice children if we have value offsets (the variable-width types)
      s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, o * t, o * i)
    );
  }
  _changeLengthAndBackfillNullBitmap(t) {
    if (this.typeId === O.Null)
      return this.clone(this.type, 0, t, 0);
    const { length: i, nullCount: r } = this, n = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, i >> 3);
    n[i >> 3] = (1 << i - (i & -8)) - 1, r > 0 && n.set(Kg(this.offset, i, this.nullBitmap), 0);
    const s = this.buffers;
    return s[oo.VALIDITY] = n, this.clone(this.type, 0, t, r + (t - i), s);
  }
  _sliceBuffers(t, i, r, n) {
    let s;
    const { buffers: a } = this;
    return (s = a[oo.TYPE]) && (a[oo.TYPE] = s.subarray(t, t + i)), (s = a[oo.OFFSET]) && (a[oo.OFFSET] = s.subarray(t, t + i + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (s = a[oo.DATA]) && (a[oo.DATA] = n === 6 ? s : s.subarray(r * t, r * (t + i))), a;
  }
  _sliceChildren(t, i, r) {
    return t.map((n) => n.slice(i, r));
  }
};
rr.prototype.children = Object.freeze([]);
let _j = class ig extends ti {
  visit(t) {
    return this.getVisitFn(t.type).call(this, t);
  }
  visitNull(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["length"]: n = 0 } = t;
    return new rr(i, r, n, n);
  }
  visitBool(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length >> 3, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitInt(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitFloat(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitUtf8(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.data), s = Ti(t.nullBitmap), a = Yh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, o, c, [a, n, s]);
  }
  visitBinary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.data), s = Ti(t.nullBitmap), a = Yh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, o, c, [a, n, s]);
  }
  visitFixedSizeBinary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitDate(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitTimestamp(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitTime(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitDecimal(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitList(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n } = t, s = Ti(t.nullBitmap), a = Yh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, o, c, [a, void 0, s], [n]);
  }
  visitStruct(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["children"]: n = [] } = t, s = Ti(t.nullBitmap), { length: a = n.reduce((c, { length: l }) => Math.max(c, l), 0), nullCount: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, void 0, s], n);
  }
  visitUnion(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["children"]: n = [] } = t, s = Wi(i.ArrayType, t.typeIds), { ["length"]: a = s.length, ["nullCount"]: o = -1 } = t;
    if (Ie.isSparseUnion(i))
      return new rr(i, r, a, o, [void 0, void 0, void 0, s], n);
    const c = Yh(t.valueOffsets);
    return new rr(i, r, a, o, [c, void 0, void 0, s], n);
  }
  visitDictionary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.indices.ArrayType, t.data), { ["dictionary"]: a = new Ki([new ig().visit({ type: i.dictionary })]) } = t, { ["length"]: o = s.length, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, o, c, [void 0, s, n], [], a);
  }
  visitInterval(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitDuration(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = Ti(t.nullBitmap), s = Wi(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, s, n]);
  }
  visitFixedSizeList(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n = new ig().visit({ type: i.valueType }) } = t, s = Ti(t.nullBitmap), { ["length"]: a = n.length / xa(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, a, o, [void 0, void 0, s], [n]);
  }
  visitMap(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n = new ig().visit({ type: i.childType }) } = t, s = Ti(t.nullBitmap), a = Yh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new rr(i, r, o, c, [a, void 0, s], [n]);
  }
};
const bj = new _j();
function di(e) {
  return bj.visit(e);
}
let gA = class {
  constructor(t = 0, i) {
    this.numChunks = t, this.getChunkIterator = i, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    for (; this.chunkIndex < this.numChunks; ) {
      const t = this.chunkIterator.next();
      if (!t.done)
        return t;
      ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex));
    }
    return { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
function rC(e) {
  return e.reduce((t, i) => t + i.nullCount, 0);
}
function nC(e) {
  return e.reduce((t, i, r) => (t[r + 1] = t[r] + i.length, t), new Uint32Array(e.length + 1));
}
function sC(e, t, i, r) {
  const n = [];
  for (let s = -1, a = e.length; ++s < a; ) {
    const o = e[s], c = t[s], { length: l } = o;
    if (c >= r)
      break;
    if (i >= c + l)
      continue;
    if (c >= i && c + l <= r) {
      n.push(o);
      continue;
    }
    const d = Math.max(0, i - c), u = Math.min(r - c, l);
    n.push(o.slice(d, u - d));
  }
  return n.length === 0 && n.push(e[0].slice(0, 0)), n;
}
function yx(e, t, i, r) {
  let n = 0, s = 0, a = t.length - 1;
  do {
    if (n >= a - 1)
      return i < t[a] ? r(e, n, i - t[n]) : null;
    s = n + Math.trunc((a - n) * 0.5), i < t[s] ? a = s : n = s;
  } while (n < a);
}
function vx(e, t) {
  return e.getValid(t);
}
function yu(e) {
  function t(i, r, n) {
    return e(i[r], n);
  }
  return function(i) {
    const r = this.data;
    return yx(r, this._offsets, i, t);
  };
}
function aC(e) {
  let t;
  function i(r, n, s) {
    return e(r[n], s, t);
  }
  return function(r, n) {
    const s = this.data;
    t = n;
    const a = yx(s, this._offsets, r, i);
    return t = void 0, a;
  };
}
function oC(e) {
  let t;
  function i(r, n, s) {
    let a = s, o = 0, c = 0;
    for (let l = n - 1, d = r.length; ++l < d; ) {
      const u = r[l];
      if (~(o = e(u, t, a)))
        return c + o;
      a = 0, c += u.length;
    }
    return -1;
  }
  return function(r, n) {
    t = r;
    const s = this.data, a = typeof n != "number" ? i(s, 0, 0) : yx(s, this._offsets, n, i);
    return t = void 0, a;
  };
}
let Oe = class extends ti {
};
function xj(e, t) {
  return t === null && e.length > 0 ? 0 : -1;
}
function wj(e, t) {
  const { nullBitmap: i } = e;
  if (!i || e.nullCount <= 0)
    return -1;
  let r = 0;
  for (const n of new gx(i, e.offset + (t || 0), e.length, i, iC)) {
    if (!n)
      return r;
    ++r;
  }
  return -1;
}
function He(e, t, i) {
  if (t === void 0)
    return -1;
  if (t === null)
    switch (e.typeId) {
      case O.Union:
        break;
      case O.Dictionary:
        break;
      default:
        return wj(e, i);
    }
  const r = jn.getVisitFn(e), n = rh(t);
  for (let s = (i || 0) - 1, a = e.length; ++s < a; )
    if (n(r(e, s)))
      return s;
  return -1;
}
function cC(e, t, i) {
  const r = jn.getVisitFn(e), n = rh(t);
  for (let s = (i || 0) - 1, a = e.length; ++s < a; )
    if (n(r(e, s)))
      return s;
  return -1;
}
Oe.prototype.visitNull = xj;
Oe.prototype.visitBool = He;
Oe.prototype.visitInt = He;
Oe.prototype.visitInt8 = He;
Oe.prototype.visitInt16 = He;
Oe.prototype.visitInt32 = He;
Oe.prototype.visitInt64 = He;
Oe.prototype.visitUint8 = He;
Oe.prototype.visitUint16 = He;
Oe.prototype.visitUint32 = He;
Oe.prototype.visitUint64 = He;
Oe.prototype.visitFloat = He;
Oe.prototype.visitFloat16 = He;
Oe.prototype.visitFloat32 = He;
Oe.prototype.visitFloat64 = He;
Oe.prototype.visitUtf8 = He;
Oe.prototype.visitBinary = He;
Oe.prototype.visitFixedSizeBinary = He;
Oe.prototype.visitDate = He;
Oe.prototype.visitDateDay = He;
Oe.prototype.visitDateMillisecond = He;
Oe.prototype.visitTimestamp = He;
Oe.prototype.visitTimestampSecond = He;
Oe.prototype.visitTimestampMillisecond = He;
Oe.prototype.visitTimestampMicrosecond = He;
Oe.prototype.visitTimestampNanosecond = He;
Oe.prototype.visitTime = He;
Oe.prototype.visitTimeSecond = He;
Oe.prototype.visitTimeMillisecond = He;
Oe.prototype.visitTimeMicrosecond = He;
Oe.prototype.visitTimeNanosecond = He;
Oe.prototype.visitDecimal = He;
Oe.prototype.visitList = He;
Oe.prototype.visitStruct = He;
Oe.prototype.visitUnion = He;
Oe.prototype.visitDenseUnion = cC;
Oe.prototype.visitSparseUnion = cC;
Oe.prototype.visitDictionary = He;
Oe.prototype.visitInterval = He;
Oe.prototype.visitIntervalDayTime = He;
Oe.prototype.visitIntervalYearMonth = He;
Oe.prototype.visitDuration = He;
Oe.prototype.visitDurationSecond = He;
Oe.prototype.visitDurationMillisecond = He;
Oe.prototype.visitDurationMicrosecond = He;
Oe.prototype.visitDurationNanosecond = He;
Oe.prototype.visitFixedSizeList = He;
Oe.prototype.visitMap = He;
const Qg = new Oe();
let De = class extends ti {
};
function Re(e) {
  const { type: t } = e;
  if (e.nullCount === 0 && e.stride === 1 && (t.typeId === O.Timestamp || t instanceof kn && t.bitWidth !== 64 || t instanceof ko && t.bitWidth !== 64 || t instanceof Ac && t.precision !== hn.HALF))
    return new gA(e.data.length, (r) => {
      const n = e.data[r];
      return n.values.subarray(0, n.length)[Symbol.iterator]();
    });
  let i = 0;
  return new gA(e.data.length, (r) => {
    const s = e.data[r].length, a = e.slice(i, i + s);
    return i += s, new Sj(a);
  });
}
let Sj = class {
  constructor(t) {
    this.vector = t, this.index = 0;
  }
  next() {
    return this.index < this.vector.length ? {
      value: this.vector.get(this.index++)
    } : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
};
De.prototype.visitNull = Re;
De.prototype.visitBool = Re;
De.prototype.visitInt = Re;
De.prototype.visitInt8 = Re;
De.prototype.visitInt16 = Re;
De.prototype.visitInt32 = Re;
De.prototype.visitInt64 = Re;
De.prototype.visitUint8 = Re;
De.prototype.visitUint16 = Re;
De.prototype.visitUint32 = Re;
De.prototype.visitUint64 = Re;
De.prototype.visitFloat = Re;
De.prototype.visitFloat16 = Re;
De.prototype.visitFloat32 = Re;
De.prototype.visitFloat64 = Re;
De.prototype.visitUtf8 = Re;
De.prototype.visitBinary = Re;
De.prototype.visitFixedSizeBinary = Re;
De.prototype.visitDate = Re;
De.prototype.visitDateDay = Re;
De.prototype.visitDateMillisecond = Re;
De.prototype.visitTimestamp = Re;
De.prototype.visitTimestampSecond = Re;
De.prototype.visitTimestampMillisecond = Re;
De.prototype.visitTimestampMicrosecond = Re;
De.prototype.visitTimestampNanosecond = Re;
De.prototype.visitTime = Re;
De.prototype.visitTimeSecond = Re;
De.prototype.visitTimeMillisecond = Re;
De.prototype.visitTimeMicrosecond = Re;
De.prototype.visitTimeNanosecond = Re;
De.prototype.visitDecimal = Re;
De.prototype.visitList = Re;
De.prototype.visitStruct = Re;
De.prototype.visitUnion = Re;
De.prototype.visitDenseUnion = Re;
De.prototype.visitSparseUnion = Re;
De.prototype.visitDictionary = Re;
De.prototype.visitInterval = Re;
De.prototype.visitIntervalDayTime = Re;
De.prototype.visitIntervalYearMonth = Re;
De.prototype.visitDuration = Re;
De.prototype.visitDurationSecond = Re;
De.prototype.visitDurationMillisecond = Re;
De.prototype.visitDurationMicrosecond = Re;
De.prototype.visitDurationNanosecond = Re;
De.prototype.visitFixedSizeList = Re;
De.prototype.visitMap = Re;
const _x = new De(), Ij = (e, t) => e + t;
class jc extends ti {
  visitNull(t, i) {
    return 0;
  }
  visitInt(t, i) {
    return t.type.bitWidth / 8;
  }
  visitFloat(t, i) {
    return t.type.ArrayType.BYTES_PER_ELEMENT;
  }
  visitBool(t, i) {
    return 1 / 8;
  }
  visitDecimal(t, i) {
    return t.type.bitWidth / 8;
  }
  visitDate(t, i) {
    return (t.type.unit + 1) * 4;
  }
  visitTime(t, i) {
    return t.type.bitWidth / 8;
  }
  visitTimestamp(t, i) {
    return t.type.unit === ke.SECOND ? 4 : 8;
  }
  visitInterval(t, i) {
    return (t.type.unit + 1) * 4;
  }
  visitDuration(t, i) {
    return 8;
  }
  visitStruct(t, i) {
    return t.children.reduce((r, n) => r + La.visit(n, i), 0);
  }
  visitFixedSizeBinary(t, i) {
    return t.type.byteWidth;
  }
  visitMap(t, i) {
    return 8 + t.children.reduce((r, n) => r + La.visit(n, i), 0);
  }
  visitDictionary(t, i) {
    var r;
    return t.type.indices.bitWidth / 8 + (((r = t.dictionary) === null || r === void 0 ? void 0 : r.getByteLength(t.values[i])) || 0);
  }
}
const Aj = ({ valueOffsets: e }, t) => 8 + (e[t + 1] - e[t]), Tj = ({ valueOffsets: e }, t) => 8 + (e[t + 1] - e[t]), Ej = ({ valueOffsets: e, stride: t, children: i }, r) => {
  const n = i[0], { [r * t]: s } = e, { [r * t + 1]: a } = e, o = La.getVisitFn(n.type), c = n.slice(s, a - s);
  let l = 8;
  for (let d = -1, u = a - s; ++d < u; )
    l += o(c, d);
  return l;
}, kj = ({ stride: e, children: t }, i) => {
  const r = t[0], n = r.slice(i * e, e), s = La.getVisitFn(r.type);
  let a = 0;
  for (let o = -1, c = n.length; ++o < c; )
    a += s(n, o);
  return a;
}, Cj = (e, t) => e.type.mode === En.Dense ? lC(e, t) : dC(e, t), lC = ({ type: e, children: t, typeIds: i, valueOffsets: r }, n) => {
  const s = e.typeIdToChildIndex[i[n]];
  return 8 + La.visit(t[s], r[n]);
}, dC = ({ children: e }, t) => 4 + La.visitMany(e, e.map(() => t)).reduce(Ij, 0);
jc.prototype.visitUtf8 = Aj;
jc.prototype.visitBinary = Tj;
jc.prototype.visitList = Ej;
jc.prototype.visitFixedSizeList = kj;
jc.prototype.visitUnion = Cj;
jc.prototype.visitDenseUnion = lC;
jc.prototype.visitSparseUnion = dC;
const La = new jc();
var uC;
const hC = {}, fC = {};
let Ki = class yl {
  constructor(t) {
    var i, r, n;
    const s = t[0] instanceof yl ? t.flatMap((o) => o.data) : t;
    if (s.length === 0 || s.some((o) => !(o instanceof rr)))
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    const a = (i = s[0]) === null || i === void 0 ? void 0 : i.type;
    switch (s.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: o, set: c, indexOf: l, byteLength: d } = hC[a.typeId], u = s[0];
        this.isValid = (h) => vx(u, h), this.get = (h) => o(u, h), this.set = (h, p) => c(u, h, p), this.indexOf = (h) => l(u, h), this.getByteLength = (h) => d(u, h), this._offsets = [0, u.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, fC[a.typeId]), this._offsets = nC(s);
        break;
    }
    this.data = s, this.type = a, this.stride = xa(a), this.numChildren = (n = (r = a.children) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : 0, this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((t, i) => t + i.byteLength, 0);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return rC(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${O[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, i) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, i) {
    return -1;
  }
  includes(t, i) {
    return this.indexOf(t, i) > -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(t) {
    return 0;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return _x.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...t) {
    return new yl(this.data.concat(t.flatMap((i) => i.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    return new yl(eC(this, t, i, ({ data: r, _offsets: n }, s, a) => sC(r, n, s, a)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: t, data: i, length: r, stride: n, ArrayType: s } = this;
    switch (t.typeId) {
      case O.Int:
      case O.Float:
      case O.Decimal:
      case O.Time:
      case O.Timestamp:
        switch (i.length) {
          case 0:
            return new s();
          case 1:
            return i[0].values.subarray(0, r * n);
          default:
            return i.reduce((a, { values: o, length: c }) => (a.array.set(o.subarray(0, c * n), a.offset), a.offset += c * n, a), { array: new s(r * n), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var i;
    return this.getChildAt((i = this.type.children) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.numChildren ? new yl(this.data.map(({ children: i }) => i[t])) : null;
  }
  get isMemoized() {
    return Ie.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Uft8. The memoization creates a cache of the size of the Vector and
   * therfore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (Ie.isDictionary(this.type)) {
      const t = new yA(this.data[0].dictionary), i = this.data.map((r) => {
        const n = r.clone();
        return n.dictionary = t, n;
      });
      return new yl(i);
    }
    return new yA(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A a vector without memoization.
   */
  unmemoize() {
    if (Ie.isDictionary(this.type) && this.isMemoized) {
      const t = this.data[0].dictionary.unmemoize(), i = this.data.map((r) => {
        const n = r.clone();
        return n.dictionary = t, n;
      });
      return new yl(i);
    }
    return this;
  }
};
uC = Symbol.toStringTag;
Ki[uC] = ((e) => {
  e.type = Ie.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
  const t = Object.keys(O).map((i) => O[i]).filter((i) => typeof i == "number" && i !== O.NONE);
  for (const i of t) {
    const r = jn.getVisitFnByTypeId(i), n = Is.getVisitFnByTypeId(i), s = Qg.getVisitFnByTypeId(i), a = La.getVisitFnByTypeId(i);
    hC[i] = { get: r, set: n, indexOf: s, byteLength: a }, fC[i] = Object.create(e, {
      isValid: { value: yu(vx) },
      get: { value: yu(jn.getVisitFnByTypeId(i)) },
      set: { value: aC(Is.getVisitFnByTypeId(i)) },
      indexOf: { value: oC(Qg.getVisitFnByTypeId(i)) },
      getByteLength: { value: yu(La.getVisitFnByTypeId(i)) }
    });
  }
  return "Vector";
})(Ki.prototype);
let yA = class pC extends Ki {
  constructor(t) {
    super(t.data);
    const i = this.get, r = this.set, n = this.slice, s = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(a) {
        const o = s[a];
        if (o !== void 0)
          return o;
        const c = i.call(this, a);
        return s[a] = c, c;
      }
    }), Object.defineProperty(this, "set", {
      value(a, o) {
        r.call(this, a, o), s[a] = o;
      }
    }), Object.defineProperty(this, "slice", {
      value: (a, o) => new pC(n.call(this, a, o))
    }), Object.defineProperty(this, "isMemoized", { value: !0 }), Object.defineProperty(this, "unmemoize", {
      value: () => new Ki(this.data)
    }), Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
};
function Oj(e) {
  if (!e || e.length <= 0)
    return function(n) {
      return !0;
    };
  let t = "";
  const i = e.filter((r) => r === r);
  return i.length > 0 && (t = `
    switch (x) {${i.map((r) => `
        case ${Dj(r)}:`).join("")}
            return false;
    }`), e.length !== i.length && (t = `if (x !== x) return false;
${t}`), new Function("x", `${t}
return true;`);
}
function Dj(e) {
  return typeof e != "bigint" ? $l(e) : `${$l(e)}n`;
}
const b_ = (e, t) => (Math.ceil(e) * t + 63 & -64 || 64) / t, Nj = (e, t = 0) => e.length >= t ? e.subarray(0, t) : Wg(new e.constructor(t), e, 0);
class Ay {
  constructor(t, i = 1) {
    this.buffer = t, this.stride = i, this.BYTES_PER_ELEMENT = t.BYTES_PER_ELEMENT, this.ArrayType = t.constructor, this._resize(this.length = Math.ceil(t.length / i));
  }
  get byteLength() {
    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
  }
  get reservedLength() {
    return this.buffer.length / this.stride;
  }
  get reservedByteLength() {
    return this.buffer.byteLength;
  }
  // @ts-ignore
  set(t, i) {
    return this;
  }
  append(t) {
    return this.set(this.length, t);
  }
  reserve(t) {
    if (t > 0) {
      this.length += t;
      const i = this.stride, r = this.length * i, n = this.buffer.length;
      r >= n && this._resize(n === 0 ? b_(r * 1, this.BYTES_PER_ELEMENT) : b_(r * 2, this.BYTES_PER_ELEMENT));
    }
    return this;
  }
  flush(t = this.length) {
    t = b_(t * this.stride, this.BYTES_PER_ELEMENT);
    const i = Nj(this.buffer, t);
    return this.clear(), i;
  }
  clear() {
    return this.length = 0, this._resize(0), this;
  }
  _resize(t) {
    return this.buffer = Wg(new this.ArrayType(t), this.buffer);
  }
}
Ay.prototype.offset = 0;
class Ap extends Ay {
  last() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.buffer[t];
  }
  set(t, i) {
    return this.reserve(t - this.length + 1), this.buffer[t * this.stride] = i, this;
  }
}
class mC extends Ap {
  constructor(t = new Uint8Array(0)) {
    super(t, 1 / 8), this.numValid = 0;
  }
  get numInvalid() {
    return this.length - this.numValid;
  }
  get(t) {
    return this.buffer[t >> 3] >> t % 8 & 1;
  }
  set(t, i) {
    const { buffer: r } = this.reserve(t - this.length + 1), n = t >> 3, s = t % 8, a = r[n] >> s & 1;
    return i ? a === 0 && (r[n] |= 1 << s, ++this.numValid) : a === 1 && (r[n] &= ~(1 << s), --this.numValid), this;
  }
  clear() {
    return this.numValid = 0, super.clear();
  }
}
class gC extends Ap {
  constructor(t = new Int32Array(1)) {
    super(t, 1);
  }
  append(t) {
    return this.set(this.length - 1, t);
  }
  set(t, i) {
    const r = this.length - 1, n = this.reserve(t - r + 1).buffer;
    return r < t++ && n.fill(n[r], r, t), n[t] = n[t - 1] + i, this;
  }
  flush(t = this.length - 1) {
    return t > this.length && this.set(t - 1, 0), super.flush(t + 1);
  }
}
let qn = class {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  // @ts-ignore
  static throughDOM(t) {
    throw new Error('"throughDOM" not available in this environment');
  }
  /**
   * Construct a builder with the given Arrow DataType with optional null values,
   * which will be interpreted as "null" when set or appended to the `Builder`.
   * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
   */
  constructor({ type: t, nullValues: i }) {
    this.length = 0, this.finished = !1, this.type = t, this.children = [], this.nullValues = i, this.stride = xa(t), this._nulls = new mC(), i && i.length > 0 && (this._isValid = Oj(i));
  }
  /**
   * Flush the `Builder` and return a `Vector<T>`.
   * @returns {Vector<T>} A `Vector<T>` of the flushed values.
   */
  toVector() {
    return new Ki([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  /**
   * @returns The aggregate length (in bytes) of the values that have been written.
   */
  get byteLength() {
    let t = 0;
    const { _offsets: i, _values: r, _nulls: n, _typeIds: s, children: a } = this;
    return i && (t += i.byteLength), r && (t += r.byteLength), n && (t += n.byteLength), s && (t += s.byteLength), a.reduce((o, c) => o + c.byteLength, t);
  }
  /**
   * @returns The aggregate number of rows that have been reserved to write new values.
   */
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  /**
   * @returns The aggregate length (in bytes) that has been reserved to write new values.
   */
  get reservedByteLength() {
    let t = 0;
    return this._offsets && (t += this._offsets.reservedByteLength), this._values && (t += this._values.reservedByteLength), this._nulls && (t += this._nulls.reservedByteLength), this._typeIds && (t += this._typeIds.reservedByteLength), this.children.reduce((i, r) => i + r.reservedByteLength, t);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  /**
   * Appends a value (or null) to this `Builder`.
   * This is equivalent to `builder.set(builder.length, value)`.
   * @param {T['TValue'] | TNull } value The value to append.
   */
  append(t) {
    return this.set(this.length, t);
  }
  /**
   * Validates whether a value is valid (true), or null (false)
   * @param {T['TValue'] | TNull } value The value to compare against null the value representations
   */
  isValid(t) {
    return this._isValid(t);
  }
  /**
   * Write a value (or null-value sentinel) at the supplied index.
   * If the value matches one of the null-value representations, a 1-bit is
   * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
   * the null `BitmapBufferBuilder`, and the value is passed to
   * `Builder.prototype.setValue()`.
   * @param {number} index The index of the value to write.
   * @param {T['TValue'] | TNull } value The value to write at the supplied index.
   * @returns {this} The updated `Builder` instance.
   */
  set(t, i) {
    return this.setValid(t, this.isValid(i)) && this.setValue(t, i), this;
  }
  /**
   * Write a value to the underlying buffers at the supplied index, bypassing
   * the null-value check. This is a low-level method that
   * @param {number} index
   * @param {T['TValue'] | TNull } value
   */
  setValue(t, i) {
    this._setValue(this, t, i);
  }
  setValid(t, i) {
    return this.length = this._nulls.set(t, +i).length, i;
  }
  // @ts-ignore
  addChild(t, i = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  /**
   * Retrieve the child `Builder` at the supplied `index`, or null if no child
   * exists at that index.
   * @param {number} index The index of the child `Builder` to retrieve.
   * @returns {Builder | null} The child Builder at the supplied index or null.
   */
  getChildAt(t) {
    return this.children[t] || null;
  }
  /**
   * Commit all the values that have been written to their underlying
   * ArrayBuffers, including any child Builders if applicable, and reset
   * the internal `Builder` state.
   * @returns A `Data<T>` of the buffers and children representing the values written.
   */
  flush() {
    let t, i, r, n;
    const { type: s, length: a, nullCount: o, _typeIds: c, _offsets: l, _values: d, _nulls: u } = this;
    (i = c == null ? void 0 : c.flush(a)) ? n = l == null ? void 0 : l.flush(a) : (n = l == null ? void 0 : l.flush(a)) ? t = d == null ? void 0 : d.flush(l.last()) : t = d == null ? void 0 : d.flush(a), o > 0 && (r = u == null ? void 0 : u.flush(a));
    const h = this.children.map((p) => p.flush());
    return this.clear(), di({
      type: s,
      length: a,
      nullCount: o,
      children: h,
      child: h[0],
      data: t,
      typeIds: i,
      nullBitmap: r,
      valueOffsets: n
    });
  }
  /**
   * Finalize this `Builder`, and child builders if applicable.
   * @returns {this} The finalized `Builder` instance.
   */
  finish() {
    this.finished = !0;
    for (const t of this.children)
      t.finish();
    return this;
  }
  /**
   * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
   * @returns {this} The cleared `Builder` instance.
   */
  clear() {
    var t, i, r, n;
    this.length = 0, (t = this._nulls) === null || t === void 0 || t.clear(), (i = this._values) === null || i === void 0 || i.clear(), (r = this._offsets) === null || r === void 0 || r.clear(), (n = this._typeIds) === null || n === void 0 || n.clear();
    for (const s of this.children)
      s.clear();
    return this;
  }
};
qn.prototype.length = 1;
qn.prototype.stride = 1;
qn.prototype.children = null;
qn.prototype.finished = !1;
qn.prototype.nullValues = null;
qn.prototype._isValid = () => !0;
class zo extends qn {
  constructor(t) {
    super(t), this._values = new Ap(new this.ArrayType(0), this.stride);
  }
  setValue(t, i) {
    const r = this._values;
    return r.reserve(t - r.length + 1), super.setValue(t, i);
  }
}
class Ty extends qn {
  constructor(t) {
    super(t), this._pendingLength = 0, this._offsets = new gC();
  }
  setValue(t, i) {
    const r = this._pending || (this._pending = /* @__PURE__ */ new Map()), n = r.get(t);
    n && (this._pendingLength -= n.length), this._pendingLength += i instanceof Sy ? i[Us].length : i.length, r.set(t, i);
  }
  setValid(t, i) {
    return super.setValid(t, i) ? !0 : ((this._pending || (this._pending = /* @__PURE__ */ new Map())).set(t, void 0), !1);
  }
  clear() {
    return this._pendingLength = 0, this._pending = void 0, super.clear();
  }
  flush() {
    return this._flush(), super.flush();
  }
  finish() {
    return this._flush(), super.finish();
  }
  _flush() {
    const t = this._pending, i = this._pendingLength;
    return this._pendingLength = 0, this._pending = void 0, t && t.size > 0 && this._flushPending(t, i), this;
  }
}
let gb = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(t, i, r, n) {
    return t.prep(8, 24), t.writeInt64(BigInt(n ?? 0)), t.pad(4), t.writeInt32(r), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
};
const x_ = 2, Sa = 4, mo = 4, de = 4, pc = new Int32Array(2), vA = new Float32Array(pc.buffer), _A = new Float64Array(pc.buffer), $m = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var yb;
(function(e) {
  e[e.UTF8_BYTES = 1] = "UTF8_BYTES", e[e.UTF16_STRING = 2] = "UTF16_STRING";
})(yb || (yb = {}));
let Fa = class yC {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(t) {
    this.bytes_ = t, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(t) {
    return new yC(new Uint8Array(t));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(t) {
    this.position_ = t;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(t) {
    return this.readUint8(t) << 24 >> 24;
  }
  readUint8(t) {
    return this.bytes_[t];
  }
  readInt16(t) {
    return this.readUint16(t) << 16 >> 16;
  }
  readUint16(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8;
  }
  readInt32(t) {
    return this.bytes_[t] | this.bytes_[t + 1] << 8 | this.bytes_[t + 2] << 16 | this.bytes_[t + 3] << 24;
  }
  readUint32(t) {
    return this.readInt32(t) >>> 0;
  }
  readInt64(t) {
    return BigInt.asIntN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readUint64(t) {
    return BigInt.asUintN(64, BigInt(this.readUint32(t)) + (BigInt(this.readUint32(t + 4)) << BigInt(32)));
  }
  readFloat32(t) {
    return pc[0] = this.readInt32(t), vA[0];
  }
  readFloat64(t) {
    return pc[$m ? 0 : 1] = this.readInt32(t), pc[$m ? 1 : 0] = this.readInt32(t + 4), _A[0];
  }
  writeInt8(t, i) {
    this.bytes_[t] = i;
  }
  writeUint8(t, i) {
    this.bytes_[t] = i;
  }
  writeInt16(t, i) {
    this.bytes_[t] = i, this.bytes_[t + 1] = i >> 8;
  }
  writeUint16(t, i) {
    this.bytes_[t] = i, this.bytes_[t + 1] = i >> 8;
  }
  writeInt32(t, i) {
    this.bytes_[t] = i, this.bytes_[t + 1] = i >> 8, this.bytes_[t + 2] = i >> 16, this.bytes_[t + 3] = i >> 24;
  }
  writeUint32(t, i) {
    this.bytes_[t] = i, this.bytes_[t + 1] = i >> 8, this.bytes_[t + 2] = i >> 16, this.bytes_[t + 3] = i >> 24;
  }
  writeInt64(t, i) {
    this.writeInt32(t, Number(BigInt.asIntN(32, i))), this.writeInt32(t + 4, Number(BigInt.asIntN(32, i >> BigInt(32))));
  }
  writeUint64(t, i) {
    this.writeUint32(t, Number(BigInt.asUintN(32, i))), this.writeUint32(t + 4, Number(BigInt.asUintN(32, i >> BigInt(32))));
  }
  writeFloat32(t, i) {
    vA[0] = i, this.writeInt32(t, pc[0]);
  }
  writeFloat64(t, i) {
    _A[0] = i, this.writeInt32(t, pc[$m ? 0 : 1]), this.writeInt32(t + 4, pc[$m ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Sa + mo)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let t = "";
    for (let i = 0; i < mo; i++)
      t += String.fromCharCode(this.readInt8(this.position_ + Sa + i));
    return t;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(t, i) {
    const r = t - this.readInt32(t);
    return i < this.readInt16(r) ? this.readInt16(r + i) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, i) {
    return t.bb_pos = i + this.readInt32(i), t.bb = this, t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(t, i) {
    t += this.readInt32(t);
    const r = this.readInt32(t);
    t += Sa;
    const n = this.bytes_.subarray(t, t + r);
    return i === yb.UTF8_BYTES ? n : this.text_decoder_.decode(n);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(t, i) {
    return typeof t == "string" ? this.__string(i) : this.__union(t, i);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(t) {
    return t + this.readInt32(t);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(t) {
    return t + this.readInt32(t) + Sa;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(t) {
    return this.readInt32(t + this.readInt32(t));
  }
  __has_identifier(t) {
    if (t.length != mo)
      throw new Error("FlatBuffers: file identifier must be length " + mo);
    for (let i = 0; i < mo; i++)
      if (t.charCodeAt(i) != this.readInt8(this.position() + Sa + i))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(t, i) {
    const r = [];
    for (let n = 0; n < i; ++n) {
      const s = t(n);
      s !== null && r.push(s);
    }
    return r;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(t, i) {
    const r = [];
    for (let n = 0; n < i; ++n) {
      const s = t(n);
      s !== null && r.push(s.unpack());
    }
    return r;
  }
}, Ey = class vC {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(t) {
    this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null, this.text_encoder = new TextEncoder();
    let i;
    t ? i = t : i = 1024, this.bb = Fa.allocate(i), this.space = i;
  }
  clear() {
    this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = !1, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = !1, this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(t) {
    this.force_defaults = t;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(t, i) {
    t > this.minalign && (this.minalign = t);
    const r = ~(this.bb.capacity() - this.space + i) + 1 & t - 1;
    for (; this.space < r + t + i; ) {
      const n = this.bb.capacity();
      this.bb = vC.growByteBuffer(this.bb), this.space += this.bb.capacity() - n;
    }
    this.pad(r);
  }
  pad(t) {
    for (let i = 0; i < t; i++)
      this.bb.writeInt8(--this.space, 0);
  }
  writeInt8(t) {
    this.bb.writeInt8(this.space -= 1, t);
  }
  writeInt16(t) {
    this.bb.writeInt16(this.space -= 2, t);
  }
  writeInt32(t) {
    this.bb.writeInt32(this.space -= 4, t);
  }
  writeInt64(t) {
    this.bb.writeInt64(this.space -= 8, t);
  }
  writeFloat32(t) {
    this.bb.writeFloat32(this.space -= 4, t);
  }
  writeFloat64(t) {
    this.bb.writeFloat64(this.space -= 8, t);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(t) {
    this.prep(1, 0), this.writeInt8(t);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(t) {
    this.prep(2, 0), this.writeInt16(t);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(t) {
    this.prep(4, 0), this.writeInt32(t);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(t) {
    this.prep(8, 0), this.writeInt64(t);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(t) {
    this.prep(4, 0), this.writeFloat32(t);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(t) {
    this.prep(8, 0), this.writeFloat64(t);
  }
  addFieldInt8(t, i, r) {
    (this.force_defaults || i != r) && (this.addInt8(i), this.slot(t));
  }
  addFieldInt16(t, i, r) {
    (this.force_defaults || i != r) && (this.addInt16(i), this.slot(t));
  }
  addFieldInt32(t, i, r) {
    (this.force_defaults || i != r) && (this.addInt32(i), this.slot(t));
  }
  addFieldInt64(t, i, r) {
    (this.force_defaults || i !== r) && (this.addInt64(i), this.slot(t));
  }
  addFieldFloat32(t, i, r) {
    (this.force_defaults || i != r) && (this.addFloat32(i), this.slot(t));
  }
  addFieldFloat64(t, i, r) {
    (this.force_defaults || i != r) && (this.addFloat64(i), this.slot(t));
  }
  addFieldOffset(t, i, r) {
    (this.force_defaults || i != r) && (this.addOffset(i), this.slot(t));
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(t, i, r) {
    i != r && (this.nested(i), this.slot(t));
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(t) {
    if (t != this.offset())
      throw new TypeError("FlatBuffers: struct must be serialized inline.");
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested)
      throw new TypeError("FlatBuffers: object serialization must not be nested.");
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(t) {
    this.vtable !== null && (this.vtable[t] = this.offset());
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(t) {
    const i = t.capacity();
    if (i & 3221225472)
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    const r = i << 1, n = Fa.allocate(r);
    return n.setPosition(r - i), n.bytes().set(t.bytes(), r - i), n;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(t) {
    this.prep(Sa, 0), this.writeInt32(this.offset() - t + Sa);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(t) {
    this.notNested(), this.vtable == null && (this.vtable = []), this.vtable_in_use = t;
    for (let i = 0; i < t; i++)
      this.vtable[i] = 0;
    this.isNested = !0, this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested)
      throw new Error("FlatBuffers: endObject called without startObject");
    this.addInt32(0);
    const t = this.offset();
    let i = this.vtable_in_use - 1;
    for (; i >= 0 && this.vtable[i] == 0; i--)
      ;
    const r = i + 1;
    for (; i >= 0; i--)
      this.addInt16(this.vtable[i] != 0 ? t - this.vtable[i] : 0);
    const n = 2;
    this.addInt16(t - this.object_start);
    const s = (r + n) * x_;
    this.addInt16(s);
    let a = 0;
    const o = this.space;
    t:
      for (i = 0; i < this.vtables.length; i++) {
        const c = this.bb.capacity() - this.vtables[i];
        if (s == this.bb.readInt16(c)) {
          for (let l = x_; l < s; l += x_)
            if (this.bb.readInt16(o + l) != this.bb.readInt16(c + l))
              continue t;
          a = this.vtables[i];
          break;
        }
      }
    return a ? (this.space = this.bb.capacity() - t, this.bb.writeInt32(this.space, a - t)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t, this.offset() - t)), this.isNested = !1, t;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(t, i, r) {
    const n = r ? de : 0;
    if (i) {
      const s = i;
      if (this.prep(this.minalign, Sa + mo + n), s.length != mo)
        throw new TypeError("FlatBuffers: file identifier must be length " + mo);
      for (let a = mo - 1; a >= 0; a--)
        this.writeInt8(s.charCodeAt(a));
    }
    this.prep(this.minalign, Sa + n), this.addOffset(t), n && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(t, i) {
    this.finish(t, i, !0);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(t, i) {
    const r = this.bb.capacity() - t, n = r - this.bb.readInt32(r);
    if (!(i < this.bb.readInt16(n) && this.bb.readInt16(n + i) != 0))
      throw new TypeError("FlatBuffers: field " + i + " must be set");
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(t, i, r) {
    this.notNested(), this.vector_num_elems = i, this.prep(Sa, t * i), this.prep(r, t * i);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    return this.writeInt32(this.vector_num_elems), this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(t) {
    if (!t)
      return 0;
    if (this.string_maps || (this.string_maps = /* @__PURE__ */ new Map()), this.string_maps.has(t))
      return this.string_maps.get(t);
    const i = this.createString(t);
    return this.string_maps.set(t, i), i;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(t) {
    if (t == null)
      return 0;
    let i;
    t instanceof Uint8Array ? i = t : i = this.text_encoder.encode(t), this.addInt8(0), this.startVector(1, i.length, 1), this.bb.setPosition(this.space -= i.length);
    for (let r = 0, n = this.space, s = this.bb.bytes(); r < i.length; r++)
      s[n++] = i[r];
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(t) {
    return t === null ? 0 : typeof t == "string" ? this.createString(t) : t.pack(this);
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(t) {
    const i = [];
    for (let r = 0; r < t.length; ++r) {
      const n = t[r];
      if (n !== null)
        i.push(this.createObjectOffset(n));
      else
        throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
    }
    return i;
  }
  createStructOffsetList(t, i) {
    return i(this, t.length), this.createObjectOffsetList(t.slice().reverse()), this.endVector();
  }
}, xs = class vl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsKeyValue(t, i) {
    return (i || new vl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsKeyValue(t, i) {
    return t.setPosition(t.position() + de), (i || new vl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  key(t) {
    const i = this.bb.__offset(this.bb_pos, 4);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  value(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  static startKeyValue(t) {
    t.startObject(2);
  }
  static addKey(t, i) {
    t.addFieldOffset(0, i, 0);
  }
  static addValue(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static endKeyValue(t) {
    return t.endObject();
  }
  static createKeyValue(t, i, r) {
    return vl.startKeyValue(t), vl.addKey(t, i), vl.addValue(t, r), vl.endKeyValue(t);
  }
};
var $u;
(function(e) {
  e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
})($u || ($u = {}));
var zu;
(function(e) {
  e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
})(zu || (zu = {}));
var t0;
(function(e) {
  e[e.DenseArray = 0] = "DenseArray";
})(t0 || (t0 = {}));
let ru = class _l {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsInt(t, i) {
    return (i || new _l()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInt(t, i) {
    return t.setPosition(t.position() + de), (i || new _l()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  isSigned() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startInt(t) {
    t.startObject(2);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static addIsSigned(t, i) {
    t.addFieldInt8(1, +i, 0);
  }
  static endInt(t) {
    return t.endObject();
  }
  static createInt(t, i, r) {
    return _l.startInt(t), _l.addBitWidth(t, i), _l.addIsSigned(t, r), _l.endInt(t);
  }
}, Bd = class vb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDictionaryEncoding(t, i) {
    return (i || new vb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryEncoding(t, i) {
    return t.setPosition(t.position() + de), (i || new vb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new ru()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  dictionaryKind() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt16(this.bb_pos + t) : t0.DenseArray;
  }
  static startDictionaryEncoding(t) {
    t.startObject(4);
  }
  static addId(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addIndexType(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addIsOrdered(t, i) {
    t.addFieldInt8(2, +i, 0);
  }
  static addDictionaryKind(t, i) {
    t.addFieldInt16(3, i, t0.DenseArray);
  }
  static endDictionaryEncoding(t) {
    return t.endObject();
  }
}, bA = class tf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBinary(t, i) {
    return (i || new tf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBinary(t, i) {
    return t.setPosition(t.position() + de), (i || new tf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBinary(t) {
    t.startObject(0);
  }
  static endBinary(t) {
    return t.endObject();
  }
  static createBinary(t) {
    return tf.startBinary(t), tf.endBinary(t);
  }
}, xA = class ef {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBool(t, i) {
    return (i || new ef()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBool(t, i) {
    return t.setPosition(t.position() + de), (i || new ef()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBool(t) {
    t.startObject(0);
  }
  static endBool(t) {
    return t.endObject();
  }
  static createBool(t) {
    return ef.startBool(t), ef.endBool(t);
  }
};
var e0;
(function(e) {
  e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
})(e0 || (e0 = {}));
let rg = class Rd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDate(t, i) {
    return (i || new Rd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDate(t, i) {
    return t.setPosition(t.position() + de), (i || new Rd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : e0.MILLISECOND;
  }
  static startDate(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, e0.MILLISECOND);
  }
  static endDate(t) {
    return t.endObject();
  }
  static createDate(t, i) {
    return Rd.startDate(t), Rd.addUnit(t, i), Rd.endDate(t);
  }
}, Md = class lc {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDecimal(t, i) {
    return (i || new lc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDecimal(t, i) {
    return t.setPosition(t.position() + de), (i || new lc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readInt32(this.bb_pos + t) : 128;
  }
  static startDecimal(t) {
    t.startObject(3);
  }
  static addPrecision(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static addScale(t, i) {
    t.addFieldInt32(1, i, 0);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(2, i, 128);
  }
  static endDecimal(t) {
    return t.endObject();
  }
  static createDecimal(t, i, r, n) {
    return lc.startDecimal(t), lc.addPrecision(t, i), lc.addScale(t, r), lc.addBitWidth(t, n), lc.endDecimal(t);
  }
};
var Ec;
(function(e) {
  e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
})(Ec || (Ec = {}));
let ng = class Pd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDuration(t, i) {
    return (i || new Pd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDuration(t, i) {
    return t.setPosition(t.position() + de), (i || new Pd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ec.MILLISECOND;
  }
  static startDuration(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Ec.MILLISECOND);
  }
  static endDuration(t) {
    return t.endObject();
  }
  static createDuration(t, i) {
    return Pd.startDuration(t), Pd.addUnit(t, i), Pd.endDuration(t);
  }
}, sg = class $d {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFixedSizeBinary(t, i) {
    return (i || new $d()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeBinary(t, i) {
    return t.setPosition(t.position() + de), (i || new $d()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeBinary(t) {
    t.startObject(1);
  }
  static addByteWidth(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static endFixedSizeBinary(t) {
    return t.endObject();
  }
  static createFixedSizeBinary(t, i) {
    return $d.startFixedSizeBinary(t), $d.addByteWidth(t, i), $d.endFixedSizeBinary(t);
  }
}, ag = class zd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFixedSizeList(t, i) {
    return (i || new zd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeList(t, i) {
    return t.setPosition(t.position() + de), (i || new zd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeList(t) {
    t.startObject(1);
  }
  static addListSize(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static endFixedSizeList(t) {
    return t.endObject();
  }
  static createFixedSizeList(t, i) {
    return zd.startFixedSizeList(t), zd.addListSize(t, i), zd.endFixedSizeList(t);
  }
};
var i0;
(function(e) {
  e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
})(i0 || (i0 = {}));
let og = class Ud {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFloatingPoint(t, i) {
    return (i || new Ud()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFloatingPoint(t, i) {
    return t.setPosition(t.position() + de), (i || new Ud()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : i0.HALF;
  }
  static startFloatingPoint(t) {
    t.startObject(1);
  }
  static addPrecision(t, i) {
    t.addFieldInt16(0, i, i0.HALF);
  }
  static endFloatingPoint(t) {
    return t.endObject();
  }
  static createFloatingPoint(t, i) {
    return Ud.startFloatingPoint(t), Ud.addPrecision(t, i), Ud.endFloatingPoint(t);
  }
};
var r0;
(function(e) {
  e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
})(r0 || (r0 = {}));
let cg = class Vd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsInterval(t, i) {
    return (i || new Vd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInterval(t, i) {
    return t.setPosition(t.position() + de), (i || new Vd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : r0.YEAR_MONTH;
  }
  static startInterval(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, r0.YEAR_MONTH);
  }
  static endInterval(t) {
    return t.endObject();
  }
  static createInterval(t, i) {
    return Vd.startInterval(t), Vd.addUnit(t, i), Vd.endInterval(t);
  }
}, wA = class rf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsList(t, i) {
    return (i || new rf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsList(t, i) {
    return t.setPosition(t.position() + de), (i || new rf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startList(t) {
    t.startObject(0);
  }
  static endList(t) {
    return t.endObject();
  }
  static createList(t) {
    return rf.startList(t), rf.endList(t);
  }
}, lg = class jd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsMap(t, i) {
    return (i || new jd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMap(t, i) {
    return t.setPosition(t.position() + de), (i || new jd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startMap(t) {
    t.startObject(1);
  }
  static addKeysSorted(t, i) {
    t.addFieldInt8(0, +i, 0);
  }
  static endMap(t) {
    return t.endObject();
  }
  static createMap(t, i) {
    return jd.startMap(t), jd.addKeysSorted(t, i), jd.endMap(t);
  }
}, SA = class nf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsNull(t, i) {
    return (i || new nf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsNull(t, i) {
    return t.setPosition(t.position() + de), (i || new nf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startNull(t) {
    t.startObject(0);
  }
  static endNull(t) {
    return t.endObject();
  }
  static createNull(t) {
    return nf.startNull(t), nf.endNull(t);
  }
}, IA = class sf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsStruct_(t, i) {
    return (i || new sf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsStruct_(t, i) {
    return t.setPosition(t.position() + de), (i || new sf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startStruct_(t) {
    t.startObject(0);
  }
  static endStruct_(t) {
    return t.endObject();
  }
  static createStruct_(t) {
    return sf.startStruct_(t), sf.endStruct_(t);
  }
}, af = class bl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsTime(t, i) {
    return (i || new bl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTime(t, i) {
    return t.setPosition(t.position() + de), (i || new bl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ec.MILLISECOND;
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 32;
  }
  static startTime(t) {
    t.startObject(2);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Ec.MILLISECOND);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(1, i, 32);
  }
  static endTime(t) {
    return t.endObject();
  }
  static createTime(t, i, r) {
    return bl.startTime(t), bl.addUnit(t, i), bl.addBitWidth(t, r), bl.endTime(t);
  }
}, of = class xl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsTimestamp(t, i) {
    return (i || new xl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTimestamp(t, i) {
    return t.setPosition(t.position() + de), (i || new xl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Ec.SECOND;
  }
  timezone(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  static startTimestamp(t) {
    t.startObject(2);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Ec.SECOND);
  }
  static addTimezone(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static endTimestamp(t) {
    return t.endObject();
  }
  static createTimestamp(t, i, r) {
    return xl.startTimestamp(t), xl.addUnit(t, i), xl.addTimezone(t, r), xl.endTimestamp(t);
  }
};
var n0;
(function(e) {
  e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
})(n0 || (n0 = {}));
let wl = class Sl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsUnion(t, i) {
    return (i || new Sl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUnion(t, i) {
    return t.setPosition(t.position() + de), (i || new Sl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  mode() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : n0.Sparse;
  }
  typeIds(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.readInt32(this.bb.__vector(this.bb_pos + i) + t * 4) : 0;
  }
  typeIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  typeIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  static startUnion(t) {
    t.startObject(2);
  }
  static addMode(t, i) {
    t.addFieldInt16(0, i, n0.Sparse);
  }
  static addTypeIds(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static createTypeIdsVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addInt32(i[r]);
    return t.endVector();
  }
  static startTypeIdsVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endUnion(t) {
    return t.endObject();
  }
  static createUnion(t, i, r) {
    return Sl.startUnion(t), Sl.addMode(t, i), Sl.addTypeIds(t, r), Sl.endUnion(t);
  }
}, AA = class cf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsUtf8(t, i) {
    return (i || new cf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUtf8(t, i) {
    return t.setPosition(t.position() + de), (i || new cf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startUtf8(t) {
    t.startObject(0);
  }
  static endUtf8(t) {
    return t.endObject();
  }
  static createUtf8(t) {
    return cf.startUtf8(t), cf.endUtf8(t);
  }
};
var dr;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
})(dr || (dr = {}));
let ds = class dg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsField(t, i) {
    return (i || new dg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsField(t, i) {
    return t.setPosition(t.position() + de), (i || new dg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  name(t) {
    const i = this.bb.__offset(this.bb_pos, 4);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  typeType() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readUint8(this.bb_pos + t) : dr.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? this.bb.__union(t, this.bb_pos + i) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(t) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (t || new Bd()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(t, i) {
    const r = this.bb.__offset(this.bb_pos, 14);
    return r ? (i || new dg()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  childrenLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 16);
    return r ? (i || new xs()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startField(t) {
    t.startObject(7);
  }
  static addName(t, i) {
    t.addFieldOffset(0, i, 0);
  }
  static addNullable(t, i) {
    t.addFieldInt8(1, +i, 0);
  }
  static addTypeType(t, i) {
    t.addFieldInt8(2, i, dr.NONE);
  }
  static addType(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static addDictionary(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static addChildren(t, i) {
    t.addFieldOffset(5, i, 0);
  }
  static createChildrenVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startChildrenVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(6, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endField(t) {
    return t.endObject();
  }
}, ya = class io {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsSchema(t, i) {
    return (i || new io()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSchema(t, i) {
    return t.setPosition(t.position() + de), (i || new io()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : zu.Little;
  }
  fields(t, i) {
    const r = this.bb.__offset(this.bb_pos, 6);
    return r ? (i || new ds()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  fieldsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new xs()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? this.bb.readInt64(this.bb.__vector(this.bb_pos + i) + t * 8) : BigInt(0);
  }
  featuresLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startSchema(t) {
    t.startObject(4);
  }
  static addEndianness(t, i) {
    t.addFieldInt16(0, i, zu.Little);
  }
  static addFields(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static createFieldsVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startFieldsVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addFeatures(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static createFeaturesVector(t, i) {
    t.startVector(8, i.length, 8);
    for (let r = i.length - 1; r >= 0; r--)
      t.addInt64(i[r]);
    return t.endVector();
  }
  static startFeaturesVector(t, i) {
    t.startVector(8, i, 8);
  }
  static endSchema(t) {
    return t.endObject();
  }
  static finishSchemaBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedSchemaBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
  static createSchema(t, i, r, n, s) {
    return io.startSchema(t), io.addEndianness(t, i), io.addFields(t, r), io.addCustomMetadata(t, n), io.addFeatures(t, s), io.endSchema(t);
  }
}, fa = class _b {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFooter(t, i) {
    return (i || new _b()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFooter(t, i) {
    return t.setPosition(t.position() + de), (i || new _b()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : $u.V1;
  }
  schema(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new ya()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  dictionaries(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new gb()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
  }
  dictionariesLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  recordBatches(t, i) {
    const r = this.bb.__offset(this.bb_pos, 10);
    return r ? (i || new gb()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 12);
    return r ? (i || new xs()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startFooter(t) {
    t.startObject(5);
  }
  static addVersion(t, i) {
    t.addFieldInt16(0, i, $u.V1);
  }
  static addSchema(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addDictionaries(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static startDictionariesVector(t, i) {
    t.startVector(24, i, 8);
  }
  static addRecordBatches(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static startRecordBatchesVector(t, i) {
    t.startVector(24, i, 8);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endFooter(t) {
    return t.endObject();
  }
  static finishFooterBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedFooterBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
}, yr = class Il {
  constructor(t = [], i, r, n = dn.V5) {
    this.fields = t || [], this.metadata = i || /* @__PURE__ */ new Map(), r || (r = xb(t)), this.dictionaries = r, this.metadataVersion = n;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((t) => t.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((t, i) => `${i}: ${t}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(t) {
    const i = new Set(t), r = this.fields.filter((n) => i.has(n.name));
    return new Il(r, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(t) {
    const i = t.map((r) => this.fields[r]).filter(Boolean);
    return new Il(i, this.metadata);
  }
  assign(...t) {
    const i = t[0] instanceof Il ? t[0] : Array.isArray(t[0]) ? new Il(t[0]) : new Il(t), r = [...this.fields], n = zm(zm(/* @__PURE__ */ new Map(), this.metadata), i.metadata), s = i.fields.filter((o) => {
      const c = r.findIndex((l) => l.name === o.name);
      return ~c ? (r[c] = o.clone({
        metadata: zm(zm(/* @__PURE__ */ new Map(), r[c].metadata), o.metadata)
      })) && !1 : !0;
    }), a = xb(s, /* @__PURE__ */ new Map());
    return new Il([...r, ...s], n, new Map([...this.dictionaries, ...a]));
  }
};
yr.prototype.fields = null;
yr.prototype.metadata = null;
yr.prototype.dictionaries = null;
let zi = class bb {
  /** @nocollapse */
  static new(...t) {
    let [i, r, n, s] = t;
    return t[0] && typeof t[0] == "object" && ({ name: i } = t[0], r === void 0 && (r = t[0].type), n === void 0 && (n = t[0].nullable), s === void 0 && (s = t[0].metadata)), new bb(`${i}`, r, n, s);
  }
  constructor(t, i, r = !1, n) {
    this.name = t, this.type = i, this.nullable = r, this.metadata = n || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...t) {
    let [i, r, n, s] = t;
    return !t[0] || typeof t[0] != "object" ? [i = this.name, r = this.type, n = this.nullable, s = this.metadata] = t : { name: i = this.name, type: r = this.type, nullable: n = this.nullable, metadata: s = this.metadata } = t[0], bb.new(i, r, n, s);
  }
};
zi.prototype.type = null;
zi.prototype.name = null;
zi.prototype.nullable = null;
zi.prototype.metadata = null;
function zm(e, t) {
  return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
}
function xb(e, t = /* @__PURE__ */ new Map()) {
  for (let i = -1, r = e.length; ++i < r; ) {
    const s = e[i].type;
    if (Ie.isDictionary(s)) {
      if (!t.has(s.id))
        t.set(s.id, s.dictionary);
      else if (t.get(s.id) !== s.dictionary)
        throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
    }
    s.children && s.children.length > 0 && xb(s.children, t);
  }
  return t;
}
var Lj = Ey, Fj = Fa;
let jf = class {
  /** @nocollapse */
  static decode(t) {
    t = new Fj(Ti(t));
    const i = fa.getRootAsFooter(t), r = yr.decode(i.schema(), /* @__PURE__ */ new Map(), i.version());
    return new Bj(r, i);
  }
  /** @nocollapse */
  static encode(t) {
    const i = new Lj(), r = yr.encode(i, t.schema);
    fa.startRecordBatchesVector(i, t.numRecordBatches);
    for (const a of [...t.recordBatches()].slice().reverse())
      Uu.encode(i, a);
    const n = i.endVector();
    fa.startDictionariesVector(i, t.numDictionaries);
    for (const a of [...t.dictionaryBatches()].slice().reverse())
      Uu.encode(i, a);
    const s = i.endVector();
    return fa.startFooter(i), fa.addSchema(i, r), fa.addVersion(i, dn.V5), fa.addRecordBatches(i, n), fa.addDictionaries(i, s), fa.finishFooterBuffer(i, fa.endFooter(i)), i.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(t, i = dn.V5, r, n) {
    this.schema = t, this.version = i, r && (this._recordBatches = r), n && (this._dictionaryBatches = n);
  }
  *recordBatches() {
    for (let t, i = -1, r = this.numRecordBatches; ++i < r; )
      (t = this.getRecordBatch(i)) && (yield t);
  }
  *dictionaryBatches() {
    for (let t, i = -1, r = this.numDictionaries; ++i < r; )
      (t = this.getDictionaryBatch(i)) && (yield t);
  }
  getRecordBatch(t) {
    return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
  }
  getDictionaryBatch(t) {
    return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
  }
}, Bj = class extends jf {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(t, i) {
    super(t, i.version()), this._footer = i;
  }
  getRecordBatch(t) {
    if (t >= 0 && t < this.numRecordBatches) {
      const i = this._footer.recordBatches(t);
      if (i)
        return Uu.decode(i);
    }
    return null;
  }
  getDictionaryBatch(t) {
    if (t >= 0 && t < this.numDictionaries) {
      const i = this._footer.dictionaries(t);
      if (i)
        return Uu.decode(i);
    }
    return null;
  }
}, Uu = class _C {
  /** @nocollapse */
  static decode(t) {
    return new _C(t.metaDataLength(), t.bodyLength(), t.offset());
  }
  /** @nocollapse */
  static encode(t, i) {
    const { metaDataLength: r } = i, n = BigInt(i.offset), s = BigInt(i.bodyLength);
    return gb.createBlock(t, n, r, s);
  }
  constructor(t, i, r) {
    this.metaDataLength = t, this.offset = Js(r), this.bodyLength = Js(i);
  }
};
const vr = Object.freeze({ done: !0, value: void 0 });
let TA = class {
  constructor(t) {
    this._json = t;
  }
  get schema() {
    return this._json.schema;
  }
  get batches() {
    return this._json.batches || [];
  }
  get dictionaries() {
    return this._json.dictionaries || [];
  }
}, bx = class {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(t, i) {
    return this._getNodeStream().pipe(t, i);
  }
  pipeTo(t, i) {
    return this._getDOMStream().pipeTo(t, i);
  }
  pipeThrough(t, i) {
    return this._getDOMStream().pipeThrough(t, i);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
}, Rj = class extends bx {
  constructor() {
    super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  write(t) {
    this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({ done: !1, value: t }));
  }
  abort(t) {
    this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = { error: t } : this.resolvers.shift().reject({ done: !0, value: t }));
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers: t } = this;
      for (; t.length > 0; )
        t.shift().resolve(vr);
      this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(t) {
    return ps.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  toNodeStream(t) {
    return ps.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.abort(t), vr;
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), vr;
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(...t) {
    return this._values.length > 0 ? Promise.resolve({ done: !1, value: this._values.shift() }) : this._error ? Promise.reject({ done: !0, value: this._error.error }) : this._closedPromiseResolve ? new Promise((i, r) => {
      this.resolvers.push({ resolve: i, reject: r });
    }) : Promise.resolve(vr);
  }
  _ensureOpen() {
    if (this._closedPromiseResolve)
      return !0;
    throw new Error("AsyncQueue is closed");
  }
}, ug = class extends Rj {
  write(t) {
    if ((t = Ti(t)).byteLength > 0)
      return super.write(t);
  }
  toString(t = !1) {
    return t ? db(this.toUint8Array(!0)) : this.toUint8Array(!1).then(db);
  }
  toUint8Array(t = !1) {
    return t ? Da(this._values)[0] : Dt(this, void 0, void 0, function* () {
      var i, r, n, s;
      const a = [];
      let o = 0;
      try {
        for (var c = !0, l = es(this), d; d = yield l.next(), i = d.done, !i; c = !0) {
          s = d.value, c = !1;
          const u = s;
          a.push(u), o += u.byteLength;
        }
      } catch (u) {
        r = { error: u };
      } finally {
        try {
          !c && !i && (n = l.return) && (yield n.call(l));
        } finally {
          if (r)
            throw r.error;
        }
      }
      return Da(a, o)[0];
    });
  }
}, s0 = class {
  constructor(t) {
    t && (this.source = new Mj(ps.fromIterable(t)));
  }
  [Symbol.iterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}, a0 = class bC {
  constructor(t) {
    t instanceof bC ? this.source = t.source : t instanceof ug ? this.source = new hl(ps.fromAsyncIterable(t)) : qE(t) ? this.source = new hl(ps.fromNodeStream(t)) : $1(t) ? this.source = new hl(ps.fromDOMStream(t)) : YE(t) ? this.source = new hl(ps.fromDOMStream(t.body)) : Ip(t) ? this.source = new hl(ps.fromIterable(t)) : Sc(t) ? this.source = new hl(ps.fromAsyncIterable(t)) : ih(t) && (this.source = new hl(ps.fromAsyncIterable(t)));
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(t) {
    return this.source.cancel(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}, Mj = class {
  constructor(t) {
    this.source = t;
  }
  cancel(t) {
    this.return(t);
  }
  peek(t) {
    return this.next(t, "peek").value;
  }
  read(t) {
    return this.next(t, "read").value;
  }
  next(t, i = "read") {
    return this.source.next({ cmd: i, size: t });
  }
  throw(t) {
    return Object.create(this.source.throw && this.source.throw(t) || vr);
  }
  return(t) {
    return Object.create(this.source.return && this.source.return(t) || vr);
  }
}, hl = class {
  constructor(t) {
    this.source = t, this._closedPromise = new Promise((i) => this._closedPromiseResolve = i);
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(t, i = "read") {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd: i, size: t });
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = this.source.throw && (yield this.source.throw(t)) || vr;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(i);
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = this.source.return && (yield this.source.return(t)) || vr;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(i);
    });
  }
}, EA = class extends s0 {
  constructor(t, i) {
    super(), this.position = 0, this.buffer = Ti(t), this.size = i === void 0 ? this.buffer.byteLength : i;
  }
  readInt32(t) {
    const { buffer: i, byteOffset: r } = this.readAt(t, 4);
    return new DataView(i, r).getInt32(0, !0);
  }
  seek(t) {
    return this.position = Math.min(t, this.size), t < this.size;
  }
  read(t) {
    const { buffer: i, size: r, position: n } = this;
    return i && n < r ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(r, n + Math.min(r - n, t)), i.subarray(n, this.position)) : null;
  }
  readAt(t, i) {
    const r = this.buffer, n = Math.min(this.size, t + i);
    return r ? r.subarray(t, n) : new Uint8Array(i);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(t) {
    return this.close(), { done: !0, value: t };
  }
  return(t) {
    return this.close(), { done: !0, value: t };
  }
}, o0 = class extends a0 {
  constructor(t, i) {
    super(), this.position = 0, this._handle = t, typeof i == "number" ? this.size = i : this._pending = Dt(this, void 0, void 0, function* () {
      this.size = (yield t.stat()).size, delete this._pending;
    });
  }
  readInt32(t) {
    return Dt(this, void 0, void 0, function* () {
      const { buffer: i, byteOffset: r } = yield this.readAt(t, 4);
      return new DataView(i, r).getInt32(0, !0);
    });
  }
  seek(t) {
    return Dt(this, void 0, void 0, function* () {
      return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: i, size: r, position: n } = this;
      if (i && n < r) {
        typeof t != "number" && (t = Number.POSITIVE_INFINITY);
        let s = n, a = 0, o = 0;
        const c = Math.min(r, s + Math.min(r - s, t)), l = new Uint8Array(Math.max(0, (this.position = c) - s));
        for (; (s += o) < c && (a += o) < l.byteLength; )
          ({ bytesRead: o } = yield i.read(l, a, l.byteLength - a, s));
        return l;
      }
      return null;
    });
  }
  readAt(t, i) {
    return Dt(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: r, size: n } = this;
      if (r && t + i < n) {
        const s = Math.min(n, t + i), a = new Uint8Array(s - t);
        return (yield r.read(a, 0, i, t)).buffer;
      }
      return new Uint8Array(i);
    });
  }
  close() {
    return Dt(this, void 0, void 0, function* () {
      const t = this._handle;
      this._handle = null, t && (yield t.close());
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
};
const Pj = 65536;
function nu(e) {
  return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
}
const Vu = 8, xx = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
let xC = class {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(t) {
    const i = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]), r = new Uint32Array([
      t.buffer[1] >>> 16,
      t.buffer[1] & 65535,
      t.buffer[0] >>> 16,
      t.buffer[0] & 65535
    ]);
    let n = i[3] * r[3];
    this.buffer[0] = n & 65535;
    let s = n >>> 16;
    return n = i[2] * r[3], s += n, n = i[3] * r[2] >>> 0, s += n, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < n ? Pj : 0, this.buffer[1] += s >>> 16, this.buffer[1] += i[1] * r[3] + i[2] * r[2] + i[3] * r[1], this.buffer[1] += i[0] * r[3] + i[1] * r[2] + i[2] * r[1] + i[3] * r[0] << 16, this;
  }
  _plus(t) {
    const i = this.buffer[0] + t.buffer[0] >>> 0;
    this.buffer[1] += t.buffer[1], i < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = i;
  }
  lessThan(t) {
    return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
  }
  equals(t) {
    return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
  }
  greaterThan(t) {
    return t.lessThan(this);
  }
  hex() {
    return `${nu(this.buffer[1])} ${nu(this.buffer[0])}`;
  }
}, Ur = class ro extends xC {
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(2)) {
    return ro.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(2)) {
    return ro.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(2)) {
    const r = t.length, n = new ro(i);
    for (let s = 0; s < r; ) {
      const a = Vu < r - s ? Vu : r - s, o = new ro(new Uint32Array([Number.parseInt(t.slice(s, s + a), 10), 0])), c = new ro(new Uint32Array([xx[a], 0]));
      n.times(c), n.plus(o), s += a;
    }
    return n;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 2);
    for (let r = -1, n = t.length; ++r < n; )
      ro.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 2 * r * 4, 2));
    return i;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new ro(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new ro(new Uint32Array(t.buffer)).plus(i);
  }
}, If = class no extends xC {
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
  }
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  lessThan(t) {
    const i = this.buffer[1] << 0, r = t.buffer[1] << 0;
    return i < r || i === r && this.buffer[0] < t.buffer[0];
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(2)) {
    return no.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(2)) {
    return no.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(2)) {
    const r = t.startsWith("-"), n = t.length, s = new no(i);
    for (let a = r ? 1 : 0; a < n; ) {
      const o = Vu < n - a ? Vu : n - a, c = new no(new Uint32Array([Number.parseInt(t.slice(a, a + o), 10), 0])), l = new no(new Uint32Array([xx[o], 0]));
      s.times(l), s.plus(c), a += o;
    }
    return r ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 2);
    for (let r = -1, n = t.length; ++r < n; )
      no.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 2 * r * 4, 2));
    return i;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new no(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new no(new Uint32Array(t.buffer)).plus(i);
  }
}, $j = class so {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return new If(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new If(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
  }
  times(t) {
    const i = new Ur(new Uint32Array([this.buffer[3], 0])), r = new Ur(new Uint32Array([this.buffer[2], 0])), n = new Ur(new Uint32Array([this.buffer[1], 0])), s = new Ur(new Uint32Array([this.buffer[0], 0])), a = new Ur(new Uint32Array([t.buffer[3], 0])), o = new Ur(new Uint32Array([t.buffer[2], 0])), c = new Ur(new Uint32Array([t.buffer[1], 0])), l = new Ur(new Uint32Array([t.buffer[0], 0]));
    let d = Ur.multiply(s, l);
    this.buffer[0] = d.low();
    const u = new Ur(new Uint32Array([d.high(), 0]));
    return d = Ur.multiply(n, l), u.plus(d), d = Ur.multiply(s, c), u.plus(d), this.buffer[1] = u.low(), this.buffer[3] = u.lessThan(d) ? 1 : 0, this.buffer[2] = u.high(), new Ur(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Ur.multiply(r, l)).plus(Ur.multiply(n, c)).plus(Ur.multiply(s, o)), this.buffer[3] += Ur.multiply(i, l).plus(Ur.multiply(r, c)).plus(Ur.multiply(n, o)).plus(Ur.multiply(s, a)).low(), this;
  }
  plus(t) {
    const i = new Uint32Array(4);
    return i[3] = this.buffer[3] + t.buffer[3] >>> 0, i[2] = this.buffer[2] + t.buffer[2] >>> 0, i[1] = this.buffer[1] + t.buffer[1] >>> 0, i[0] = this.buffer[0] + t.buffer[0] >>> 0, i[0] < this.buffer[0] >>> 0 && ++i[1], i[1] < this.buffer[1] >>> 0 && ++i[2], i[2] < this.buffer[2] >>> 0 && ++i[3], this.buffer[3] = i[3], this.buffer[2] = i[2], this.buffer[1] = i[1], this.buffer[0] = i[0], this;
  }
  hex() {
    return `${nu(this.buffer[3])} ${nu(this.buffer[2])} ${nu(this.buffer[1])} ${nu(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new so(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new so(new Uint32Array(t.buffer)).plus(i);
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(4)) {
    return so.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(4)) {
    return so.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(4)) {
    const r = t.startsWith("-"), n = t.length, s = new so(i);
    for (let a = r ? 1 : 0; a < n; ) {
      const o = Vu < n - a ? Vu : n - a, c = new so(new Uint32Array([Number.parseInt(t.slice(a, a + o), 10), 0, 0, 0])), l = new so(new Uint32Array([xx[o], 0, 0, 0]));
      s.times(l), s.plus(c), a += o;
    }
    return r ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 4);
    for (let r = -1, n = t.length; ++r < n; )
      so.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 4 * 4 * r, 4));
    return i;
  }
}, wC = class extends ti {
  constructor(t, i, r, n, s = dn.V5) {
    super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = i, this.buffers = r, this.dictionaries = n, this.metadataVersion = s;
  }
  visit(t) {
    return super.visit(t instanceof zi ? t.type : t);
  }
  visitNull(t, { length: i } = this.nextFieldNode()) {
    return di({ type: t, length: i });
  }
  visitBool(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitInt(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitFloat(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitUtf8(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitBinary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitFixedSizeBinary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDate(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitTimestamp(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitTime(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDecimal(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitList(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  visitStruct(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), children: this.visitMany(t.children) });
  }
  visitUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return this.metadataVersion < dn.V5 && this.readNullBitmap(t, r), t.mode === En.Sparse ? this.visitSparseUnion(t, { length: i, nullCount: r }) : this.visitDenseUnion(t, { length: i, nullCount: r });
  }
  visitDenseUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, typeIds: this.readTypeIds(t), valueOffsets: this.readOffsets(t), children: this.visitMany(t.children) });
  }
  visitSparseUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, typeIds: this.readTypeIds(t), children: this.visitMany(t.children) });
  }
  visitDictionary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t.indices), dictionary: this.readDictionary(t) });
  }
  visitInterval(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDuration(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitFixedSizeList(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), child: this.visit(t.children[0]) });
  }
  visitMap(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return di({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(t, i, r = this.nextBufferRange()) {
    return i > 0 && this.readData(t, r) || new Uint8Array(0);
  }
  readOffsets(t, i) {
    return this.readData(t, i);
  }
  readTypeIds(t, i) {
    return this.readData(t, i);
  }
  readData(t, { length: i, offset: r } = this.nextBufferRange()) {
    return this.bytes.subarray(r, r + i);
  }
  readDictionary(t) {
    return this.dictionaries.get(t.id);
  }
}, zj = class extends wC {
  constructor(t, i, r, n, s) {
    super(new Uint8Array(0), i, r, n, s), this.sources = t;
  }
  readNullBitmap(t, i, { offset: r } = this.nextBufferRange()) {
    return i <= 0 ? new Uint8Array(0) : Jg(this.sources[r]);
  }
  readOffsets(t, { offset: i } = this.nextBufferRange()) {
    return Wi(Uint8Array, Wi(Int32Array, this.sources[i]));
  }
  readTypeIds(t, { offset: i } = this.nextBufferRange()) {
    return Wi(Uint8Array, Wi(t.ArrayType, this.sources[i]));
  }
  readData(t, { offset: i } = this.nextBufferRange()) {
    const { sources: r } = this;
    return Ie.isTimestamp(t) || (Ie.isInt(t) || Ie.isTime(t)) && t.bitWidth === 64 || Ie.isDuration(t) || Ie.isDate(t) && t.unit === Ks.MILLISECOND ? Wi(Uint8Array, If.convertArray(r[i])) : Ie.isDecimal(t) ? Wi(Uint8Array, $j.convertArray(r[i])) : Ie.isBinary(t) || Ie.isFixedSizeBinary(t) ? Uj(r[i]) : Ie.isBool(t) ? Jg(r[i]) : Ie.isUtf8(t) ? xy(r[i].join("")) : Wi(Uint8Array, Wi(t.ArrayType, r[i].map((n) => +n)));
  }
};
function Uj(e) {
  const t = e.join(""), i = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    i[r >> 1] = Number.parseInt(t.slice(r, r + 2), 16);
  return i;
}
class SC extends Ty {
  constructor(t) {
    super(t), this._values = new Ay(new Uint8Array(0));
  }
  get byteLength() {
    let t = this._pendingLength + this.length * 4;
    return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t;
  }
  setValue(t, i) {
    return super.setValue(t, Ti(i));
  }
  _flushPending(t, i) {
    const r = this._offsets, n = this._values.reserve(i).buffer;
    let s = 0;
    for (const [a, o] of t)
      if (o === void 0)
        r.set(a, 0);
      else {
        const c = o.length;
        n.set(o, s), r.set(a, c), s += c;
      }
  }
}
class Vj extends qn {
  constructor(t) {
    super(t), this._values = new mC();
  }
  setValue(t, i) {
    this._values.set(t, +i);
  }
}
class ky extends zo {
}
ky.prototype._setValue = Tk;
class IC extends ky {
}
IC.prototype._setValue = J1;
class AC extends ky {
}
AC.prototype._setValue = Q1;
class TC extends zo {
}
TC.prototype._setValue = Ck;
class jj extends qn {
  constructor({ type: t, nullValues: i, dictionaryHashFunction: r }) {
    super({ type: new Tc(t.dictionary, t.indices, t.id, t.isOrdered) }), this._nulls = null, this._dictionaryOffset = 0, this._keysToIndices = /* @__PURE__ */ Object.create(null), this.indices = c0({ type: this.type.indices, nullValues: i }), this.dictionary = c0({ type: this.type.dictionary, nullValues: null }), typeof r == "function" && (this.valueToKey = r);
  }
  get values() {
    return this.indices.values;
  }
  get nullCount() {
    return this.indices.nullCount;
  }
  get nullBitmap() {
    return this.indices.nullBitmap;
  }
  get byteLength() {
    return this.indices.byteLength + this.dictionary.byteLength;
  }
  get reservedLength() {
    return this.indices.reservedLength + this.dictionary.reservedLength;
  }
  get reservedByteLength() {
    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
  }
  isValid(t) {
    return this.indices.isValid(t);
  }
  setValid(t, i) {
    const r = this.indices;
    return i = r.setValid(t, i), this.length = r.length, i;
  }
  setValue(t, i) {
    const r = this._keysToIndices, n = this.valueToKey(i);
    let s = r[n];
    return s === void 0 && (r[n] = s = this._dictionaryOffset + this.dictionary.append(i).length - 1), this.indices.setValue(t, s);
  }
  flush() {
    const t = this.type, i = this._dictionary, r = this.dictionary.toVector(), n = this.indices.flush().clone(t);
    return n.dictionary = i ? i.concat(r) : r, this.finished || (this._dictionaryOffset += r.length), this._dictionary = n.dictionary, this.clear(), n;
  }
  finish() {
    return this.indices.finish(), this.dictionary.finish(), this._dictionaryOffset = 0, this._keysToIndices = /* @__PURE__ */ Object.create(null), super.finish();
  }
  clear() {
    return this.indices.clear(), this.dictionary.clear(), super.clear();
  }
  valueToKey(t) {
    return typeof t == "string" ? t : `${t}`;
  }
}
class EC extends zo {
}
EC.prototype._setValue = Ak;
class Gj extends qn {
  setValue(t, i) {
    const [r] = this.children, n = t * this.stride;
    for (let s = -1, a = i.length; ++s < a; )
      r.set(n + s, i[s]);
  }
  addChild(t, i = "0") {
    if (this.numChildren > 0)
      throw new Error("FixedSizeListBuilder can only have one child.");
    const r = this.children.push(t);
    return this.type = new Pu(this.type.listSize, new zi(i, t.type, !0)), r;
  }
}
class Cy extends zo {
  setValue(t, i) {
    this._values.set(t, i);
  }
}
class Hj extends Cy {
  setValue(t, i) {
    super.setValue(t, wk(i));
  }
}
class Wj extends Cy {
}
class Yj extends Cy {
}
class Oy extends zo {
}
Oy.prototype._setValue = Nk;
class kC extends Oy {
}
kC.prototype._setValue = cx;
class CC extends Oy {
}
CC.prototype._setValue = lx;
class nh extends zo {
}
nh.prototype._setValue = Lk;
class OC extends nh {
}
OC.prototype._setValue = dx;
class DC extends nh {
}
DC.prototype._setValue = ux;
class NC extends nh {
}
NC.prototype._setValue = hx;
class LC extends nh {
}
LC.prototype._setValue = fx;
class Uo extends zo {
  setValue(t, i) {
    this._values.set(t, i);
  }
}
class qj extends Uo {
}
class Zj extends Uo {
}
class Xj extends Uo {
}
class Kj extends Uo {
}
class Jj extends Uo {
}
class Qj extends Uo {
}
class tG extends Uo {
}
class eG extends Uo {
}
class iG extends Ty {
  constructor(t) {
    super(t), this._offsets = new gC();
  }
  addChild(t, i = "0") {
    if (this.numChildren > 0)
      throw new Error("ListBuilder can only have one child.");
    return this.children[this.numChildren] = t, this.type = new Mu(new zi(i, t.type, !0)), this.numChildren - 1;
  }
  _flushPending(t) {
    const i = this._offsets, [r] = this.children;
    for (const [n, s] of t)
      if (typeof s > "u")
        i.set(n, 0);
      else {
        const a = s, o = a.length, c = i.set(n, o).buffer[n];
        for (let l = -1; ++l < o; )
          r.set(c + l, a[l]);
      }
  }
}
class rG extends Ty {
  set(t, i) {
    return super.set(t, i);
  }
  setValue(t, i) {
    const r = i instanceof Map ? i : new Map(Object.entries(i)), n = this._pending || (this._pending = /* @__PURE__ */ new Map()), s = n.get(t);
    s && (this._pendingLength -= s.size), this._pendingLength += r.size, n.set(t, r);
  }
  addChild(t, i = `${this.numChildren}`) {
    if (this.numChildren > 0)
      throw new Error("ListBuilder can only have one child.");
    return this.children[this.numChildren] = t, this.type = new Vf(new zi(i, t.type, !0), this.type.keysSorted), this.numChildren - 1;
  }
  _flushPending(t) {
    const i = this._offsets, [r] = this.children;
    for (const [n, s] of t)
      if (s === void 0)
        i.set(n, 0);
      else {
        let { [n]: a, [n + 1]: o } = i.set(n, s.size).buffer;
        for (const c of s.entries())
          if (r.set(a, c), ++a >= o)
            break;
      }
  }
}
class nG extends qn {
  // @ts-ignore
  setValue(t, i) {
  }
  setValid(t, i) {
    return this.length = Math.max(t + 1, this.length), i;
  }
}
class sG extends qn {
  setValue(t, i) {
    const { children: r, type: n } = this;
    switch (Array.isArray(i) || i.constructor) {
      case !0:
        return n.children.forEach((s, a) => r[a].set(t, i[a]));
      case Map:
        return n.children.forEach((s, a) => r[a].set(t, i.get(s.name)));
      default:
        return n.children.forEach((s, a) => r[a].set(t, i[s.name]));
    }
  }
  /** @inheritdoc */
  setValid(t, i) {
    return super.setValid(t, i) || this.children.forEach((r) => r.setValid(t, i)), i;
  }
  addChild(t, i = `${this.numChildren}`) {
    const r = this.children.push(t);
    return this.type = new un([...this.type.children, new zi(i, t.type, !0)]), r;
  }
}
class sh extends zo {
}
sh.prototype._setValue = Ek;
class FC extends sh {
}
FC.prototype._setValue = tx;
class BC extends sh {
}
BC.prototype._setValue = ex;
class RC extends sh {
}
RC.prototype._setValue = ix;
class MC extends sh {
}
MC.prototype._setValue = rx;
class ah extends zo {
}
ah.prototype._setValue = kk;
class PC extends ah {
}
PC.prototype._setValue = nx;
class $C extends ah {
}
$C.prototype._setValue = sx;
class zC extends ah {
}
zC.prototype._setValue = ax;
class UC extends ah {
}
UC.prototype._setValue = ox;
class wx extends qn {
  constructor(t) {
    super(t), this._typeIds = new Ap(new Int8Array(0), 1), typeof t.valueToChildTypeId == "function" && (this._valueToChildTypeId = t.valueToChildTypeId);
  }
  get typeIdToChildIndex() {
    return this.type.typeIdToChildIndex;
  }
  append(t, i) {
    return this.set(this.length, t, i);
  }
  set(t, i, r) {
    return r === void 0 && (r = this._valueToChildTypeId(this, i, t)), this.setValue(t, i, r), this;
  }
  setValue(t, i, r) {
    this._typeIds.set(t, r);
    const n = this.type.typeIdToChildIndex[r], s = this.children[n];
    s == null || s.set(t, i);
  }
  addChild(t, i = `${this.children.length}`) {
    const r = this.children.push(t), { type: { children: n, mode: s, typeIds: a } } = this, o = [...n, new zi(i, t.type)];
    return this.type = new Uf(s, [...a, r], o), r;
  }
  /** @ignore */
  // @ts-ignore
  _valueToChildTypeId(t, i, r) {
    throw new Error("Cannot map UnionBuilder value to child typeId. Pass the `childTypeId` as the second argument to unionBuilder.append(), or supply a `valueToChildTypeId` function as part of the UnionBuilder constructor options.");
  }
}
class aG extends wx {
}
class oG extends wx {
  constructor(t) {
    super(t), this._offsets = new Ap(new Int32Array(0));
  }
  /** @ignore */
  setValue(t, i, r) {
    const n = this._typeIds.set(t, r).buffer[t], s = this.getChildAt(this.type.typeIdToChildIndex[n]), a = this._offsets.set(t, s.length).buffer[t];
    s == null || s.set(a, i);
  }
}
class VC extends Ty {
  constructor(t) {
    super(t), this._values = new Ay(new Uint8Array(0));
  }
  get byteLength() {
    let t = this._pendingLength + this.length * 4;
    return this._offsets && (t += this._offsets.byteLength), this._values && (t += this._values.byteLength), this._nulls && (t += this._nulls.byteLength), t;
  }
  setValue(t, i) {
    return super.setValue(t, xy(i));
  }
  // @ts-ignore
  _flushPending(t, i) {
  }
}
VC.prototype._flushPending = SC.prototype._flushPending;
class cG extends ti {
  visitNull() {
    return nG;
  }
  visitBool() {
    return Vj;
  }
  visitInt() {
    return Uo;
  }
  visitInt8() {
    return qj;
  }
  visitInt16() {
    return Zj;
  }
  visitInt32() {
    return Xj;
  }
  visitInt64() {
    return Kj;
  }
  visitUint8() {
    return Jj;
  }
  visitUint16() {
    return Qj;
  }
  visitUint32() {
    return tG;
  }
  visitUint64() {
    return eG;
  }
  visitFloat() {
    return Cy;
  }
  visitFloat16() {
    return Hj;
  }
  visitFloat32() {
    return Wj;
  }
  visitFloat64() {
    return Yj;
  }
  visitUtf8() {
    return VC;
  }
  visitBinary() {
    return SC;
  }
  visitFixedSizeBinary() {
    return EC;
  }
  visitDate() {
    return ky;
  }
  visitDateDay() {
    return IC;
  }
  visitDateMillisecond() {
    return AC;
  }
  visitTimestamp() {
    return sh;
  }
  visitTimestampSecond() {
    return FC;
  }
  visitTimestampMillisecond() {
    return BC;
  }
  visitTimestampMicrosecond() {
    return RC;
  }
  visitTimestampNanosecond() {
    return MC;
  }
  visitTime() {
    return ah;
  }
  visitTimeSecond() {
    return PC;
  }
  visitTimeMillisecond() {
    return $C;
  }
  visitTimeMicrosecond() {
    return zC;
  }
  visitTimeNanosecond() {
    return UC;
  }
  visitDecimal() {
    return TC;
  }
  visitList() {
    return iG;
  }
  visitStruct() {
    return sG;
  }
  visitUnion() {
    return wx;
  }
  visitDenseUnion() {
    return oG;
  }
  visitSparseUnion() {
    return aG;
  }
  visitDictionary() {
    return jj;
  }
  visitInterval() {
    return Oy;
  }
  visitIntervalDayTime() {
    return kC;
  }
  visitIntervalYearMonth() {
    return CC;
  }
  visitDuration() {
    return nh;
  }
  visitDurationSecond() {
    return OC;
  }
  visitDurationMillisecond() {
    return DC;
  }
  visitDurationMicrosecond() {
    return NC;
  }
  visistDurationNanosecond() {
    return LC;
  }
  visitFixedSizeList() {
    return Gj;
  }
  visitMap() {
    return rG;
  }
}
const lG = new cG();
let Ne = class extends ti {
  compareSchemas(t, i) {
    return t === i || i instanceof t.constructor && this.compareManyFields(t.fields, i.fields);
  }
  compareManyFields(t, i) {
    return t === i || Array.isArray(t) && Array.isArray(i) && t.length === i.length && t.every((r, n) => this.compareFields(r, i[n]));
  }
  compareFields(t, i) {
    return t === i || i instanceof t.constructor && t.name === i.name && t.nullable === i.nullable && this.visit(t.type, i.type);
  }
};
function Dn(e, t) {
  return t instanceof e.constructor;
}
function Tp(e, t) {
  return e === t || Dn(e, t);
}
function Vo(e, t) {
  return e === t || Dn(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
}
function Dy(e, t) {
  return e === t || Dn(e, t) && e.precision === t.precision;
}
function dG(e, t) {
  return e === t || Dn(e, t) && e.byteWidth === t.byteWidth;
}
function Sx(e, t) {
  return e === t || Dn(e, t) && e.unit === t.unit;
}
function Ep(e, t) {
  return e === t || Dn(e, t) && e.unit === t.unit && e.timezone === t.timezone;
}
function kp(e, t) {
  return e === t || Dn(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
}
function uG(e, t) {
  return e === t || Dn(e, t) && e.children.length === t.children.length && kc.compareManyFields(e.children, t.children);
}
function hG(e, t) {
  return e === t || Dn(e, t) && e.children.length === t.children.length && kc.compareManyFields(e.children, t.children);
}
function Ix(e, t) {
  return e === t || Dn(e, t) && e.mode === t.mode && e.typeIds.every((i, r) => i === t.typeIds[r]) && kc.compareManyFields(e.children, t.children);
}
function fG(e, t) {
  return e === t || Dn(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && kc.visit(e.indices, t.indices) && kc.visit(e.dictionary, t.dictionary);
}
function Ax(e, t) {
  return e === t || Dn(e, t) && e.unit === t.unit;
}
function Cp(e, t) {
  return e === t || Dn(e, t) && e.unit === t.unit;
}
function pG(e, t) {
  return e === t || Dn(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && kc.compareManyFields(e.children, t.children);
}
function mG(e, t) {
  return e === t || Dn(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && kc.compareManyFields(e.children, t.children);
}
Ne.prototype.visitNull = Tp;
Ne.prototype.visitBool = Tp;
Ne.prototype.visitInt = Vo;
Ne.prototype.visitInt8 = Vo;
Ne.prototype.visitInt16 = Vo;
Ne.prototype.visitInt32 = Vo;
Ne.prototype.visitInt64 = Vo;
Ne.prototype.visitUint8 = Vo;
Ne.prototype.visitUint16 = Vo;
Ne.prototype.visitUint32 = Vo;
Ne.prototype.visitUint64 = Vo;
Ne.prototype.visitFloat = Dy;
Ne.prototype.visitFloat16 = Dy;
Ne.prototype.visitFloat32 = Dy;
Ne.prototype.visitFloat64 = Dy;
Ne.prototype.visitUtf8 = Tp;
Ne.prototype.visitBinary = Tp;
Ne.prototype.visitFixedSizeBinary = dG;
Ne.prototype.visitDate = Sx;
Ne.prototype.visitDateDay = Sx;
Ne.prototype.visitDateMillisecond = Sx;
Ne.prototype.visitTimestamp = Ep;
Ne.prototype.visitTimestampSecond = Ep;
Ne.prototype.visitTimestampMillisecond = Ep;
Ne.prototype.visitTimestampMicrosecond = Ep;
Ne.prototype.visitTimestampNanosecond = Ep;
Ne.prototype.visitTime = kp;
Ne.prototype.visitTimeSecond = kp;
Ne.prototype.visitTimeMillisecond = kp;
Ne.prototype.visitTimeMicrosecond = kp;
Ne.prototype.visitTimeNanosecond = kp;
Ne.prototype.visitDecimal = Tp;
Ne.prototype.visitList = uG;
Ne.prototype.visitStruct = hG;
Ne.prototype.visitUnion = Ix;
Ne.prototype.visitDenseUnion = Ix;
Ne.prototype.visitSparseUnion = Ix;
Ne.prototype.visitDictionary = fG;
Ne.prototype.visitInterval = Ax;
Ne.prototype.visitIntervalDayTime = Ax;
Ne.prototype.visitIntervalYearMonth = Ax;
Ne.prototype.visitDuration = Cp;
Ne.prototype.visitDurationSecond = Cp;
Ne.prototype.visitDurationMillisecond = Cp;
Ne.prototype.visitDurationMicrosecond = Cp;
Ne.prototype.visitDurationNanosecond = Cp;
Ne.prototype.visitFixedSizeList = pG;
Ne.prototype.visitMap = mG;
const kc = new Ne();
function wb(e, t) {
  return kc.compareSchemas(e, t);
}
function c0(e) {
  const t = e.type, i = new (lG.getVisitFn(t)())(e);
  if (t.children && t.children.length > 0) {
    const r = e.children || [], n = { nullValues: e.nullValues }, s = Array.isArray(r) ? (a, o) => r[o] || n : ({ name: a }) => r[a] || n;
    for (const [a, o] of t.children.entries()) {
      const { type: c } = o, l = s(o, a);
      i.children.push(c0(Object.assign(Object.assign({}, l), { type: c })));
    }
  }
  return i;
}
function w_(e, t) {
  return gG(e, t.map((i) => i.data.concat()));
}
function gG(e, t) {
  const i = [...e.fields], r = [], n = { numBatches: t.reduce((u, h) => Math.max(u, h.length), 0) };
  let s = 0, a = 0, o = -1;
  const c = t.length;
  let l, d = [];
  for (; n.numBatches-- > 0; ) {
    for (a = Number.POSITIVE_INFINITY, o = -1; ++o < c; )
      d[o] = l = t[o].shift(), a = Math.min(a, l ? l.length : a);
    Number.isFinite(a) && (d = yG(i, a, d, t, n), a > 0 && (r[s++] = di({
      type: new un(i),
      length: a,
      nullCount: 0,
      children: d.slice()
    })));
  }
  return [
    e = e.assign(i),
    r.map((u) => new Pn(e, u))
  ];
}
function yG(e, t, i, r, n) {
  var s;
  const a = (t + 63 & -64) >> 3;
  for (let o = -1, c = r.length; ++o < c; ) {
    const l = i[o], d = l == null ? void 0 : l.length;
    if (d >= t)
      d === t ? i[o] = l : (i[o] = l.slice(0, t), n.numBatches = Math.max(n.numBatches, r[o].unshift(l.slice(t, d - t))));
    else {
      const u = e[o];
      e[o] = u.clone({ nullable: !0 }), i[o] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : di({
        type: u.type,
        length: t,
        nullCount: t,
        nullBitmap: new Uint8Array(a)
      });
    }
  }
  return i;
}
var jC;
let Co = class Al {
  constructor(...t) {
    var i, r;
    if (t.length === 0)
      return this.batches = [], this.schema = new yr([]), this._offsets = [0], this;
    let n, s;
    t[0] instanceof yr && (n = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
    const a = (c) => {
      if (c) {
        if (c instanceof Pn)
          return [c];
        if (c instanceof Al)
          return c.batches;
        if (c instanceof rr) {
          if (c.type instanceof un)
            return [new Pn(new yr(c.type.children), c)];
        } else {
          if (Array.isArray(c))
            return c.flatMap((l) => a(l));
          if (typeof c[Symbol.iterator] == "function")
            return [...c].flatMap((l) => a(l));
          if (typeof c == "object") {
            const l = Object.keys(c), d = l.map((p) => new Ki([c[p]])), u = new yr(l.map((p, m) => new zi(String(p), d[m].type))), [, h] = w_(u, d);
            return h.length === 0 ? [new Pn(c)] : h;
          }
        }
      }
      return [];
    }, o = t.flatMap((c) => a(c));
    if (n = (r = n ?? ((i = o[0]) === null || i === void 0 ? void 0 : i.schema)) !== null && r !== void 0 ? r : new yr([]), !(n instanceof yr))
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    for (const c of o) {
      if (!(c instanceof Pn))
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      if (!wb(n, c.schema))
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
    }
    this.schema = n, this.batches = o, this._offsets = s ?? nC(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data: t }) => t);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((t, i) => t + i.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    return this._nullCount === -1 && (this._nullCount = rC(this.data)), this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, i) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, i) {
    return -1;
  }
  /**
   * Get the size in bytes of an element by index.
   * @param index The index at which to get the byteLength.
   */
  // @ts-ignore
  getByteLength(t) {
    return 0;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    return this.batches.length > 0 ? _x.visit(new Ki(this.data)) : new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(`,
  `)}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...t) {
    const i = this.schema, r = this.data.concat(t.flatMap(({ data: n }) => n));
    return new Al(i, r.map((n) => new Pn(i, n)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    const r = this.schema;
    [t, i] = eC({ length: this.numRows }, t, i);
    const n = sC(this.data, this._offsets, t, i);
    return new Al(r, n.map((s) => new Pn(r, s)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    return this.getChildAt(this.schema.fields.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    if (t > -1 && t < this.schema.fields.length) {
      const i = this.data.map((r) => r.children[t]);
      if (i.length === 0) {
        const { type: r } = this.schema.fields[t], n = di({ type: r, length: 0, nullCount: 0 });
        i.push(n._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Ki(i);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(t, i) {
    var r;
    return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((n) => n.name === t), i);
  }
  setChildAt(t, i) {
    let r = this.schema, n = [...this.batches];
    if (t > -1 && t < this.numCols) {
      i || (i = new Ki([di({ type: new Eo(), length: this.numRows })]));
      const s = r.fields.slice(), a = s[t].clone({ type: i.type }), o = this.schema.fields.map((c, l) => this.getChildAt(l));
      [s[t], o[t]] = [a, i], [r, n] = w_(r, o);
    }
    return new Al(r, n);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(t) {
    const i = this.schema.fields.reduce((r, n, s) => r.set(n.name, s), /* @__PURE__ */ new Map());
    return this.selectAt(t.map((r) => i.get(r)).filter((r) => r > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(t) {
    const i = this.schema.selectAt(t), r = this.batches.map((n) => n.selectAt(t));
    return new Al(i, r);
  }
  assign(t) {
    const i = this.schema.fields, [r, n] = t.schema.fields.reduce((o, c, l) => {
      const [d, u] = o, h = i.findIndex((p) => p.name === c.name);
      return ~h ? u[h] = l : d.push(l), o;
    }, [[], []]), s = this.schema.assign(t.schema), a = [
      ...i.map((o, c) => [c, n[c]]).map(([o, c]) => c === void 0 ? this.getChildAt(o) : t.getChildAt(c)),
      ...r.map((o) => t.getChildAt(o))
    ].filter(Boolean);
    return new Al(...w_(s, a));
  }
};
jC = Symbol.toStringTag;
Co[jC] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = yu(vx), e.get = yu(jn.getVisitFn(O.Struct)), e.set = aC(Is.getVisitFn(O.Struct)), e.indexOf = oC(Qg.getVisitFn(O.Struct)), e.getByteLength = yu(La.getVisitFn(O.Struct)), "Table"))(Co.prototype);
var GC;
let Pn = class lf {
  constructor(...t) {
    switch (t.length) {
      case 2: {
        if ([this.schema] = t, !(this.schema instanceof yr))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        if ([
          ,
          this.data = di({
            nullCount: 0,
            type: new un(this.schema.fields),
            children: this.schema.fields.map((i) => di({ type: i.type, nullCount: 0 }))
          })
        ] = t, !(this.data instanceof rr))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        [this.schema, this.data] = kA(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [i] = t, { fields: r, children: n, length: s } = Object.keys(i).reduce((c, l, d) => (c.children[d] = i[l], c.length = Math.max(c.length, i[l].length), c.fields[d] = zi.new({ name: l, type: i[l].type, nullable: !0 }), c), {
          length: 0,
          fields: new Array(),
          children: new Array()
        }), a = new yr(r), o = di({ type: new un(r), length: s, children: n, nullCount: 0 });
        [this.schema, this.data] = kA(a, o.children, s);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = HC(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(t) {
    return this.data.getValid(t);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(t) {
    return jn.visit(this.data, t);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(t, i) {
    return Is.visit(this.data, t, i);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(t, i) {
    return Qg.visit(this.data, t, i);
  }
  /**
   * Get the size (in bytes) of a row by index.
   * @param index The row index for which to compute the byteLength.
   */
  getByteLength(t) {
    return La.visit(this.data, t);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return _x.visit(new Ki([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...t) {
    return new Co(this.schema, [this, ...t]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    const [r] = new Ki([this.data]).slice(t, i).data;
    return new lf(this.schema, r);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var i;
    return this.getChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.schema.fields.length ? new Ki([this.data.children[t]]) : null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(t, i) {
    var r;
    return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((n) => n.name === t), i);
  }
  setChildAt(t, i) {
    let r = this.schema, n = this.data;
    if (t > -1 && t < this.numCols) {
      i || (i = new Ki([di({ type: new Eo(), length: this.numRows })]));
      const s = r.fields.slice(), a = n.children.slice(), o = s[t].clone({ type: i.type });
      [s[t], a[t]] = [o, i.data[0]], r = new yr(s, new Map(this.schema.metadata)), n = di({ type: new un(s), children: a });
    }
    return new lf(r, n);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(t) {
    const i = this.schema.select(t), r = new un(i.fields), n = [];
    for (const s of t) {
      const a = this.schema.fields.findIndex((o) => o.name === s);
      ~a && (n[a] = this.data.children[a]);
    }
    return new lf(i, di({ type: r, length: this.numRows, children: n }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(t) {
    const i = this.schema.selectAt(t), r = t.map((s) => this.data.children[s]).filter(Boolean), n = di({ type: new un(i.fields), length: this.numRows, children: r });
    return new lf(i, n);
  }
};
GC = Symbol.toStringTag;
Pn[GC] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))(Pn.prototype);
function kA(e, t, i = t.reduce((r, n) => Math.max(r, n.length), 0)) {
  var r;
  const n = [...e.fields], s = [...t], a = (i + 63 & -64) >> 3;
  for (const [o, c] of e.fields.entries()) {
    const l = t[o];
    (!l || l.length !== i) && (n[o] = c.clone({ nullable: !0 }), s[o] = (r = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(i)) !== null && r !== void 0 ? r : di({
      type: c.type,
      length: i,
      nullCount: i,
      nullBitmap: new Uint8Array(a)
    }));
  }
  return [
    e.assign(n),
    di({ type: new un(n), length: i, children: s })
  ];
}
function HC(e, t, i = /* @__PURE__ */ new Map()) {
  var r, n;
  if (((r = e == null ? void 0 : e.length) !== null && r !== void 0 ? r : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
    for (let s = -1, a = e.length; ++s < a; ) {
      const { type: o } = e[s], c = t[s];
      for (const l of [c, ...((n = c == null ? void 0 : c.dictionary) === null || n === void 0 ? void 0 : n.data) || []])
        HC(o.children, l == null ? void 0 : l.children, i);
      if (Ie.isDictionary(o)) {
        const { id: l } = o;
        if (!i.has(l))
          c != null && c.dictionary && i.set(l, c.dictionary);
        else if (i.get(l) !== c.dictionary)
          throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
      }
    }
  return i;
}
let Tx = class extends Pn {
  constructor(t) {
    const i = t.fields.map((n) => di({ type: n.type })), r = di({ type: new un(t.fields), nullCount: 0, children: i });
    super(t, r);
  }
};
var l0;
(function(e) {
  e[e.BUFFER = 0] = "BUFFER";
})(l0 || (l0 = {}));
var d0;
(function(e) {
  e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
})(d0 || (d0 = {}));
let vG = class Tl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBodyCompression(t, i) {
    return (i || new Tl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBodyCompression(t, i) {
    return t.setPosition(t.position() + de), (i || new Tl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt8(this.bb_pos + t) : d0.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt8(this.bb_pos + t) : l0.BUFFER;
  }
  static startBodyCompression(t) {
    t.startObject(2);
  }
  static addCodec(t, i) {
    t.addFieldInt8(0, i, d0.LZ4_FRAME);
  }
  static addMethod(t, i) {
    t.addFieldInt8(1, i, l0.BUFFER);
  }
  static endBodyCompression(t) {
    return t.endObject();
  }
  static createBodyCompression(t, i, r) {
    return Tl.startBodyCompression(t), Tl.addCodec(t, i), Tl.addMethod(t, r), Tl.endBodyCompression(t);
  }
}, WC = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(t, i, r) {
    return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
}, YC = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(t, i, r) {
    return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
}, co = class Sb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsRecordBatch(t, i) {
    return (i || new Sb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsRecordBatch(t, i) {
    return t.setPosition(t.position() + de), (i || new Sb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(t, i) {
    const r = this.bb.__offset(this.bb_pos, 6);
    return r ? (i || new YC()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
  }
  nodesLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new WC()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
  }
  buffersLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? (t || new vG()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  static startRecordBatch(t) {
    t.startObject(4);
  }
  static addLength(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addNodes(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static startNodesVector(t, i) {
    t.startVector(16, i, 8);
  }
  static addBuffers(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static startBuffersVector(t, i) {
    t.startVector(16, i, 8);
  }
  static addCompression(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static endRecordBatch(t) {
    return t.endObject();
  }
}, Gd = class Ib {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDictionaryBatch(t, i) {
    return (i || new Ib()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryBatch(t, i) {
    return t.setPosition(t.position() + de), (i || new Ib()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  data(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new co()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startDictionaryBatch(t) {
    t.startObject(3);
  }
  static addId(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addData(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addIsDelta(t, i) {
    t.addFieldInt8(2, +i, 0);
  }
  static endDictionaryBatch(t) {
    return t.endObject();
  }
};
var u0;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
})(u0 || (u0 = {}));
let oc = class pa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsMessage(t, i) {
    return (i || new pa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMessage(t, i) {
    return t.setPosition(t.position() + de), (i || new pa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : $u.V1;
  }
  headerType() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb_pos + t) : u0.NONE;
  }
  header(t) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? this.bb.__union(t, this.bb_pos + i) : null;
  }
  bodyLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 12);
    return r ? (i || new xs()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startMessage(t) {
    t.startObject(5);
  }
  static addVersion(t, i) {
    t.addFieldInt16(0, i, $u.V1);
  }
  static addHeaderType(t, i) {
    t.addFieldInt8(1, i, u0.NONE);
  }
  static addHeader(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static addBodyLength(t, i) {
    t.addFieldInt64(3, i, BigInt("0"));
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endMessage(t) {
    return t.endObject();
  }
  static finishMessageBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedMessageBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
  static createMessage(t, i, r, n, s, a) {
    return pa.startMessage(t), pa.addVersion(t, i), pa.addHeaderType(t, r), pa.addHeader(t, n), pa.addBodyLength(t, s), pa.addCustomMetadata(t, a), pa.endMessage(t);
  }
}, _G = class extends ti {
  visit(t, i) {
    return t == null || i == null ? void 0 : super.visit(t, i);
  }
  visitNull(t, i) {
    return SA.startNull(i), SA.endNull(i);
  }
  visitInt(t, i) {
    return ru.startInt(i), ru.addBitWidth(i, t.bitWidth), ru.addIsSigned(i, t.isSigned), ru.endInt(i);
  }
  visitFloat(t, i) {
    return og.startFloatingPoint(i), og.addPrecision(i, t.precision), og.endFloatingPoint(i);
  }
  visitBinary(t, i) {
    return bA.startBinary(i), bA.endBinary(i);
  }
  visitBool(t, i) {
    return xA.startBool(i), xA.endBool(i);
  }
  visitUtf8(t, i) {
    return AA.startUtf8(i), AA.endUtf8(i);
  }
  visitDecimal(t, i) {
    return Md.startDecimal(i), Md.addScale(i, t.scale), Md.addPrecision(i, t.precision), Md.addBitWidth(i, t.bitWidth), Md.endDecimal(i);
  }
  visitDate(t, i) {
    return rg.startDate(i), rg.addUnit(i, t.unit), rg.endDate(i);
  }
  visitTime(t, i) {
    return af.startTime(i), af.addUnit(i, t.unit), af.addBitWidth(i, t.bitWidth), af.endTime(i);
  }
  visitTimestamp(t, i) {
    const r = t.timezone && i.createString(t.timezone) || void 0;
    return of.startTimestamp(i), of.addUnit(i, t.unit), r !== void 0 && of.addTimezone(i, r), of.endTimestamp(i);
  }
  visitInterval(t, i) {
    return cg.startInterval(i), cg.addUnit(i, t.unit), cg.endInterval(i);
  }
  visitDuration(t, i) {
    return ng.startDuration(i), ng.addUnit(i, t.unit), ng.endDuration(i);
  }
  visitList(t, i) {
    return wA.startList(i), wA.endList(i);
  }
  visitStruct(t, i) {
    return IA.startStruct_(i), IA.endStruct_(i);
  }
  visitUnion(t, i) {
    wl.startTypeIdsVector(i, t.typeIds.length);
    const r = wl.createTypeIdsVector(i, t.typeIds);
    return wl.startUnion(i), wl.addMode(i, t.mode), wl.addTypeIds(i, r), wl.endUnion(i);
  }
  visitDictionary(t, i) {
    const r = this.visit(t.indices, i);
    return Bd.startDictionaryEncoding(i), Bd.addId(i, BigInt(t.id)), Bd.addIsOrdered(i, t.isOrdered), r !== void 0 && Bd.addIndexType(i, r), Bd.endDictionaryEncoding(i);
  }
  visitFixedSizeBinary(t, i) {
    return sg.startFixedSizeBinary(i), sg.addByteWidth(i, t.byteWidth), sg.endFixedSizeBinary(i);
  }
  visitFixedSizeList(t, i) {
    return ag.startFixedSizeList(i), ag.addListSize(i, t.listSize), ag.endFixedSizeList(i);
  }
  visitMap(t, i) {
    return lg.startMap(i), lg.addKeysSorted(i, t.keysSorted), lg.endMap(i);
  }
};
const S_ = new _G();
function bG(e, t = /* @__PURE__ */ new Map()) {
  return new yr(wG(e, t), hg(e.metadata), t);
}
function qC(e) {
  return new rs(e.count, ZC(e.columns), XC(e.columns));
}
function xG(e) {
  return new Ba(qC(e.data), e.id, e.isDelta);
}
function wG(e, t) {
  return (e.fields || []).filter(Boolean).map((i) => zi.fromJSON(i, t));
}
function CA(e, t) {
  return (e.children || []).filter(Boolean).map((i) => zi.fromJSON(i, t));
}
function ZC(e) {
  return (e || []).reduce((t, i) => [
    ...t,
    new Cc(i.count, SG(i.VALIDITY)),
    ...ZC(i.children)
  ], []);
}
function XC(e, t = []) {
  for (let i = -1, r = (e || []).length; ++i < r; ) {
    const n = e[i];
    n.VALIDITY && t.push(new ka(t.length, n.VALIDITY.length)), n.TYPE_ID && t.push(new ka(t.length, n.TYPE_ID.length)), n.OFFSET && t.push(new ka(t.length, n.OFFSET.length)), n.DATA && t.push(new ka(t.length, n.DATA.length)), t = XC(n.children, t);
  }
  return t;
}
function SG(e) {
  return (e || []).reduce((t, i) => t + +(i === 0), 0);
}
function IG(e, t) {
  let i, r, n, s, a, o;
  return !t || !(s = e.dictionary) ? (a = DA(e, CA(e, t)), n = new zi(e.name, a, e.nullable, hg(e.metadata))) : t.has(i = s.id) ? (r = (r = s.indexType) ? OA(r) : new Ic(), o = new Tc(t.get(i), r, i, s.isOrdered), n = new zi(e.name, o, e.nullable, hg(e.metadata))) : (r = (r = s.indexType) ? OA(r) : new Ic(), t.set(i, a = DA(e, CA(e, t))), o = new Tc(a, r, i, s.isOrdered), n = new zi(e.name, o, e.nullable, hg(e.metadata))), n || null;
}
function hg(e = []) {
  return new Map(e.map(({ key: t, value: i }) => [t, i]));
}
function OA(e) {
  return new kn(e.isSigned, e.bitWidth);
}
function DA(e, t) {
  const i = e.type.name;
  switch (i) {
    case "NONE":
      return new Eo();
    case "null":
      return new Eo();
    case "binary":
      return new $f();
    case "utf8":
      return new Fu();
    case "bool":
      return new zf();
    case "list":
      return new Mu((t || [])[0]);
    case "struct":
      return new un(t || []);
    case "struct_":
      return new un(t || []);
  }
  switch (i) {
    case "int": {
      const r = e.type;
      return new kn(r.isSigned, r.bitWidth);
    }
    case "floatingpoint": {
      const r = e.type;
      return new Ac(hn[r.precision]);
    }
    case "decimal": {
      const r = e.type;
      return new Yg(r.scale, r.precision, r.bitWidth);
    }
    case "date": {
      const r = e.type;
      return new Bu(Ks[r.unit]);
    }
    case "time": {
      const r = e.type;
      return new ko(ke[r.unit], r.bitWidth);
    }
    case "timestamp": {
      const r = e.type;
      return new qg(ke[r.unit], r.timezone);
    }
    case "interval": {
      const r = e.type;
      return new Ru(Na[r.unit]);
    }
    case "duration": {
      const r = e.type;
      return new Zg(ke[r.unit]);
    }
    case "union": {
      const r = e.type, [n, ...s] = (r.mode + "").toLowerCase(), a = n.toUpperCase() + s.join("");
      return new Uf(En[a], r.typeIds || [], t || []);
    }
    case "fixedsizebinary": {
      const r = e.type;
      return new Xg(r.byteWidth);
    }
    case "fixedsizelist": {
      const r = e.type;
      return new Pu(r.listSize, (t || [])[0]);
    }
    case "map": {
      const r = e.type;
      return new Vf((t || [])[0], r.keysSorted);
    }
  }
  throw new Error(`Unrecognized type: "${i}"`);
}
var AG = Ey, TG = Fa;
let _o = class Hd {
  /** @nocollapse */
  static fromJSON(t, i) {
    const r = new Hd(0, dn.V5, i);
    return r._createHeader = EG(t, i), r;
  }
  /** @nocollapse */
  static decode(t) {
    t = new TG(Ti(t));
    const i = oc.getRootAsMessage(t), r = i.bodyLength(), n = i.version(), s = i.headerType(), a = new Hd(r, n, s);
    return a._createHeader = kG(i, s), a;
  }
  /** @nocollapse */
  static encode(t) {
    const i = new AG();
    let r = -1;
    return t.isSchema() ? r = yr.encode(i, t.header()) : t.isRecordBatch() ? r = rs.encode(i, t.header()) : t.isDictionaryBatch() && (r = Ba.encode(i, t.header())), oc.startMessage(i), oc.addVersion(i, dn.V5), oc.addHeader(i, r), oc.addHeaderType(i, t.headerType), oc.addBodyLength(i, BigInt(t.bodyLength)), oc.finishMessageBuffer(i, oc.endMessage(i)), i.asUint8Array();
  }
  /** @nocollapse */
  static from(t, i = 0) {
    if (t instanceof yr)
      return new Hd(0, dn.V5, Li.Schema, t);
    if (t instanceof rs)
      return new Hd(i, dn.V5, Li.RecordBatch, t);
    if (t instanceof Ba)
      return new Hd(i, dn.V5, Li.DictionaryBatch, t);
    throw new Error(`Unrecognized Message header: ${t}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === Li.Schema;
  }
  isRecordBatch() {
    return this.headerType === Li.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === Li.DictionaryBatch;
  }
  constructor(t, i, r, n) {
    this._version = i, this._headerType = r, this.body = new Uint8Array(0), n && (this._createHeader = () => n), this._bodyLength = Js(t);
  }
}, rs = class {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(t, i, r) {
    this._nodes = i, this._buffers = r, this._length = Js(t);
  }
}, Ba = class {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(t, i, r = !1) {
    this._data = t, this._isDelta = r, this._id = Js(i);
  }
}, ka = class {
  constructor(t, i) {
    this.offset = Js(t), this.length = Js(i);
  }
}, Cc = class {
  constructor(t, i) {
    this.length = Js(t), this.nullCount = Js(i);
  }
};
function EG(e, t) {
  return () => {
    switch (t) {
      case Li.Schema:
        return yr.fromJSON(e);
      case Li.RecordBatch:
        return rs.fromJSON(e);
      case Li.DictionaryBatch:
        return Ba.fromJSON(e);
    }
    throw new Error(`Unrecognized Message type: { name: ${Li[t]}, type: ${t} }`);
  };
}
function kG(e, t) {
  return () => {
    switch (t) {
      case Li.Schema:
        return yr.decode(e.header(new ya()), /* @__PURE__ */ new Map(), e.version());
      case Li.RecordBatch:
        return rs.decode(e.header(new co()), e.version());
      case Li.DictionaryBatch:
        return Ba.decode(e.header(new Gd()), e.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${Li[t]}, type: ${t} }`);
  };
}
zi.encode = $G;
zi.decode = MG;
zi.fromJSON = IG;
yr.encode = PG;
yr.decode = CG;
yr.fromJSON = bG;
rs.encode = zG;
rs.decode = OG;
rs.fromJSON = qC;
Ba.encode = UG;
Ba.decode = DG;
Ba.fromJSON = xG;
Cc.encode = VG;
Cc.decode = LG;
ka.encode = jG;
ka.decode = NG;
function CG(e, t = /* @__PURE__ */ new Map(), i = dn.V5) {
  const r = RG(e, t);
  return new yr(r, fg(e), t, i);
}
function OG(e, t = dn.V5) {
  if (e.compression() !== null)
    throw new Error("Record batch compression not implemented");
  return new rs(e.length(), FG(e), BG(e, t));
}
function DG(e, t = dn.V5) {
  return new Ba(rs.decode(e.data(), t), e.id(), e.isDelta());
}
function NG(e) {
  return new ka(e.offset(), e.length());
}
function LG(e) {
  return new Cc(e.length(), e.nullCount());
}
function FG(e) {
  const t = [];
  for (let i, r = -1, n = -1, s = e.nodesLength(); ++r < s; )
    (i = e.nodes(r)) && (t[++n] = Cc.decode(i));
  return t;
}
function BG(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.buffersLength(); ++n < a; )
    (r = e.buffers(n)) && (t < dn.V4 && (r.bb_pos += 8 * (n + 1)), i[++s] = ka.decode(r));
  return i;
}
function RG(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.fieldsLength(); ++n < a; )
    (r = e.fields(n)) && (i[++s] = zi.decode(r, t));
  return i;
}
function NA(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.childrenLength(); ++n < a; )
    (r = e.children(n)) && (i[++s] = zi.decode(r, t));
  return i;
}
function MG(e, t) {
  let i, r, n, s, a, o;
  return !t || !(o = e.dictionary()) ? (n = FA(e, NA(e, t)), r = new zi(e.name(), n, e.nullable(), fg(e))) : t.has(i = Js(o.id())) ? (s = (s = o.indexType()) ? LA(s) : new Ic(), a = new Tc(t.get(i), s, i, o.isOrdered()), r = new zi(e.name(), a, e.nullable(), fg(e))) : (s = (s = o.indexType()) ? LA(s) : new Ic(), t.set(i, n = FA(e, NA(e, t))), a = new Tc(n, s, i, o.isOrdered()), r = new zi(e.name(), a, e.nullable(), fg(e))), r || null;
}
function fg(e) {
  const t = /* @__PURE__ */ new Map();
  if (e)
    for (let i, r, n = -1, s = Math.trunc(e.customMetadataLength()); ++n < s; )
      (i = e.customMetadata(n)) && (r = i.key()) != null && t.set(r, i.value());
  return t;
}
function LA(e) {
  return new kn(e.isSigned(), e.bitWidth());
}
function FA(e, t) {
  const i = e.typeType();
  switch (i) {
    case dr.NONE:
      return new Eo();
    case dr.Null:
      return new Eo();
    case dr.Binary:
      return new $f();
    case dr.Utf8:
      return new Fu();
    case dr.Bool:
      return new zf();
    case dr.List:
      return new Mu((t || [])[0]);
    case dr.Struct_:
      return new un(t || []);
  }
  switch (i) {
    case dr.Int: {
      const r = e.type(new ru());
      return new kn(r.isSigned(), r.bitWidth());
    }
    case dr.FloatingPoint: {
      const r = e.type(new og());
      return new Ac(r.precision());
    }
    case dr.Decimal: {
      const r = e.type(new Md());
      return new Yg(r.scale(), r.precision(), r.bitWidth());
    }
    case dr.Date: {
      const r = e.type(new rg());
      return new Bu(r.unit());
    }
    case dr.Time: {
      const r = e.type(new af());
      return new ko(r.unit(), r.bitWidth());
    }
    case dr.Timestamp: {
      const r = e.type(new of());
      return new qg(r.unit(), r.timezone());
    }
    case dr.Interval: {
      const r = e.type(new cg());
      return new Ru(r.unit());
    }
    case dr.Duration: {
      const r = e.type(new ng());
      return new Zg(r.unit());
    }
    case dr.Union: {
      const r = e.type(new wl());
      return new Uf(r.mode(), r.typeIdsArray() || [], t || []);
    }
    case dr.FixedSizeBinary: {
      const r = e.type(new sg());
      return new Xg(r.byteWidth());
    }
    case dr.FixedSizeList: {
      const r = e.type(new ag());
      return new Pu(r.listSize(), (t || [])[0]);
    }
    case dr.Map: {
      const r = e.type(new lg());
      return new Vf((t || [])[0], r.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${dr[i]}" (${i})`);
}
function PG(e, t) {
  const i = t.fields.map((s) => zi.encode(e, s));
  ya.startFieldsVector(e, i.length);
  const r = ya.createFieldsVector(e, i), n = t.metadata && t.metadata.size > 0 ? ya.createCustomMetadataVector(e, [...t.metadata].map(([s, a]) => {
    const o = e.createString(`${s}`), c = e.createString(`${a}`);
    return xs.startKeyValue(e), xs.addKey(e, o), xs.addValue(e, c), xs.endKeyValue(e);
  })) : -1;
  return ya.startSchema(e), ya.addFields(e, r), ya.addEndianness(e, GG ? zu.Little : zu.Big), n !== -1 && ya.addCustomMetadata(e, n), ya.endSchema(e);
}
function $G(e, t) {
  let i = -1, r = -1, n = -1;
  const s = t.type;
  let a = t.typeId;
  Ie.isDictionary(s) ? (a = s.dictionary.typeId, n = S_.visit(s, e), r = S_.visit(s.dictionary, e)) : r = S_.visit(s, e);
  const o = (s.children || []).map((d) => zi.encode(e, d)), c = ds.createChildrenVector(e, o), l = t.metadata && t.metadata.size > 0 ? ds.createCustomMetadataVector(e, [...t.metadata].map(([d, u]) => {
    const h = e.createString(`${d}`), p = e.createString(`${u}`);
    return xs.startKeyValue(e), xs.addKey(e, h), xs.addValue(e, p), xs.endKeyValue(e);
  })) : -1;
  return t.name && (i = e.createString(t.name)), ds.startField(e), ds.addType(e, r), ds.addTypeType(e, a), ds.addChildren(e, c), ds.addNullable(e, !!t.nullable), i !== -1 && ds.addName(e, i), n !== -1 && ds.addDictionary(e, n), l !== -1 && ds.addCustomMetadata(e, l), ds.endField(e);
}
function zG(e, t) {
  const i = t.nodes || [], r = t.buffers || [];
  co.startNodesVector(e, i.length);
  for (const a of i.slice().reverse())
    Cc.encode(e, a);
  const n = e.endVector();
  co.startBuffersVector(e, r.length);
  for (const a of r.slice().reverse())
    ka.encode(e, a);
  const s = e.endVector();
  return co.startRecordBatch(e), co.addLength(e, BigInt(t.length)), co.addNodes(e, n), co.addBuffers(e, s), co.endRecordBatch(e);
}
function UG(e, t) {
  const i = rs.encode(e, t.data);
  return Gd.startDictionaryBatch(e), Gd.addId(e, BigInt(t.id)), Gd.addIsDelta(e, t.isDelta), Gd.addData(e, i), Gd.endDictionaryBatch(e);
}
function VG(e, t) {
  return YC.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
}
function jG(e, t) {
  return WC.createBuffer(e, BigInt(t.offset), BigInt(t.length));
}
const GG = (() => {
  const e = new ArrayBuffer(2);
  return new DataView(e).setInt16(
    0,
    256,
    !0
    /* littleEndian */
  ), new Int16Array(e)[0] === 256;
})(), Ex = (e) => `Expected ${Li[e]} Message in stream, but was null or length 0.`, kx = (e) => `Header pointer of flatbuffer-encoded ${Li[e]} Message is null or length 0.`, KC = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`, JC = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
let QC = class {
  constructor(t) {
    this.source = t instanceof s0 ? t : new s0(t);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let t;
    return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? vr : t;
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  readMessage(t) {
    let i;
    if ((i = this.next()).done)
      return null;
    if (t != null && i.value.headerType !== t)
      throw new Error(Ex(t));
    return i.value;
  }
  readMessageBody(t) {
    if (t <= 0)
      return new Uint8Array(0);
    const i = Ti(this.source.read(t));
    if (i.byteLength < t)
      throw new Error(JC(t, i.byteLength));
    return (
      /* 1. */
      i.byteOffset % 8 === 0 && /* 2. */
      i.byteOffset + i.byteLength <= i.buffer.byteLength ? i : i.slice()
    );
  }
  readSchema(t = !1) {
    const i = Li.Schema, r = this.readMessage(i), n = r == null ? void 0 : r.header();
    if (t && !n)
      throw new Error(kx(i));
    return n;
  }
  readMetadataLength() {
    const t = this.source.read(Ny), i = t && new Fa(t), r = (i == null ? void 0 : i.readInt32(0)) || 0;
    return { done: r === 0, value: r };
  }
  readMetadata(t) {
    const i = this.source.read(t);
    if (!i)
      return vr;
    if (i.byteLength < t)
      throw new Error(KC(t, i.byteLength));
    return { done: !1, value: _o.decode(i) };
  }
}, HG = class {
  constructor(t, i) {
    this.source = t instanceof a0 ? t : WE(t) ? new o0(t, i) : new a0(t);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return Dt(this, void 0, void 0, function* () {
      let t;
      return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? vr : t;
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.throw(t);
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.return(t);
    });
  }
  readMessage(t) {
    return Dt(this, void 0, void 0, function* () {
      let i;
      if ((i = yield this.next()).done)
        return null;
      if (t != null && i.value.headerType !== t)
        throw new Error(Ex(t));
      return i.value;
    });
  }
  readMessageBody(t) {
    return Dt(this, void 0, void 0, function* () {
      if (t <= 0)
        return new Uint8Array(0);
      const i = Ti(yield this.source.read(t));
      if (i.byteLength < t)
        throw new Error(JC(t, i.byteLength));
      return (
        /* 1. */
        i.byteOffset % 8 === 0 && /* 2. */
        i.byteOffset + i.byteLength <= i.buffer.byteLength ? i : i.slice()
      );
    });
  }
  readSchema(t = !1) {
    return Dt(this, void 0, void 0, function* () {
      const i = Li.Schema, r = yield this.readMessage(i), n = r == null ? void 0 : r.header();
      if (t && !n)
        throw new Error(kx(i));
      return n;
    });
  }
  readMetadataLength() {
    return Dt(this, void 0, void 0, function* () {
      const t = yield this.source.read(Ny), i = t && new Fa(t), r = (i == null ? void 0 : i.readInt32(0)) || 0;
      return { done: r === 0, value: r };
    });
  }
  readMetadata(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = yield this.source.read(t);
      if (!i)
        return vr;
      if (i.byteLength < t)
        throw new Error(KC(t, i.byteLength));
      return { done: !1, value: _o.decode(i) };
    });
  }
}, WG = class extends QC {
  constructor(t) {
    super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof TA ? t : new TA(t);
  }
  next() {
    const { _json: t } = this;
    if (!this._schema)
      return this._schema = !0, { done: !1, value: _o.fromJSON(t.schema, Li.Schema) };
    if (this._dictionaryIndex < t.dictionaries.length) {
      const i = t.dictionaries[this._dictionaryIndex++];
      return this._body = i.data.columns, { done: !1, value: _o.fromJSON(i, Li.DictionaryBatch) };
    }
    if (this._batchIndex < t.batches.length) {
      const i = t.batches[this._batchIndex++];
      return this._body = i.columns, { done: !1, value: _o.fromJSON(i, Li.RecordBatch) };
    }
    return this._body = [], vr;
  }
  readMessageBody(t) {
    return i(this._body);
    function i(r) {
      return (r || []).reduce((n, s) => [
        ...n,
        ...s.VALIDITY && [s.VALIDITY] || [],
        ...s.TYPE_ID && [s.TYPE_ID] || [],
        ...s.OFFSET && [s.OFFSET] || [],
        ...s.DATA && [s.DATA] || [],
        ...i(s.children)
      ], []);
    }
  }
  readMessage(t) {
    let i;
    if ((i = this.next()).done)
      return null;
    if (t != null && i.value.headerType !== t)
      throw new Error(Ex(t));
    return i.value;
  }
  readSchema() {
    const t = Li.Schema, i = this.readMessage(t), r = i == null ? void 0 : i.header();
    if (!i || !r)
      throw new Error(kx(t));
    return r;
  }
};
const Ny = 4, Ab = "ARROW1", Gf = new Uint8Array(Ab.length);
for (let e = 0; e < Ab.length; e += 1)
  Gf[e] = Ab.codePointAt(e);
function Cx(e, t = 0) {
  for (let i = -1, r = Gf.length; ++i < r; )
    if (Gf[i] !== e[t + i])
      return !1;
  return !0;
}
const Op = Gf.length, tO = Op + Ny, YG = Op * 2 + Ny;
let Dp = class pg extends bx {
  constructor(t) {
    super(), this._impl = t;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(t) {
    return this._impl.throw(t);
  }
  return(t) {
    return this._impl.return(t);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(t) {
    return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
  }
  open(t) {
    const i = this._impl.open(t);
    return Sc(i) ? i.then(() => this) : this;
  }
  readRecordBatch(t) {
    return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return ps.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return ps.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: !0 });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  static throughDOM(t, i) {
    throw new Error('"throughDOM" not available in this environment');
  }
  /** @nocollapse */
  static from(t) {
    return t instanceof pg ? t : ub(t) ? KG(t) : WE(t) ? tH(t) : Sc(t) ? Dt(this, void 0, void 0, function* () {
      return yield pg.from(yield t);
    }) : YE(t) || $1(t) || qE(t) || ih(t) ? QG(new a0(t)) : JG(new s0(t));
  }
  /** @nocollapse */
  static readAll(t) {
    return t instanceof pg ? t.isSync() ? BA(t) : RA(t) : ub(t) || ArrayBuffer.isView(t) || Ip(t) || HE(t) ? BA(t) : RA(t);
  }
}, h0 = class extends Dp {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return jr(this, arguments, function* () {
      yield Vt(yield* xc(es(this[Symbol.iterator]())));
    });
  }
}, f0 = class extends Dp {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    var t, i, r, n;
    return Dt(this, void 0, void 0, function* () {
      const s = new Array();
      try {
        for (var a = !0, o = es(this), c; c = yield o.next(), t = c.done, !t; a = !0) {
          n = c.value, a = !1;
          const l = n;
          s.push(l);
        }
      } catch (l) {
        i = { error: l };
      } finally {
        try {
          !a && !t && (r = o.return) && (yield r.call(o));
        } finally {
          if (i)
            throw i.error;
        }
      }
      return s;
    });
  }
  [Symbol.iterator]() {
    throw new Error("AsyncRecordBatchStreamReader is not Iterable");
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}, eO = class extends h0 {
  constructor(t) {
    super(t), this._impl = t;
  }
}, qG = class extends f0 {
  constructor(t) {
    super(t), this._impl = t;
  }
}, iO = class {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(t = /* @__PURE__ */ new Map()) {
    this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
  }
  isSync() {
    return !1;
  }
  isAsync() {
    return !1;
  }
  isFile() {
    return !1;
  }
  isStream() {
    return !1;
  }
  reset(t) {
    return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
  }
  _loadRecordBatch(t, i) {
    const r = this._loadVectors(t, i, this.schema.fields), n = di({ type: new un(this.schema.fields), length: t.length, children: r });
    return new Pn(this.schema, n);
  }
  _loadDictionaryBatch(t, i) {
    const { id: r, isDelta: n } = t, { dictionaries: s, schema: a } = this, o = s.get(r);
    if (n || !o) {
      const c = a.dictionaries.get(r), l = this._loadVectors(t.data, i, [c]);
      return (o && n ? o.concat(new Ki(l)) : new Ki(l)).memoize();
    }
    return o.memoize();
  }
  _loadVectors(t, i, r) {
    return new wC(i, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
  }
}, p0 = class extends iO {
  constructor(t, i) {
    super(i), this._reader = ub(t) ? new WG(this._handle = t) : new QC(this._handle = t);
  }
  isSync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
  }
  open(t) {
    return this.closed || (this.autoDestroy = nO(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
  }
  throw(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : vr;
  }
  return(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : vr;
  }
  next() {
    if (this.closed)
      return vr;
    let t;
    const { _reader: i } = this;
    for (; t = this._readNextMessageAndValidate(); )
      if (t.isSchema())
        this.reset(t.header());
      else if (t.isRecordBatch()) {
        this._recordBatchIndex++;
        const r = t.header(), n = i.readMessageBody(t.bodyLength);
        return { done: !1, value: this._loadRecordBatch(r, n) };
      } else if (t.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const r = t.header(), n = i.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(r, n);
        this.dictionaries.set(r.id, s);
      }
    return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new Tx(this.schema) }) : this.return();
  }
  _readNextMessageAndValidate(t) {
    return this._reader.readMessage(t);
  }
}, m0 = class extends iO {
  constructor(t, i) {
    super(i), this._reader = new HG(this._handle = t);
  }
  isAsync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return Dt(this, void 0, void 0, function* () {
      !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
    });
  }
  open(t) {
    return Dt(this, void 0, void 0, function* () {
      return this.closed || (this.autoDestroy = nO(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t) : vr;
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t) : vr;
    });
  }
  next() {
    return Dt(this, void 0, void 0, function* () {
      if (this.closed)
        return vr;
      let t;
      const { _reader: i } = this;
      for (; t = yield this._readNextMessageAndValidate(); )
        if (t.isSchema())
          yield this.reset(t.header());
        else if (t.isRecordBatch()) {
          this._recordBatchIndex++;
          const r = t.header(), n = yield i.readMessageBody(t.bodyLength);
          return { done: !1, value: this._loadRecordBatch(r, n) };
        } else if (t.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const r = t.header(), n = yield i.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(r, n);
          this.dictionaries.set(r.id, s);
        }
      return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new Tx(this.schema) }) : yield this.return();
    });
  }
  _readNextMessageAndValidate(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(t);
    });
  }
}, rO = class extends p0 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, i) {
    super(t instanceof EA ? t : new EA(t), i);
  }
  isSync() {
    return !0;
  }
  isFile() {
    return !0;
  }
  open(t) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const i of this._footer.dictionaryBatches())
        i && this._readDictionaryBatch(this._dictionaryIndex++);
    }
    return super.open(t);
  }
  readRecordBatch(t) {
    var i;
    if (this.closed)
      return null;
    this._footer || this.open();
    const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(t);
    if (r && this._handle.seek(r.offset)) {
      const n = this._reader.readMessage(Li.RecordBatch);
      if (n != null && n.isRecordBatch()) {
        const s = n.header(), a = this._reader.readMessageBody(n.bodyLength);
        return this._loadRecordBatch(s, a);
      }
    }
    return null;
  }
  _readDictionaryBatch(t) {
    var i;
    const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getDictionaryBatch(t);
    if (r && this._handle.seek(r.offset)) {
      const n = this._reader.readMessage(Li.DictionaryBatch);
      if (n != null && n.isDictionaryBatch()) {
        const s = n.header(), a = this._reader.readMessageBody(n.bodyLength), o = this._loadDictionaryBatch(s, a);
        this.dictionaries.set(s.id, o);
      }
    }
  }
  _readFooter() {
    const { _handle: t } = this, i = t.size - tO, r = t.readInt32(i), n = t.readAt(i - r, r);
    return jf.decode(n);
  }
  _readNextMessageAndValidate(t) {
    var i;
    if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(this._recordBatchIndex);
      if (r && this._handle.seek(r.offset))
        return this._reader.readMessage(t);
    }
    return null;
  }
}, ZG = class extends m0 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, ...i) {
    const r = typeof i[0] != "number" ? i.shift() : void 0, n = i[0] instanceof Map ? i.shift() : void 0;
    super(t instanceof o0 ? t : new o0(t, r), n);
  }
  isFile() {
    return !0;
  }
  isAsync() {
    return !0;
  }
  open(t) {
    const i = Object.create(null, {
      open: { get: () => super.open }
    });
    return Dt(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const r of this._footer.dictionaryBatches())
          r && (yield this._readDictionaryBatch(this._dictionaryIndex++));
      }
      return yield i.open.call(this, t);
    });
  }
  readRecordBatch(t) {
    var i;
    return Dt(this, void 0, void 0, function* () {
      if (this.closed)
        return null;
      this._footer || (yield this.open());
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(t);
      if (r && (yield this._handle.seek(r.offset))) {
        const n = yield this._reader.readMessage(Li.RecordBatch);
        if (n != null && n.isRecordBatch()) {
          const s = n.header(), a = yield this._reader.readMessageBody(n.bodyLength);
          return this._loadRecordBatch(s, a);
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(t) {
    var i;
    return Dt(this, void 0, void 0, function* () {
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getDictionaryBatch(t);
      if (r && (yield this._handle.seek(r.offset))) {
        const n = yield this._reader.readMessage(Li.DictionaryBatch);
        if (n != null && n.isDictionaryBatch()) {
          const s = n.header(), a = yield this._reader.readMessageBody(n.bodyLength), o = this._loadDictionaryBatch(s, a);
          this.dictionaries.set(s.id, o);
        }
      }
    });
  }
  _readFooter() {
    return Dt(this, void 0, void 0, function* () {
      const { _handle: t } = this;
      t._pending && (yield t._pending);
      const i = t.size - tO, r = yield t.readInt32(i), n = yield t.readAt(i - r, r);
      return jf.decode(n);
    });
  }
  _readNextMessageAndValidate(t) {
    return Dt(this, void 0, void 0, function* () {
      if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const i = this._footer.getRecordBatch(this._recordBatchIndex);
        if (i && (yield this._handle.seek(i.offset)))
          return yield this._reader.readMessage(t);
      }
      return null;
    });
  }
}, XG = class extends p0 {
  constructor(t, i) {
    super(t, i);
  }
  _loadVectors(t, i, r) {
    return new zj(i, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
  }
};
function nO(e, t) {
  return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
}
function* BA(e) {
  const t = Dp.from(e);
  try {
    if (!t.open({ autoDestroy: !1 }).closed)
      do
        yield t;
      while (!t.reset().open().closed);
  } finally {
    t.cancel();
  }
}
function RA(e) {
  return jr(this, arguments, function* () {
    const i = yield Vt(Dp.from(e));
    try {
      if (!(yield Vt(i.open({ autoDestroy: !1 }))).closed)
        do
          yield yield Vt(i);
        while (!(yield Vt(i.reset().open())).closed);
    } finally {
      yield Vt(i.cancel());
    }
  });
}
function KG(e) {
  return new h0(new XG(e));
}
function JG(e) {
  const t = e.peek(Op + 7 & -8);
  return t && t.byteLength >= 4 ? Cx(t) ? new eO(new rO(e.read())) : new h0(new p0(e)) : new h0(new p0(function* () {
  }()));
}
function QG(e) {
  return Dt(this, void 0, void 0, function* () {
    const t = yield e.peek(Op + 7 & -8);
    return t && t.byteLength >= 4 ? Cx(t) ? new eO(new rO(yield e.read())) : new f0(new m0(e)) : new f0(new m0(function() {
      return jr(this, arguments, function* () {
      });
    }()));
  });
}
function tH(e) {
  return Dt(this, void 0, void 0, function* () {
    const { size: t } = yield e.stat(), i = new o0(e, t);
    return t >= YG && Cx(yield i.readAt(0, Op + 7 & -8)) ? new qG(new ZG(i)) : new f0(new m0(i));
  });
}
class Rr extends ti {
  /** @nocollapse */
  static assemble(...t) {
    const i = (n) => n.flatMap((s) => Array.isArray(s) ? i(s) : s instanceof Pn ? s.data.children : s.data), r = new Rr();
    return r.visitMany(i(t)), r;
  }
  constructor() {
    super(), this._byteLength = 0, this._nodes = [], this._buffers = [], this._bufferRegions = [];
  }
  visit(t) {
    if (t instanceof Ki)
      return this.visitMany(t.data), this;
    const { type: i } = t;
    if (!Ie.isDictionary(i)) {
      const { length: r } = t;
      if (r > 2147483647)
        throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
      if (Ie.isUnion(i))
        this.nodes.push(new Cc(r, 0));
      else {
        const { nullCount: n } = t;
        Ie.isNull(i) || Ws.call(this, n <= 0 ? new Uint8Array(0) : Kg(t.offset, r, t.nullBitmap)), this.nodes.push(new Cc(r, n));
      }
    }
    return super.visit(t);
  }
  visitNull(t) {
    return this;
  }
  visitDictionary(t) {
    return this.visit(t.clone(t.type.indices));
  }
  get nodes() {
    return this._nodes;
  }
  get buffers() {
    return this._buffers;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferRegions() {
    return this._bufferRegions;
  }
}
function Ws(e) {
  const t = e.byteLength + 7 & -8;
  return this.buffers.push(e), this.bufferRegions.push(new ka(this._byteLength, t)), this._byteLength += t, this;
}
function eH(e) {
  var t;
  const { type: i, length: r, typeIds: n, valueOffsets: s } = e;
  if (Ws.call(this, n), i.mode === En.Sparse)
    return Tb.call(this, e);
  if (i.mode === En.Dense) {
    if (e.offset <= 0)
      return Ws.call(this, s), Tb.call(this, e);
    {
      const a = new Int32Array(r), o = /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null);
      for (let l, d, u = -1; ++u < r; )
        (l = n[u]) !== void 0 && ((d = o[l]) === void 0 && (d = o[l] = s[u]), a[u] = s[u] - d, c[l] = ((t = c[l]) !== null && t !== void 0 ? t : 0) + 1);
      Ws.call(this, a), this.visitMany(e.children.map((l, d) => {
        const u = i.typeIds[d], h = o[u], p = c[u];
        return l.slice(h, Math.min(r, p));
      }));
    }
  }
  return this;
}
function iH(e) {
  let t;
  return e.nullCount >= e.length ? Ws.call(this, new Uint8Array(0)) : (t = e.values) instanceof Uint8Array ? Ws.call(this, Kg(e.offset, e.length, t)) : Ws.call(this, Jg(e.values));
}
function jo(e) {
  return Ws.call(this, e.values.subarray(0, e.length * e.stride));
}
function sO(e) {
  const { length: t, values: i, valueOffsets: r } = e, { [0]: n, [t]: s } = r, a = Math.min(s - n, i.byteLength - n);
  return Ws.call(this, XE(-n, t + 1, r)), Ws.call(this, i.subarray(n, n + a)), this;
}
function Ox(e) {
  const { length: t, valueOffsets: i } = e;
  if (i) {
    const { [0]: r, [t]: n } = i;
    return Ws.call(this, XE(-r, t + 1, i)), this.visit(e.children[0].slice(r, n - r));
  }
  return this.visit(e.children[0]);
}
function Tb(e) {
  return this.visitMany(e.type.children.map((t, i) => e.children[i]).filter(Boolean))[0];
}
Rr.prototype.visitBool = iH;
Rr.prototype.visitInt = jo;
Rr.prototype.visitFloat = jo;
Rr.prototype.visitUtf8 = sO;
Rr.prototype.visitBinary = sO;
Rr.prototype.visitFixedSizeBinary = jo;
Rr.prototype.visitDate = jo;
Rr.prototype.visitTimestamp = jo;
Rr.prototype.visitTime = jo;
Rr.prototype.visitDecimal = jo;
Rr.prototype.visitList = Ox;
Rr.prototype.visitStruct = Tb;
Rr.prototype.visitUnion = eH;
Rr.prototype.visitInterval = jo;
Rr.prototype.visitDuration = jo;
Rr.prototype.visitFixedSizeList = Ox;
Rr.prototype.visitMap = Ox;
class aO extends bx {
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  static throughDOM(t, i) {
    throw new Error('"throughDOM" not available in this environment');
  }
  constructor(t) {
    super(), this._position = 0, this._started = !1, this._sink = new ug(), this._schema = null, this._dictionaryBlocks = [], this._recordBatchBlocks = [], this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map(), Vn(t) || (t = { autoDestroy: !0, writeLegacyIpcFormat: !1 }), this._autoDestroy = typeof t.autoDestroy == "boolean" ? t.autoDestroy : !0, this._writeLegacyIpcFormat = typeof t.writeLegacyIpcFormat == "boolean" ? t.writeLegacyIpcFormat : !1;
  }
  toString(t = !1) {
    return this._sink.toString(t);
  }
  toUint8Array(t = !1) {
    return this._sink.toUint8Array(t);
  }
  writeAll(t) {
    return Sc(t) ? t.then((i) => this.writeAll(i)) : ih(t) ? Fx(this, t) : Lx(this, t);
  }
  get closed() {
    return this._sink.closed;
  }
  [Symbol.asyncIterator]() {
    return this._sink[Symbol.asyncIterator]();
  }
  toDOMStream(t) {
    return this._sink.toDOMStream(t);
  }
  toNodeStream(t) {
    return this._sink.toNodeStream(t);
  }
  close() {
    return this.reset()._sink.close();
  }
  abort(t) {
    return this.reset()._sink.abort(t);
  }
  finish() {
    return this._autoDestroy ? this.close() : this.reset(this._sink, this._schema), this;
  }
  reset(t = this._sink, i = null) {
    return t === this._sink || t instanceof ug ? this._sink = t : (this._sink = new ug(), t && H9(t) ? this.toDOMStream({ type: "bytes" }).pipeTo(t) : t && W9(t) && this.toNodeStream({ objectMode: !1 }).pipe(t)), this._started && this._schema && this._writeFooter(this._schema), this._started = !1, this._dictionaryBlocks = [], this._recordBatchBlocks = [], this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map(), (!i || !wb(i, this._schema)) && (i == null ? (this._position = 0, this._schema = null) : (this._started = !0, this._schema = i, this._writeSchema(i))), this;
  }
  write(t) {
    let i = null;
    if (this._sink) {
      if (t == null)
        return this.finish() && void 0;
      if (t instanceof Co && !(i = t.schema))
        return this.finish() && void 0;
      if (t instanceof Pn && !(i = t.schema))
        return this.finish() && void 0;
    } else
      throw new Error("RecordBatchWriter is closed");
    if (i && !wb(i, this._schema)) {
      if (this._started && this._autoDestroy)
        return this.close();
      this.reset(this._sink, i);
    }
    t instanceof Pn ? t instanceof Tx || this._writeRecordBatch(t) : t instanceof Co ? this.writeAll(t.batches) : Ip(t) && this.writeAll(t);
  }
  _writeMessage(t, i = 8) {
    const r = i - 1, n = _o.encode(t), s = n.byteLength, a = this._writeLegacyIpcFormat ? 4 : 8, o = s + a + r & ~r, c = o - s - a;
    return t.headerType === Li.RecordBatch ? this._recordBatchBlocks.push(new Uu(o, t.bodyLength, this._position)) : t.headerType === Li.DictionaryBatch && this._dictionaryBlocks.push(new Uu(o, t.bodyLength, this._position)), this._writeLegacyIpcFormat || this._write(Int32Array.of(-1)), this._write(Int32Array.of(o - a)), s > 0 && this._write(n), this._writePadding(c);
  }
  _write(t) {
    if (this._started) {
      const i = Ti(t);
      i && i.byteLength > 0 && (this._sink.write(i), this._position += i.byteLength);
    }
    return this;
  }
  _writeSchema(t) {
    return this._writeMessage(_o.from(t));
  }
  // @ts-ignore
  _writeFooter(t) {
    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
  }
  _writeMagic() {
    return this._write(Gf);
  }
  _writePadding(t) {
    return t > 0 ? this._write(new Uint8Array(t)) : this;
  }
  _writeRecordBatch(t) {
    const { byteLength: i, nodes: r, bufferRegions: n, buffers: s } = Rr.assemble(t), a = new rs(t.numRows, r, n), o = _o.from(a, i);
    return this._writeDictionaries(t)._writeMessage(o)._writeBodyBuffers(s);
  }
  _writeDictionaryBatch(t, i, r = !1) {
    this._dictionaryDeltaOffsets.set(i, t.length + (this._dictionaryDeltaOffsets.get(i) || 0));
    const { byteLength: n, nodes: s, bufferRegions: a, buffers: o } = Rr.assemble(new Ki([t])), c = new rs(t.length, s, a), l = new Ba(c, i, r), d = _o.from(l, n);
    return this._writeMessage(d)._writeBodyBuffers(o);
  }
  _writeBodyBuffers(t) {
    let i, r, n;
    for (let s = -1, a = t.length; ++s < a; )
      (i = t[s]) && (r = i.byteLength) > 0 && (this._write(i), (n = (r + 7 & -8) - r) > 0 && this._writePadding(n));
    return this;
  }
  _writeDictionaries(t) {
    for (let [i, r] of t.dictionaries) {
      let n = this._dictionaryDeltaOffsets.get(i) || 0;
      if (n === 0 || (r = r == null ? void 0 : r.slice(n)).length > 0)
        for (const s of r.data)
          this._writeDictionaryBatch(s, i, n > 0), n += s.length;
    }
    return this;
  }
}
class Dx extends aO {
  /** @nocollapse */
  static writeAll(t, i) {
    const r = new Dx(i);
    return Sc(t) ? t.then((n) => r.writeAll(n)) : ih(t) ? Fx(r, t) : Lx(r, t);
  }
}
class Nx extends aO {
  /** @nocollapse */
  static writeAll(t) {
    const i = new Nx();
    return Sc(t) ? t.then((r) => i.writeAll(r)) : ih(t) ? Fx(i, t) : Lx(i, t);
  }
  constructor() {
    super(), this._autoDestroy = !0;
  }
  // @ts-ignore
  _writeSchema(t) {
    return this._writeMagic()._writePadding(2);
  }
  _writeFooter(t) {
    const i = jf.encode(new jf(t, dn.V5, this._recordBatchBlocks, this._dictionaryBlocks));
    return super._writeFooter(t)._write(i)._write(Int32Array.of(i.byteLength))._writeMagic();
  }
}
function Lx(e, t) {
  let i = t;
  t instanceof Co && (i = t.batches, e.reset(void 0, t.schema));
  for (const r of i)
    e.write(r);
  return e.finish();
}
function Fx(e, t) {
  var i, r, n, s, a, o, c;
  return Dt(this, void 0, void 0, function* () {
    try {
      for (i = !0, r = es(t); n = yield r.next(), s = n.done, !s; i = !0) {
        c = n.value, i = !1;
        const l = c;
        e.write(l);
      }
    } catch (l) {
      a = { error: l };
    } finally {
      try {
        !i && !s && (o = r.return) && (yield o.call(r));
      } finally {
        if (a)
          throw a.error;
      }
    }
    return e.finish();
  });
}
function oO(e) {
  const t = Dp.from(e);
  return Sc(t) ? t.then((i) => oO(i)) : t.isAsync() ? t.readAll().then((i) => new Co(i)) : new Co(t.readAll());
}
function rH(e, t = "stream") {
  return (t === "stream" ? Dx : Nx).writeAll(e).toUint8Array(!0);
}
function Bx(e, t = 1) {
  return (e * t + 63 & -64 || 64) / t;
}
function Oc(e, t, i = e.BYTES_PER_ELEMENT) {
  return new e(Bx(t, i));
}
function Rx(e) {
  return e instanceof rr ? e : new rr(e.type, 0, e.length, e.nulls, e.buffers, null, e.dict);
}
function nH(e) {
  return new Ki([Rx(e)]);
}
const Mx = new TextEncoder();
function sH(e, t, i) {
  const r = Mx.encode(i);
  return e.set(r, t), r.length;
}
function aH(e, t, i) {
  return Mx.encodeInto(i, e.subarray(t)).written;
}
const oH = Mx.encodeInto ? aH : sH;
function MA(e, t) {
  const i = Oc(e.ArrayType, t);
  return {
    set(r, n) {
      i[n] = r;
    },
    data: () => ({ type: e, length: t, buffers: [null, i] })
  };
}
function cH(e, t) {
  const i = Oc(e.ArrayType, t / 8);
  return {
    set(r, n) {
      r && (i[n >> 3] |= 1 << n % 8);
    },
    data: () => ({ type: e, length: t, buffers: [null, i] })
  };
}
function lH(e, t) {
  const i = Oc(e.ArrayType, t);
  return {
    set(r, n) {
      i[n] = r / 864e5 | 0;
    },
    data: () => ({ type: e, length: t, buffers: [null, i] })
  };
}
function dH(e, t) {
  const i = Oc(e.ArrayType, t << 1);
  return {
    set(r, n) {
      const s = n << 1;
      i[s] = r % 4294967296 | 0, i[s + 1] = r / 4294967296 | 0;
    },
    data: () => ({ type: e, length: t, buffers: [null, i] })
  };
}
function uH(e) {
  const t = c0({
    type: e,
    nullValues: [null, void 0]
  });
  return {
    set(i, r) {
      t.set(r, i);
    },
    data: () => t.finish().flush()
  };
}
function hH(e, t, i) {
  const r = Oc(Int32Array, t + 1), n = Oc(Uint8Array, 3 * i);
  let s = 0;
  return {
    set(a, o) {
      s += oH(n, s, a), r[o + 1] = s;
    },
    data: () => {
      const a = Bx(s), o = n.length > a ? n.subarray(0, a) : n;
      return { type: e, length: t, buffers: [r, o] };
    }
  };
}
function fH(e, t) {
  const i = [], r = Oc(e.indices.ArrayType, t), n = /* @__PURE__ */ Object.create(null);
  let s = -1, a = 0;
  return {
    set(o, c) {
      const l = String(o);
      let d = n[l];
      d === void 0 && (a += l.length, n[l] = d = ++s, i.push(l)), r[c] = d;
    },
    data: () => ({
      type: e,
      length: t,
      buffers: [null, r],
      dict: pH(e.dictionary, i, a)
    })
  };
}
function pH(e, t, i) {
  const r = hH(e, t.length, i);
  return t.forEach(r.set), nH(r.data());
}
function mH(e, t) {
  const i = Oc(Uint8Array, t / 8);
  let r = 0;
  return {
    set(n, s) {
      n == null ? ++r : (e.set(n, s), i[s >> 3] |= 1 << s % 8);
    },
    data: () => {
      const n = e.data();
      return r && (n.nulls = r, n.buffers[2] = i), n;
    }
  };
}
function gH(e, t, i = !0) {
  let r;
  switch (e.typeId) {
    case O.Int:
      r = e.bitWidth < 64 ? MA : null;
      break;
    case O.Float:
      r = e.precision > 0 ? MA : null;
      break;
    case O.Dictionary:
      r = e.dictionary.typeId === O.Utf8 && e.indices.typeId === O.Int && e.indices.bitWidth < 64 ? fH : null;
      break;
    case O.Bool:
      r = cH;
      break;
    case O.Date:
      r = e.unit ? dH : lH;
      break;
  }
  return r == null ? uH(e) : i ? mH(r(e, t), t) : r(e, t);
}
function yH(e, t) {
  const i = e.length, r = Bx(i, e.BYTES_PER_ELEMENT);
  let n = e;
  return i !== r && (n = new e.constructor(r), n.set(e)), Rx({ type: t, length: i, buffers: [null, n] });
}
function cO(e, t, i, r, n = !0) {
  const s = gH(r, e, n);
  return t(i, s.set), Rx(s.data());
}
function Px(e) {
  if (e instanceof Ie || e == null)
    return e;
  switch (e) {
    case O.Binary:
      return new $f();
    case O.Bool:
      return new zf();
    case O.DateDay:
      return new cV();
    case O.DateMillisecond:
    case O.Date:
      return new lV();
    case O.Dictionary:
      return new Tc(new Fu(), new Ic());
    case O.Float16:
      return new _k();
    case O.Float32:
      return new q1();
    case O.Float64:
    case O.Float:
      return new Z1();
    case O.Int8:
      return new U1();
    case O.Int16:
      return new V1();
    case O.Int32:
    case O.Int:
      return new Ic();
    case O.Int64:
      return new j1();
    case O.IntervalDayTime:
      return new pV();
    case O.Interval:
    case O.IntervalYearMonth:
      return new mV();
    case O.Null:
      return new Eo();
    case O.TimeMicrosecond:
      return new hV();
    case O.TimeMillisecond:
    case O.Time:
      return new uV();
    case O.TimeNanosecond:
      return new fV();
    case O.TimeSecond:
      return new dV();
    case O.Uint8:
      return new G1();
    case O.Uint16:
      return new H1();
    case O.Uint32:
      return new W1();
    case O.Uint64:
      return new Y1();
    case O.Utf8:
      return new Fu();
    default:
      Qe(
        `Unsupported type code: ${Ss(e)}. Use a data type constructor instead?`
      );
  }
}
function vH(e) {
  return e.getUTCHours() === 0 && e.getUTCMinutes() === 0 && e.getUTCSeconds() === 0 && e.getUTCMilliseconds() === 0;
}
function lO(e, t) {
  const i = Eb();
  return e(t, i.add), i;
}
function Eb() {
  const e = {
    count: 0,
    nulls: 0,
    bools: 0,
    nums: 0,
    ints: 0,
    bigints: 0,
    min: 1 / 0,
    max: -1 / 0,
    digits: 0,
    dates: 0,
    utcdays: 0,
    strings: 0,
    strlen: 0,
    arrays: 0,
    minlen: 1 / 0,
    maxlen: 0,
    structs: 0,
    add(t) {
      if (++e.count, t == null) {
        ++e.nulls;
        return;
      }
      const i = typeof t;
      if (i === "string")
        ++e.strings;
      else if (i === "number")
        ++e.nums, t < e.min && (e.min = t), t > e.max && (e.max = t), Number.isInteger(t) && ++e.ints;
      else if (i === "boolean")
        ++e.bools;
      else if (i === "object")
        if (To(t))
          ++e.dates, vH(t) && ++e.utcdays;
        else if (Dl(t)) {
          ++e.arrays, t.length < e.minlen && (e.minlen = t.length), t.length > e.maxlen && (e.maxlen = t.length);
          const r = e.array_prof || (e.array_prof = Eb());
          t.forEach(r.add);
        } else {
          ++e.structs;
          const r = e.struct_prof || (e.struct_prof = {});
          for (const n in t)
            (r[n] || (r[n] = Eb())).add(t[n]);
        }
      else
        i === "bigint" && (++e.bigints, t < e.min && (e.min = t), t > e.max && (e.max = t));
    },
    type() {
      return Px(_H(e));
    }
  };
  return e;
}
function _H(e) {
  const t = e.count - e.nulls;
  if (t === 0)
    return O.Null;
  if (e.ints === t) {
    const i = Math.max(Math.abs(e.min) - 1, e.max);
    return e.min < 0 ? i >= 2 ** 31 ? O.Float64 : i < 128 ? O.Int8 : i < 32768 ? O.Int16 : O.Int32 : i >= 2 ** 32 ? O.Float64 : i < 256 ? O.Uint8 : i < 65536 ? O.Uint16 : O.Uint32;
  } else {
    if (e.nums === t)
      return O.Float64;
    if (e.bigints === t) {
      const i = -e.min > e.max ? -e.min - 1n : e.max;
      return e.min < 0 ? i < 2 ** 63 ? O.Int64 : Qe(`BigInt exceeds 64 bits: ${i}`) : e.max < 2 ** 64 ? O.Uint64 : Qe(`BigInt exceeds 64 bits: ${e.max}`);
    } else {
      if (e.bools === t)
        return O.Bool;
      if (e.utcdays === t)
        return O.DateDay;
      if (e.dates === t)
        return O.DateMillisecond;
      if (e.arrays === t) {
        const i = zi.new("value", e.array_prof.type(), !0);
        return e.minlen === e.maxlen ? new Pu(e.minlen, i) : new Mu(i);
      } else if (e.structs === t) {
        const i = e.struct_prof;
        return new un(
          Object.keys(i).map((r) => zi.new(r, i[r].type(), !0))
        );
      } else {
        if (e.strings > 0)
          return O.Dictionary;
        Qe("Type inference failure");
      }
    }
  }
}
function bH(e, t, i, r, n, s = !0) {
  if (n = Px(n), !n) {
    const a = lO(r, t);
    s = a.nulls > 0, n = a.type();
  }
  return cO(i, r, t, n, s);
}
function xH(e, t, i, r, n, s = !0) {
  n = Px(n);
  const a = e.column(t), o = !(e.isFiltered() || e.isOrdered()), c = wH(a);
  if (c && o && PA(c.type, n))
    return c;
  const l = a.data;
  if (wp(l)) {
    const d = SH(l);
    if (o && d && PA(d, n))
      return yH(l, d);
    n = n || d, s = !1;
  }
  if (!n) {
    const d = lO(r, a);
    s = d.nulls > 0, n = d.type();
  }
  return cO(i, r, a, n, s);
}
function wH(e) {
  return e instanceof Ki ? e : e.vector instanceof Ki ? e.vector : null;
}
function SH(e) {
  const i = {
    Float32Array: q1,
    Float64Array: Z1,
    Int8Array: U1,
    Int16Array: V1,
    Int32Array: Ic,
    Uint8Array: G1,
    Uint16Array: H1,
    Uint32Array: W1,
    BigInt64Array: j1,
    BigUint64Array: Y1
  }[e.constructor.name];
  return i ? new i() : null;
}
function PA(e, t) {
  return !e || !t ? !0 : e.compareTo(t);
}
function IH(e, t, i) {
  const r = Math.min(e.length, i + t);
  return (n, s) => {
    for (let a = i; a < r; ++a)
      s(e[a][n], a);
  };
}
function AH(e, t, i) {
  const r = i === 0 && e.numRows() <= t && !e.isFiltered() && !e.isOrdered();
  return (n, s) => {
    let a = -1;
    r && Dl(n.data) ? n.data.forEach(s) : e.scan(
      (o) => s(n.get(o), ++a),
      !0,
      t,
      i
    );
  };
}
const dO = () => Qe(
  "Apache Arrow not imported, see https://github.com/uwdata/arquero#usage"
);
function TH() {
  try {
    return Co;
  } catch {
    dO();
  }
}
function EH() {
  try {
    return oO;
  } catch {
    dO();
  }
}
function uO(e, t = {}) {
  const { types: i = {} } = t, { dataFrom: r, names: n, nrows: s, scan: a } = kH(e, t), o = {};
  n.forEach((l) => {
    const d = r(e, l, s, a, i[l]);
    d.length !== s && Qe("Column length mismatch"), o[l] = d;
  });
  const c = TH();
  return new c(o);
}
function kH(e, t) {
  const { columns: i, limit: r = 1 / 0, offset: n = 0 } = t, s = or(i) ? i(e) : Ei(i) ? i : null;
  if (Ei(e))
    return {
      dataFrom: bH,
      names: s || Object.keys(e[0]),
      nrows: Math.min(r, e.length - n),
      scan: IH(e, r, n)
    };
  if (CH(e))
    return {
      dataFrom: xH,
      names: s || e.columnNames(),
      nrows: Math.min(r, e.numRows() - n),
      scan: AH(e, r, n)
    };
  Qe("Unsupported input data type");
}
function CH(e) {
  return e && or(e.reify);
}
function OH(e, t = {}) {
  const { format: i, ...r } = t, n = i || "stream";
  if (!["stream", "file"].includes(n))
    throw Error("Unrecognised output format");
  return rH(uO(e, r), i);
}
function DH(e) {
  return e.getUTCHours() === 0 && e.getUTCMinutes() === 0 && e.getUTCSeconds() === 0 && e.getUTCMilliseconds() === 0;
}
function NH(e, t = {}) {
  let i = 0, r = 0, n = 0, s = 0, a = 0, o = 0;
  return e((c) => {
    if (++i, c == null) {
      ++r;
      return;
    }
    const l = typeof c;
    if (l === "object" && To(c))
      ++n, DH(c) && ++s;
    else if (l === "number" && (++a, c === c && (c | 0) !== c)) {
      const d = c + "", u = d.indexOf(".");
      if (u >= 0) {
        const h = d.indexOf("e"), p = h > 0 ? h : d.length;
        o = Math.max(o, p - u - 1);
      }
    }
  }), {
    align: (r + a + n) / i > 0.5 ? "r" : "l",
    format: {
      utc: n === s,
      digits: Math.min(o, t.maxdigits || 6)
    }
  };
}
function Ly(e, t) {
  return or(t) ? t(e) : t || e.columnNames();
}
function hO(e, t, i) {
  const r = i.format || {}, n = i.align || {}, s = {}, a = {};
  return t.forEach((o) => {
    const c = NH(LH(e, o), i);
    a[o] = n[o] || c.align, s[o] = r[o] || c.format;
  }), { align: a, format: s };
}
function LH(e, t) {
  const i = e.column(t);
  return (r) => e.scan((n) => r(i.get(n)));
}
function $x(e, t, i = 100, r, n) {
  const s = e.data(), a = t.length;
  e.scan((o) => {
    n.row(o);
    for (let c = 0; c < a; ++c) {
      const l = t[c];
      n.cell(s[t[c]].get(o), l, c);
    }
  }, !0, i, r);
}
function FH(e, t = {}) {
  const i = Ly(e, t.columns), r = t.format || {}, n = t.delimiter || ",", s = new RegExp(`["${n}
\r]`), a = (l) => l == null ? "" : To(l) ? _y(l, !0) : s.test(l += "") ? '"' + l.replace(/"/g, '""') + '"' : l, o = i.map(a);
  let c = "";
  return $x(e, i, t.limit || 1 / 0, t.offset, {
    row() {
      c += o.join(n) + `
`;
    },
    cell(l, d, u) {
      o[u] = a(r[d] ? r[d](l) : l);
    }
  }), c + o.join(n);
}
function fO(e, t = {}) {
  if (or(t))
    return t(e) + "";
  const i = typeof e;
  if (i === "object") {
    if (To(e))
      return t.utc ? _y(e) : yE(e);
    {
      const r = JSON.stringify(
        e,
        (s, a) => wp(a) ? Array.from(a) : a
      ), n = t.maxlen || 30;
      return r.length > n ? r.slice(0, 28) + "…" + (r[0] === "[" ? "]" : "}") : r;
    }
  } else if (i === "number") {
    const r = t.digits || 0;
    let n;
    return e !== 0 && ((n = Math.abs(e)) >= 1e18 || n < Math.pow(10, -r)) ? e.toExponential(r) : e.toFixed(r);
  } else
    return e + "";
}
function Fy(e, t, i = {}) {
  for (const r in e)
    i[r] = t(e[r], r);
  return i;
}
function BH(e, t = {}) {
  const i = Ly(e, t.columns), { align: r, format: n } = hO(e, i, t), s = RH(t), a = t.null, o = (w) => w === "c" ? "center" : w === "r" ? "right" : "left", c = (w) => w.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), l = (w, C) => c(fO(w, C)), d = a ? (w, C) => w == null ? a(w) : l(w, C) : l;
  let u = -1, h = -1;
  const p = (w, C, F) => {
    const W = F ? o(r[C]) : "", et = s[w] && s[w](C, h, u) || "", E = (W ? `text-align: ${W};` + (et ? " " : "") : "") + et;
    return `<${w}${E ? ` style="${E}"` : ""}>`;
  };
  let m = p("table") + p("thead") + p("tr", u) + i.map((w) => `${p("th", w, 1)}${w}</th>`).join("") + "</tr></thead>" + p("tbody");
  return $x(e, i, t.limit, t.offset, {
    row(w) {
      u = w, m += (++h ? "</tr>" : "") + p("tr");
    },
    cell(w, C) {
      m += p("td", C, 1) + d(w, n[C]) + "</td>";
    }
  }), m + "</tr></tbody></table>";
}
function RH(e) {
  return Fy(
    e.style,
    (t) => or(t) ? t : () => t
  );
}
function MH(e, t = !0, i = !1) {
  return e === void 0 || e ? t : i;
}
const PH = (e) => To(e) ? _y(e, !0) : e;
function $H(e, t = {}) {
  const i = MH(t.schema), r = t.format || {}, n = Ly(e, t.columns);
  let s = "{";
  return i && (s += '"schema":{"fields":' + JSON.stringify(n.map((a) => ({ name: a }))) + '},"data":{'), n.forEach((a, o) => {
    s += (o ? "," : "") + JSON.stringify(a) + ":[";
    const c = e.column(a), l = r[a] || PH;
    let d = -1;
    e.scan((u) => {
      const h = c.get(u);
      s += (++d ? "," : "") + JSON.stringify(l(h));
    }, !0, t.limit, t.offset), s += "]";
  }), s + "}" + (i ? "}" : "");
}
function zH(e, t = {}) {
  const i = Ly(e, t.columns), { align: r, format: n } = hO(e, i, t), s = (c) => c === "c" ? ":-:" : c === "r" ? "-:" : ":-", a = (c) => c.replace(/\|/g, "\\|");
  let o = "|" + i.map(a).join("|") + `|
|` + i.map((c) => s(r[c])).join("|") + "|";
  return $x(e, i, t.limit, t.offset, {
    row() {
      o += `
|`;
    },
    cell(c, l) {
      o += a(fO(c, n[l])) + "|";
    }
  }), o + `
`;
}
function pO(e, t) {
  for (const [i, r] of by(t))
    e.set(i, r);
  return e;
}
function UH(e) {
  return e.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function Ra(e, t, i = /* @__PURE__ */ new Map()) {
  return t = Tn(t) ? e.columnName(t) : t, fn(t) ? i.set(t, t) : Ei(t) ? t.forEach((r) => Ra(e, r, i)) : or(t) ? Ra(e, t(e), i) : _n(t) ? pO(i, t) : Qe(`Invalid column selection: ${Ss(t)}`), i;
}
function By(e, t) {
  return e.toObject = t, e;
}
function mO(e) {
  return Ei(e) ? e.map(mO) : e && e.toObject ? e.toObject() : e;
}
function zl() {
  return By(
    (e) => e.columnNames(),
    () => ({ all: [] })
  );
}
function gO(...e) {
  return e = e.flat(), By(
    (t) => {
      const i = Ra(t, e);
      return t.columnNames((r) => !i.has(r));
    },
    () => ({ not: mO(e) })
  );
}
function VH(e, t) {
  return By(
    (i) => {
      let r = Tn(e) ? e : i.columnIndex(e), n = Tn(t) ? t : i.columnIndex(t);
      if (n < r) {
        const s = n;
        n = r, r = s;
      }
      return i.columnNames().slice(r, n + 1);
    },
    () => ({ range: [e, t] })
  );
}
function jH(e) {
  return fn(e) && (e = RegExp(UH(e))), By(
    (t) => t.columnNames((i) => e.test(i)),
    () => ({ matches: [e.source, e.flags] })
  );
}
function GH(e) {
  return wp(e.data) ? e.data.constructor : Array;
}
class go extends WU {
  /**
   * Create a new ColumnTable from existing input data.
   * @param {object[]|Iterable<object>|object|Map} values The backing table data values.
   *  If array-valued, should be a list of JavaScript objects with
   *  key-value properties for each column value.
   *  If object- or Map-valued, a table with two columns (one for keys,
   *  one for values) will be created.
   * @param {string[]} [names] The named columns to include.
   * @return {ColumnTable} A new ColumnTable instance.
   */
  static from(t, i) {
    return new go(ZU(t, i), i);
  }
  /**
   * Create a new table for a set of named columns.
   * @param {object|Map} columns
   *  The set of named column arrays. Keys are column names.
   *  The enumeration order of the keys determines the column indices,
   *  unless the names parameter is specified.
   *  Values must be arrays (or array-like values) of identical length.
   * @param {string[]} [names] Ordered list of column names. If specified,
   *  this array determines the column indices. If not specified, the
   *  key enumeration order of the columns object is used.
   * @return {ColumnTable} the instantiated ColumnTable instance.
   */
  static new(t, i) {
    if (t instanceof go)
      return t;
    const r = {}, n = [];
    for (const [s, a] of by(t))
      r[s] = a, n.push(s);
    return new go(r, i || n);
  }
  /**
   * Instantiate a new ColumnTable instance.
   * @param {object} columns An object mapping column names to values.
   * @param {string[]} [names] An ordered list of column names.
   * @param {BitSet} [filter] A filtering BitSet.
   * @param {GroupBySpec} [group] A groupby specification.
   * @param {RowComparator} [order] A row comparator function.
   * @param {Params} [params] An object mapping parameter names to values.
   */
  constructor(t, i, r, n, s, a) {
    Fy(t, qU, t), i = i || Object.keys(t);
    const o = i.length ? t[i[0]].length : 0;
    super(i, o, t, r, n, s, a);
  }
  /**
   * Create a new table with the same type as this table.
   * The new table may have different data, filter, grouping, or ordering
   * based on the values of the optional configuration argument. If a
   * setting is not specified, it is inherited from the current table.
   * @param {CreateOptions} [options] Creation options for the new table.
   * @return {ColumnTable} A newly created table.
   */
  create({ data: t, names: i, filter: r, groups: n, order: s }) {
    const a = r !== void 0 ? r : this.mask();
    return new go(
      t || this._data,
      i || (t ? null : this._names),
      a,
      n !== void 0 ? n : S9(this._group, r && a),
      s !== void 0 ? s : this._order,
      this._params
    );
  }
  /**
   * Create a new table with additional columns drawn from one or more input
   * tables. All tables must have the same numer of rows and are reified
   * prior to assignment. In the case of repeated column names, input table
   * columns overwrite existing columns.
   * @param {...ColumnTable} tables The tables to merge with this table.
   * @return {ColumnTable} A new table with merged columns.
   * @example table.assign(table1, table2)
   */
  assign(...t) {
    const i = this.numRows(), r = this.reify(), n = Yn(r).groupby(r.groups());
    return t.forEach((s) => {
      s = go.new(s), s.numRows() !== i && Qe("Assign row counts do not match"), s = s.reify(), s.columnNames((a) => n.add(a, s.column(a)));
    }), this.create(n.new());
  }
  /**
   * Get the backing set of columns for this table.
   * @return {ColumnData} Object of named column instances.
   */
  columns() {
    return this._data;
  }
  /**
   * Get the column instance with the given name.
   * @param {string} name The column name.
   * @return {ColumnType | undefined} The named column, or undefined if it does not exist.
   */
  column(t) {
    return this._data[t];
  }
  /**
   * Get the column instance at the given index position.
   * @param {number} index The zero-based column index.
   * @return {ColumnType | undefined} The column, or undefined if it does not exist.
   */
  columnAt(t) {
    return this._data[this._names[t]];
  }
  /**
   * Get an array of values contained in a column. The resulting array
   * respects any table filter or orderby criteria.
   * @param {string} name The column name.
   * @param {ArrayConstructor|import('./table').TypedArrayConstructor} [constructor=Array]
   *  The array constructor for instantiating the output array.
   * @return {import('./table').DataValue[]|import('./table).TypedArray} The array of column values.
   */
  array(t, i = Array) {
    const r = this.column(t), n = new i(this.numRows());
    let s = -1;
    return this.scan((a) => n[++s] = r.get(a), !0), n;
  }
  /**
   * Get the value for the given column and row.
   * @param {string} name The column name.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {import('./table').DataValue} The table value at (column, row).
   */
  get(t, i = 0) {
    const r = this.column(t);
    return this.isFiltered() || this.isOrdered() ? r.get(this.indices()[i]) : r.get(i);
  }
  /**
   * Returns an accessor ("getter") function for a column. The returned
   * function takes a row index as its single argument and returns the
   * corresponding column value.
   * @param {string} name The column name.
   * @return {import('./table').ColumnGetter} The column getter function.
   */
  getter(t) {
    const i = this.column(t), r = this.isFiltered() || this.isOrdered() ? this.indices() : null;
    return r ? (n) => i.get(r[n]) : i ? (n) => i.get(n) : Qe(`Unrecognized column: ${t}`);
  }
  /**
   * Returns an object representing a table row.
   * @param {number} [row=0] The row index, defaults to zero if not specified.
   * @return {object} A row object with named properties for each column.
   */
  object(t = 0) {
    return $A(this)(t);
  }
  /**
   * Returns an array of objects representing table rows.
   * @param {ObjectsOptions} [options] The options for row object generation.
   * @return {object[]} An array of row objects.
   */
  objects(t = {}) {
    const { grouped: i, limit: r, offset: n } = t, s = Ra(this, t.columns || zl()), a = jE(s), o = [];
    if (this.scan(
      (c, l) => o.push(a(c, l)),
      !0,
      r,
      n
    ), i && this.isGrouped()) {
      const c = [];
      return this.scan((l) => c.push(l), !0, r, n), A9(this, c, o, i);
    }
    return o;
  }
  /**
   * Returns an iterator over objects representing table rows.
   * @return {Iterator<object>} An iterator over row objects.
   */
  *[Symbol.iterator]() {
    const t = $A(this), i = this.numRows();
    for (let r = 0; r < i; ++r)
      yield t(r);
  }
  /**
   * Create a new fully-materialized instance of this table.
   * All filter and orderby settings are removed from the new table.
   * Instead, the backing data itself is filtered and ordered as needed.
   * @param {number[]} [indices] Ordered row indices to materialize.
   *  If unspecified, all rows passing the table filter are used.
   * @return {ColumnTable} A reified table.
   */
  reify(t) {
    const i = t ? t.length : this.numRows(), r = this._names;
    let n, s;
    if (!t && !this.isOrdered())
      if (this.isFiltered())
        i === this.totalRows() && (n = this.data());
      else
        return this;
    if (!n) {
      const a = t ? (c) => t.forEach(c) : (c) => this.scan(c, !0), o = r.length;
      n = {};
      for (let c = 0; c < o; ++c) {
        const l = r[c], d = this.column(l), u = n[l] = new (GH(d))(i);
        let h = -1;
        a((p) => u[++h] = d.get(p));
      }
      this.isGrouped() && (s = I9(this.groups(), a, !!t, i));
    }
    return this.create({ data: n, names: r, groups: s, filter: null, order: null });
  }
  /**
   * Apply a sequence of transformations to this table. The output
   * of each transform is passed as input to the next transform, and
   * the output of the last transform is then returned.
   * @param {...(Transform|Transform[])} transforms Transformation
   *  functions to apply to the table in sequence. Each function should
   *  take a single table as input and return a table as output.
   * @return {ColumnTable} The output of the last transform.
   */
  transform(...t) {
    return t.flat().reduce((i, r) => r(i), this);
  }
  /**
   * Format this table as an Apache Arrow table.
   * @param {ArrowFormatOptions} [options] The formatting options.
   * @return {import('apache-arrow').Table} An Apache Arrow table.
   */
  toArrow(t) {
    return uO(this, t);
  }
  /**
   * Format this table as binary data in the Apache Arrow IPC format.
   * @param {ArrowFormatOptions} [options] The formatting options. Set {format: 'stream'} 
   *        or {format:"file"} for specific IPC format
   * @return {Uint8Array} A new Uint8Array of Arrow-encoded binary data.
   */
  toArrowBuffer(t) {
    return OH(this, t);
  }
  /**
   * Format this table as a comma-separated values (CSV) string. Other
   * delimiters, such as tabs or pipes ('|'), can be specified using
   * the options argument.
   * @param {CSVFormatOptions} [options] The formatting options.
   * @return {string} A delimited value string.
   */
  toCSV(t) {
    return FH(this, t);
  }
  /**
   * Format this table as an HTML table string.
   * @param {HTMLFormatOptions} [options] The formatting options.
   * @return {string} An HTML table string.
   */
  toHTML(t) {
    return BH(this, t);
  }
  /**
   * Format this table as a JavaScript Object Notation (JSON) string.
   * @param {JSONFormatOptions} [options] The formatting options.
   * @return {string} A JSON string.
   */
  toJSON(t) {
    return $H(this, t);
  }
  /**
   * Format this table as a GitHub-Flavored Markdown table string.
   * @param {MarkdownFormatOptions} [options] The formatting options.
   * @return {string} A GitHub-Flavored Markdown table string.
   */
  toMarkdown(t) {
    return zH(this, t);
  }
}
function $A(e) {
  let t = e._builder;
  if (!t) {
    const i = jE(e.columnNames()), r = e.data();
    if (e.isOrdered() || e.isFiltered()) {
      const n = e.indices();
      t = (s) => i(n[s], r);
    } else
      t = (n) => i(n, r);
    e._builder = t;
  }
  return t;
}
class HH {
  constructor(t) {
    this._outputs = t;
  }
  size() {
    return this._outputs.length;
  }
  outputs() {
    return this._outputs;
  }
  init() {
    return {};
  }
  add() {
  }
  rem() {
  }
  write() {
  }
}
function bi(e, t, i, r) {
  const n = i[e.type] || i.Default;
  if (n && n(e, t, r) === !1)
    return;
  const s = WH[e.type];
  s && s(e, t, i);
}
const Um = (e, t, i) => {
  bi(e.argument, t, i, e);
}, I_ = (e, t, i) => {
  bi(e.left, t, i, e), bi(e.right, t, i, e);
}, zA = (e, t, i) => {
  bi(e.test, t, i, e), bi(e.consequent, t, i, e), e.alternate && bi(e.alternate, t, i, e);
}, A_ = (e, t, i) => {
  va(e.params, t, i, e), bi(e.body, t, i, e);
}, UA = (e, t, i) => {
  bi(e.callee, t, i, e), va(e.arguments, t, i, e);
}, va = (e, t, i, r) => {
  e.forEach((n) => bi(n, t, i, r));
}, WH = {
  TemplateLiteral: (e, t, i) => {
    va(e.expressions, t, i, e), va(e.quasis, t, i, e);
  },
  MemberExpression: (e, t, i) => {
    bi(e.object, t, i, e), bi(e.property, t, i, e);
  },
  CallExpression: UA,
  NewExpression: UA,
  ArrayExpression: (e, t, i) => {
    va(e.elements, t, i, e);
  },
  AssignmentExpression: I_,
  AwaitExpression: Um,
  BinaryExpression: I_,
  LogicalExpression: I_,
  UnaryExpression: Um,
  UpdateExpression: Um,
  ConditionalExpression: zA,
  ObjectExpression: (e, t, i) => {
    va(e.properties, t, i, e);
  },
  Property: (e, t, i) => {
    bi(e.key, t, i, e), bi(e.value, t, i, e);
  },
  ArrowFunctionExpression: A_,
  FunctionExpression: A_,
  FunctionDeclaration: A_,
  VariableDeclaration: (e, t, i) => {
    va(e.declarations, t, i, e);
  },
  VariableDeclarator: (e, t, i) => {
    bi(e.id, t, i, e), bi(e.init, t, i, e);
  },
  SpreadElement: (e, t, i) => {
    bi(e.argument, t, i, e);
  },
  BlockStatement: (e, t, i) => {
    va(e.body, t, i, e);
  },
  ExpressionStatement: (e, t, i) => {
    bi(e.expression, t, i, e);
  },
  IfStatement: zA,
  ForStatement: (e, t, i) => {
    bi(e.init, t, i, e), bi(e.test, t, i, e), bi(e.update, t, i, e), bi(e.body, t, i, e);
  },
  WhileStatement: (e, t, i) => {
    bi(e.test, t, i, e), bi(e.body, t, i, e);
  },
  DoWhileStatement: (e, t, i) => {
    bi(e.body, t, i, e), bi(e.test, t, i, e);
  },
  SwitchStatement: (e, t, i) => {
    bi(e.discriminant, t, i, e), va(e.cases, t, i, e);
  },
  SwitchCase: (e, t, i) => {
    e.test && bi(e.test, t, i, e), va(e.consequent, t, i, e);
  },
  ReturnStatement: Um,
  Program: (e, t, i) => {
    bi(e.body[0], t, i, e);
  }
};
function yO(e) {
  delete e.start, delete e.end, delete e.optional;
}
function VA(e) {
  yO(e), delete e.object, delete e.property, delete e.computed, e.table || delete e.table;
}
function YH(e) {
  return bi(e, null, {
    Column: VA,
    Constant: VA,
    Default: yO
  }), e;
}
function Qr(e, t) {
  return t && t.type === e;
}
function qH(e) {
  return Qr(k9, e) || Qr(E9, e);
}
function ZH(e) {
  return or(e) ? e : () => e;
}
const XH = "Escaped functions are not valid as rollup or pivot values.";
function KH(e, t, i) {
  e.aggronly && Qe(XH);
  const r = "(row,data)=>fn(" + VE(e.table.columnNames()) + ",$)";
  return { escape: P1.escape(r, ZH(t.expr), i) };
}
var JH = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], vO = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], QH = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", _O = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", T_ = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, E_ = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", tW = {
  5: E_,
  "5module": E_ + " export import",
  6: E_ + " const class extends export import super"
}, eW = /^in(stanceof)?$/, iW = new RegExp("[" + _O + "]"), rW = new RegExp("[" + _O + QH + "]");
function kb(e, t) {
  for (var i = 65536, r = 0; r < t.length; r += 2) {
    if (i += t[r], i > e)
      return !1;
    if (i += t[r + 1], i >= e)
      return !0;
  }
  return !1;
}
function Oo(e, t) {
  return e < 65 ? e === 36 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && iW.test(String.fromCharCode(e)) : t === !1 ? !1 : kb(e, vO);
}
function ju(e, t) {
  return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e < 91 ? !0 : e < 97 ? e === 95 : e < 123 ? !0 : e <= 65535 ? e >= 170 && rW.test(String.fromCharCode(e)) : t === !1 ? !1 : kb(e, vO) || kb(e, JH);
}
var wi = function(t, i) {
  i === void 0 && (i = {}), this.label = t, this.keyword = i.keyword, this.beforeExpr = !!i.beforeExpr, this.startsExpr = !!i.startsExpr, this.isLoop = !!i.isLoop, this.isAssign = !!i.isAssign, this.prefix = !!i.prefix, this.postfix = !!i.postfix, this.binop = i.binop || null, this.updateContext = null;
};
function cs(e, t) {
  return new wi(e, { beforeExpr: !0, binop: t });
}
var ls = { beforeExpr: !0 }, Rn = { startsExpr: !0 }, zx = {};
function yi(e, t) {
  return t === void 0 && (t = {}), t.keyword = e, zx[e] = new wi(e, t);
}
var v = {
  num: new wi("num", Rn),
  regexp: new wi("regexp", Rn),
  string: new wi("string", Rn),
  name: new wi("name", Rn),
  privateId: new wi("privateId", Rn),
  eof: new wi("eof"),
  // Punctuation token types.
  bracketL: new wi("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new wi("]"),
  braceL: new wi("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new wi("}"),
  parenL: new wi("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new wi(")"),
  comma: new wi(",", ls),
  semi: new wi(";", ls),
  colon: new wi(":", ls),
  dot: new wi("."),
  question: new wi("?", ls),
  questionDot: new wi("?."),
  arrow: new wi("=>", ls),
  template: new wi("template"),
  invalidTemplate: new wi("invalidTemplate"),
  ellipsis: new wi("...", ls),
  backQuote: new wi("`", Rn),
  dollarBraceL: new wi("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new wi("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new wi("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new wi("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new wi("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: cs("||", 1),
  logicalAND: cs("&&", 2),
  bitwiseOR: cs("|", 3),
  bitwiseXOR: cs("^", 4),
  bitwiseAND: cs("&", 5),
  equality: cs("==/!=/===/!==", 6),
  relational: cs("</>/<=/>=", 7),
  bitShift: cs("<</>>/>>>", 8),
  plusMin: new wi("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: cs("%", 10),
  star: cs("*", 10),
  slash: cs("/", 10),
  starstar: new wi("**", { beforeExpr: !0 }),
  coalesce: cs("??", 1),
  // Keyword token types.
  _break: yi("break"),
  _case: yi("case", ls),
  _catch: yi("catch"),
  _continue: yi("continue"),
  _debugger: yi("debugger"),
  _default: yi("default", ls),
  _do: yi("do", { isLoop: !0, beforeExpr: !0 }),
  _else: yi("else", ls),
  _finally: yi("finally"),
  _for: yi("for", { isLoop: !0 }),
  _function: yi("function", Rn),
  _if: yi("if"),
  _return: yi("return", ls),
  _switch: yi("switch"),
  _throw: yi("throw", ls),
  _try: yi("try"),
  _var: yi("var"),
  _const: yi("const"),
  _while: yi("while", { isLoop: !0 }),
  _with: yi("with"),
  _new: yi("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: yi("this", Rn),
  _super: yi("super", Rn),
  _class: yi("class", Rn),
  _extends: yi("extends", ls),
  _export: yi("export"),
  _import: yi("import", Rn),
  _null: yi("null", Rn),
  _true: yi("true", Rn),
  _false: yi("false", Rn),
  _in: yi("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: yi("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: yi("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: yi("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: yi("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, Ts = /\r\n?|\n|\u2028|\u2029/, nW = new RegExp(Ts.source, "g");
function oh(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function bO(e, t, i) {
  i === void 0 && (i = e.length);
  for (var r = t; r < i; r++) {
    var n = e.charCodeAt(r);
    if (oh(n))
      return r < i - 1 && n === 13 && e.charCodeAt(r + 1) === 10 ? r + 2 : r + 1;
  }
  return -1;
}
var xO = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, gs = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, wO = Object.prototype, sW = wO.hasOwnProperty, aW = wO.toString, Np = Object.hasOwn || function(e, t) {
  return sW.call(e, t);
}, jA = Array.isArray || function(e) {
  return aW.call(e) === "[object Array]";
}, GA = /* @__PURE__ */ Object.create(null);
function _c(e) {
  return GA[e] || (GA[e] = new RegExp("^(?:" + e.replace(/ /g, "|") + ")$"));
}
function Dc(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
var oW = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Hf = function(t, i) {
  this.line = t, this.column = i;
};
Hf.prototype.offset = function(t) {
  return new Hf(this.line, this.column + t);
};
var Ry = function(t, i, r) {
  this.start = i, this.end = r, t.sourceFile !== null && (this.source = t.sourceFile);
};
function SO(e, t) {
  for (var i = 1, r = 0; ; ) {
    var n = bO(e, r, t);
    if (n < 0)
      return new Hf(i, t - r);
    ++i, r = n;
  }
}
var Cb = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, HA = !1;
function cW(e) {
  var t = {};
  for (var i in Cb)
    t[i] = e && Np(e, i) ? e[i] : Cb[i];
  if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!HA && typeof console == "object" && console.warn && (HA = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), (!e || e.allowHashBang == null) && (t.allowHashBang = t.ecmaVersion >= 14), jA(t.onToken)) {
    var r = t.onToken;
    t.onToken = function(n) {
      return r.push(n);
    };
  }
  return jA(t.onComment) && (t.onComment = lW(t, t.onComment)), t;
}
function lW(e, t) {
  return function(i, r, n, s, a, o) {
    var c = {
      type: i ? "Block" : "Line",
      value: r,
      start: n,
      end: s
    };
    e.locations && (c.loc = new Ry(this, a, o)), e.ranges && (c.range = [n, s]), t.push(c);
  };
}
var Wf = 1, ch = 2, Ux = 4, IO = 8, AO = 16, TO = 32, Vx = 64, EO = 128, Lp = 256, jx = Wf | ch | Lp;
function Gx(e, t) {
  return ch | (e ? Ux : 0) | (t ? IO : 0);
}
var g0 = 0, Hx = 1, Go = 2, kO = 3, CO = 4, OO = 5, tn = function(t, i, r) {
  this.options = t = cW(t), this.sourceFile = t.sourceFile, this.keywords = _c(tW[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
  var n = "";
  t.allowReserved !== !0 && (n = T_[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (n += " await")), this.reservedWords = _c(n);
  var s = (n ? n + " " : "") + T_.strict;
  this.reservedWordsStrict = _c(s), this.reservedWordsStrictBind = _c(s + " " + T_.strictBind), this.input = String(i), this.containsEsc = !1, r ? (this.pos = r, this.lineStart = this.input.lastIndexOf(`
`, r - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Ts).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = v.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Wf), this.regexpState = null, this.privateNameStack = [];
}, Ha = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
tn.prototype.parse = function() {
  var t = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(t);
};
Ha.inFunction.get = function() {
  return (this.currentVarScope().flags & ch) > 0;
};
Ha.inGenerator.get = function() {
  return (this.currentVarScope().flags & IO) > 0 && !this.currentVarScope().inClassFieldInit;
};
Ha.inAsync.get = function() {
  return (this.currentVarScope().flags & Ux) > 0 && !this.currentVarScope().inClassFieldInit;
};
Ha.canAwait.get = function() {
  for (var e = this.scopeStack.length - 1; e >= 0; e--) {
    var t = this.scopeStack[e];
    if (t.inClassFieldInit || t.flags & Lp)
      return !1;
    if (t.flags & ch)
      return (t.flags & Ux) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
Ha.allowSuper.get = function() {
  var e = this.currentThisScope(), t = e.flags, i = e.inClassFieldInit;
  return (t & Vx) > 0 || i || this.options.allowSuperOutsideMethod;
};
Ha.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & EO) > 0;
};
Ha.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Ha.allowNewDotTarget.get = function() {
  var e = this.currentThisScope(), t = e.flags, i = e.inClassFieldInit;
  return (t & (ch | Lp)) > 0 || i;
};
Ha.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & Lp) > 0;
};
tn.extend = function() {
  for (var t = [], i = arguments.length; i--; )
    t[i] = arguments[i];
  for (var r = this, n = 0; n < t.length; n++)
    r = t[n](r);
  return r;
};
tn.parse = function(t, i) {
  return new this(i, t).parse();
};
tn.parseExpressionAt = function(t, i, r) {
  var n = new this(r, t, i);
  return n.nextToken(), n.parseExpression();
};
tn.tokenizer = function(t, i) {
  return new this(i, t);
};
Object.defineProperties(tn.prototype, Ha);
var Nn = tn.prototype, dW = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
Nn.strictDirective = function(e) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    gs.lastIndex = e, e += gs.exec(this.input)[0].length;
    var t = dW.exec(this.input.slice(e));
    if (!t)
      return !1;
    if ((t[1] || t[2]) === "use strict") {
      gs.lastIndex = e + t[0].length;
      var i = gs.exec(this.input), r = i.index + i[0].length, n = this.input.charAt(r);
      return n === ";" || n === "}" || Ts.test(i[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || n === "!" && this.input.charAt(r + 1) === "=");
    }
    e += t[0].length, gs.lastIndex = e, e += gs.exec(this.input)[0].length, this.input[e] === ";" && e++;
  }
};
Nn.eat = function(e) {
  return this.type === e ? (this.next(), !0) : !1;
};
Nn.isContextual = function(e) {
  return this.type === v.name && this.value === e && !this.containsEsc;
};
Nn.eatContextual = function(e) {
  return this.isContextual(e) ? (this.next(), !0) : !1;
};
Nn.expectContextual = function(e) {
  this.eatContextual(e) || this.unexpected();
};
Nn.canInsertSemicolon = function() {
  return this.type === v.eof || this.type === v.braceR || Ts.test(this.input.slice(this.lastTokEnd, this.start));
};
Nn.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
Nn.semicolon = function() {
  !this.eat(v.semi) && !this.insertSemicolon() && this.unexpected();
};
Nn.afterTrailingComma = function(e, t) {
  if (this.type === e)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), !0;
};
Nn.expect = function(e) {
  this.eat(e) || this.unexpected();
};
Nn.unexpected = function(e) {
  this.raise(e ?? this.start, "Unexpected token");
};
var My = function() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
Nn.checkPatternErrors = function(e, t) {
  if (e) {
    e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
    var i = t ? e.parenthesizedAssign : e.parenthesizedBind;
    i > -1 && this.raiseRecoverable(i, t ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
Nn.checkExpressionErrors = function(e, t) {
  if (!e)
    return !1;
  var i = e.shorthandAssign, r = e.doubleProto;
  if (!t)
    return i >= 0 || r >= 0;
  i >= 0 && this.raise(i, "Shorthand property assignments are valid only in destructuring patterns"), r >= 0 && this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
Nn.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
Nn.isSimpleAssignTarget = function(e) {
  return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
};
var ue = tn.prototype;
ue.parseTopLevel = function(e) {
  var t = /* @__PURE__ */ Object.create(null);
  for (e.body || (e.body = []); this.type !== v.eof; ) {
    var i = this.parseStatement(null, !0, t);
    e.body.push(i);
  }
  if (this.inModule)
    for (var r = 0, n = Object.keys(this.undefinedExports); r < n.length; r += 1) {
      var s = n[r];
      this.raiseRecoverable(this.undefinedExports[s].start, "Export '" + s + "' is not defined");
    }
  return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
};
var Wx = { kind: "loop" }, uW = { kind: "switch" };
ue.isLet = function(e) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  gs.lastIndex = this.pos;
  var t = gs.exec(this.input), i = this.pos + t[0].length, r = this.input.charCodeAt(i);
  if (r === 91 || r === 92)
    return !0;
  if (e)
    return !1;
  if (r === 123 || r > 55295 && r < 56320)
    return !0;
  if (Oo(r, !0)) {
    for (var n = i + 1; ju(r = this.input.charCodeAt(n), !0); )
      ++n;
    if (r === 92 || r > 55295 && r < 56320)
      return !0;
    var s = this.input.slice(i, n);
    if (!eW.test(s))
      return !0;
  }
  return !1;
};
ue.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  gs.lastIndex = this.pos;
  var e = gs.exec(this.input), t = this.pos + e[0].length, i;
  return !Ts.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(ju(i = this.input.charCodeAt(t + 8)) || i > 55295 && i < 56320));
};
ue.parseStatement = function(e, t, i) {
  var r = this.type, n = this.startNode(), s;
  switch (this.isLet(e) && (r = v._var, s = "let"), r) {
    case v._break:
    case v._continue:
      return this.parseBreakContinueStatement(n, r.keyword);
    case v._debugger:
      return this.parseDebuggerStatement(n);
    case v._do:
      return this.parseDoStatement(n);
    case v._for:
      return this.parseForStatement(n);
    case v._function:
      return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, !1, !e);
    case v._class:
      return e && this.unexpected(), this.parseClass(n, !0);
    case v._if:
      return this.parseIfStatement(n);
    case v._return:
      return this.parseReturnStatement(n);
    case v._switch:
      return this.parseSwitchStatement(n);
    case v._throw:
      return this.parseThrowStatement(n);
    case v._try:
      return this.parseTryStatement(n);
    case v._const:
    case v._var:
      return s = s || this.value, e && s !== "var" && this.unexpected(), this.parseVarStatement(n, s);
    case v._while:
      return this.parseWhileStatement(n);
    case v._with:
      return this.parseWithStatement(n);
    case v.braceL:
      return this.parseBlock(!0, n);
    case v.semi:
      return this.parseEmptyStatement(n);
    case v._export:
    case v._import:
      if (this.options.ecmaVersion > 10 && r === v._import) {
        gs.lastIndex = this.pos;
        var a = gs.exec(this.input), o = this.pos + a[0].length, c = this.input.charCodeAt(o);
        if (c === 40 || c === 46)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r === v._import ? this.parseImport(n) : this.parseExport(n, i);
    default:
      if (this.isAsyncFunction())
        return e && this.unexpected(), this.next(), this.parseFunctionStatement(n, !0, !e);
      var l = this.value, d = this.parseExpression();
      return r === v.name && d.type === "Identifier" && this.eat(v.colon) ? this.parseLabeledStatement(n, l, d, e) : this.parseExpressionStatement(n, d);
  }
};
ue.parseBreakContinueStatement = function(e, t) {
  var i = t === "break";
  this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.label = null : this.type !== v.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
  for (var r = 0; r < this.labels.length; ++r) {
    var n = this.labels[r];
    if ((e.label == null || n.name === e.label.name) && (n.kind != null && (i || n.kind === "loop") || e.label && i))
      break;
  }
  return r === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, i ? "BreakStatement" : "ContinueStatement");
};
ue.parseDebuggerStatement = function(e) {
  return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
};
ue.parseDoStatement = function(e) {
  return this.next(), this.labels.push(Wx), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(v._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(v.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
};
ue.parseForStatement = function(e) {
  this.next();
  var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(Wx), this.enterScope(0), this.expect(v.parenL), this.type === v.semi)
    return t > -1 && this.unexpected(t), this.parseFor(e, null);
  var i = this.isLet();
  if (this.type === v._var || this.type === v._const || i) {
    var r = this.startNode(), n = i ? "let" : this.value;
    return this.next(), this.parseVar(r, !0, n), this.finishNode(r, "VariableDeclaration"), (this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && r.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, r)) : (t > -1 && this.unexpected(t), this.parseFor(e, r));
  }
  var s = this.isContextual("let"), a = !1, o = new My(), c = this.parseExpression(t > -1 ? "await" : !0, o);
  return this.type === v._in || (a = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === v._in ? t > -1 && this.unexpected(t) : e.await = t > -1), s && a && this.raise(c.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(c, !1, o), this.checkLValPattern(c), this.parseForIn(e, c)) : (this.checkExpressionErrors(o, !0), t > -1 && this.unexpected(t), this.parseFor(e, c));
};
ue.parseFunctionStatement = function(e, t, i) {
  return this.next(), this.parseFunction(e, Af | (i ? 0 : Ob), !1, t);
};
ue.parseIfStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(v._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
};
ue.parseReturnStatement = function(e) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(v.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
};
ue.parseSwitchStatement = function(e) {
  this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(v.braceL), this.labels.push(uW), this.enterScope(0);
  for (var t, i = !1; this.type !== v.braceR; )
    if (this.type === v._case || this.type === v._default) {
      var r = this.type === v._case;
      t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), r ? t.test = this.parseExpression() : (i && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), i = !0, t.test = null), this.expect(v.colon);
    } else
      t || this.unexpected(), t.consequent.push(this.parseStatement(null));
  return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
};
ue.parseThrowStatement = function(e) {
  return this.next(), Ts.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
};
var hW = [];
ue.parseCatchClauseParam = function() {
  var e = this.parseBindingAtom(), t = e.type === "Identifier";
  return this.enterScope(t ? TO : 0), this.checkLValPattern(e, t ? CO : Go), this.expect(v.parenR), e;
};
ue.parseTryStatement = function(e) {
  if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === v._catch) {
    var t = this.startNode();
    this.next(), this.eat(v.parenL) ? t.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0)), t.body = this.parseBlock(!1), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
  }
  return e.finalizer = this.eat(v._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
};
ue.parseVarStatement = function(e, t, i) {
  return this.next(), this.parseVar(e, !1, t, i), this.semicolon(), this.finishNode(e, "VariableDeclaration");
};
ue.parseWhileStatement = function(e) {
  return this.next(), e.test = this.parseParenExpression(), this.labels.push(Wx), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
};
ue.parseWithStatement = function(e) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
};
ue.parseEmptyStatement = function(e) {
  return this.next(), this.finishNode(e, "EmptyStatement");
};
ue.parseLabeledStatement = function(e, t, i, r) {
  for (var n = 0, s = this.labels; n < s.length; n += 1) {
    var a = s[n];
    a.name === t && this.raise(i.start, "Label '" + t + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === v._switch ? "switch" : null, c = this.labels.length - 1; c >= 0; c--) {
    var l = this.labels[c];
    if (l.statementStart === e.start)
      l.statementStart = this.start, l.kind = o;
    else
      break;
  }
  return this.labels.push({ name: t, kind: o, statementStart: this.start }), e.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.labels.pop(), e.label = i, this.finishNode(e, "LabeledStatement");
};
ue.parseExpressionStatement = function(e, t) {
  return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
};
ue.parseBlock = function(e, t, i) {
  for (e === void 0 && (e = !0), t === void 0 && (t = this.startNode()), t.body = [], this.expect(v.braceL), e && this.enterScope(0); this.type !== v.braceR; ) {
    var r = this.parseStatement(null);
    t.body.push(r);
  }
  return i && (this.strict = !1), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
};
ue.parseFor = function(e, t) {
  return e.init = t, this.expect(v.semi), e.test = this.type === v.semi ? null : this.parseExpression(), this.expect(v.semi), e.update = this.type === v.parenR ? null : this.parseExpression(), this.expect(v.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
};
ue.parseForIn = function(e, t) {
  var i = this.type === v._in;
  return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!i || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(
    t.start,
    (i ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), e.left = t, e.right = i ? this.parseExpression() : this.parseMaybeAssign(), this.expect(v.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, i ? "ForInStatement" : "ForOfStatement");
};
ue.parseVar = function(e, t, i, r) {
  for (e.declarations = [], e.kind = i; ; ) {
    var n = this.startNode();
    if (this.parseVarId(n, i), this.eat(v.eq) ? n.init = this.parseMaybeAssign(t) : !r && i === "const" && !(this.type === v._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !r && n.id.type !== "Identifier" && !(t && (this.type === v._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : n.init = null, e.declarations.push(this.finishNode(n, "VariableDeclarator")), !this.eat(v.comma))
      break;
  }
  return e;
};
ue.parseVarId = function(e, t) {
  e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? Hx : Go, !1);
};
var Af = 1, Ob = 2, DO = 4;
ue.parseFunction = function(e, t, i, r, n) {
  this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !r) && (this.type === v.star && t & Ob && this.unexpected(), e.generator = this.eat(v.star)), this.options.ecmaVersion >= 8 && (e.async = !!r), t & Af && (e.id = t & DO && this.type !== v.name ? null : this.parseIdent(), e.id && !(t & Ob) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? Hx : Go : kO));
  var s = this.yieldPos, a = this.awaitPos, o = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Gx(e.async, e.generator)), t & Af || (e.id = this.type === v.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, i, !1, n), this.yieldPos = s, this.awaitPos = a, this.awaitIdentPos = o, this.finishNode(e, t & Af ? "FunctionDeclaration" : "FunctionExpression");
};
ue.parseFunctionParams = function(e) {
  this.expect(v.parenL), e.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
ue.parseClass = function(e, t) {
  this.next();
  var i = this.strict;
  this.strict = !0, this.parseClassId(e, t), this.parseClassSuper(e);
  var r = this.enterClassBody(), n = this.startNode(), s = !1;
  for (n.body = [], this.expect(v.braceL); this.type !== v.braceR; ) {
    var a = this.parseClassElement(e.superClass !== null);
    a && (n.body.push(a), a.type === "MethodDefinition" && a.kind === "constructor" ? (s && this.raiseRecoverable(a.start, "Duplicate constructor in the same class"), s = !0) : a.key && a.key.type === "PrivateIdentifier" && fW(r, a) && this.raiseRecoverable(a.key.start, "Identifier '#" + a.key.name + "' has already been declared"));
  }
  return this.strict = i, this.next(), e.body = this.finishNode(n, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
};
ue.parseClassElement = function(e) {
  if (this.eat(v.semi))
    return null;
  var t = this.options.ecmaVersion, i = this.startNode(), r = "", n = !1, s = !1, a = "method", o = !1;
  if (this.eatContextual("static")) {
    if (t >= 13 && this.eat(v.braceL))
      return this.parseClassStaticBlock(i), i;
    this.isClassElementNameStart() || this.type === v.star ? o = !0 : r = "static";
  }
  if (i.static = o, !r && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === v.star) && !this.canInsertSemicolon() ? s = !0 : r = "async"), !r && (t >= 9 || !s) && this.eat(v.star) && (n = !0), !r && !s && !n) {
    var c = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a = c : r = c);
  }
  if (r ? (i.computed = !1, i.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), i.key.name = r, this.finishNode(i.key, "Identifier")) : this.parseClassElementName(i), t < 13 || this.type === v.parenL || a !== "method" || n || s) {
    var l = !i.static && y0(i, "constructor"), d = l && e;
    l && a !== "method" && this.raise(i.key.start, "Constructor can't have get/set modifier"), i.kind = l ? "constructor" : a, this.parseClassMethod(i, n, s, d);
  } else
    this.parseClassField(i);
  return i;
};
ue.isClassElementNameStart = function() {
  return this.type === v.name || this.type === v.privateId || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword;
};
ue.parseClassElementName = function(e) {
  this.type === v.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = !1, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
};
ue.parseClassMethod = function(e, t, i, r) {
  var n = e.key;
  e.kind === "constructor" ? (t && this.raise(n.start, "Constructor can't be a generator"), i && this.raise(n.start, "Constructor can't be an async method")) : e.static && y0(e, "prototype") && this.raise(n.start, "Classes may not have a static property named prototype");
  var s = e.value = this.parseMethod(t, i, r);
  return e.kind === "get" && s.params.length !== 0 && this.raiseRecoverable(s.start, "getter should have no params"), e.kind === "set" && s.params.length !== 1 && this.raiseRecoverable(s.start, "setter should have exactly one param"), e.kind === "set" && s.params[0].type === "RestElement" && this.raiseRecoverable(s.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
};
ue.parseClassField = function(e) {
  if (y0(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && y0(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(v.eq)) {
    var t = this.currentThisScope(), i = t.inClassFieldInit;
    t.inClassFieldInit = !0, e.value = this.parseMaybeAssign(), t.inClassFieldInit = i;
  } else
    e.value = null;
  return this.semicolon(), this.finishNode(e, "PropertyDefinition");
};
ue.parseClassStaticBlock = function(e) {
  e.body = [];
  var t = this.labels;
  for (this.labels = [], this.enterScope(Lp | Vx); this.type !== v.braceR; ) {
    var i = this.parseStatement(null);
    e.body.push(i);
  }
  return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
};
ue.parseClassId = function(e, t) {
  this.type === v.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, Go, !1)) : (t === !0 && this.unexpected(), e.id = null);
};
ue.parseClassSuper = function(e) {
  e.superClass = this.eat(v._extends) ? this.parseExprSubscripts(null, !1) : null;
};
ue.enterClassBody = function() {
  var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(e), e.declared;
};
ue.exitClassBody = function() {
  var e = this.privateNameStack.pop(), t = e.declared, i = e.used;
  if (this.options.checkPrivateFields)
    for (var r = this.privateNameStack.length, n = r === 0 ? null : this.privateNameStack[r - 1], s = 0; s < i.length; ++s) {
      var a = i[s];
      Np(t, a.name) || (n ? n.used.push(a) : this.raiseRecoverable(a.start, "Private field '#" + a.name + "' must be declared in an enclosing class"));
    }
};
function fW(e, t) {
  var i = t.key.name, r = e[i], n = "true";
  return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (n = (t.static ? "s" : "i") + t.kind), r === "iget" && n === "iset" || r === "iset" && n === "iget" || r === "sget" && n === "sset" || r === "sset" && n === "sget" ? (e[i] = "true", !1) : r ? !0 : (e[i] = n, !1);
}
function y0(e, t) {
  var i = e.computed, r = e.key;
  return !i && (r.type === "Identifier" && r.name === t || r.type === "Literal" && r.value === t);
}
ue.parseExportAllDeclaration = function(e, t) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
};
ue.parseExport = function(e, t) {
  if (this.next(), this.eat(v.star))
    return this.parseExportAllDeclaration(e, t);
  if (this.eat(v._default))
    return this.checkExport(t, "default", this.lastTokStart), e.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    e.declaration = this.parseExportDeclaration(e), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
  else {
    if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from"))
      this.type !== v.string && this.unexpected(), e.source = this.parseExprAtom();
    else {
      for (var i = 0, r = e.specifiers; i < r.length; i += 1) {
        var n = r[i];
        this.checkUnreserved(n.local), this.checkLocalExport(n.local), n.local.type === "Literal" && this.raise(n.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      e.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(e, "ExportNamedDeclaration");
};
ue.parseExportDeclaration = function(e) {
  return this.parseStatement(null);
};
ue.parseExportDefaultDeclaration = function() {
  var e;
  if (this.type === v._function || (e = this.isAsyncFunction())) {
    var t = this.startNode();
    return this.next(), e && this.next(), this.parseFunction(t, Af | DO, !1, e);
  } else if (this.type === v._class) {
    var i = this.startNode();
    return this.parseClass(i, "nullableID");
  } else {
    var r = this.parseMaybeAssign();
    return this.semicolon(), r;
  }
};
ue.checkExport = function(e, t, i) {
  e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), Np(e, t) && this.raiseRecoverable(i, "Duplicate export '" + t + "'"), e[t] = !0);
};
ue.checkPatternExport = function(e, t) {
  var i = t.type;
  if (i === "Identifier")
    this.checkExport(e, t, t.start);
  else if (i === "ObjectPattern")
    for (var r = 0, n = t.properties; r < n.length; r += 1) {
      var s = n[r];
      this.checkPatternExport(e, s);
    }
  else if (i === "ArrayPattern")
    for (var a = 0, o = t.elements; a < o.length; a += 1) {
      var c = o[a];
      c && this.checkPatternExport(e, c);
    }
  else
    i === "Property" ? this.checkPatternExport(e, t.value) : i === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : i === "RestElement" && this.checkPatternExport(e, t.argument);
};
ue.checkVariableExport = function(e, t) {
  if (e)
    for (var i = 0, r = t; i < r.length; i += 1) {
      var n = r[i];
      this.checkPatternExport(e, n.id);
    }
};
ue.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
ue.parseExportSpecifier = function(e) {
  var t = this.startNode();
  return t.local = this.parseModuleExportName(), t.exported = this.eatContextual("as") ? this.parseModuleExportName() : t.local, this.checkExport(
    e,
    t.exported,
    t.exported.start
  ), this.finishNode(t, "ExportSpecifier");
};
ue.parseExportSpecifiers = function(e) {
  var t = [], i = !0;
  for (this.expect(v.braceL); !this.eat(v.braceR); ) {
    if (i)
      i = !1;
    else if (this.expect(v.comma), this.afterTrailingComma(v.braceR))
      break;
    t.push(this.parseExportSpecifier(e));
  }
  return t;
};
ue.parseImport = function(e) {
  return this.next(), this.type === v.string ? (e.specifiers = hW, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === v.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
};
ue.parseImportSpecifier = function() {
  var e = this.startNode();
  return e.imported = this.parseModuleExportName(), this.eatContextual("as") ? e.local = this.parseIdent() : (this.checkUnreserved(e.imported), e.local = e.imported), this.checkLValSimple(e.local, Go), this.finishNode(e, "ImportSpecifier");
};
ue.parseImportDefaultSpecifier = function() {
  var e = this.startNode();
  return e.local = this.parseIdent(), this.checkLValSimple(e.local, Go), this.finishNode(e, "ImportDefaultSpecifier");
};
ue.parseImportNamespaceSpecifier = function() {
  var e = this.startNode();
  return this.next(), this.expectContextual("as"), e.local = this.parseIdent(), this.checkLValSimple(e.local, Go), this.finishNode(e, "ImportNamespaceSpecifier");
};
ue.parseImportSpecifiers = function() {
  var e = [], t = !0;
  if (this.type === v.name && (e.push(this.parseImportDefaultSpecifier()), !this.eat(v.comma)))
    return e;
  if (this.type === v.star)
    return e.push(this.parseImportNamespaceSpecifier()), e;
  for (this.expect(v.braceL); !this.eat(v.braceR); ) {
    if (t)
      t = !1;
    else if (this.expect(v.comma), this.afterTrailingComma(v.braceR))
      break;
    e.push(this.parseImportSpecifier());
  }
  return e;
};
ue.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === v.string) {
    var e = this.parseLiteral(this.value);
    return oW.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
  }
  return this.parseIdent(!0);
};
ue.adaptDirectivePrologue = function(e) {
  for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t)
    e[t].directive = e[t].expression.raw.slice(1, -1);
};
ue.isDirectiveCandidate = function(e) {
  return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && // Reject parenthesized strings.
  (this.input[e.start] === '"' || this.input[e.start] === "'");
};
var Es = tn.prototype;
Es.toAssignable = function(e, t, i) {
  if (this.options.ecmaVersion >= 6 && e)
    switch (e.type) {
      case "Identifier":
        this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e.type = "ObjectPattern", i && this.checkPatternErrors(i, !0);
        for (var r = 0, n = e.properties; r < n.length; r += 1) {
          var s = n[r];
          this.toAssignable(s, t), s.type === "RestElement" && (s.argument.type === "ArrayPattern" || s.argument.type === "ObjectPattern") && this.raise(s.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
        break;
      case "ArrayExpression":
        e.type = "ArrayPattern", i && this.checkPatternErrors(i, !0), this.toAssignableList(e.elements, t);
        break;
      case "SpreadElement":
        e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(e.expression, t, i);
        break;
      case "ChainExpression":
        this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!t)
          break;
      default:
        this.raise(e.start, "Assigning to rvalue");
    }
  else
    i && this.checkPatternErrors(i, !0);
  return e;
};
Es.toAssignableList = function(e, t) {
  for (var i = e.length, r = 0; r < i; r++) {
    var n = e[r];
    n && this.toAssignable(n, t);
  }
  if (i) {
    var s = e[i - 1];
    this.options.ecmaVersion === 6 && t && s && s.type === "RestElement" && s.argument.type !== "Identifier" && this.unexpected(s.argument.start);
  }
  return e;
};
Es.parseSpread = function(e) {
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeAssign(!1, e), this.finishNode(t, "SpreadElement");
};
Es.parseRestBinding = function() {
  var e = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== v.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
};
Es.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case v.bracketL:
        var e = this.startNode();
        return this.next(), e.elements = this.parseBindingList(v.bracketR, !0, !0), this.finishNode(e, "ArrayPattern");
      case v.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
Es.parseBindingList = function(e, t, i, r) {
  for (var n = [], s = !0; !this.eat(e); )
    if (s ? s = !1 : this.expect(v.comma), t && this.type === v.comma)
      n.push(null);
    else {
      if (i && this.afterTrailingComma(e))
        break;
      if (this.type === v.ellipsis) {
        var a = this.parseRestBinding();
        this.parseBindingListItem(a), n.push(a), this.type === v.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e);
        break;
      } else
        n.push(this.parseAssignableListItem(r));
    }
  return n;
};
Es.parseAssignableListItem = function(e) {
  var t = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(t), t;
};
Es.parseBindingListItem = function(e) {
  return e;
};
Es.parseMaybeDefault = function(e, t, i) {
  if (i = i || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(v.eq))
    return i;
  var r = this.startNodeAt(e, t);
  return r.left = i, r.right = this.parseMaybeAssign(), this.finishNode(r, "AssignmentPattern");
};
Es.checkLValSimple = function(e, t, i) {
  t === void 0 && (t = g0);
  var r = t !== g0;
  switch (e.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (r ? "Binding " : "Assigning to ") + e.name + " in strict mode"), r && (t === Go && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), i && (Np(i, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), i[e.name] = !0), t !== OO && this.declareName(e.name, t, e.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      r && this.raiseRecoverable(e.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return r && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, i);
    default:
      this.raise(e.start, (r ? "Binding" : "Assigning to") + " rvalue");
  }
};
Es.checkLValPattern = function(e, t, i) {
  switch (t === void 0 && (t = g0), e.type) {
    case "ObjectPattern":
      for (var r = 0, n = e.properties; r < n.length; r += 1) {
        var s = n[r];
        this.checkLValInnerPattern(s, t, i);
      }
      break;
    case "ArrayPattern":
      for (var a = 0, o = e.elements; a < o.length; a += 1) {
        var c = o[a];
        c && this.checkLValInnerPattern(c, t, i);
      }
      break;
    default:
      this.checkLValSimple(e, t, i);
  }
};
Es.checkLValInnerPattern = function(e, t, i) {
  switch (t === void 0 && (t = g0), e.type) {
    case "Property":
      this.checkLValInnerPattern(e.value, t, i);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(e.left, t, i);
      break;
    case "RestElement":
      this.checkLValPattern(e.argument, t, i);
      break;
    default:
      this.checkLValPattern(e, t, i);
  }
};
var Ls = function(t, i, r, n, s) {
  this.token = t, this.isExpr = !!i, this.preserveSpace = !!r, this.override = n, this.generator = !!s;
}, ur = {
  b_stat: new Ls("{", !1),
  b_expr: new Ls("{", !0),
  b_tmpl: new Ls("${", !1),
  p_stat: new Ls("(", !1),
  p_expr: new Ls("(", !0),
  q_tmpl: new Ls("`", !0, !0, function(e) {
    return e.tryReadTemplateToken();
  }),
  f_stat: new Ls("function", !1),
  f_expr: new Ls("function", !0),
  f_expr_gen: new Ls("function", !0, !1, null, !0),
  f_gen: new Ls("function", !1, !1, null, !0)
}, lh = tn.prototype;
lh.initialContext = function() {
  return [ur.b_stat];
};
lh.curContext = function() {
  return this.context[this.context.length - 1];
};
lh.braceIsBlock = function(e) {
  var t = this.curContext();
  return t === ur.f_expr || t === ur.f_stat ? !0 : e === v.colon && (t === ur.b_stat || t === ur.b_expr) ? !t.isExpr : e === v._return || e === v.name && this.exprAllowed ? Ts.test(this.input.slice(this.lastTokEnd, this.start)) : e === v._else || e === v.semi || e === v.eof || e === v.parenR || e === v.arrow ? !0 : e === v.braceL ? t === ur.b_stat : e === v._var || e === v._const || e === v.name ? !1 : !this.exprAllowed;
};
lh.inGeneratorContext = function() {
  for (var e = this.context.length - 1; e >= 1; e--) {
    var t = this.context[e];
    if (t.token === "function")
      return t.generator;
  }
  return !1;
};
lh.updateContext = function(e) {
  var t, i = this.type;
  i.keyword && e === v.dot ? this.exprAllowed = !1 : (t = i.updateContext) ? t.call(this, e) : this.exprAllowed = i.beforeExpr;
};
lh.overrideContext = function(e) {
  this.curContext() !== e && (this.context[this.context.length - 1] = e);
};
v.parenR.updateContext = v.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var e = this.context.pop();
  e === ur.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
};
v.braceL.updateContext = function(e) {
  this.context.push(this.braceIsBlock(e) ? ur.b_stat : ur.b_expr), this.exprAllowed = !0;
};
v.dollarBraceL.updateContext = function() {
  this.context.push(ur.b_tmpl), this.exprAllowed = !0;
};
v.parenL.updateContext = function(e) {
  var t = e === v._if || e === v._for || e === v._with || e === v._while;
  this.context.push(t ? ur.p_stat : ur.p_expr), this.exprAllowed = !0;
};
v.incDec.updateContext = function() {
};
v._function.updateContext = v._class.updateContext = function(e) {
  e.beforeExpr && e !== v._else && !(e === v.semi && this.curContext() !== ur.p_stat) && !(e === v._return && Ts.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === v.colon || e === v.braceL) && this.curContext() === ur.b_stat) ? this.context.push(ur.f_expr) : this.context.push(ur.f_stat), this.exprAllowed = !1;
};
v.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
v.backQuote.updateContext = function() {
  this.curContext() === ur.q_tmpl ? this.context.pop() : this.context.push(ur.q_tmpl), this.exprAllowed = !1;
};
v.star.updateContext = function(e) {
  if (e === v._function) {
    var t = this.context.length - 1;
    this.context[t] === ur.f_expr ? this.context[t] = ur.f_expr_gen : this.context[t] = ur.f_gen;
  }
  this.exprAllowed = !0;
};
v.name.updateContext = function(e) {
  var t = !1;
  this.options.ecmaVersion >= 6 && e !== v.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = !0), this.exprAllowed = t;
};
var Ve = tn.prototype;
Ve.checkPropClash = function(e, t, i) {
  if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
    var r = e.key, n;
    switch (r.type) {
      case "Identifier":
        n = r.name;
        break;
      case "Literal":
        n = String(r.value);
        break;
      default:
        return;
    }
    var s = e.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && s === "init" && (t.proto && (i ? i.doubleProto < 0 && (i.doubleProto = r.start) : this.raiseRecoverable(r.start, "Redefinition of __proto__ property")), t.proto = !0);
      return;
    }
    n = "$" + n;
    var a = t[n];
    if (a) {
      var o;
      s === "init" ? o = this.strict && a.init || a.get || a.set : o = a.init || a[s], o && this.raiseRecoverable(r.start, "Redefinition of property");
    } else
      a = t[n] = {
        init: !1,
        get: !1,
        set: !1
      };
    a[s] = !0;
  }
};
Ve.parseExpression = function(e, t) {
  var i = this.start, r = this.startLoc, n = this.parseMaybeAssign(e, t);
  if (this.type === v.comma) {
    var s = this.startNodeAt(i, r);
    for (s.expressions = [n]; this.eat(v.comma); )
      s.expressions.push(this.parseMaybeAssign(e, t));
    return this.finishNode(s, "SequenceExpression");
  }
  return n;
};
Ve.parseMaybeAssign = function(e, t, i) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(e);
    this.exprAllowed = !1;
  }
  var r = !1, n = -1, s = -1, a = -1;
  t ? (n = t.parenthesizedAssign, s = t.trailingComma, a = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new My(), r = !0);
  var o = this.start, c = this.startLoc;
  (this.type === v.parenL || this.type === v.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
  var l = this.parseMaybeConditional(e, t);
  if (i && (l = i.call(this, l, o, c)), this.type.isAssign) {
    var d = this.startNodeAt(o, c);
    return d.operator = this.value, this.type === v.eq && (l = this.toAssignable(l, !1, t)), r || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= l.start && (t.shorthandAssign = -1), this.type === v.eq ? this.checkLValPattern(l) : this.checkLValSimple(l), d.left = l, this.next(), d.right = this.parseMaybeAssign(e), a > -1 && (t.doubleProto = a), this.finishNode(d, "AssignmentExpression");
  } else
    r && this.checkExpressionErrors(t, !0);
  return n > -1 && (t.parenthesizedAssign = n), s > -1 && (t.trailingComma = s), l;
};
Ve.parseMaybeConditional = function(e, t) {
  var i = this.start, r = this.startLoc, n = this.parseExprOps(e, t);
  if (this.checkExpressionErrors(t))
    return n;
  if (this.eat(v.question)) {
    var s = this.startNodeAt(i, r);
    return s.test = n, s.consequent = this.parseMaybeAssign(), this.expect(v.colon), s.alternate = this.parseMaybeAssign(e), this.finishNode(s, "ConditionalExpression");
  }
  return n;
};
Ve.parseExprOps = function(e, t) {
  var i = this.start, r = this.startLoc, n = this.parseMaybeUnary(t, !1, !1, e);
  return this.checkExpressionErrors(t) || n.start === i && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, i, r, -1, e);
};
Ve.parseExprOp = function(e, t, i, r, n) {
  var s = this.type.binop;
  if (s != null && (!n || this.type !== v._in) && s > r) {
    var a = this.type === v.logicalOR || this.type === v.logicalAND, o = this.type === v.coalesce;
    o && (s = v.logicalAND.binop);
    var c = this.value;
    this.next();
    var l = this.start, d = this.startLoc, u = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, n), l, d, s, n), h = this.buildBinary(t, i, e, u, c, a || o);
    return (a && this.type === v.coalesce || o && (this.type === v.logicalOR || this.type === v.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(h, t, i, r, n);
  }
  return e;
};
Ve.buildBinary = function(e, t, i, r, n, s) {
  r.type === "PrivateIdentifier" && this.raise(r.start, "Private identifier can only be left side of binary expression");
  var a = this.startNodeAt(e, t);
  return a.left = i, a.operator = n, a.right = r, this.finishNode(a, s ? "LogicalExpression" : "BinaryExpression");
};
Ve.parseMaybeUnary = function(e, t, i, r) {
  var n = this.start, s = this.startLoc, a;
  if (this.isContextual("await") && this.canAwait)
    a = this.parseAwait(r), t = !0;
  else if (this.type.prefix) {
    var o = this.startNode(), c = this.type === v.incDec;
    o.operator = this.value, o.prefix = !0, this.next(), o.argument = this.parseMaybeUnary(null, !0, c, r), this.checkExpressionErrors(e, !0), c ? this.checkLValSimple(o.argument) : this.strict && o.operator === "delete" && o.argument.type === "Identifier" ? this.raiseRecoverable(o.start, "Deleting local variable in strict mode") : o.operator === "delete" && NO(o.argument) ? this.raiseRecoverable(o.start, "Private fields can not be deleted") : t = !0, a = this.finishNode(o, c ? "UpdateExpression" : "UnaryExpression");
  } else if (!t && this.type === v.privateId)
    (r || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), a = this.parsePrivateIdent(), this.type !== v._in && this.unexpected();
  else {
    if (a = this.parseExprSubscripts(e, r), this.checkExpressionErrors(e))
      return a;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var l = this.startNodeAt(n, s);
      l.operator = this.value, l.prefix = !1, l.argument = a, this.checkLValSimple(a), this.next(), a = this.finishNode(l, "UpdateExpression");
    }
  }
  if (!i && this.eat(v.starstar))
    if (t)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(n, s, a, this.parseMaybeUnary(null, !1, !1, r), "**", !1);
  else
    return a;
};
function NO(e) {
  return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && NO(e.expression);
}
Ve.parseExprSubscripts = function(e, t) {
  var i = this.start, r = this.startLoc, n = this.parseExprAtom(e, t);
  if (n.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return n;
  var s = this.parseSubscripts(n, i, r, !1, t);
  return e && s.type === "MemberExpression" && (e.parenthesizedAssign >= s.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= s.start && (e.parenthesizedBind = -1), e.trailingComma >= s.start && (e.trailingComma = -1)), s;
};
Ve.parseSubscripts = function(e, t, i, r, n) {
  for (var s = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, a = !1; ; ) {
    var o = this.parseSubscript(e, t, i, r, s, a, n);
    if (o.optional && (a = !0), o === e || o.type === "ArrowFunctionExpression") {
      if (a) {
        var c = this.startNodeAt(t, i);
        c.expression = o, o = this.finishNode(c, "ChainExpression");
      }
      return o;
    }
    e = o;
  }
};
Ve.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(v.arrow);
};
Ve.parseSubscriptAsyncArrow = function(e, t, i, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), i, !0, r);
};
Ve.parseSubscript = function(e, t, i, r, n, s, a) {
  var o = this.options.ecmaVersion >= 11, c = o && this.eat(v.questionDot);
  r && c && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var l = this.eat(v.bracketL);
  if (l || c && this.type !== v.parenL && this.type !== v.backQuote || this.eat(v.dot)) {
    var d = this.startNodeAt(t, i);
    d.object = e, l ? (d.property = this.parseExpression(), this.expect(v.bracketR)) : this.type === v.privateId && e.type !== "Super" ? d.property = this.parsePrivateIdent() : d.property = this.parseIdent(this.options.allowReserved !== "never"), d.computed = !!l, o && (d.optional = c), e = this.finishNode(d, "MemberExpression");
  } else if (!r && this.eat(v.parenL)) {
    var u = new My(), h = this.yieldPos, p = this.awaitPos, m = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var w = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1, u);
    if (n && !c && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(u, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = h, this.awaitPos = p, this.awaitIdentPos = m, this.parseSubscriptAsyncArrow(t, i, w, a);
    this.checkExpressionErrors(u, !0), this.yieldPos = h || this.yieldPos, this.awaitPos = p || this.awaitPos, this.awaitIdentPos = m || this.awaitIdentPos;
    var C = this.startNodeAt(t, i);
    C.callee = e, C.arguments = w, o && (C.optional = c), e = this.finishNode(C, "CallExpression");
  } else if (this.type === v.backQuote) {
    (c || s) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var F = this.startNodeAt(t, i);
    F.tag = e, F.quasi = this.parseTemplate({ isTagged: !0 }), e = this.finishNode(F, "TaggedTemplateExpression");
  }
  return e;
};
Ve.parseExprAtom = function(e, t, i) {
  this.type === v.slash && this.readRegexp();
  var r, n = this.potentialArrowAt === this.start;
  switch (this.type) {
    case v._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === v.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== v.dot && this.type !== v.bracketL && this.type !== v.parenL && this.unexpected(), this.finishNode(r, "Super");
    case v._this:
      return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
    case v.name:
      var s = this.start, a = this.startLoc, o = this.containsEsc, c = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !o && c.name === "async" && !this.canInsertSemicolon() && this.eat(v._function))
        return this.overrideContext(ur.f_expr), this.parseFunction(this.startNodeAt(s, a), 0, !1, !0, t);
      if (n && !this.canInsertSemicolon()) {
        if (this.eat(v.arrow))
          return this.parseArrowExpression(this.startNodeAt(s, a), [c], !1, t);
        if (this.options.ecmaVersion >= 8 && c.name === "async" && this.type === v.name && !o && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return c = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(v.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(s, a), [c], !0, t);
      }
      return c;
    case v.regexp:
      var l = this.value;
      return r = this.parseLiteral(l.value), r.regex = { pattern: l.pattern, flags: l.flags }, r;
    case v.num:
    case v.string:
      return this.parseLiteral(this.value);
    case v._null:
    case v._true:
    case v._false:
      return r = this.startNode(), r.value = this.type === v._null ? null : this.type === v._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
    case v.parenL:
      var d = this.start, u = this.parseParenAndDistinguishExpression(n, t);
      return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (e.parenthesizedAssign = d), e.parenthesizedBind < 0 && (e.parenthesizedBind = d)), u;
    case v.bracketL:
      return r = this.startNode(), this.next(), r.elements = this.parseExprList(v.bracketR, !0, !0, e), this.finishNode(r, "ArrayExpression");
    case v.braceL:
      return this.overrideContext(ur.b_expr), this.parseObj(!1, e);
    case v._function:
      return r = this.startNode(), this.next(), this.parseFunction(r, 0);
    case v._class:
      return this.parseClass(this.startNode(), !1);
    case v._new:
      return this.parseNew();
    case v.backQuote:
      return this.parseTemplate();
    case v._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(i) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
Ve.parseExprAtomDefault = function() {
  this.unexpected();
};
Ve.parseExprImport = function(e) {
  var t = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === v.parenL && !e)
    return this.parseDynamicImport(t);
  if (this.type === v.dot) {
    var i = this.startNodeAt(t.start, t.loc && t.loc.start);
    return i.name = "import", t.meta = this.finishNode(i, "Identifier"), this.parseImportMeta(t);
  } else
    this.unexpected();
};
Ve.parseDynamicImport = function(e) {
  if (this.next(), e.source = this.parseMaybeAssign(), !this.eat(v.parenR)) {
    var t = this.start;
    this.eat(v.comma) && this.eat(v.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
  }
  return this.finishNode(e, "ImportExpression");
};
Ve.parseImportMeta = function(e) {
  this.next();
  var t = this.containsEsc;
  return e.property = this.parseIdent(!0), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
};
Ve.parseLiteral = function(e) {
  var t = this.startNode();
  return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
};
Ve.parseParenExpression = function() {
  this.expect(v.parenL);
  var e = this.parseExpression();
  return this.expect(v.parenR), e;
};
Ve.shouldParseArrow = function(e) {
  return !this.canInsertSemicolon();
};
Ve.parseParenAndDistinguishExpression = function(e, t) {
  var i = this.start, r = this.startLoc, n, s = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var a = this.start, o = this.startLoc, c = [], l = !0, d = !1, u = new My(), h = this.yieldPos, p = this.awaitPos, m;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== v.parenR; )
      if (l ? l = !1 : this.expect(v.comma), s && this.afterTrailingComma(v.parenR, !0)) {
        d = !0;
        break;
      } else if (this.type === v.ellipsis) {
        m = this.start, c.push(this.parseParenItem(this.parseRestBinding())), this.type === v.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        c.push(this.parseMaybeAssign(!1, u, this.parseParenItem));
    var w = this.lastTokEnd, C = this.lastTokEndLoc;
    if (this.expect(v.parenR), e && this.shouldParseArrow(c) && this.eat(v.arrow))
      return this.checkPatternErrors(u, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = h, this.awaitPos = p, this.parseParenArrowList(i, r, c, t);
    (!c.length || d) && this.unexpected(this.lastTokStart), m && this.unexpected(m), this.checkExpressionErrors(u, !0), this.yieldPos = h || this.yieldPos, this.awaitPos = p || this.awaitPos, c.length > 1 ? (n = this.startNodeAt(a, o), n.expressions = c, this.finishNodeAt(n, "SequenceExpression", w, C)) : n = c[0];
  } else
    n = this.parseParenExpression();
  if (this.options.preserveParens) {
    var F = this.startNodeAt(i, r);
    return F.expression = n, this.finishNode(F, "ParenthesizedExpression");
  } else
    return n;
};
Ve.parseParenItem = function(e) {
  return e;
};
Ve.parseParenArrowList = function(e, t, i, r) {
  return this.parseArrowExpression(this.startNodeAt(e, t), i, !1, r);
};
var pW = [];
Ve.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var e = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === v.dot) {
    var t = this.startNodeAt(e.start, e.loc && e.loc.start);
    t.name = "new", e.meta = this.finishNode(t, "Identifier"), this.next();
    var i = this.containsEsc;
    return e.property = this.parseIdent(!0), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), i && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
  }
  var r = this.start, n = this.startLoc;
  return e.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), r, n, !0, !1), this.eat(v.parenL) ? e.arguments = this.parseExprList(v.parenR, this.options.ecmaVersion >= 8, !1) : e.arguments = pW, this.finishNode(e, "NewExpression");
};
Ve.parseTemplateElement = function(e) {
  var t = e.isTagged, i = this.startNode();
  return this.type === v.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), i.value = {
    raw: this.value,
    cooked: null
  }) : i.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), i.tail = this.type === v.backQuote, this.finishNode(i, "TemplateElement");
};
Ve.parseTemplate = function(e) {
  e === void 0 && (e = {});
  var t = e.isTagged;
  t === void 0 && (t = !1);
  var i = this.startNode();
  this.next(), i.expressions = [];
  var r = this.parseTemplateElement({ isTagged: t });
  for (i.quasis = [r]; !r.tail; )
    this.type === v.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(v.dollarBraceL), i.expressions.push(this.parseExpression()), this.expect(v.braceR), i.quasis.push(r = this.parseTemplateElement({ isTagged: t }));
  return this.next(), this.finishNode(i, "TemplateLiteral");
};
Ve.isAsyncProp = function(e) {
  return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === v.name || this.type === v.num || this.type === v.string || this.type === v.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === v.star) && !Ts.test(this.input.slice(this.lastTokEnd, this.start));
};
Ve.parseObj = function(e, t) {
  var i = this.startNode(), r = !0, n = {};
  for (i.properties = [], this.next(); !this.eat(v.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(v.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(v.braceR))
      break;
    var s = this.parseProperty(e, t);
    e || this.checkPropClash(s, n, t), i.properties.push(s);
  }
  return this.finishNode(i, e ? "ObjectPattern" : "ObjectExpression");
};
Ve.parseProperty = function(e, t) {
  var i = this.startNode(), r, n, s, a;
  if (this.options.ecmaVersion >= 9 && this.eat(v.ellipsis))
    return e ? (i.argument = this.parseIdent(!1), this.type === v.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(i, "RestElement")) : (i.argument = this.parseMaybeAssign(!1, t), this.type === v.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(i, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (i.method = !1, i.shorthand = !1, (e || t) && (s = this.start, a = this.startLoc), e || (r = this.eat(v.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(i), !e && !o && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(i) ? (n = !0, r = this.options.ecmaVersion >= 9 && this.eat(v.star), this.parsePropertyName(i)) : n = !1, this.parsePropertyValue(i, e, r, n, s, a, t, o), this.finishNode(i, "Property");
};
Ve.parseGetterSetter = function(e) {
  e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(!1);
  var t = e.kind === "get" ? 0 : 1;
  if (e.value.params.length !== t) {
    var i = e.value.start;
    e.kind === "get" ? this.raiseRecoverable(i, "getter should have no params") : this.raiseRecoverable(i, "setter should have exactly one param");
  } else
    e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
};
Ve.parsePropertyValue = function(e, t, i, r, n, s, a, o) {
  (i || r) && this.type === v.colon && this.unexpected(), this.eat(v.colon) ? (e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, a), e.kind = "init") : this.options.ecmaVersion >= 6 && this.type === v.parenL ? (t && this.unexpected(), e.kind = "init", e.method = !0, e.value = this.parseMethod(i, r)) : !t && !o && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== v.comma && this.type !== v.braceR && this.type !== v.eq ? ((i || r) && this.unexpected(), this.parseGetterSetter(e)) : this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((i || r) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), e.kind = "init", t ? e.value = this.parseMaybeDefault(n, s, this.copyNode(e.key)) : this.type === v.eq && a ? (a.shorthandAssign < 0 && (a.shorthandAssign = this.start), e.value = this.parseMaybeDefault(n, s, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = !0) : this.unexpected();
};
Ve.parsePropertyName = function(e) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(v.bracketL))
      return e.computed = !0, e.key = this.parseMaybeAssign(), this.expect(v.bracketR), e.key;
    e.computed = !1;
  }
  return e.key = this.type === v.num || this.type === v.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
Ve.initFunction = function(e) {
  e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = !1), this.options.ecmaVersion >= 8 && (e.async = !1);
};
Ve.parseMethod = function(e, t, i) {
  var r = this.startNode(), n = this.yieldPos, s = this.awaitPos, a = this.awaitIdentPos;
  return this.initFunction(r), this.options.ecmaVersion >= 6 && (r.generator = e), this.options.ecmaVersion >= 8 && (r.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Gx(t, r.generator) | Vx | (i ? EO : 0)), this.expect(v.parenL), r.params = this.parseBindingList(v.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(r, !1, !0, !1), this.yieldPos = n, this.awaitPos = s, this.awaitIdentPos = a, this.finishNode(r, "FunctionExpression");
};
Ve.parseArrowExpression = function(e, t, i, r) {
  var n = this.yieldPos, s = this.awaitPos, a = this.awaitIdentPos;
  return this.enterScope(Gx(i, !1) | AO), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!i), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, !0), this.parseFunctionBody(e, !0, !1, r), this.yieldPos = n, this.awaitPos = s, this.awaitIdentPos = a, this.finishNode(e, "ArrowFunctionExpression");
};
Ve.parseFunctionBody = function(e, t, i, r) {
  var n = t && this.type !== v.braceL, s = this.strict, a = !1;
  if (n)
    e.body = this.parseMaybeAssign(r), e.expression = !0, this.checkParams(e, !1);
  else {
    var o = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
    (!s || o) && (a = this.strictDirective(this.end), a && o && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var c = this.labels;
    this.labels = [], a && (this.strict = !0), this.checkParams(e, !s && !a && !t && !i && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, OO), e.body = this.parseBlock(!1, void 0, a && !s), e.expression = !1, this.adaptDirectivePrologue(e.body.body), this.labels = c;
  }
  this.exitScope();
};
Ve.isSimpleParamList = function(e) {
  for (var t = 0, i = e; t < i.length; t += 1) {
    var r = i[t];
    if (r.type !== "Identifier")
      return !1;
  }
  return !0;
};
Ve.checkParams = function(e, t) {
  for (var i = /* @__PURE__ */ Object.create(null), r = 0, n = e.params; r < n.length; r += 1) {
    var s = n[r];
    this.checkLValInnerPattern(s, Hx, t ? null : i);
  }
};
Ve.parseExprList = function(e, t, i, r) {
  for (var n = [], s = !0; !this.eat(e); ) {
    if (s)
      s = !1;
    else if (this.expect(v.comma), t && this.afterTrailingComma(e))
      break;
    var a = void 0;
    i && this.type === v.comma ? a = null : this.type === v.ellipsis ? (a = this.parseSpread(r), r && this.type === v.comma && r.trailingComma < 0 && (r.trailingComma = this.start)) : a = this.parseMaybeAssign(!1, r), n.push(a);
  }
  return n;
};
Ve.checkUnreserved = function(e) {
  var t = e.start, i = e.end, r = e.name;
  if (this.inGenerator && r === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && r === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (r === "arguments" || r === "await") && this.raise(t, "Cannot use " + r + " in class static initialization block"), this.keywords.test(r) && this.raise(t, "Unexpected keyword '" + r + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, i).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(r) && (!this.inAsync && r === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + r + "' is reserved"));
  }
};
Ve.parseIdent = function(e) {
  var t = this.parseIdentNode();
  return this.next(!!e), this.finishNode(t, "Identifier"), e || (this.checkUnreserved(t), t.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = t.start)), t;
};
Ve.parseIdentNode = function() {
  var e = this.startNode();
  return this.type === v.name ? e.name = this.value : this.type.keyword ? (e.name = this.type.keyword, (e.name === "class" || e.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = v.name) : this.unexpected(), e;
};
Ve.parsePrivateIdent = function() {
  var e = this.startNode();
  return this.type === v.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e)), e;
};
Ve.parseYield = function(e) {
  this.yieldPos || (this.yieldPos = this.start);
  var t = this.startNode();
  return this.next(), this.type === v.semi || this.canInsertSemicolon() || this.type !== v.star && !this.type.startsExpr ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(v.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
};
Ve.parseAwait = function(e) {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0, !1, e), this.finishNode(t, "AwaitExpression");
};
var v0 = tn.prototype;
v0.raise = function(e, t) {
  var i = SO(this.input, e);
  t += " (" + i.line + ":" + i.column + ")";
  var r = new SyntaxError(t);
  throw r.pos = e, r.loc = i, r.raisedAt = this.pos, r;
};
v0.raiseRecoverable = v0.raise;
v0.curPosition = function() {
  if (this.options.locations)
    return new Hf(this.curLine, this.pos - this.lineStart);
};
var Gc = tn.prototype, mW = function(t) {
  this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
Gc.enterScope = function(e) {
  this.scopeStack.push(new mW(e));
};
Gc.exitScope = function() {
  this.scopeStack.pop();
};
Gc.treatFunctionsAsVarInScope = function(e) {
  return e.flags & ch || !this.inModule && e.flags & Wf;
};
Gc.declareName = function(e, t, i) {
  var r = !1;
  if (t === Go) {
    var n = this.currentScope();
    r = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1, n.lexical.push(e), this.inModule && n.flags & Wf && delete this.undefinedExports[e];
  } else if (t === CO) {
    var s = this.currentScope();
    s.lexical.push(e);
  } else if (t === kO) {
    var a = this.currentScope();
    this.treatFunctionsAsVar ? r = a.lexical.indexOf(e) > -1 : r = a.lexical.indexOf(e) > -1 || a.var.indexOf(e) > -1, a.functions.push(e);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var c = this.scopeStack[o];
      if (c.lexical.indexOf(e) > -1 && !(c.flags & TO && c.lexical[0] === e) || !this.treatFunctionsAsVarInScope(c) && c.functions.indexOf(e) > -1) {
        r = !0;
        break;
      }
      if (c.var.push(e), this.inModule && c.flags & Wf && delete this.undefinedExports[e], c.flags & jx)
        break;
    }
  r && this.raiseRecoverable(i, "Identifier '" + e + "' has already been declared");
};
Gc.checkLocalExport = function(e) {
  this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
};
Gc.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Gc.currentVarScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & jx)
      return t;
  }
};
Gc.currentThisScope = function() {
  for (var e = this.scopeStack.length - 1; ; e--) {
    var t = this.scopeStack[e];
    if (t.flags & jx && !(t.flags & AO))
      return t;
  }
};
var Py = function(t, i, r) {
  this.type = "", this.start = i, this.end = 0, t.options.locations && (this.loc = new Ry(t, r)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [i, 0]);
}, Fp = tn.prototype;
Fp.startNode = function() {
  return new Py(this, this.start, this.startLoc);
};
Fp.startNodeAt = function(e, t) {
  return new Py(this, e, t);
};
function LO(e, t, i, r) {
  return e.type = t, e.end = i, this.options.locations && (e.loc.end = r), this.options.ranges && (e.range[1] = i), e;
}
Fp.finishNode = function(e, t) {
  return LO.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
};
Fp.finishNodeAt = function(e, t, i, r) {
  return LO.call(this, e, t, i, r);
};
Fp.copyNode = function(e) {
  var t = new Py(this, e.start, this.startLoc);
  for (var i in e)
    t[i] = e[i];
  return t;
};
var FO = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", BO = FO + " Extended_Pictographic", RO = BO, MO = RO + " EBase EComp EMod EPres ExtPict", PO = MO, gW = PO, yW = {
  9: FO,
  10: BO,
  11: RO,
  12: MO,
  13: PO,
  14: gW
}, vW = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", _W = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: vW
}, WA = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", $O = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", zO = $O + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", UO = zO + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", VO = UO + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", jO = VO + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", bW = jO + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", xW = {
  9: $O,
  10: zO,
  11: UO,
  12: VO,
  13: jO,
  14: bW
}, GO = {};
function wW(e) {
  var t = GO[e] = {
    binary: _c(yW[e] + " " + WA),
    binaryOfStrings: _c(_W[e]),
    nonBinary: {
      General_Category: _c(WA),
      Script: _c(xW[e])
    }
  };
  t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
}
for (var k_ = 0, YA = [9, 10, 11, 12, 13, 14]; k_ < YA.length; k_ += 1) {
  var SW = YA[k_];
  wW(SW);
}
var re = tn.prototype, Wa = function(t) {
  this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : "") + (t.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = GO[t.options.ecmaVersion >= 14 ? 14 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
Wa.prototype.reset = function(t, i, r) {
  var n = r.indexOf("v") !== -1, s = r.indexOf("u") !== -1;
  this.start = t | 0, this.source = i + "", this.flags = r, n && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = s && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = s && this.parser.options.ecmaVersion >= 9);
};
Wa.prototype.raise = function(t) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
};
Wa.prototype.at = function(t, i) {
  i === void 0 && (i = !1);
  var r = this.source, n = r.length;
  if (t >= n)
    return -1;
  var s = r.charCodeAt(t);
  if (!(i || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= n)
    return s;
  var a = r.charCodeAt(t + 1);
  return a >= 56320 && a <= 57343 ? (s << 10) + a - 56613888 : s;
};
Wa.prototype.nextIndex = function(t, i) {
  i === void 0 && (i = !1);
  var r = this.source, n = r.length;
  if (t >= n)
    return n;
  var s = r.charCodeAt(t), a;
  return !(i || this.switchU) || s <= 55295 || s >= 57344 || t + 1 >= n || (a = r.charCodeAt(t + 1)) < 56320 || a > 57343 ? t + 1 : t + 2;
};
Wa.prototype.current = function(t) {
  return t === void 0 && (t = !1), this.at(this.pos, t);
};
Wa.prototype.lookahead = function(t) {
  return t === void 0 && (t = !1), this.at(this.nextIndex(this.pos, t), t);
};
Wa.prototype.advance = function(t) {
  t === void 0 && (t = !1), this.pos = this.nextIndex(this.pos, t);
};
Wa.prototype.eat = function(t, i) {
  return i === void 0 && (i = !1), this.current(i) === t ? (this.advance(i), !0) : !1;
};
Wa.prototype.eatChars = function(t, i) {
  i === void 0 && (i = !1);
  for (var r = this.pos, n = 0, s = t; n < s.length; n += 1) {
    var a = s[n], o = this.at(r, i);
    if (o === -1 || o !== a)
      return !1;
    r = this.nextIndex(r, i);
  }
  return this.pos = r, !0;
};
re.validateRegExpFlags = function(e) {
  for (var t = e.validFlags, i = e.flags, r = !1, n = !1, s = 0; s < i.length; s++) {
    var a = i.charAt(s);
    t.indexOf(a) === -1 && this.raise(e.start, "Invalid regular expression flag"), i.indexOf(a, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag"), a === "u" && (r = !0), a === "v" && (n = !0);
  }
  this.options.ecmaVersion >= 15 && r && n && this.raise(e.start, "Invalid regular expression flag");
};
re.validateRegExpPattern = function(e) {
  this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = !0, this.regexp_pattern(e));
};
re.regexp_pattern = function(e) {
  e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = !1, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(
    41
    /* ) */
  ) && e.raise("Unmatched ')'"), (e.eat(
    93
    /* ] */
  ) || e.eat(
    125
    /* } */
  )) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
  for (var t = 0, i = e.backReferenceNames; t < i.length; t += 1) {
    var r = i[t];
    e.groupNames.indexOf(r) === -1 && e.raise("Invalid named capture referenced");
  }
};
re.regexp_disjunction = function(e) {
  for (this.regexp_alternative(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_alternative(e);
  this.regexp_eatQuantifier(e, !0) && e.raise("Nothing to repeat"), e.eat(
    123
    /* { */
  ) && e.raise("Lone quantifier brackets");
};
re.regexp_alternative = function(e) {
  for (; e.pos < e.source.length && this.regexp_eatTerm(e); )
    ;
};
re.regexp_eatTerm = function(e) {
  return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), !0) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), !0) : !1;
};
re.regexp_eatAssertion = function(e) {
  var t = e.pos;
  if (e.lastAssertionIsQuantifiable = !1, e.eat(
    94
    /* ^ */
  ) || e.eat(
    36
    /* $ */
  ))
    return !0;
  if (e.eat(
    92
    /* \ */
  )) {
    if (e.eat(
      66
      /* B */
    ) || e.eat(
      98
      /* b */
    ))
      return !0;
    e.pos = t;
  }
  if (e.eat(
    40
    /* ( */
  ) && e.eat(
    63
    /* ? */
  )) {
    var i = !1;
    if (this.options.ecmaVersion >= 9 && (i = e.eat(
      60
      /* < */
    )), e.eat(
      61
      /* = */
    ) || e.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !i, !0;
  }
  return e.pos = t, !1;
};
re.regexp_eatQuantifier = function(e, t) {
  return t === void 0 && (t = !1), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(
    63
    /* ? */
  ), !0) : !1;
};
re.regexp_eatQuantifierPrefix = function(e, t) {
  return e.eat(
    42
    /* * */
  ) || e.eat(
    43
    /* + */
  ) || e.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(e, t);
};
re.regexp_eatBracedQuantifier = function(e, t) {
  var i = e.pos;
  if (e.eat(
    123
    /* { */
  )) {
    var r = 0, n = -1;
    if (this.regexp_eatDecimalDigits(e) && (r = e.lastIntValue, e.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(
      125
      /* } */
    )))
      return n !== -1 && n < r && !t && e.raise("numbers out of order in {} quantifier"), !0;
    e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = i;
  }
  return !1;
};
re.regexp_eatAtom = function(e) {
  return this.regexp_eatPatternCharacters(e) || e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
};
re.regexp_eatReverseSolidusAtomEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
re.regexp_eatUncapturingGroup = function(e) {
  var t = e.pos;
  if (e.eat(
    40
    /* ( */
  )) {
    if (e.eat(
      63
      /* ? */
    ) && e.eat(
      58
      /* : */
    )) {
      if (this.regexp_disjunction(e), e.eat(
        41
        /* ) */
      ))
        return !0;
      e.raise("Unterminated group");
    }
    e.pos = t;
  }
  return !1;
};
re.regexp_eatCapturingGroup = function(e) {
  if (e.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(
      41
      /* ) */
    ))
      return e.numCapturingParens += 1, !0;
    e.raise("Unterminated group");
  }
  return !1;
};
re.regexp_eatExtendedAtom = function(e) {
  return e.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
};
re.regexp_eatInvalidBracedQuantifier = function(e) {
  return this.regexp_eatBracedQuantifier(e, !0) && e.raise("Nothing to repeat"), !1;
};
re.regexp_eatSyntaxCharacter = function(e) {
  var t = e.current();
  return HO(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function HO(e) {
  return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
}
re.regexp_eatPatternCharacters = function(e) {
  for (var t = e.pos, i = 0; (i = e.current()) !== -1 && !HO(i); )
    e.advance();
  return e.pos !== t;
};
re.regexp_eatExtendedPatternCharacter = function(e) {
  var t = e.current();
  return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), !0) : !1;
};
re.regexp_groupSpecifier = function(e) {
  if (e.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(e)) {
      e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue);
      return;
    }
    e.raise("Invalid group");
  }
};
re.regexp_eatGroupName = function(e) {
  if (e.lastStringValue = "", e.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(e) && e.eat(
      62
      /* > */
    ))
      return !0;
    e.raise("Invalid capture group name");
  }
  return !1;
};
re.regexp_eatRegExpIdentifierName = function(e) {
  if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
    for (e.lastStringValue += Dc(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); )
      e.lastStringValue += Dc(e.lastIntValue);
    return !0;
  }
  return !1;
};
re.regexp_eatRegExpIdentifierStart = function(e) {
  var t = e.pos, i = this.options.ecmaVersion >= 11, r = e.current(i);
  return e.advance(i), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, i) && (r = e.lastIntValue), IW(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function IW(e) {
  return Oo(e, !0) || e === 36 || e === 95;
}
re.regexp_eatRegExpIdentifierPart = function(e) {
  var t = e.pos, i = this.options.ecmaVersion >= 11, r = e.current(i);
  return e.advance(i), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, i) && (r = e.lastIntValue), AW(r) ? (e.lastIntValue = r, !0) : (e.pos = t, !1);
};
function AW(e) {
  return ju(e, !0) || e === 36 || e === 95 || e === 8204 || e === 8205;
}
re.regexp_eatAtomEscape = function(e) {
  return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? !0 : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), !1);
};
re.regexp_eatBackReference = function(e) {
  var t = e.pos;
  if (this.regexp_eatDecimalEscape(e)) {
    var i = e.lastIntValue;
    if (e.switchU)
      return i > e.maxBackReference && (e.maxBackReference = i), !0;
    if (i <= e.numCapturingParens)
      return !0;
    e.pos = t;
  }
  return !1;
};
re.regexp_eatKGroupName = function(e) {
  if (e.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(e))
      return e.backReferenceNames.push(e.lastStringValue), !0;
    e.raise("Invalid named reference");
  }
  return !1;
};
re.regexp_eatCharacterEscape = function(e) {
  return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, !1) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
};
re.regexp_eatCControlLetter = function(e) {
  var t = e.pos;
  if (e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(e))
      return !0;
    e.pos = t;
  }
  return !1;
};
re.regexp_eatZero = function(e) {
  return e.current() === 48 && !$y(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), !0) : !1;
};
re.regexp_eatControlEscape = function(e) {
  var t = e.current();
  return t === 116 ? (e.lastIntValue = 9, e.advance(), !0) : t === 110 ? (e.lastIntValue = 10, e.advance(), !0) : t === 118 ? (e.lastIntValue = 11, e.advance(), !0) : t === 102 ? (e.lastIntValue = 12, e.advance(), !0) : t === 114 ? (e.lastIntValue = 13, e.advance(), !0) : !1;
};
re.regexp_eatControlLetter = function(e) {
  var t = e.current();
  return WO(t) ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
function WO(e) {
  return e >= 65 && e <= 90 || e >= 97 && e <= 122;
}
re.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
  t === void 0 && (t = !1);
  var i = e.pos, r = t || e.switchU;
  if (e.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 4)) {
      var n = e.lastIntValue;
      if (r && n >= 55296 && n <= 56319) {
        var s = e.pos;
        if (e.eat(
          92
          /* \ */
        ) && e.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(e, 4)) {
          var a = e.lastIntValue;
          if (a >= 56320 && a <= 57343)
            return e.lastIntValue = (n - 55296) * 1024 + (a - 56320) + 65536, !0;
        }
        e.pos = s, e.lastIntValue = n;
      }
      return !0;
    }
    if (r && e.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(e) && e.eat(
      125
      /* } */
    ) && TW(e.lastIntValue))
      return !0;
    r && e.raise("Invalid unicode escape"), e.pos = i;
  }
  return !1;
};
function TW(e) {
  return e >= 0 && e <= 1114111;
}
re.regexp_eatIdentityEscape = function(e) {
  if (e.switchU)
    return this.regexp_eatSyntaxCharacter(e) ? !0 : e.eat(
      47
      /* / */
    ) ? (e.lastIntValue = 47, !0) : !1;
  var t = e.current();
  return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
re.regexp_eatDecimalEscape = function(e) {
  e.lastIntValue = 0;
  var t = e.current();
  if (t >= 49 && t <= 57) {
    do
      e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
    while ((t = e.current()) >= 48 && t <= 57);
    return !0;
  }
  return !1;
};
var YO = 0, Do = 1, bs = 2;
re.regexp_eatCharacterClassEscape = function(e) {
  var t = e.current();
  if (EW(t))
    return e.lastIntValue = -1, e.advance(), Do;
  var i = !1;
  if (e.switchU && this.options.ecmaVersion >= 9 && ((i = t === 80) || t === 112)) {
    e.lastIntValue = -1, e.advance();
    var r;
    if (e.eat(
      123
      /* { */
    ) && (r = this.regexp_eatUnicodePropertyValueExpression(e)) && e.eat(
      125
      /* } */
    ))
      return i && r === bs && e.raise("Invalid property name"), r;
    e.raise("Invalid property name");
  }
  return YO;
};
function EW(e) {
  return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
}
re.regexp_eatUnicodePropertyValueExpression = function(e) {
  var t = e.pos;
  if (this.regexp_eatUnicodePropertyName(e) && e.eat(
    61
    /* = */
  )) {
    var i = e.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(e)) {
      var r = e.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(e, i, r), Do;
    }
  }
  if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
    var n = e.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(e, n);
  }
  return YO;
};
re.regexp_validateUnicodePropertyNameAndValue = function(e, t, i) {
  Np(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(i) || e.raise("Invalid property value");
};
re.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
  if (e.unicodeProperties.binary.test(t))
    return Do;
  if (e.switchV && e.unicodeProperties.binaryOfStrings.test(t))
    return bs;
  e.raise("Invalid property name");
};
re.regexp_eatUnicodePropertyName = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; qO(t = e.current()); )
    e.lastStringValue += Dc(t), e.advance();
  return e.lastStringValue !== "";
};
function qO(e) {
  return WO(e) || e === 95;
}
re.regexp_eatUnicodePropertyValue = function(e) {
  var t = 0;
  for (e.lastStringValue = ""; kW(t = e.current()); )
    e.lastStringValue += Dc(t), e.advance();
  return e.lastStringValue !== "";
};
function kW(e) {
  return qO(e) || $y(e);
}
re.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
  return this.regexp_eatUnicodePropertyValue(e);
};
re.regexp_eatCharacterClass = function(e) {
  if (e.eat(
    91
    /* [ */
  )) {
    var t = e.eat(
      94
      /* ^ */
    ), i = this.regexp_classContents(e);
    return e.eat(
      93
      /* ] */
    ) || e.raise("Unterminated character class"), t && i === bs && e.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
re.regexp_classContents = function(e) {
  return e.current() === 93 ? Do : e.switchV ? this.regexp_classSetExpression(e) : (this.regexp_nonEmptyClassRanges(e), Do);
};
re.regexp_nonEmptyClassRanges = function(e) {
  for (; this.regexp_eatClassAtom(e); ) {
    var t = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(e)) {
      var i = e.lastIntValue;
      e.switchU && (t === -1 || i === -1) && e.raise("Invalid character class"), t !== -1 && i !== -1 && t > i && e.raise("Range out of order in character class");
    }
  }
};
re.regexp_eatClassAtom = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(e))
      return !0;
    if (e.switchU) {
      var i = e.current();
      (i === 99 || KO(i)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
    }
    e.pos = t;
  }
  var r = e.current();
  return r !== 93 ? (e.lastIntValue = r, e.advance(), !0) : !1;
};
re.regexp_eatClassEscape = function(e) {
  var t = e.pos;
  if (e.eat(
    98
    /* b */
  ))
    return e.lastIntValue = 8, !0;
  if (e.switchU && e.eat(
    45
    /* - */
  ))
    return e.lastIntValue = 45, !0;
  if (!e.switchU && e.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(e))
      return !0;
    e.pos = t;
  }
  return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
};
re.regexp_classSetExpression = function(e) {
  var t = Do, i;
  if (!this.regexp_eatClassSetRange(e))
    if (i = this.regexp_eatClassSetOperand(e)) {
      i === bs && (t = bs);
      for (var r = e.pos; e.eatChars(
        [38, 38]
        /* && */
      ); ) {
        if (e.current() !== 38 && (i = this.regexp_eatClassSetOperand(e))) {
          i !== bs && (t = Do);
          continue;
        }
        e.raise("Invalid character in character class");
      }
      if (r !== e.pos)
        return t;
      for (; e.eatChars(
        [45, 45]
        /* -- */
      ); )
        this.regexp_eatClassSetOperand(e) || e.raise("Invalid character in character class");
      if (r !== e.pos)
        return t;
    } else
      e.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(e)) {
      if (i = this.regexp_eatClassSetOperand(e), !i)
        return t;
      i === bs && (t = bs);
    }
};
re.regexp_eatClassSetRange = function(e) {
  var t = e.pos;
  if (this.regexp_eatClassSetCharacter(e)) {
    var i = e.lastIntValue;
    if (e.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(e)) {
      var r = e.lastIntValue;
      return i !== -1 && r !== -1 && i > r && e.raise("Range out of order in character class"), !0;
    }
    e.pos = t;
  }
  return !1;
};
re.regexp_eatClassSetOperand = function(e) {
  return this.regexp_eatClassSetCharacter(e) ? Do : this.regexp_eatClassStringDisjunction(e) || this.regexp_eatNestedClass(e);
};
re.regexp_eatNestedClass = function(e) {
  var t = e.pos;
  if (e.eat(
    91
    /* [ */
  )) {
    var i = e.eat(
      94
      /* ^ */
    ), r = this.regexp_classContents(e);
    if (e.eat(
      93
      /* ] */
    ))
      return i && r === bs && e.raise("Negated character class may contain strings"), r;
    e.pos = t;
  }
  if (e.eat(
    92
    /* \ */
  )) {
    var n = this.regexp_eatCharacterClassEscape(e);
    if (n)
      return n;
    e.pos = t;
  }
  return null;
};
re.regexp_eatClassStringDisjunction = function(e) {
  var t = e.pos;
  if (e.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (e.eat(
      123
      /* { */
    )) {
      var i = this.regexp_classStringDisjunctionContents(e);
      if (e.eat(
        125
        /* } */
      ))
        return i;
    } else
      e.raise("Invalid escape");
    e.pos = t;
  }
  return null;
};
re.regexp_classStringDisjunctionContents = function(e) {
  for (var t = this.regexp_classString(e); e.eat(
    124
    /* | */
  ); )
    this.regexp_classString(e) === bs && (t = bs);
  return t;
};
re.regexp_classString = function(e) {
  for (var t = 0; this.regexp_eatClassSetCharacter(e); )
    t++;
  return t === 1 ? Do : bs;
};
re.regexp_eatClassSetCharacter = function(e) {
  var t = e.pos;
  if (e.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(e) || this.regexp_eatClassSetReservedPunctuator(e) ? !0 : e.eat(
      98
      /* b */
    ) ? (e.lastIntValue = 8, !0) : (e.pos = t, !1);
  var i = e.current();
  return i < 0 || i === e.lookahead() && CW(i) || OW(i) ? !1 : (e.advance(), e.lastIntValue = i, !0);
};
function CW(e) {
  return e === 33 || e >= 35 && e <= 38 || e >= 42 && e <= 44 || e === 46 || e >= 58 && e <= 64 || e === 94 || e === 96 || e === 126;
}
function OW(e) {
  return e === 40 || e === 41 || e === 45 || e === 47 || e >= 91 && e <= 93 || e >= 123 && e <= 125;
}
re.regexp_eatClassSetReservedPunctuator = function(e) {
  var t = e.current();
  return DW(t) ? (e.lastIntValue = t, e.advance(), !0) : !1;
};
function DW(e) {
  return e === 33 || e === 35 || e === 37 || e === 38 || e === 44 || e === 45 || e >= 58 && e <= 62 || e === 64 || e === 96 || e === 126;
}
re.regexp_eatClassControlLetter = function(e) {
  var t = e.current();
  return $y(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), !0) : !1;
};
re.regexp_eatHexEscapeSequence = function(e) {
  var t = e.pos;
  if (e.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(e, 2))
      return !0;
    e.switchU && e.raise("Invalid escape"), e.pos = t;
  }
  return !1;
};
re.regexp_eatDecimalDigits = function(e) {
  var t = e.pos, i = 0;
  for (e.lastIntValue = 0; $y(i = e.current()); )
    e.lastIntValue = 10 * e.lastIntValue + (i - 48), e.advance();
  return e.pos !== t;
};
function $y(e) {
  return e >= 48 && e <= 57;
}
re.regexp_eatHexDigits = function(e) {
  var t = e.pos, i = 0;
  for (e.lastIntValue = 0; ZO(i = e.current()); )
    e.lastIntValue = 16 * e.lastIntValue + XO(i), e.advance();
  return e.pos !== t;
};
function ZO(e) {
  return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
}
function XO(e) {
  return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
}
re.regexp_eatLegacyOctalEscapeSequence = function(e) {
  if (this.regexp_eatOctalDigit(e)) {
    var t = e.lastIntValue;
    if (this.regexp_eatOctalDigit(e)) {
      var i = e.lastIntValue;
      t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + i * 8 + e.lastIntValue : e.lastIntValue = t * 8 + i;
    } else
      e.lastIntValue = t;
    return !0;
  }
  return !1;
};
re.regexp_eatOctalDigit = function(e) {
  var t = e.current();
  return KO(t) ? (e.lastIntValue = t - 48, e.advance(), !0) : (e.lastIntValue = 0, !1);
};
function KO(e) {
  return e >= 48 && e <= 55;
}
re.regexp_eatFixedHexDigits = function(e, t) {
  var i = e.pos;
  e.lastIntValue = 0;
  for (var r = 0; r < t; ++r) {
    var n = e.current();
    if (!ZO(n))
      return e.pos = i, !1;
    e.lastIntValue = 16 * e.lastIntValue + XO(n), e.advance();
  }
  return !0;
};
var Yx = function(t) {
  this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new Ry(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
}, mi = tn.prototype;
mi.next = function(e) {
  !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Yx(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
mi.getToken = function() {
  return this.next(), new Yx(this);
};
typeof Symbol < "u" && (mi[Symbol.iterator] = function() {
  var e = this;
  return {
    next: function() {
      var t = e.getToken();
      return {
        done: t.type === v.eof,
        value: t
      };
    }
  };
});
mi.nextToken = function() {
  var e = this.curContext();
  if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(v.eof);
  if (e.override)
    return e.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
mi.readToken = function(e) {
  return Oo(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
};
mi.fullCharCodeAtPos = function() {
  var e = this.input.charCodeAt(this.pos);
  if (e <= 55295 || e >= 56320)
    return e;
  var t = this.input.charCodeAt(this.pos + 1);
  return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
};
mi.skipBlockComment = function() {
  var e = this.options.onComment && this.curPosition(), t = this.pos, i = this.input.indexOf("*/", this.pos += 2);
  if (i === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i + 2, this.options.locations)
    for (var r = void 0, n = t; (r = bO(this.input, n, this.pos)) > -1; )
      ++this.curLine, n = this.lineStart = r;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(t + 2, i),
    t,
    this.pos,
    e,
    this.curPosition()
  );
};
mi.skipLineComment = function(e) {
  for (var t = this.pos, i = this.options.onComment && this.curPosition(), r = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !oh(r); )
    r = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(t + e, this.pos),
    t,
    this.pos,
    i,
    this.curPosition()
  );
};
mi.skipSpace = function() {
  t:
    for (; this.pos < this.input.length; ) {
      var e = this.input.charCodeAt(this.pos);
      switch (e) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break t;
          }
          break;
        default:
          if (e > 8 && e < 14 || e >= 5760 && xO.test(String.fromCharCode(e)))
            ++this.pos;
          else
            break t;
      }
    }
};
mi.finishToken = function(e, t) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var i = this.type;
  this.type = e, this.value = t, this.updateContext(i);
};
mi.readToken_dot = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e >= 48 && e <= 57)
    return this.readNumber(!0);
  var t = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(v.ellipsis)) : (++this.pos, this.finishToken(v.dot));
};
mi.readToken_slash = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.slash, 1);
};
mi.readToken_mult_modulo_exp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), i = 1, r = e === 42 ? v.star : v.modulo;
  return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++i, r = v.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(v.assign, i + 1) : this.finishOp(r, i);
};
mi.readToken_pipe_amp = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t === e) {
    if (this.options.ecmaVersion >= 12) {
      var i = this.input.charCodeAt(this.pos + 2);
      if (i === 61)
        return this.finishOp(v.assign, 3);
    }
    return this.finishOp(e === 124 ? v.logicalOR : v.logicalAND, 2);
  }
  return t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(e === 124 ? v.bitwiseOR : v.bitwiseAND, 1);
};
mi.readToken_caret = function() {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.bitwiseXOR, 1);
};
mi.readToken_plus_min = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Ts.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(v.incDec, 2) : t === 61 ? this.finishOp(v.assign, 2) : this.finishOp(v.plusMin, 1);
};
mi.readToken_lt_gt = function(e) {
  var t = this.input.charCodeAt(this.pos + 1), i = 1;
  return t === e ? (i = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + i) === 61 ? this.finishOp(v.assign, i + 1) : this.finishOp(v.bitShift, i)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (i = 2), this.finishOp(v.relational, i));
};
mi.readToken_eq_excl = function(e) {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(v.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(v.arrow)) : this.finishOp(e === 61 ? v.eq : v.prefix, 1);
};
mi.readToken_question = function() {
  var e = this.options.ecmaVersion;
  if (e >= 11) {
    var t = this.input.charCodeAt(this.pos + 1);
    if (t === 46) {
      var i = this.input.charCodeAt(this.pos + 2);
      if (i < 48 || i > 57)
        return this.finishOp(v.questionDot, 2);
    }
    if (t === 63) {
      if (e >= 12) {
        var r = this.input.charCodeAt(this.pos + 2);
        if (r === 61)
          return this.finishOp(v.assign, 3);
      }
      return this.finishOp(v.coalesce, 2);
    }
  }
  return this.finishOp(v.question, 1);
};
mi.readToken_numberSign = function() {
  var e = this.options.ecmaVersion, t = 35;
  if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), Oo(t, !0) || t === 92))
    return this.finishToken(v.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + Dc(t) + "'");
};
mi.getTokenFromCode = function(e) {
  switch (e) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(v.parenL);
    case 41:
      return ++this.pos, this.finishToken(v.parenR);
    case 59:
      return ++this.pos, this.finishToken(v.semi);
    case 44:
      return ++this.pos, this.finishToken(v.comma);
    case 91:
      return ++this.pos, this.finishToken(v.bracketL);
    case 93:
      return ++this.pos, this.finishToken(v.bracketR);
    case 123:
      return ++this.pos, this.finishToken(v.braceL);
    case 125:
      return ++this.pos, this.finishToken(v.braceR);
    case 58:
      return ++this.pos, this.finishToken(v.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(v.backQuote);
    case 48:
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === 120 || t === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (t === 111 || t === 79)
          return this.readRadixNumber(8);
        if (t === 98 || t === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(e);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(e);
    case 124:
    case 38:
      return this.readToken_pipe_amp(e);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(e);
    case 60:
    case 62:
      return this.readToken_lt_gt(e);
    case 61:
    case 33:
      return this.readToken_eq_excl(e);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(v.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + Dc(e) + "'");
};
mi.finishOp = function(e, t) {
  var i = this.input.slice(this.pos, this.pos + t);
  return this.pos += t, this.finishToken(e, i);
};
mi.readRegexp = function() {
  for (var e, t, i = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(i, "Unterminated regular expression");
    var r = this.input.charAt(this.pos);
    if (Ts.test(r) && this.raise(i, "Unterminated regular expression"), e)
      e = !1;
    else {
      if (r === "[")
        t = !0;
      else if (r === "]" && t)
        t = !1;
      else if (r === "/" && !t)
        break;
      e = r === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(i, this.pos);
  ++this.pos;
  var s = this.pos, a = this.readWord1();
  this.containsEsc && this.unexpected(s);
  var o = this.regexpState || (this.regexpState = new Wa(this));
  o.reset(i, n, a), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var c = null;
  try {
    c = new RegExp(n, a);
  } catch {
  }
  return this.finishToken(v.regexp, { pattern: n, flags: a, value: c });
};
mi.readInt = function(e, t, i) {
  for (var r = this.options.ecmaVersion >= 12 && t === void 0, n = i && this.input.charCodeAt(this.pos) === 48, s = this.pos, a = 0, o = 0, c = 0, l = t ?? 1 / 0; c < l; ++c, ++this.pos) {
    var d = this.input.charCodeAt(this.pos), u = void 0;
    if (r && d === 95) {
      n && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), c === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = d;
      continue;
    }
    if (d >= 97 ? u = d - 97 + 10 : d >= 65 ? u = d - 65 + 10 : d >= 48 && d <= 57 ? u = d - 48 : u = 1 / 0, u >= e)
      break;
    o = d, a = a * e + u;
  }
  return r && o === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === s || t != null && this.pos - s !== t ? null : a;
};
function NW(e, t) {
  return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
}
function JO(e) {
  return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
}
mi.readRadixNumber = function(e) {
  var t = this.pos;
  this.pos += 2;
  var i = this.readInt(e);
  return i == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (i = JO(this.input.slice(t, this.pos)), ++this.pos) : Oo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, i);
};
mi.readNumber = function(e) {
  var t = this.pos;
  !e && this.readInt(10, void 0, !0) === null && this.raise(t, "Invalid number");
  var i = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
  i && this.strict && this.raise(t, "Invalid number");
  var r = this.input.charCodeAt(this.pos);
  if (!i && !e && this.options.ecmaVersion >= 11 && r === 110) {
    var n = JO(this.input.slice(t, this.pos));
    return ++this.pos, Oo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(v.num, n);
  }
  i && /[89]/.test(this.input.slice(t, this.pos)) && (i = !1), r === 46 && !i && (++this.pos, this.readInt(10), r = this.input.charCodeAt(this.pos)), (r === 69 || r === 101) && !i && (r = this.input.charCodeAt(++this.pos), (r === 43 || r === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), Oo(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = NW(this.input.slice(t, this.pos), i);
  return this.finishToken(v.num, s);
};
mi.readCodePoint = function() {
  var e = this.input.charCodeAt(this.pos), t;
  if (e === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var i = ++this.pos;
    t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(i, "Code point out of bounds");
  } else
    t = this.readHexChar(4);
  return t;
};
mi.readString = function(e) {
  for (var t = "", i = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var r = this.input.charCodeAt(this.pos);
    if (r === e)
      break;
    r === 92 ? (t += this.input.slice(i, this.pos), t += this.readEscapedChar(!1), i = this.pos) : r === 8232 || r === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (oh(r) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return t += this.input.slice(i, this.pos++), this.finishToken(v.string, t);
};
var QO = {};
mi.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (e) {
    if (e === QO)
      this.readInvalidTemplateToken();
    else
      throw e;
  }
  this.inTemplateElement = !1;
};
mi.invalidStringToken = function(e, t) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw QO;
  this.raise(e, t);
};
mi.readTmplToken = function() {
  for (var e = "", t = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var i = this.input.charCodeAt(this.pos);
    if (i === 96 || i === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === v.template || this.type === v.invalidTemplate) ? i === 36 ? (this.pos += 2, this.finishToken(v.dollarBraceL)) : (++this.pos, this.finishToken(v.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(v.template, e));
    if (i === 92)
      e += this.input.slice(t, this.pos), e += this.readEscapedChar(!0), t = this.pos;
    else if (oh(i)) {
      switch (e += this.input.slice(t, this.pos), ++this.pos, i) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          e += `
`;
          break;
        default:
          e += String.fromCharCode(i);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
    } else
      ++this.pos;
  }
};
mi.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(v.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
mi.readEscapedChar = function(e) {
  var t = this.input.charCodeAt(++this.pos);
  switch (++this.pos, t) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return Dc(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), e) {
        var i = this.pos - 1;
        this.invalidStringToken(
          i,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (t >= 48 && t <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n = parseInt(r, 8);
        return n > 255 && (r = r.slice(0, -1), n = parseInt(r, 8)), this.pos += r.length - 1, t = this.input.charCodeAt(this.pos), (r !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(
          this.pos - 1 - r.length,
          e ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(n);
      }
      return oh(t) ? "" : String.fromCharCode(t);
  }
};
mi.readHexChar = function(e) {
  var t = this.pos, i = this.readInt(16, e);
  return i === null && this.invalidStringToken(t, "Bad character escape sequence"), i;
};
mi.readWord1 = function() {
  this.containsEsc = !1;
  for (var e = "", t = !0, i = this.pos, r = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (ju(n, r))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = !0, e += this.input.slice(i, this.pos);
      var s = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var a = this.readCodePoint();
      (t ? Oo : ju)(a, r) || this.invalidStringToken(s, "Invalid Unicode escape"), e += Dc(a), i = this.pos;
    } else
      break;
    t = !1;
  }
  return e + this.input.slice(i, this.pos);
};
mi.readWord = function() {
  var e = this.readWord1(), t = v.name;
  return this.keywords.test(e) && (t = zx[e]), this.finishToken(t, e);
};
var LW = "8.11.3";
tn.acorn = {
  Parser: tn,
  version: LW,
  defaultOptions: Cb,
  Position: Hf,
  SourceLocation: Ry,
  getLineInfo: SO,
  Node: Py,
  TokenType: wi,
  tokTypes: v,
  keywordTypes: zx,
  TokContext: Ls,
  tokContexts: ur,
  isIdentifierChar: ju,
  isIdentifierStart: Oo,
  Token: Yx,
  isNewLine: oh,
  lineBreak: Ts,
  lineBreakG: nW,
  nonASCIIwhitespace: xO
};
function FW(e, t) {
  return tn.parse(e, t);
}
const qx = {
  undefined: "void(0)",
  Infinity: "Number.POSITIVE_INFINITY",
  NaN: "Number.NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2"
}, BW = { ecmaVersion: 11 }, qA = "$", RW = "d", MW = "d1", PW = "d2", cn = (e) => (t, i) => i.error(t, e + " not allowed"), $W = cn("Aggregate function"), zW = cn("Window function"), UW = "Invalid argument", Zx = "Invalid column reference", VW = Zx + " (must be input to an aggregate function)", t4 = "Invalid function call", jW = "Invalid member expression", GW = "Invalid operator parameter", HW = "Invalid param reference", WW = "Invalid variable reference", YW = "Variable not accessible in operator call", qW = "Unsupported variable declaration", ZW = "Unsupported destructuring pattern", e4 = "Table expressions do not support closures", i4 = "Use aq.escape(fn) to use a function as-is (including closures)", XW = "use table.params({ name: value }) to define dynamic parameters", KW = "use aq.addFunction(name, fn) to add new op functions", JW = `
Note: ${e4}. ${i4}, or ${XW}.`, r4 = `
Note: ${e4}. ${i4}, or ${KW}.`, QW = `The ${zE} method is not valid in multi-table expressions.`;
function tY(e, t) {
  const i = eY(t);
  let r = e.root = i;
  return e.spec = t, e.tuple = null, e.tuple1 = null, e.tuple2 = null, e.$param = null, e.$op = 0, e.scope = /* @__PURE__ */ new Set(), e.paramsRef = /* @__PURE__ */ new Map(), e.columnRef = /* @__PURE__ */ new Map(), qH(r) ? (rY(r, e), r = r.body) : e.join ? (e.scope.add(e.tuple1 = MW), e.scope.add(e.tuple2 = PW), e.scope.add(e.$param = qA)) : (e.scope.add(e.tuple = RW), e.scope.add(e.$param = qA)), bi(r, e, Xx), e.root;
}
function eY(e) {
  try {
    const t = e.field ? iY(e) : Ei(e) ? Ss(e) : e;
    return FW(`expr=(${t})`, BW).body[0].expression.right;
  } catch {
    Qe(`Expression parse error: ${e + ""}`);
  }
}
function iY(e) {
  const t = JSON.stringify(e + "");
  return e.table ? `(a,b)=>b[${t}]` : `d=>d[${t}]`;
}
const Xx = {
  FunctionDeclaration: cn("Function definitions"),
  ForStatement: cn("For loops"),
  ForOfStatement: cn("For-of loops"),
  ForInStatement: cn("For-in loops"),
  WhileStatement: cn("While loops"),
  DoWhileStatement: cn("Do-while loops"),
  AwaitExpression: cn("Await expressions"),
  ArrowFunctionExpression: cn("Function definitions"),
  AssignmentExpression: cn("Assignments"),
  FunctionExpression: cn("Function definitions"),
  NewExpression: cn('Use of "new"'),
  UpdateExpression: cn("Update expressions"),
  VariableDeclarator(e, t) {
    Lb(e.id, t);
  },
  Identifier(e, t, i) {
    a4(e, t, i) && !t.scope.has(e.name) && t.error(e, WW, JW);
  },
  CallExpression(e, t) {
    const i = n4(e.callee), r = ME(i) || PE(i);
    if (r) {
      if ((t.join || t.aggregate === !1) && R1(i) && $W(e, t), (t.join || t.window === !1) && M1(i) && zW(e, t), t.$op = 1, t.ast)
        Nb(e, i, t), e.arguments.forEach((n) => bi(n, t, Db));
      else {
        const n = t.op(nY(t, r, i, e.arguments));
        Object.assign(e, { type: NE, name: n.id });
      }
      return t.$op = 0, !1;
    } else
      RE(i) ? Nb(e, i, t) : t.error(e, t4, r4);
  },
  MemberExpression(e, t, i) {
    const { object: r, property: n } = e;
    if (!Qr(bc, r))
      return;
    const { name: s } = r;
    if (s4(e) && Qr(bc, n) && Xs(qx, n.name)) {
      l4(e, n.name);
      return;
    }
    const a = s === t.tuple ? 0 : s === t.tuple1 ? 1 : s === t.tuple2 ? 2 : -1;
    if (a >= 0)
      return ZA(e, a, t, o4, i);
    if (s === t.$param)
      return ZA(e, a, t, aY);
    t.paramsRef.has(s) ? Yf(e, t.paramsRef.get(s)) : t.columnRef.has(s) ? c4(r, s, t, e) : Xs(t.params, s) && Yf(r, s);
  }
};
function ZA(e, t, i, r, n) {
  const { property: s, computed: a } = e;
  let o;
  if (!a)
    o = s.name;
  else if (Qr(eh, s))
    o = s.value;
  else
    try {
      bi(s, i, Xx, e), o = i.param(s);
    } catch {
      i.error(e, jW);
    }
  return r(e, o, t, i, n), !1;
}
const Db = {
  ...Xx,
  VariableDeclarator: cn("Variable declaration in operator call"),
  Identifier(e, t, i) {
    a4(e, t, i) && t.error(e, YW);
  },
  CallExpression(e, t) {
    const i = n4(e.callee);
    RE(i) ? Nb(e, i, t) : t.error(e, t4, r4);
  }
};
function rY(e, t) {
  e.generator && cn("Generator functions")(e, t), e.async && cn("Async functions")(e, t);
  const { params: i } = e, r = i.length, n = (a) => (o, c) => t.columnRef.set(o, [c, a]), s = (a, o) => t.paramsRef.set(a, o);
  r && (t.join ? (qh(t, i[0], "tuple1", n(1)), r > 1 && qh(t, i[1], "tuple2", n(2)), r > 2 && qh(t, i[2], "$param", s)) : (qh(t, i[0], "tuple", n(0)), r > 1 && qh(t, i[1], "$param", s))), t.root = e.body;
}
function qh(e, t, i, r) {
  Qr(bc, t) ? (e.scope.add(t.name), e[i] = t.name) : Qr(OE, t) && t.properties.forEach((n) => {
    const s = Qr(bc, n.key) ? n.key.name : Qr(eh, n.key) ? n.key.value : e.error(n, UW);
    Qr(bc, n.value) || e.error(n.value, ZW), r(n.value.name, s);
  });
}
function nY(e, t, i, r) {
  const n = [], s = [], a = t.param[0] || 0, o = a + (t.param[1] || 0);
  return r.forEach((c, l) => {
    l < a ? (bi(c, e, Db), n.push(e.field(c))) : l < o ? (bi(c, e, Db), s.push(e.param(c))) : e.error(c, GW);
  }), { name: i, fields: n, params: s, ...e.spec.window || {} };
}
function n4(e) {
  return Qr(bc, e) ? e.name : Qr(CE, e) ? s4(e) ? sY(e.property.name) : e.property.name : null;
}
function s4(e) {
  return Qr(bc, e.object) && e.object.name === "Math";
}
function sY(e) {
  return e === "max" ? "greatest" : e === "min" ? "least" : e;
}
function a4(e, t, i) {
  const { name: r } = e;
  if (!(Qr(CE, i) && i.property === e)) {
    if (!(Qr(DE, i) && i.key === e))
      if (t.paramsRef.has(r))
        Yf(e, t.paramsRef.get(r));
      else if (t.columnRef.has(r))
        c4(e, r, t, i);
      else if (Xs(t.params, r))
        Yf(e, r);
      else if (Xs(qx, r))
        l4(e, r);
      else
        return !0;
  }
}
function o4(e, t, i, r, n) {
  const s = i === 0 ? r.table : i > 0 ? r.join[i - 1] : null, a = s && s.column(t);
  s && !a && r.error(e, Zx), r.aggronly && !r.$op && r.error(e, VW), $E(e, t, i, a, n);
}
function c4(e, t, i, r) {
  const [n, s] = i.columnRef.get(t);
  o4(e, n, s, i, r);
}
function aY(e, t, i, r) {
  r.params && !Xs(r.params, t) && r.error(e, HW), Yf(e, t);
}
function Yf(e, t) {
  e.type = L9, e.name = t;
}
function l4(e, t) {
  e.type = O9, e.name = t, e.raw = qx[t];
}
function Nb(e, t, i) {
  if (t === zE) {
    const r = i.table;
    r || i.error(e, QW), UE(
      e,
      e.arguments.length ? e.arguments.map((n) => {
        const s = i.param(n), a = Tn(s) ? r.columnName(s) : s;
        return r.column(a) || i.error(n, Zx), a;
      }) : r.columnNames()
    );
  } else
    e.callee = { type: N9, name: t };
}
function Lb(e, t) {
  Qr(bc, e) ? t.scope.add(e.name) : Qr(T9, e) ? e.elements.forEach((i) => Lb(i, t)) : Qr(OE, e) ? e.properties.forEach((i) => Lb(i.value, t)) : t.error(e.id, qW);
}
const oY = { [Sp]: 1, [NE]: 1 };
function Gn(e, t = {}) {
  const i = t.generate || Gg, r = t.compiler || P1, n = lY(t), s = {}, a = {}, o = [], c = [];
  let l = 0, d = -1;
  const u = t.join ? r.join : t.index == 1 ? r.expr2 : r.expr, h = {
    op(w) {
      const C = cY(w);
      return a[C] || (w.id = ++d, a[C] = w);
    },
    field(w) {
      const C = i(w);
      return s[C] || (s[C] = ++l);
    },
    param(w) {
      return Qr(eh, w) ? w.value : r.param(i(w), n);
    },
    value(w, C) {
      o.push(w);
      const F = C.escape || (t.ast ? YH(C) : u(i(C), n));
      c.push(F), oY[C.type] && F !== C && _n(F) && (F.field = C.name);
    },
    error(w, C, F = "") {
      const W = w.start - 6, et = w.end - 6, E = String(h.spec).slice(W, et);
      Qe(`${C}: "${E}"${F}`);
    }
  };
  Object.assign(h, t, { params: n });
  for (const [w, C] of by(e))
    h.value(
      w + "",
      C.escape ? KH(h, C, n) : tY(h, C)
    );
  if (t.ast)
    return { names: o, exprs: c };
  const p = [];
  for (const w in s)
    p[s[w]] = r.expr(w, n);
  const m = Object.values(a);
  return m.forEach((w) => w.fields = w.fields.map((C) => p[C])), { names: o, exprs: c, ops: m };
}
function cY(e) {
  let t = `${e.name}(${e.fields.concat(e.params).join(",")})`;
  if (e.frame) {
    const i = e.frame.map((r) => Number.isFinite(r) ? Math.abs(r) : -1);
    t += `[${i},${!!e.peers}]`;
  }
  return t;
}
function lY(e) {
  return (e.table ? C_(e.table) : e.join ? {
    ...C_(e.join[1]),
    ...C_(e.join[0])
  } : {}) || {};
}
function C_(e) {
  return e && or(e.params) ? e.params() : {};
}
const d4 = "Expr", Fs = "ExprList", u4 = "ExprNumber", df = "ExprObject", su = "JoinKeys", _0 = "JoinValues", us = "Options", Kx = "OrderKeys", dc = "SelectionList", kl = "TableRef", au = "TableRefList", dY = "Descending", uY = "Query", hY = "Selection", fY = "Verb", pY = "Window";
function Jx(e, t) {
  return e && e.expr ? new XA({ ...e, ...t }) : new XA(t, e);
}
class XA {
  constructor(t, i) {
    this.expr = i, Object.assign(this, t);
  }
  toString() {
    return String(this.expr);
  }
  toObject() {
    return {
      ...this,
      expr: this.toString(),
      ...or(this.expr) ? { func: !0 } : {}
    };
  }
}
function mY(e) {
  return Jx(e, { desc: !0 });
}
function Ul(e, t, i = 0) {
  const r = i ? { field: !0, table: i } : { field: !0 };
  return Jx(
    e,
    t ? { expr: t, ...r } : r
  );
}
function gY(e, t, i) {
  return Jx(e, {
    window: {
      frame: t || [-1 / 0, 0],
      peers: !!i
    }
  });
}
function yY(e) {
  const t = (i) => i;
  return t.toString = () => e, t;
}
function KA(e, t) {
  return t = t && or(t.query) ? t.query() : t, t && or(t.evaluate) ? t.evaluate(null, e) : e(t);
}
function h4(e) {
  return _n(e) && (Ei(e.all) || Ei(e.matches) || Ei(e.not) || Ei(e.range));
}
function qf(e) {
  return e && or(e.toObject) ? e.toObject() : or(e) ? { expr: String(e), func: !0 } : Ei(e) ? e.map(qf) : _n(e) ? Fy(e, (t) => qf(t)) : e;
}
function Qx(e) {
  return Ei(e) ? e.map(Qx) : _n(e) ? Ei(e.verbs) ? Bp.from(e) : Ei(e.all) ? zl() : Ei(e.range) ? VH(...e.range) : Ei(e.match) ? jH(RegExp(...e.match)) : Ei(e.not) ? gO(e.not.map(qf)) : vY(e) : e;
}
function vY(e) {
  let t = e, i = e.expr;
  if (i != null) {
    if (e.field === !0 ? t = i = Ul(i) : e.func === !0 && (t = i = yY(i)), _n(e.window)) {
      const { frame: r, peers: n } = e.window;
      t = i = gY(i, r, n);
    }
    e.desc === !0 && (t = mY(i));
  }
  return e === t ? Fy(e, (r) => Qx(r)) : t;
}
function _Y(e) {
  return Ei(e) ? e.map(bY) : e;
}
function bY(e) {
  const t = [];
  return Un(e).forEach((i) => {
    Tn(i) ? t.push(i) : fn(i) ? t.push(Ul(i, null)) : _n(i) && i.expr || or(i) ? t.push(i) : Qe(`Invalid key value: ${i + ""}`);
  }), t;
}
function xY(e) {
  return Ei(e) ? e.map(wY) : e;
}
function wY(e, t) {
  return t < 2 ? Un(e) : e;
}
function SY(e) {
  const t = [];
  return e.forEach((i) => {
    const r = i.expr != null ? i.expr : i;
    if (_n(r) && !or(r))
      for (const n in r)
        t.push(r[n]);
    else
      i = Tn(r) ? r : fn(r) ? Ul(i) : or(r) ? i : Qe(`Invalid orderby field: ${i + ""}`), t.push(i);
  }), t;
}
const IY = {
  [d4]: g4,
  [Fs]: Gu,
  [u4]: OY,
  [df]: Nc,
  [su]: DY,
  [_0]: NY,
  [Kx]: Gu,
  [dc]: kY
};
function AY(e, t, i) {
  return t === kl ? JA(e) : t === au ? e.map(JA) : f4(qf(e), t, i);
}
function f4(e, t, i) {
  return t === us ? e && TY(e, i) : IY[t](e);
}
function TY(e, t = {}) {
  const i = {};
  for (const r in e) {
    const n = e[r];
    i[r] = t[r] ? f4(n, t[r]) : n;
  }
  return i;
}
function EY(e, t) {
  return Gn({ expr: e }, { ...t, ast: !0 }).exprs[0];
}
function tw(e) {
  return { type: Sp, name: e };
}
function p4(e) {
  return { type: Sp, index: e };
}
function Nc(e, t) {
  if (fn(e))
    return EY(e, t);
  if (e.expr) {
    let i;
    if (e.field === !0 ? i = tw(e.expr) : e.func === !0 && (i = Nc(e.expr, t)), i)
      return e.desc && (i = { type: dY, expr: i }), e.window && (i = { type: pY, expr: i, ...e.window }), i;
  }
  return Object.keys(e).map((i) => ({
    ...Nc(e[i], t),
    as: i
  }));
}
function m4(e) {
  const t = hY;
  return e.all ? { type: t, operator: "all" } : e.not ? { type: t, operator: "not", arguments: Gu(e.not) } : e.range ? { type: t, operator: "range", arguments: Gu(e.range) } : e.matches ? { type: t, operator: "matches", arguments: e.matches } : Qe("Invalid input");
}
function kY(e) {
  return Un(e).map(CY).flat();
}
function CY(e) {
  return h4(e) ? m4(e) : Tn(e) ? p4(e) : fn(e) ? tw(e) : _n(e) ? Object.keys(e).map((t) => ({ type: Sp, name: t, as: e[t] })) : Qe("Invalid input");
}
function g4(e) {
  return h4(e) ? m4(e) : Tn(e) ? p4(e) : fn(e) ? tw(e) : _n(e) ? Nc(e) : Qe("Invalid input");
}
function Gu(e) {
  return Un(e).map(g4).flat();
}
function OY(e) {
  return Tn(e) ? e : Nc(e);
}
function DY(e) {
  return Ei(e) ? e.map(Gu) : Nc(e, { join: !0 });
}
function NY(e) {
  return Ei(e) ? e.map(
    (t, i) => i < 2 ? Gu(t) : Nc(t, { join: !0 })
  ) : Nc(e, { join: !0 });
}
function JA(e) {
  return e && or(e.toAST) ? e.toAST() : e;
}
class y4 {
  /**
   * Construct a new verb instance.
   * @param {string} verb The verb name.
   * @param {object[]} schema Schema describing verb parameters.
   * @param {any[]} params Array of parameter values.
   */
  constructor(t, i = [], r = []) {
    this.verb = t, this.schema = i, i.forEach((n, s) => {
      const a = n.type, o = r[s], c = a === su ? _Y(o) : a === _0 ? xY(o) : a === Kx ? SY(o) : o;
      this[n.name] = c !== void 0 ? c : n.default;
    });
  }
  /**
   * Create new verb instance from the given serialized object.
   * @param {object} object A serialized verb representation, such as
   *  those generated by Verb.toObject.
   * @returns {Verb} The instantiated verb.
   */
  static from(t) {
    const i = Fb[t.verb], r = (i.schema || []).map(({ name: n }) => Qx(t[n]));
    return i(...r);
  }
  /**
   * Evaluate this verb against a given table and catalog.
   * @param {Table} table The Arquero table to process.
   * @param {Function} catalog A table lookup function that accepts a table
   *  name string as input and returns a corresponding Arquero table.
   * @returns {Table} The resulting Arquero table.
   */
  evaluate(t, i) {
    const r = this.schema.map(({ name: n, type: s }) => {
      const a = this[n];
      return s === kl ? KA(i, a) : s === au ? a.map((o) => KA(i, o)) : a;
    });
    return t[this.verb](...r);
  }
  /**
   * Serialize this verb as a JSON-compatible object. The resulting
   * object can be passed to Verb.from to re-instantiate this verb.
   * @returns {object} A JSON-compatible object representing this verb.
   */
  toObject() {
    const t = { verb: this.verb };
    return this.schema.forEach(({ name: i }) => {
      t[i] = qf(this[i]);
    }), t;
  }
  /**
   * Serialize this verb to a JSON-compatible abstract syntax tree.
   * All table expressions will be parsed and represented as AST instances
   * using a modified form of the Mozilla JavaScript AST format.
   * This method can be used to output parsed and serialized representations
   * to translate Arquero verbs to alternative data processing platforms.
   * @returns {object} A JSON-compatible abstract syntax tree object.
   */
  toAST() {
    const t = { type: fY, verb: this.verb };
    return this.schema.forEach(({ name: i, type: r, props: n }) => {
      t[i] = AY(this[i], r, n);
    }), t;
  }
}
function Hi(e, t) {
  return Object.assign(
    (...i) => new y4(e, t, i),
    { schema: t }
  );
}
const Fb = {
  count: Hi("count", [
    { name: "options", type: us }
  ]),
  derive: Hi("derive", [
    { name: "values", type: df },
    {
      name: "options",
      type: us,
      props: { before: dc, after: dc }
    }
  ]),
  filter: Hi("filter", [
    { name: "criteria", type: df }
  ]),
  groupby: Hi("groupby", [
    { name: "keys", type: Fs }
  ]),
  orderby: Hi("orderby", [
    { name: "keys", type: Kx }
  ]),
  relocate: Hi("relocate", [
    { name: "columns", type: dc },
    {
      name: "options",
      type: us,
      props: { before: dc, after: dc }
    }
  ]),
  rename: Hi("rename", [
    { name: "columns", type: dc }
  ]),
  rollup: Hi("rollup", [
    { name: "values", type: df }
  ]),
  sample: Hi("sample", [
    { name: "size", type: u4 },
    { name: "options", type: us, props: { weight: d4 } }
  ]),
  select: Hi("select", [
    { name: "columns", type: dc }
  ]),
  ungroup: Hi("ungroup"),
  unorder: Hi("unorder"),
  reify: Hi("reify"),
  dedupe: Hi("dedupe", [
    { name: "keys", type: Fs, default: [] }
  ]),
  impute: Hi("impute", [
    { name: "values", type: df },
    { name: "options", type: us, props: { expand: Fs } }
  ]),
  fold: Hi("fold", [
    { name: "values", type: Fs },
    { name: "options", type: us }
  ]),
  pivot: Hi("pivot", [
    { name: "keys", type: Fs },
    { name: "values", type: Fs },
    { name: "options", type: us }
  ]),
  spread: Hi("spread", [
    { name: "values", type: Fs },
    { name: "options", type: us }
  ]),
  unroll: Hi("unroll", [
    { name: "values", type: Fs },
    { name: "options", type: us, props: { drop: Fs } }
  ]),
  lookup: Hi("lookup", [
    { name: "table", type: kl },
    { name: "on", type: su },
    { name: "values", type: Fs }
  ]),
  join: Hi("join", [
    { name: "table", type: kl },
    { name: "on", type: su },
    { name: "values", type: _0 },
    { name: "options", type: us }
  ]),
  cross: Hi("cross", [
    { name: "table", type: kl },
    { name: "values", type: _0 },
    { name: "options", type: us }
  ]),
  semijoin: Hi("semijoin", [
    { name: "table", type: kl },
    { name: "on", type: su }
  ]),
  antijoin: Hi("antijoin", [
    { name: "table", type: kl },
    { name: "on", type: su }
  ]),
  concat: Hi("concat", [
    { name: "tables", type: au }
  ]),
  union: Hi("union", [
    { name: "tables", type: au }
  ]),
  intersect: Hi("intersect", [
    { name: "tables", type: au }
  ]),
  except: Hi("except", [
    { name: "tables", type: au }
  ])
};
class Bp extends mE {
  /**
   * Construct a new query instance.
   * @param {Verb[]} verbs An array of verb instances.
   * @param {object} [params] Optional query parameters, corresponding
   *  to parameter references in table expressions.
   * @param {string} [table] Optional name of the table to query.
   */
  constructor(t, i, r) {
    super(i), this._verbs = t || [], this._table = r;
  }
  /**
   * Create a new query instance from the given serialized object.
   * @param {QueryObject} object A serialized query representation, such as
   *  those generated by Query.toObject.
   * @returns {Query} The instantiated query.
   */
  static from({ verbs: t, table: i, params: r }) {
    return new Bp(t.map(y4.from), r, i);
  }
  /**
   * Provide an informative object string tag.
   */
  get [Symbol.toStringTag]() {
    return this._verbs ? `Query: ${this._verbs.length} verbs` + (this._table ? ` on '${this._table}'` : "") : "Object";
  }
  /**
   * Return the number of verbs in this query.
   */
  get length() {
    return this._verbs.length;
  }
  /**
   * Return the name of the table this query applies to.
   * @return {string} The name of the source table, or undefined.
   */
  get tableName() {
    return this._table;
  }
  /**
   * Get or set table expression parameter values.
   * If called with no arguments, returns the current parameter values
   * as an object. Otherwise, adds the provided parameters to this
   * query's parameter set and returns the table. Any prior parameters
   * with names matching the input parameters are overridden.
   * @param {object} values The parameter values.
   * @return {Query|object} The current parameter values (if called
   *  with no arguments) or this query.
   */
  params(t) {
    return arguments.length ? (this._params = { ...this._params, ...t }, this) : this._params;
  }
  /**
   * Evaluate this query against a given table and catalog.
   * @param {Table} table The Arquero table to process.
   * @param {Function} catalog A table lookup function that accepts a table
   *  name string as input and returns a corresponding Arquero table.
   * @returns {Table} The resulting Arquero table.
   */
  evaluate(t, i) {
    t = t || i(this._table);
    for (const r of this._verbs)
      t = r.evaluate(t.params(this._params), i);
    return t;
  }
  /**
   * Serialize this query as a JSON-compatible object. The resulting
   * object can be passed to Query.from to re-instantiate this query.
   * @returns {object} A JSON-compatible object representing this query.
   */
  toObject() {
    return QA(this, "toObject");
  }
  /**
   * Serialize this query as a JSON-compatible object. The resulting
   * object can be passed to Query.from to re-instantiate this query.
   * This method simply returns the result of toObject, but is provided
   * as a separate method to allow later customization of JSON export.
   * @returns {object} A JSON-compatible object representing this query.
   */
  toJSON() {
    return this.toObject();
  }
  /**
   * Serialize this query to a JSON-compatible abstract syntax tree.
   * All table expressions will be parsed and represented as AST instances
   * using a modified form of the Mozilla JavaScript AST format.
   * This method can be used to output parsed and serialized representations
   * to translate Arquero queries to alternative data processing platforms.
   * @returns {object} A JSON-compatible abstract syntax tree object.
   */
  toAST() {
    return QA(this, "toAST", { type: uY });
  }
}
function QA(e, t, i) {
  return {
    ...i,
    verbs: e._verbs.map((r) => r[t]()),
    ...e._params ? { params: e._params } : null,
    ...e._table ? { table: e._table } : null
  };
}
function LY(e, t) {
  return new Bp(
    e._verbs.concat(t),
    e._params,
    e._table
  );
}
for (const e in Fb) {
  const t = Fb[e];
  Bp.prototype["__" + e] = function(i, ...r) {
    return LY(i, t(...r));
  };
}
function FY(e) {
  const { data: t, length: i, nullCount: r } = e, n = t[t.length - 1].dictionary, s = n.length, a = BY(t || [e], i, r, s), o = Array(s), c = (l) => l == null || l < 0 || l >= s ? null : o[l] !== void 0 ? o[l] : o[l] = n.get(l);
  return {
    vector: e,
    length: i,
    get: (l) => c(a[l]),
    key: (l) => a[l],
    keyFor(l) {
      if (l === null)
        return r ? s : -1;
      for (let d = 0; d < s; ++d)
        if (o[d] === void 0 && (o[d] = n.get(d)), o[d] === l)
          return d;
      return -1;
    },
    groups(l) {
      const d = s + (r ? 1 : 0);
      return { keys: a, get: [c], names: l, rows: xE(0, d), size: d };
    },
    [Symbol.iterator]() {
      return e[Symbol.iterator]();
    }
  };
}
function BY(e, t, i, r) {
  const n = e.length > 1 || i ? RY(e, t, e[0].type.indices) : e[0].values;
  return i ? MY(e, n, r) : n;
}
function RY(e, t, i) {
  const r = new i.ArrayType(t), n = e.length;
  for (let s = 0, a = 0, o; s < n; ++s)
    o = e[s].length, r.set(e[s].values.subarray(0, o), a), a += o;
  return r;
}
function MY(e, t, i) {
  const r = e.length;
  for (let n = 0, s = 0, a, o, c, l; n < r; ++n) {
    if (c = e[n].nullBitmap, a = e[n].length >> 3, c && c.length)
      for (let d = 0; d <= a; ++d)
        (l = c[d]) !== 255 && (o = s + (d << 3), l & 1 || (t[o + 0] = i), l & 2 || (t[o + 1] = i), l & 4 || (t[o + 2] = i), l & 8 || (t[o + 3] = i), l & 16 || (t[o + 4] = i), l & 32 || (t[o + 5] = i), l & 64 || (t[o + 6] = i), l & 128 || (t[o + 7] = i));
    s += e[n].length;
  }
  return t;
}
function Xl(e, t, ...i) {
  const r = ["_", "$"], n = r.slice(0, i.length);
  return n.push(
    '"use strict"; const ' + i.map((s, a) => s.map((o, c) => `${r[a]}${c} = ${r[a]}[${c}]`).join(", ")).join(", ") + `; return (${e}) => ${t};`
  ), Function(...n)(...i);
}
const PY = ({ typeId: e }) => e === -1, $Y = ({ typeId: e }) => e === 5, zY = ({ typeId: e }) => e === 12, UY = ({ typeId: e }) => e === 13, VY = ({ typeId: e }) => e === 16, jY = (e) => zY(e) || VY(e);
function v4(e, t) {
  const { type: i, length: r, numChildren: n } = e;
  if (PY(i))
    return FY(e);
  const s = n && t ? Bb(e) : n ? t3(Bb(e)) : $Y(i) ? t3((a) => e.get(a)) : null;
  return s ? { vector: e, length: r, get: s, [Symbol.iterator]: () => GY(r, s) } : e;
}
function t3(e) {
  const t = [];
  return (i) => {
    const r = t[i];
    return r !== void 0 ? r : t[i] = e(i);
  };
}
function* GY(e, t) {
  for (let i = 0; i < e; ++i)
    yield t(i);
}
const e3 = (e) => e.numChildren ? xp(e.length, Bb(e)) : e.nullCount ? [...e] : e.toArray(), Bb = (e) => jY(e.type) ? HY(e) : UY(e.type) ? WY(e) : Qe(`Unsupported Arrow type: ${Ss(e.VectorName)}`), HY = (e) => e.nullCount ? (t) => e.isValid(t) ? e3(e.get(t)) : null : (t) => e3(e.get(t));
function WY(e) {
  const t = [], i = [];
  e.type.children.forEach((n, s) => {
    t.push(v4(e.getChildAt(s), !0)), i.push(`${Ss(n.name)}:_${s}.get(row)`);
  });
  const r = Xl("row", "({" + i + "})", t);
  return e.nullCount ? (n) => e.isValid(n) ? r(n) : null : r;
}
function YY(e, t = {}) {
  e && !e.batches && (e = EH()(e));
  const i = e.schema.fields.map((s) => s.name), r = Ra({
    columnNames: (s) => s ? i.filter(s) : i.slice(),
    columnIndex: (s) => i.indexOf(s)
  }, t.columns || zl()), n = Yn();
  return r.forEach((s, a) => {
    n.add(s, v4(e.getChild(a)));
  }), new go(n.data, n.names);
}
function qY(e, t = []) {
  return e.groupby(t.length ? t : e.columnNames()).filter("row_number() === 1").ungroup().reify();
}
function ew(e, t) {
  const i = Yn();
  return t.forEach((r, n) => {
    const s = fn(r) ? r : n;
    if (s) {
      const a = e.column(n) || Qe(`Unrecognized column: ${n}`);
      i.add(s, a);
    }
  }), e.create(i);
}
function _4(e, t, { before: i, after: r } = {}) {
  const n = i != null, s = r != null;
  n || s || Qe("relocate requires a before or after option."), n && s && Qe("relocate accepts only one of the before or after options."), t = Ra(e, t);
  const a = [...Ra(e, n ? i : r).keys()], o = n ? a[0] : a.pop(), c = /* @__PURE__ */ new Map();
  return e.columnNames().forEach((l) => {
    const d = !t.has(l);
    if (l === o) {
      s && d && c.set(l, l);
      for (const [u, h] of t)
        c.set(u, h);
      if (s)
        return;
    }
    d && c.set(l, l);
  }), ew(e, c);
}
function Rp(e, t = (r) => r, i = "") {
  const r = e.length;
  if (!r)
    return "";
  let n = t(e[0], 0);
  for (let s = 1; s < r; ++s)
    n += i + t(e[s], s);
  return n;
}
function iw(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function ZY(e, t = 0, i = e.length) {
  let r = i ? e[t++] : Si;
  for (let n = t; n < i; ++n)
    r > e[n] && (r = e[n]);
  return r;
}
function XY(e, t = 0, i = e.length) {
  let r = i ? e[t++] : Si;
  for (let n = t; n < i; ++n)
    r < e[n] && (r = e[n]);
  return r;
}
function Vm(e) {
  return Rf(e) ? e : +e;
}
function KY(e, t) {
  const i = e.length;
  if (!i)
    return Si;
  if ((t = +t) <= 0 || i < 2)
    return Vm(e[0]);
  if (t >= 1)
    return Vm(e[i - 1]);
  const r = (i - 1) * t, n = Math.floor(r), s = Vm(e[n]);
  return Rf(s) ? s : s + (Vm(e[n + 1]) - s) * (r - n);
}
class JY {
  constructor(t) {
    this._values = t || [], this._sorted = null, this._start = 0;
  }
  values(t) {
    return this._start && (this._values = this._values.slice(this._start), this._start = 0), t ? this._values.slice() : this._values;
  }
  add(t) {
    this._values.push(t), this._sorted = null;
  }
  rem() {
    this._start += 1, this._sorted = null;
  }
  min() {
    return this._sorted && this._sorted.length ? this._sorted[0] : ZY(this._values, this._start);
  }
  max() {
    return this._sorted && this._sorted.length ? this._sorted[this._sorted.length - 1] : XY(this._values, this._start);
  }
  quantile(t) {
    return this._sorted || (this._sorted = this.values(!0), this._sorted.sort(iw)), KY(this._sorted, t);
  }
}
const b0 = (e, t, i) => Xl(
  t,
  "{" + Rp(e, (r, n) => `_${n}.${i}(${t});`) + "}",
  e
);
function QY(e, t) {
  const { ops: i, output: r } = tq(e, t), n = e[0].fields, s = n.length, a = s === 0 ? rw : s === 1 ? eq : s === 2 ? iq : Qe("Unsupported field count: " + s);
  return new a(n, i, r, t);
}
function tq(e, t) {
  const i = {}, r = [];
  function n(a, o = []) {
    const c = a + ":" + o;
    if (i[c])
      return i[c];
    const l = ME(a), d = l.create(...o);
    return t < 0 && l.stream && l.stream.forEach((u) => n(u, [])), l.req && l.req.forEach((u) => n(u, [])), i[c] = d, r.push(d), d;
  }
  const s = e.map((a) => {
    const o = n(a.name, a.params);
    return o.output = a.id, o;
  });
  return { ops: r, output: s };
}
class rw extends HH {
  constructor(t, i, r, n) {
    super(r), this._op = i, this._fields = t, this._stream = !!n;
  }
  init() {
    const t = { count: 0, valid: 0, stream: this._stream };
    return this._op.forEach((i) => i.init(t)), t.values && (t.list = new JY()), t;
  }
  write(t, i, r) {
    const n = this._outputs, s = n.length;
    for (let a = 0; a < s; ++a)
      i[n[a].output][r] = n[a].value(t);
    return 1;
  }
  _add() {
  }
  _rem() {
  }
  add(t) {
    ++t.count;
  }
  rem(t) {
    --t.count;
  }
}
class eq extends rw {
  constructor(t, i, r, n) {
    super(t, i, r, n);
    const s = ["state", "v1", "v2"];
    this._add = b0(i, s, "add"), this._rem = b0(i, s, "rem");
  }
  add(t, i, r) {
    const n = this._fields[0](i, r);
    ++t.count, Gs(n) && (++t.valid, t.list && t.list.add(n), this._add(t, n));
  }
  rem(t, i, r) {
    const n = this._fields[0](i, r);
    --t.count, Gs(n) && (--t.valid, t.list && t.list.rem(), this._rem(t, n));
  }
}
class iq extends rw {
  constructor(t, i, r, n) {
    super(t, i, r, n);
    const s = ["state", "v1", "v2"];
    this._add = b0(i, s, "add"), this._rem = b0(i, s, "rem");
  }
  add(t, i, r) {
    const n = this._fields[0](i, r), s = this._fields[1](i, r);
    ++t.count, Gs(n) && Gs(s) && (++t.valid, t.list && t.list.add([n, s]), this._add(t, n, s));
  }
  rem(t, i, r) {
    const n = this._fields[0](i, r), s = this._fields[1](i, r);
    --t.count, Gs(n) && Gs(s) && (--t.valid, t.list && t.list.rem(), this._rem(t, n, s));
  }
}
function Kl(e, t, i) {
  if (t.length) {
    const r = e.data(), { keys: n } = e.groups() || {}, s = dh(e, t), a = n ? (o, c) => s[o][n[c]] : (o) => s[o][0];
    i = i.map((o) => (c) => o(c, r, a));
  }
  return i;
}
function dh(e, t, i) {
  if (!t.length)
    return i;
  const r = b4(t), n = e.groups(), s = n ? n.size : 1;
  return i = i || xp(t.length, () => Array(s)), s > 1 ? r.forEach((a) => {
    const o = w4(e, a, n);
    for (let c = 0; c < s; ++c)
      a.write(o[c], i, c);
  }) : r.forEach((a) => {
    const o = x4(e, a);
    a.write(o, i, 0);
  }), i;
}
function b4(e, t) {
  const i = [], r = {};
  for (const n of e) {
    const s = n.fields.map((a) => a + "").join(",");
    (r[s] || (r[s] = [])).push(n);
  }
  for (const n in r)
    i.push(QY(r[n], t));
  return i;
}
function x4(e, t) {
  const i = t.init(), r = e.totalRows(), n = e.data(), s = e.mask();
  if (e.isOrdered()) {
    const a = e.indices();
    for (let o = 0; o < r; ++o)
      t.add(i, a[o], n);
  } else if (s)
    for (let a = s.next(0); a >= 0; a = s.next(a + 1))
      t.add(i, a, n);
  else
    for (let a = 0; a < r; ++a)
      t.add(i, a, n);
  return i;
}
function w4(e, t, i) {
  const { keys: r, size: n } = i, s = xp(n, () => t.init()), a = e.data();
  if (e.isOrdered()) {
    const o = e.indices(), c = o.length;
    for (let l = 0; l < c; ++l) {
      const d = o[l];
      t.add(s[r[d]], d, a);
    }
  } else if (e.isFiltered()) {
    const o = e.mask();
    for (let c = o.next(0); c >= 0; c = o.next(c + 1))
      t.add(s[r[c]], c, a);
  } else {
    const o = e.totalRows();
    for (let c = 0; c < o; ++c)
      t.add(s[r[c]], c, a);
  }
  return s;
}
function S4(e, t) {
  const { get: i, names: r, rows: n, size: s } = t, a = r.length;
  for (let o = 0; o < a; ++o) {
    const c = e.add(r[o], Array(s)), l = i[o];
    for (let d = 0; d < s; ++d)
      c[d] = l(n[d]);
  }
}
function I4(e) {
  return {
    left(t, i, r, n) {
      for (r == null && (r = 0), n == null && (n = t.length); r < n; ) {
        const s = r + n >>> 1;
        e(t[s], i) < 0 ? r = s + 1 : n = s;
      }
      return r;
    },
    right(t, i, r, n) {
      for (r == null && (r = 0), n == null && (n = t.length); r < n; ) {
        const s = r + n >>> 1;
        e(t[s], i) > 0 ? n = s : r = s + 1;
      }
      return r;
    }
  };
}
const i3 = I4(iw);
function rq(e, t, i, r, n) {
  let s, a, o, c, l;
  const d = (w) => a[w - 1] === a[w], u = r.length, h = n.length, p = r.length ? Xl(
    ["w", "r", "k"],
    "{" + Rp(r, (w, C) => `r[_${C}.id][k]=_${C}.value(w,_${C}.get);`) + "}",
    r
  ) : () => {
  }, m = {
    i0: 0,
    i1: 0,
    index: 0,
    size: 0,
    peer: d,
    init(w, C, F, W) {
      m.index = m.i0 = m.i1 = 0, m.size = C.length, s = w, a = C, c = F, l = W, o = n ? n.map((et) => et.init()) : null;
      for (let et = 0; et < u; ++et)
        r[et].init();
      return m;
    },
    value(w, C) {
      return C(s[w], e);
    },
    step(w) {
      const [C, F] = t, W = m.size, et = m.i0, E = m.i1;
      m.i0 = C != null ? Math.max(0, w - Math.abs(C)) : 0, m.i1 = F != null ? Math.min(W, w + Math.abs(F) + 1) : W, m.index = w, i && (m.i0 > 0 && d(m.i0) && (m.i0 = i3.left(a, a[m.i0])), m.i1 < W && d(m.i1) && (m.i1 = i3.right(a, a[m.i1 - 1])));
      for (let Z = 0; Z < h; ++Z) {
        const yt = n[Z], bt = o[Z];
        for (let Ct = et; Ct < m.i0; ++Ct)
          yt.rem(bt, s[Ct], e);
        for (let Ct = E; Ct < m.i1; ++Ct)
          yt.add(bt, s[Ct], e);
        yt.write(bt, c, l);
      }
      return p(m, c, l), c;
    }
  };
  return m;
}
const nq = (e) => (e.frame || [null, null]).map((t) => Number.isFinite(t) ? Math.abs(t) : null), sq = (e) => !!e.peers;
function aq(e) {
  const { id: t, name: i, fields: r = [], params: n = [] } = e, s = PE(i).create(...n);
  return r.length && (s.get = r[0]), s.id = t, s;
}
function oq(e, t, i, r = {}, n) {
  const s = e.data(), a = cq(n, s), o = a.length, c = Xl(
    ["r", "d", "op"],
    "{" + Rp(t, (l, d) => `_${d}[r] = $${d}(r, d, op);`) + "}",
    t,
    i
  );
  e.partitions().forEach((l, d) => {
    const u = l.length, h = lq(e, l);
    for (let m = 0; m < o; ++m)
      a[m].init(l, h, r, d);
    const p = (m) => r[m][d];
    for (let m = 0; m < u; ++m) {
      for (let w = 0; w < o; ++w)
        a[w].step(m);
      c(l[m], s, p);
    }
  });
}
function cq(e, t) {
  const i = {};
  return e.forEach((r) => {
    const n = nq(r), s = sq(r), a = `${n},${s}`, { aggOps: o, winOps: c } = i[a] || (i[a] = {
      frame: n,
      peers: s,
      aggOps: [],
      winOps: []
    });
    R1(r.name) ? o.push(r) : c.push(aq(r));
  }), Object.values(i).map((r) => rq(
    t,
    r.frame,
    r.peers,
    r.winOps,
    b4(r.aggOps, r.frame[0] != null ? -1 : 1)
  ));
}
function lq(e, t) {
  if (e.isOrdered()) {
    const i = e.comparator(), r = e.data(), n = t.length, s = new Uint32Array(n);
    for (let a = 1, o = 0; a < n; ++a)
      s[a] = i(t[a - 1], t[a], r) ? ++o : o;
    return s;
  } else
    return t;
}
function dq(e) {
  return M1(e.name) || e.frame && (Number.isFinite(e.frame[0]) || Number.isFinite(e.frame[1]));
}
function nw(e, { names: t, exprs: i, ops: r }, n = {}) {
  const s = e.totalRows(), a = Yn(n.drop ? null : e), o = t.map((h) => a.add(h, Array(s))), [c, l] = uq(r), d = e.isGrouped() ? e.groups().size : 1, u = dh(
    e,
    c,
    xp(r.length, () => Array(d))
  );
  return l.length ? oq(e, o, i, u, l) : hq(e, o, i, u), e.create(a);
}
function uq(e) {
  const t = [], i = [], r = e.length;
  for (let n = 0; n < r; ++n) {
    const s = e[n];
    s.id = n, (dq(s) ? i : t).push(s);
  }
  return [t, i];
}
function hq(e, t, i, r) {
  const n = e.mask(), s = e.data(), { keys: a } = e.groups() || {}, o = a ? (l, d) => r[l][a[d]] : (l) => r[l][0], c = t.length;
  for (let l = 0; l < c; ++l) {
    const d = i[l], u = t[l];
    if (n)
      for (let h = n.next(0); h >= 0; h = n.next(h + 1))
        u[h] = d(h, s, o);
    else {
      const h = e.totalRows();
      for (let p = 0; p < h; ++p)
        u[p] = d(p, s, o);
    }
  }
}
function fq(e, t, i = {}) {
  const r = nw(e, Gn(t, { table: e }), i);
  return i.drop || i.before == null && i.after == null ? r : _4(
    r,
    Object.keys(t).filter((n) => !e.column(n)),
    i
  );
}
function pq(e, t) {
  if (t.length === 0)
    return e;
  const i = e.columnNames();
  return t.reduce((r, n) => r.antijoin(n.select(i)), e).dedupe();
}
const jm = 2147483648, mq = 4294967295;
class A4 {
  /**
   * Instantiate a new BitSet instance.
   * @param {number} size The number of bits.
   */
  constructor(t) {
    this._size = t, this._bits = new Uint32Array(Math.ceil(t / 32));
  }
  /**
   * The number of bits.
   * @return {number}
   */
  get length() {
    return this._size;
  }
  /**
   * The number of bits set to one.
   * https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetKernighan
   * @return {number}
   */
  count() {
    const t = this._bits.length;
    let i = 0;
    for (let r = 0; r < t; ++r)
      for (let n = this._bits[r]; n; ++i)
        n &= n - 1;
    return i;
  }
  /**
   * Get the bit at a given index.
   * @param {number} i The bit index.
   */
  get(t) {
    return this._bits[t >> 5] & jm >>> t;
  }
  /**
   * Set the bit at a given index to one.
   * @param {number} i The bit index.
   */
  set(t) {
    this._bits[t >> 5] |= jm >>> t;
  }
  /**
   * Clear the bit at a given index to zero.
   * @param {number} i The bit index.
   */
  clear(t) {
    this._bits[t >> 5] &= ~(jm >>> t);
  }
  /**
   * Scan the bits, invoking a callback function with the index of
   * each non-zero bit.
   * @param {(i: number) => void} fn A callback function.
   */
  scan(t) {
    for (let i = this.next(0); i >= 0; i = this.next(i + 1))
      t(i);
  }
  /**
   * Get the next non-zero bit starting from a given index.
   * @param {number} i The bit index.
   */
  next(t) {
    const i = this._bits, r = i.length;
    let n = t >> 5, s = i[n] & mq >>> t;
    for (; n < r; s = i[++n])
      if (s !== 0)
        return (n << 5) + Math.clz32(s);
    return -1;
  }
  /**
   * Return the index of the nth non-zero bit.
   * @param {number} n The number of non-zero bits to advance.
   * @return {number} The index of the nth non-zero bit.
   */
  nth(t) {
    let i = this.next(0);
    for (; t-- && i >= 0; )
      i = this.next(i + 1);
    return i;
  }
  /**
   * Negate all bits in this bitset.
   * Modifies this BitSet in place.
   * @return {this}
   */
  not() {
    const t = this._bits, i = t.length;
    for (let n = 0; n < i; ++n)
      t[n] = ~t[n];
    const r = this._size % 32;
    return r && (t[i - 1] &= jm >> r - 1), this;
  }
  /**
   * Compute the logical AND of this BitSet and another.
   * @param {BitSet} bitset The BitSet to combine with.
   * @return {BitSet} This BitSet updated with the logical AND.
   */
  and(t) {
    if (t) {
      const i = this._bits, r = t._bits, n = i.length;
      for (let s = 0; s < n; ++s)
        i[s] &= r[s];
    }
    return this;
  }
  /**
   * Compute the logical OR of this BitSet and another.
   * @param {BitSet} bitset The BitSet to combine with.
   * @return {BitSet} This BitSet updated with the logical OR.
   */
  or(t) {
    if (t) {
      const i = this._bits, r = t._bits, n = i.length;
      for (let s = 0; s < n; ++s)
        i[s] |= r[s];
    }
    return this;
  }
}
function gq(e, t) {
  const i = e.totalRows(), r = e.mask(), n = e.data(), s = new A4(i);
  if (r)
    for (let a = r.next(0); a >= 0; a = r.next(a + 1))
      t(a, n) && s.set(a);
  else
    for (let a = 0; a < i; ++a)
      t(a, n) && s.set(a);
  return e.create({ filter: s });
}
function yq(e, t) {
  const i = Gn({ p: t }, { table: e });
  let r = i.exprs[0];
  if (i.ops.length) {
    const { data: n } = nw(e, i, { drop: !0 }).column("p");
    r = (s) => n[s];
  }
  return gq(e, r);
}
function T4(e, { names: t = [], exprs: i = [], ops: r = [] }, n = {}) {
  if (!t.length)
    return e;
  const s = n.limit > 0 ? +n.limit : 1 / 0, a = n.index ? n.index === !0 ? "index" : n.index + "" : null, o = new Set(n.drop), c = Kl(e, r, i), l = Yn(), d = new Set(t), u = [], h = [], p = [];
  e.columnNames().forEach((E) => {
    if (!o.has(E)) {
      const Z = l.add(E, []);
      d.has(E) || (u.push(e.column(E)), h.push(Z));
    }
  }), t.forEach((E) => {
    o.has(E) || (l.has(E) || l.add(E, []), p.push(l.data[E]));
  });
  const m = a ? l.add(a, []) : null;
  let w = 0;
  const C = u.length, F = p.length, W = (E, Z) => {
    for (let yt = 0; yt < C; ++yt)
      h[yt].length = w + Z, h[yt].fill(u[yt].get(E), w, w + Z);
  }, et = m ? (E, Z) => {
    for (let yt = 0; yt < Z; ++yt)
      m[E + yt] = yt;
  } : () => {
  };
  if (F === 1) {
    const E = c[0], Z = p[0];
    e.scan((yt, bt) => {
      const Ct = Un(E(yt, bt)), Mt = Math.min(Ct.length, s);
      W(yt, Mt);
      for (let Me = 0; Me < Mt; ++Me)
        Z[w + Me] = Ct[Me];
      et(w, Mt), w += Mt;
    });
  } else
    e.scan((E, Z) => {
      let yt = 0;
      const bt = c.map((Ct) => {
        const Mt = Un(Ct(E, Z));
        return yt = Math.min(Math.max(yt, Mt.length), s), Mt;
      });
      W(E, yt);
      for (let Ct = 0; Ct < F; ++Ct) {
        const Mt = p[Ct], Me = bt[Ct];
        for (let kt = 0; kt < yt; ++kt)
          Mt[w + kt] = Me[kt];
      }
      et(w, yt), w += yt;
    });
  return e.create(l.new());
}
function vq(e, { names: t = [], exprs: i = [], ops: r = [] }, n = {}) {
  if (t.length === 0)
    return e;
  const [s = "key", a = "value"] = n.as || [], o = Kl(e, r, i);
  return T4(
    e,
    {
      names: [s, a],
      exprs: [() => t, (c, l) => o.map((d) => d(c, l))]
    },
    { ...n, drop: t }
  );
}
function Qs(e, t, i, r = { window: !1 }) {
  const n = /* @__PURE__ */ new Map(), s = (a) => {
    a = Tn(a) ? t.columnName(a) : a, fn(a) ? n.set(a, Ul(a)) : or(a) ? Ra(t, a).forEach(s) : _n(a) ? pO(n, a) : Qe(`Invalid ${e} value: ${a + ""}`);
  };
  return Un(i).forEach(s), r.preparse && r.preparse(n), Gn(n, { table: t, ...r });
}
function _q(e, t, i) {
  return vq(e, Qs("fold", e, t), i);
}
function r3(e, t, i, r) {
  const n = i && i.length;
  return bq(
    n ? xq(e, i, r) : e,
    t,
    n
  );
}
function bq(e, { names: t, exprs: i, ops: r }, n) {
  const s = Kl(e, r, i), a = n ? null : Yn(e), o = e.totalRows();
  return t.forEach((c, l) => {
    const d = e.column(c), u = n ? d.data : a.add(c, Array(o)), h = s[l];
    e.scan((p) => {
      const m = d.get(p);
      u[p] = Gs(m) ? m : h(p);
    });
  }), n ? e : e.create(a);
}
function xq(e, t, i) {
  const r = e.groups(), n = e.data(), s = (r ? r.names : []).concat(t), a = (r ? r.get : []).concat(t.map((m) => e.getter(m))), o = /* @__PURE__ */ new Set(), c = Hg(a);
  e.scan((m, w) => o.add(c(m, w)));
  const l = e.columnNames(), d = Yn(), u = l.map((m) => d.add(m, []));
  l.forEach((m, w) => {
    const C = n[m], F = u[w];
    e.scan((W) => F.push(C.get(W)));
  });
  const h = Hg(a.map((m, w) => (C) => C[w])), p = Xl(
    "v",
    "{" + u.map((m, w) => `_${w}.push(v[$${w}]);`).join("") + "}",
    u,
    l.map((m) => s.indexOf(m))
  );
  if (r) {
    let m = r.keys.length;
    const w = i.reduce((F, W) => F * W.length, r.size), C = new Uint32Array(w + (m - o.size));
    C.set(r.keys), n3(r, i, (F, W) => {
      o.has(h(F)) || (p(F), C[m++] = W[0]);
    }), d.groupby({ ...r, keys: C });
  } else
    n3(r, i, (m) => {
      o.has(h(m)) || p(m);
    });
  return e.create(d.new());
}
function n3(e, t, i) {
  const r = e ? e.get.length : 0, n = e ? 1 : 0, s = n + t.length, a = new Int32Array(s), o = new Int32Array(s), c = [];
  if (e) {
    const { get: d, rows: u, size: h } = e;
    a[0] = h, c.push((p, m) => {
      const w = u[m];
      for (let C = 0; C < r; ++C)
        p[C] = d[C](w);
    });
  }
  t.forEach((d, u) => {
    const h = u + r;
    a[u + n] = d.length, c.push((p, m) => p[h] = d[m]);
  });
  const l = Array(r + t.length);
  for (let d = 0; d < s; ++d)
    c[d](l, 0);
  i(l, o);
  for (let d = s - 1; d >= 0; ) {
    const u = ++o[d];
    u < a[d] ? (c[d](l, u), i(l, o), d = s - 1) : (o[d] = 0, c[d](l, 0), --d);
  }
}
function sw(e, { names: t, exprs: i, ops: r }) {
  const n = Yn(), s = e.groups();
  return s && S4(n, s), wq(t, i, s, dh(e, r), n), e.create(n.new());
}
function wq(e, t, i, r = [], n) {
  if (!t.length)
    return;
  const s = i ? i.size : 1, a = (c, l) => r[c][l], o = e.length;
  for (let c = 0; c < o; ++c) {
    const l = t[c];
    if (l.field != null)
      n.add(e[c], r[l.field]);
    else if (s > 1) {
      const d = n.add(e[c], Array(s));
      for (let u = 0; u < s; ++u)
        d[u] = l(u, null, a);
    } else
      n.add(e[c], [l(0, null, a)]);
  }
}
function Sq(e, t, i = {}) {
  if (t = Gn(t, { table: e }), t.names.forEach(
    (r) => e.column(r) ? 0 : Qe(`Invalid impute column ${Ss(r)}`)
  ), i.expand) {
    const r = { preparse: Iq, aggronly: !0 }, n = Qs("impute", e, i.expand, r), s = sw(e.ungroup(), n);
    return r3(
      e,
      t,
      n.names,
      n.names.map((a) => s.get(a, 0))
    );
  } else
    return r3(e, t);
}
function Iq(e) {
  e.forEach(
    (t, i) => t.field ? e.set(i, AE(t + "")) : 0
  );
}
function Aq(e, t) {
  const i = e.columnNames();
  return t.length ? t.reduce((r, n) => r.semijoin(n.select(i)), e).dedupe() : e.reify([]);
}
function E4(e, t) {
  const i = /* @__PURE__ */ new Map();
  return e.scan((r, n) => {
    const s = t(r, n);
    s != null && s === s && i.set(s, r);
  }), i;
}
function Tq(e, t, i) {
  const r = /* @__PURE__ */ new Map(), n = e.length;
  for (let s = 0; s < n; ++s) {
    const a = e[s], o = i(a, t);
    o != null && o === o && (r.has(o) ? r.get(o).push(s) : r.set(o, [s]));
  }
  return r;
}
function Eq(e, t) {
  const i = ["i", "a", "j", "b"];
  return Xl(
    i,
    "{" + Rp(e, (r, n) => `_${n}.push($${n}(${i}));`) + "}",
    e,
    t
  );
}
function kq(e, t, i, { names: r, exprs: n }, s = {}) {
  const a = e.data(), o = e.indices(!1), c = o.length, l = new Int32Array(c), d = t.data(), u = t.indices(!1), h = u.length, p = new Int32Array(h), m = r.length, w = Yn(), C = Array(m), F = Array(m);
  for (let E = 0; E < r.length; ++E)
    C[E] = w.add(r[E], []), F[E] = n[E];
  const W = Eq(C, F);
  if ((Ei(i) ? Oq : Cq)(W, i, a, d, o, u, l, p, c, h), s.left)
    for (let E = 0; E < c; ++E)
      l[E] || W(o[E], a, -1, d);
  if (s.right)
    for (let E = 0; E < h; ++E)
      p[E] || W(-1, a, u[E], d);
  return e.create(w.new());
}
function Cq(e, t, i, r, n, s, a, o, c, l) {
  for (let d = 0; d < c; ++d) {
    const u = n[d];
    for (let h = 0; h < l; ++h) {
      const p = s[h];
      t(u, i, p, r) && (e(u, i, p, r), a[d] = 1, o[h] = 1);
    }
  }
}
function Oq(e, [t, i], r, n, s, a, o, c, l, d) {
  let u, h, p, m, w, C, F, W, et = e;
  l >= d ? (u = r, h = t, p = o, m = s, w = n, C = i, F = c, W = a) : (u = n, h = i, p = c, m = a, w = r, C = t, F = o, W = s, et = (yt, bt, Ct, Mt) => e(Ct, Mt, yt, bt));
  const E = Tq(W, w, C), Z = m.length;
  for (let yt = 0; yt < Z; ++yt) {
    const bt = m[yt], Ct = E.get(h(bt, u));
    if (Ct) {
      const Mt = Ct.length;
      for (let Me = 0; Me < Mt; ++Me) {
        const kt = Ct[Me];
        et(bt, u, W[kt], w), F[kt] = 1;
      }
      p[yt] = 1;
    }
  }
}
function x0(e, t, i) {
  const r = /* @__PURE__ */ new Map();
  Un(i).forEach((s, a) => {
    s = Tn(s) ? t.columnName(s) : s, fn(s) ? r.set(a, Ul(s)) : or(s) || _n(s) && s.expr ? r.set(a, s) : Qe(`Invalid ${e} key value: ${s + ""}`);
  });
  const n = Gn(r, { table: t, aggregate: !1, window: !1 });
  return Hg(n.exprs, !0);
}
function Dq(e, t) {
  const i = new Set(t);
  return e.filter((r) => i.has(r));
}
function aw(e, t, i) {
  if (i)
    fn(i) ? i = [i, i] : Ei(i) && i.length === 1 && (i = [i[0], i[0]]);
  else {
    const r = Dq(e.columnNames(), t.columnNames());
    r.length || Qe("Natural join requires shared column names."), i = [r, r];
  }
  return i;
}
function k4(e, t, i, r) {
  return i.length !== r.length && Qe("Mismatched number of join keys"), [
    x0("join", e, i),
    x0("join", t, r)
  ];
}
const Nq = { aggregate: !1, window: !1 }, Lq = { ...Nq, index: 1 };
function s3(e, t, i, r, n = {}) {
  i = aw(e, t, i);
  const s = { join: [e, t] };
  let a;
  if (Ei(i)) {
    const [o, c] = i.map(Un);
    a = k4(e, t, o, c), r || (r = Fq(e, o, c, n));
  } else
    a = Gn({ on: i }, s).exprs[0], r || (r = [zl(), zl()]);
  return kq(
    e,
    t,
    a,
    Bq(e, t, r, s, n && n.suffix),
    n
  );
}
function Fq(e, t, i, r) {
  const n = [];
  t.forEach((a, o) => fn(a) && a === i[o] ? n.push(a) : 0);
  const s = gO(n);
  if (r.left && r.right) {
    const a = new Set(n);
    return [
      e.columnNames().map((o) => {
        const c = `[${Ss(o)}]`;
        return a.has(o) ? { [o]: `(a, b) => a${c} == null ? b${c} : a${c}` } : o;
      }),
      s
    ];
  }
  return r.right ? [s, zl()] : [zl(), s];
}
function Bq(e, t, i, r, n = []) {
  if (Ei(i)) {
    let s, a, o, c = i.length;
    s = a = o = { names: [], exprs: [] }, c-- && (s = Qs("join", e, i[0], r)), c-- && (a = Qs("join", t, i[1], Lq)), c-- && (o = Gn(i[2], r));
    const l = /* @__PURE__ */ new Set(), d = new Set(s.names);
    return a.names.forEach((u) => {
      d.has(u) && l.add(u);
    }), l.size && (n[0] !== "" && a3(s.names, l, n[0] || "_1"), n[1] !== "" && a3(a.names, l, n[1] || "_2")), {
      names: s.names.concat(a.names, o.names),
      exprs: s.exprs.concat(a.exprs, o.exprs)
    };
  } else
    return Gn(i, r);
}
function a3(e, t, i) {
  e.forEach((r, n) => t.has(r) ? e[n] = r + i : 0);
}
function Rq(e, t, i, r = {}) {
  const n = new A4(e.totalRows());
  return (Ei(i) ? Mq : Pq)(n, e, t, i), r.anti && n.not().and(e.mask()), e.create({ filter: n });
}
function Mq(e, t, i, [r, n]) {
  const s = E4(i, n);
  t.scan((a, o) => {
    s.get(r(a, o)) >= 0 && e.set(a);
  });
}
function Pq(e, t, i, r) {
  const n = t.numRows(), s = i.numRows(), a = t.data(), o = i.data();
  if (t.isFiltered() || i.isFiltered()) {
    const c = t.indices(!1), l = i.indices(!1);
    for (let d = 0; d < n; ++d) {
      const u = c[d];
      for (let h = 0; h < s; ++h)
        if (r(u, a, l[h], o)) {
          e.set(u);
          break;
        }
    }
  } else
    for (let c = 0; c < n; ++c)
      for (let l = 0; l < s; ++l)
        if (r(c, a, l, o)) {
          e.set(c);
          break;
        }
}
function o3(e, t, i, r) {
  i = aw(e, t, i);
  const n = Ei(i) ? k4(e, t, ...i.map(Un)) : Gn({ on: i }, { join: [e, t] }).exprs[0];
  return Rq(e, t, n, r);
}
function $q(e, t, [i, r], { names: n, exprs: s, ops: a }) {
  const o = Yn(e), c = e.totalRows();
  n.forEach((h) => o.add(h, Array(c).fill(Si)));
  const l = E4(t, r), d = Xl(
    ["lr", "rr", "data"],
    "{" + Rp(n, (h, p) => `_[${p}][lr] = $[${p}](rr, data);`) + "}",
    n.map((h) => o.data[h]),
    Kl(t, a, s)
  ), u = t.data();
  return e.scan((h, p) => {
    const m = l.get(i(h, p));
    m >= 0 && d(h, m, u);
  }), e.create(o);
}
function zq(e, t, i, r) {
  return i = aw(e, t, i), $q(
    e,
    t,
    [x0("lookup", e, i[0]), x0("lookup", t, i[1])],
    Qs("lookup", t, r)
  );
}
const Rb = (e, t) => e ?? t;
function Uq(e, t, i, r = {}) {
  const { keys: n, keyColumn: s } = Vq(e, t, r), a = Rb(r.valueSeparator, "_"), o = i.names.length > 1 ? (l, d) => d + a + n[l] : (l) => n[l], c = n.map(
    (l) => dh(e, i.ops.map((d) => {
      if (d.name === "count") {
        const h = (p) => l === s[p] ? 1 : NaN;
        return h.toString = () => l + ":1", { ...d, name: "sum", fields: [h] };
      }
      const u = d.fields.map((h) => {
        const p = (m, w) => l === s[m] ? h(m, w) : NaN;
        return p.toString = () => l + ":" + h, p;
      });
      return { ...d, fields: u };
    }))
  );
  return e.create(jq(i, o, e.groups(), c));
}
function Vq(e, t, i) {
  const r = i.limit > 0 ? +i.limit : 1 / 0, n = Rb(i.sort, !0), s = Rb(i.keySeparator, "_"), a = Kl(e, t.ops, t.exprs), o = a.length === 1 ? a[0] : (u, h) => a.map((p) => p(u, h)).join(s), c = Array(e.totalRows());
  e.scan((u, h) => c[u] = o(u, h));
  const l = dh(
    e.ungroup(),
    [{
      id: 0,
      name: "array_agg_distinct",
      fields: [(u) => c[u]],
      params: []
    }]
  )[0][0], d = n ? l.sort() : l;
  return {
    keys: Number.isFinite(r) ? d.slice(0, r) : d,
    keyColumn: c
  };
}
function jq({ names: e, exprs: t }, i, r, n) {
  const s = r ? r.size : 1, a = Yn(), o = n.length, c = e.length;
  let l;
  const d = (u, h) => l[u][h];
  r && S4(a, r);
  for (let u = 0; u < c; ++u) {
    const h = t[u];
    if (h.field != null)
      for (let p = 0; p < o; ++p)
        a.add(i(p, e[u]), n[p][h.field]);
    else if (s > 1)
      for (let p = 0; p < o; ++p) {
        l = n[p];
        const m = a.add(i(p, e[u]), Array(s));
        for (let w = 0; w < s; ++w)
          m[w] = h(w, null, d);
      }
    else
      for (let p = 0; p < o; ++p)
        l = n[p], a.add(i(p, e[u]), [h(0, null, d)]);
  }
  return a.new();
}
function Gq(e, t, i, r) {
  return Uq(
    e,
    Qs("fold", e, t),
    Qs("fold", e, i, { preparse: Hq, aggronly: !0 }),
    r
  );
}
function Hq(e) {
  e.forEach(
    (t, i) => t.field ? e.set(i, wE(t + "")) : 0
  );
}
function Wq(e, t) {
  const i = /* @__PURE__ */ new Map();
  return e.columnNames((r) => (i.set(r, r), 0)), ew(e, Ra(e, t, i));
}
function c3(e, t) {
  return sw(e, Gn(t, { table: e, aggronly: !0, window: !1 }));
}
function Yq(e, t, i, r) {
  return (t ? r ? Zq : qq : r ? Kq : Xq)(e.length, e, i, r);
}
function qq(e, t, i) {
  const r = i.length;
  for (let n = 0; n < e; ++n)
    t[n] = i[r * th() | 0];
  return t;
}
function Zq(e, t, i, r) {
  const n = i.length, s = new Float64Array(n);
  let a = 0;
  for (let c = 0; c < n; ++c)
    s[c] = a += r(i[c]);
  const o = I4(iw).right;
  for (let c = 0; c < e; ++c)
    t[c] = i[o(s, a * th())];
  return t;
}
function Xq(e, t, i) {
  const r = i.length;
  if (e >= r)
    return i;
  for (let n = 0; n < e; ++n)
    t[n] = i[n];
  for (let n = e; n < r; ++n) {
    const s = n * th();
    s < e && (t[s | 0] = i[n]);
  }
  return t;
}
function Kq(e, t, i, r) {
  const n = i.length;
  if (e >= n)
    return i;
  const s = new Float32Array(n), a = new Uint32Array(n);
  for (let o = 0; o < n; ++o)
    a[o] = o, s[o] = -Math.log(th()) / r(i[o]);
  a.sort((o, c) => s[o] - s[c]);
  for (let o = 0; o < e; ++o)
    t[o] = i[a[o]];
  return t;
}
function Jq(e, t = 0, i = e.length) {
  let r = i - (t = +t);
  for (; r; ) {
    const n = th() * r-- | 0, s = e[r + t];
    e[r + t] = e[n + t], e[n + t] = s;
  }
  return e;
}
function Qq(e, t, i, r = {}) {
  const { replace: n, shuffle: s } = r, a = e.partitions(!1);
  let o = 0;
  t = a.map((d, u) => {
    let h = t(u);
    return o += h = n ? h : Math.min(d.length, h), h;
  });
  const c = new Uint32Array(o);
  let l = 0;
  return a.forEach((d, u) => {
    const h = t[u], p = c.subarray(l, l += h);
    !n && h === d.length ? p.set(d) : Yq(p, n, d, i);
  }), s !== !1 && (a.length > 1 || !n) && Jq(c), e.reify(c);
}
function tZ(e, t, i = {}) {
  return Qq(
    e,
    eZ(e, t),
    iZ(e, i.weight),
    i
  );
}
const C4 = (e) => (t) => e.get(t) || 0;
function eZ(e, t) {
  return Tn(t) ? () => t : C4(sw(e, Gn({ size: t }, { table: e, window: !1 })).column("size"));
}
function iZ(e, t) {
  return t == null ? null : (t = Tn(t) ? e.columnName(t) : t, C4(
    fn(t) ? e.column(t) : nw(e, Gn({ w: t }, { table: e }), { drop: !0 }).column("w")
  ));
}
function rZ(e, t) {
  return ew(e, Ra(e, t));
}
function nZ(e, { names: t, exprs: i, ops: r = [] }, n = {}) {
  if (t.length === 0)
    return e;
  const s = t.length === 1 && n.as || [], a = n.drop == null ? !0 : !!n.drop, o = n.limit == null ? s.length || 1 / 0 : Math.max(1, +n.limit || 1), c = Kl(e, r, i), l = Yn(), d = t.reduce((h, p, m) => h.set(p, m), /* @__PURE__ */ new Map()), u = (h, p) => {
    const m = sZ(e, c[h], o), w = m.length;
    for (let C = 0; C < w; ++C)
      l.add(s[C] || `${p}_${C + 1}`, m[C]);
  };
  return e.columnNames().forEach((h) => {
    d.has(h) ? (a || l.add(h, e.column(h)), u(d.get(h), h), d.delete(h)) : l.add(h, e.column(h));
  }), d.forEach(u), e.create(l);
}
function sZ(e, t, i) {
  const r = e.totalRows(), n = [];
  return e.scan((s, a) => {
    const o = Un(t(s, a)), c = Math.min(o.length, i);
    for (; n.length < c; )
      n.push(Array(r).fill(Si));
    for (let l = 0; l < c; ++l)
      n[l][s] = o[l];
  }), n;
}
function aZ(e, t, i) {
  return nZ(e, Qs("spread", e, t), i);
}
function oZ(e, t) {
  return e.concat(t).dedupe();
}
function cZ(e, t, i) {
  return T4(
    e,
    Qs("unroll", e, t),
    i && i.drop ? { ...i, drop: Qs("unroll", e, i.drop).names } : i
  );
}
function lZ(e, t) {
  return e.create({
    groups: dZ(e, t)
  });
}
function dZ(e, { names: t = [], exprs: i = [], ops: r = [] }) {
  const n = t.length;
  if (n === 0)
    return null;
  if (n === 1 && !e.isFiltered() && i[0].field) {
    const p = e.column(i[0].field);
    if (p.groups)
      return p.groups(t);
  }
  let s = Kl(e, r, i);
  const a = Hg(s), o = e.totalRows(), c = new Uint32Array(o), l = {}, d = [], u = e.data(), h = e.mask();
  if (h)
    for (let p = h.next(0); p >= 0; p = h.next(p + 1)) {
      const m = a(p, u) + "", w = l[m];
      c[p] = w ?? (l[m] = d.push(p) - 1);
    }
  else
    for (let p = 0; p < o; ++p) {
      const m = a(p, u) + "", w = l[m];
      c[p] = w ?? (l[m] = d.push(p) - 1);
    }
  return r.length || (s = s.map((p) => (m) => p(m, u))), { keys: c, get: s, names: t, rows: d, size: d.length };
}
function uZ(e, t) {
  return lZ(e, Qs("groupby", e, t));
}
function hZ(e, t) {
  return e.create({ order: t });
}
const fZ = (e, t, i, r) => `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${i}
    : (u > v || v == null) && u != null ? ${r}
    : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${i}
    : v !== v && u === u ? ${r} : `;
function pZ(e, t) {
  const i = [], r = [], n = [];
  let s = null, a = "0", o = "0";
  e.isGrouped() && (s = e.groups().keys, a = "ka", o = "kb");
  const { ops: c } = Gn(t, {
    table: e,
    value: (p, m) => {
      if (i.push(p), m.escape) {
        const w = (C) => `fn[${n.length}](${C}, data)`;
        r.push([w("a"), w("b")]), n.push(m.escape);
      } else
        r.push([
          Gg(m, { index: "a", op: a }),
          Gg(m, { index: "b", op: o })
        ]);
    },
    window: !1
  }), l = dh(e, c), d = (p, m) => l[p][m], u = i.length;
  let h = "return (a, b) => {" + (d && e.isGrouped() ? "const ka = keys[a], kb = keys[b];" : "") + "let u, v; return ";
  for (let p = 0; p < u; ++p) {
    const m = t.get(i[p]).desc ? -1 : 1, [w, C] = r[p];
    h += fZ(w, C, -m, m);
  }
  return h += "0;};", Function("op", "keys", "fn", "data", h)(d, s, n, e.data());
}
function mZ(e, t) {
  return hZ(e, gZ(e, t));
}
function gZ(e, t) {
  let i = -1;
  const r = /* @__PURE__ */ new Map(), n = (s) => r.set(++i + "", s);
  return t.forEach((s) => {
    const a = s.expr != null ? s.expr : s;
    if (_n(a) && !or(a))
      for (const o in a)
        n(a[o]);
    else
      n(
        Tn(a) ? Ul(s, e.columnName(a)) : fn(a) ? Ul(s) : or(a) ? s : Qe(`Invalid orderby field: ${s + ""}`)
      );
  }), pZ(e, r);
}
function yZ(e, t) {
  const i = e.numRows(), r = i + t.reduce((a, o) => a + o.numRows(), 0);
  if (i === r)
    return e;
  const n = [e, ...t], s = Yn();
  return e.columnNames().forEach((a) => {
    const o = Array(r);
    let c = 0;
    n.forEach((l) => {
      const d = l.column(a) || { get: () => Si };
      l.scan((u) => o[c++] = d.get(u));
    }), s.add(a, o);
  }), e.create(s.new());
}
function vZ(e, t) {
  const i = Yn(), r = e.groups(), { get: n, names: s = [], rows: a, size: o = 1 } = r || {}, c = new Uint32Array(o + 1);
  s.forEach((h) => i.add(h, null));
  const l = r ? w4(e, t, r) : [x4(e, t)];
  t.outputs().map((h) => i.add(h, []));
  const d = c.length - 1;
  let u = 0;
  for (let h = 0; h < d; ++h)
    u += c[h + 1] = t.write(l[h], i.data, c[h]);
  if (r) {
    const h = e.data();
    s.forEach((p, m) => {
      const w = i.data[p] = Array(u), C = n[m];
      for (let F = 0, W = 0; F < o; ++F)
        w.fill(C(a[F], h), W, W += c[F + 1]);
    });
  }
  return e.create(i.new());
}
function _Z(e) {
  return e.isGrouped() ? e.create({ groups: null }) : e;
}
function bZ(e) {
  return e.isOrdered() ? e.create({ order: null }) : e;
}
const xZ = {
  __antijoin: (e, t, i) => o3(e, t, i, { anti: !0 }),
  __count: (e, t = {}) => c3(e, { [t.as || "count"]: SE() }),
  __cross: (e, t, i, r) => s3(e, t, () => !0, i, {
    ...r,
    left: !0,
    right: !0
  }),
  __concat: yZ,
  __dedupe: qY,
  __derive: fq,
  __except: pq,
  __filter: yq,
  __fold: _q,
  __impute: Sq,
  __intersect: Aq,
  __join: s3,
  __lookup: zq,
  __pivot: Gq,
  __relocate: _4,
  __rename: Wq,
  __rollup: c3,
  __sample: tZ,
  __select: rZ,
  __semijoin: o3,
  __spread: aZ,
  __union: oZ,
  __unroll: cZ,
  __groupby: uZ,
  __orderby: mZ,
  __ungroup: _Z,
  __unorder: bZ,
  __reduce: vZ
};
Object.assign(go.prototype, xZ);
go.prototype;
const wZ = new TextDecoder("utf-8"), Mb = (e) => wZ.decode(e), SZ = new TextEncoder(), ow = (e) => SZ.encode(e), IZ = (e) => typeof e == "number", AZ = (e) => typeof e == "boolean", In = (e) => typeof e == "function", ta = (e) => e != null && Object(e) === e, Zf = (e) => ta(e) && In(e.then), zy = (e) => ta(e) && In(e[Symbol.iterator]), cw = (e) => ta(e) && In(e[Symbol.asyncIterator]), Pb = (e) => ta(e) && ta(e.schema), O4 = (e) => ta(e) && "done" in e && "value" in e, D4 = (e) => ta(e) && In(e.stat) && IZ(e.fd), N4 = (e) => ta(e) && lw(e.body), L4 = (e) => "_getDOMStream" in e && "_getNodeStream" in e, lw = (e) => ta(e) && In(e.cancel) && In(e.getReader) && !L4(e), F4 = (e) => ta(e) && In(e.read) && In(e.pipe) && AZ(e.readable) && !L4(e), TZ = (e) => ta(e) && In(e.clear) && In(e.bytes) && In(e.position) && In(e.setPosition) && In(e.capacity) && In(e.getBufferIdentifier) && In(e.createLong), dw = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
function EZ(e) {
  const t = e[0] ? [e[0]] : [];
  let i, r, n, s;
  for (let a, o, c = 0, l = 0, d = e.length; ++c < d; ) {
    if (a = t[l], o = e[c], !a || !o || a.buffer !== o.buffer || o.byteOffset < a.byteOffset) {
      o && (t[++l] = o);
      continue;
    }
    if ({ byteOffset: i, byteLength: n } = a, { byteOffset: r, byteLength: s } = o, i + n < r || r + s < i) {
      o && (t[++l] = o);
      continue;
    }
    t[l] = new Uint8Array(a.buffer, i, r - i + s);
  }
  return t;
}
function l3(e, t, i = 0, r = t.byteLength) {
  const n = e.byteLength, s = new Uint8Array(e.buffer, e.byteOffset, n), a = new Uint8Array(t.buffer, t.byteOffset, Math.min(r, n));
  return s.set(a, i), e;
}
function Ma(e, t) {
  const i = EZ(e), r = i.reduce((d, u) => d + u.byteLength, 0);
  let n, s, a, o = 0, c = -1;
  const l = Math.min(t || Number.POSITIVE_INFINITY, r);
  for (const d = i.length; ++c < d; ) {
    if (n = i[c], s = n.subarray(0, Math.min(n.length, l - o)), l <= o + s.length) {
      s.length < n.length ? i[c] = n.subarray(s.length) : s.length === n.length && c++, a ? l3(a, s, o) : a = s;
      break;
    }
    l3(a || (a = new Uint8Array(l)), s, o), o += s.length;
  }
  return [a || new Uint8Array(0), i.slice(c), r - (a ? a.byteLength : 0)];
}
function $i(e, t) {
  let i = O4(t) ? t.value : t;
  return i instanceof e ? e === Uint8Array ? new e(i.buffer, i.byteOffset, i.byteLength) : i : i ? (typeof i == "string" && (i = ow(i)), i instanceof ArrayBuffer ? new e(i) : i instanceof dw ? new e(i) : TZ(i) ? $i(e, i.bytes()) : ArrayBuffer.isView(i) ? i.byteLength <= 0 ? new e(0) : new e(i.buffer, i.byteOffset, i.byteLength / e.BYTES_PER_ELEMENT) : e.from(i)) : new e(0);
}
const Zh = (e) => $i(Int32Array, e), d3 = (e) => $i(BigInt64Array, e), _i = (e) => $i(Uint8Array, e), $b = (e) => (e.next(), e);
function* kZ(e, t) {
  const i = function* (n) {
    yield n;
  }, r = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof dw ? i(t) : zy(t) ? t : i(t);
  return yield* $b(function* (n) {
    let s = null;
    do
      s = n.next(yield $i(e, s));
    while (!s.done);
  }(r[Symbol.iterator]())), new e();
}
const CZ = (e) => kZ(Uint8Array, e);
function B4(e, t) {
  return jr(this, arguments, function* () {
    if (Zf(t))
      return yield Vt(yield Vt(yield* xc(es(B4(e, yield Vt(t))))));
    const r = function(a) {
      return jr(this, arguments, function* () {
        yield yield Vt(yield Vt(a));
      });
    }, n = function(a) {
      return jr(this, arguments, function* () {
        yield Vt(yield* xc(es($b(function* (o) {
          let c = null;
          do
            c = o.next(yield c == null ? void 0 : c.value);
          while (!c.done);
        }(a[Symbol.iterator]())))));
      });
    }, s = typeof t == "string" || ArrayBuffer.isView(t) || t instanceof ArrayBuffer || t instanceof dw ? r(t) : zy(t) ? n(t) : cw(t) ? t : r(t);
    return yield Vt(
      // otherwise if AsyncIterable, use it
      yield* xc(es($b(function(a) {
        return jr(this, arguments, function* () {
          let o = null;
          do
            o = yield Vt(a.next(yield yield Vt($i(e, o))));
          while (!o.done);
        });
      }(s[Symbol.asyncIterator]()))))
    ), yield Vt(new e());
  });
}
const OZ = (e) => B4(Uint8Array, e);
function DZ(e, t) {
  let i = 0;
  const r = e.length;
  if (r !== t.length)
    return !1;
  if (r > 0)
    do
      if (e[i] !== t[i])
        return !1;
    while (++i < r);
  return !0;
}
const ms = {
  fromIterable(e) {
    return Gm(NZ(e));
  },
  fromAsyncIterable(e) {
    return Gm(LZ(e));
  },
  fromDOMStream(e) {
    return Gm(FZ(e));
  },
  fromNodeStream(e) {
    return Gm(RZ(e));
  },
  // @ts-ignore
  toDOMStream(e, t) {
    throw new Error('"toDOMStream" not available in this environment');
  },
  // @ts-ignore
  toNodeStream(e, t) {
    throw new Error('"toNodeStream" not available in this environment');
  }
}, Gm = (e) => (e.next(), e);
function* NZ(e) {
  let t, i = !1, r = [], n, s, a, o = 0;
  function c() {
    return s === "peek" ? Ma(r, a)[0] : ([n, r, o] = Ma(r, a), n);
  }
  ({ cmd: s, size: a } = (yield null) || { cmd: "read", size: 0 });
  const l = CZ(e)[Symbol.iterator]();
  try {
    do
      if ({ done: t, value: n } = Number.isNaN(a - o) ? l.next() : l.next(a - o), !t && n.byteLength > 0 && (r.push(n), o += n.byteLength), t || a <= o)
        do
          ({ cmd: s, size: a } = yield c());
        while (a < o);
    while (!t);
  } catch (d) {
    (i = !0) && typeof l.throw == "function" && l.throw(d);
  } finally {
    i === !1 && typeof l.return == "function" && l.return(null);
  }
  return null;
}
function LZ(e) {
  return jr(this, arguments, function* () {
    let i, r = !1, n = [], s, a, o, c = 0;
    function l() {
      return a === "peek" ? Ma(n, o)[0] : ([s, n, c] = Ma(n, o), s);
    }
    ({ cmd: a, size: o } = (yield yield Vt(null)) || { cmd: "read", size: 0 });
    const d = OZ(e)[Symbol.asyncIterator]();
    try {
      do
        if ({ done: i, value: s } = Number.isNaN(o - c) ? yield Vt(d.next()) : yield Vt(d.next(o - c)), !i && s.byteLength > 0 && (n.push(s), c += s.byteLength), i || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(l()));
          while (o < c);
      while (!i);
    } catch (u) {
      (r = !0) && typeof d.throw == "function" && (yield Vt(d.throw(u)));
    } finally {
      r === !1 && typeof d.return == "function" && (yield Vt(d.return(new Uint8Array(0))));
    }
    return yield Vt(null);
  });
}
function FZ(e) {
  return jr(this, arguments, function* () {
    let i = !1, r = !1, n = [], s, a, o, c = 0;
    function l() {
      return a === "peek" ? Ma(n, o)[0] : ([s, n, c] = Ma(n, o), s);
    }
    ({ cmd: a, size: o } = (yield yield Vt(null)) || { cmd: "read", size: 0 });
    const d = new BZ(e);
    try {
      do
        if ({ done: i, value: s } = Number.isNaN(o - c) ? yield Vt(d.read()) : yield Vt(d.read(o - c)), !i && s.byteLength > 0 && (n.push(_i(s)), c += s.byteLength), i || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(l()));
          while (o < c);
      while (!i);
    } catch (u) {
      (r = !0) && (yield Vt(d.cancel(u)));
    } finally {
      r === !1 ? yield Vt(d.cancel()) : e.locked && d.releaseLock();
    }
    return yield Vt(null);
  });
}
class BZ {
  constructor(t) {
    this.source = t, this.reader = null, this.reader = this.source.getReader(), this.reader.closed.catch(() => {
    });
  }
  get closed() {
    return this.reader ? this.reader.closed.catch(() => {
    }) : Promise.resolve();
  }
  releaseLock() {
    this.reader && this.reader.releaseLock(), this.reader = null;
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      const { reader: i, source: r } = this;
      i && (yield i.cancel(t).catch(() => {
      })), r && r.locked && this.releaseLock();
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      if (t === 0)
        return { done: this.reader == null, value: new Uint8Array(0) };
      const i = yield this.reader.read();
      return !i.done && (i.value = _i(i)), i;
    });
  }
}
const O_ = (e, t) => {
  const i = (n) => r([t, n]);
  let r;
  return [t, i, new Promise((n) => (r = n) && e.once(t, i))];
};
function RZ(e) {
  return jr(this, arguments, function* () {
    const i = [];
    let r = "error", n = !1, s = null, a, o, c = 0, l = [], d;
    function u() {
      return a === "peek" ? Ma(l, o)[0] : ([d, l, c] = Ma(l, o), d);
    }
    if ({ cmd: a, size: o } = (yield yield Vt(null)) || { cmd: "read", size: 0 }, e.isTTY)
      return yield yield Vt(new Uint8Array(0)), yield Vt(null);
    try {
      i[0] = O_(e, "end"), i[1] = O_(e, "error");
      do {
        if (i[2] = O_(e, "readable"), [r, s] = yield Vt(Promise.race(i.map((p) => p[2]))), r === "error")
          break;
        if ((n = r === "end") || (Number.isFinite(o - c) ? (d = _i(e.read(o - c)), d.byteLength < o - c && (d = _i(e.read()))) : d = _i(e.read()), d.byteLength > 0 && (l.push(d), c += d.byteLength)), n || o <= c)
          do
            ({ cmd: a, size: o } = yield yield Vt(u()));
          while (o < c);
      } while (!n);
    } finally {
      yield Vt(h(i, r === "error" ? s : null));
    }
    return yield Vt(null);
    function h(p, m) {
      return d = l = null, new Promise((w, C) => {
        for (const [F, W] of p)
          e.off(F, W);
        try {
          const F = e.destroy;
          F && F.call(e, m), m = void 0;
        } catch (F) {
          m = F || m;
        } finally {
          m != null ? C(m) : w();
        }
      });
    }
  });
}
var Vr;
(function(e) {
  e[e.V1 = 0] = "V1", e[e.V2 = 1] = "V2", e[e.V3 = 2] = "V3", e[e.V4 = 3] = "V4", e[e.V5 = 4] = "V5";
})(Vr || (Vr = {}));
var Hn;
(function(e) {
  e[e.Sparse = 0] = "Sparse", e[e.Dense = 1] = "Dense";
})(Hn || (Hn = {}));
var vn;
(function(e) {
  e[e.HALF = 0] = "HALF", e[e.SINGLE = 1] = "SINGLE", e[e.DOUBLE = 2] = "DOUBLE";
})(vn || (vn = {}));
var ea;
(function(e) {
  e[e.DAY = 0] = "DAY", e[e.MILLISECOND = 1] = "MILLISECOND";
})(ea || (ea = {}));
var Se;
(function(e) {
  e[e.SECOND = 0] = "SECOND", e[e.MILLISECOND = 1] = "MILLISECOND", e[e.MICROSECOND = 2] = "MICROSECOND", e[e.NANOSECOND = 3] = "NANOSECOND";
})(Se || (Se = {}));
var Pa;
(function(e) {
  e[e.YEAR_MONTH = 0] = "YEAR_MONTH", e[e.DAY_TIME = 1] = "DAY_TIME", e[e.MONTH_DAY_NANO = 2] = "MONTH_DAY_NANO";
})(Pa || (Pa = {}));
var w0;
(function(e) {
  e[e.BUFFER = 0] = "BUFFER";
})(w0 || (w0 = {}));
var S0;
(function(e) {
  e[e.LZ4_FRAME = 0] = "LZ4_FRAME", e[e.ZSTD = 1] = "ZSTD";
})(S0 || (S0 = {}));
class mc {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBodyCompression(t, i) {
    return (i || new mc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBodyCompression(t, i) {
    return t.setPosition(t.position() + de), (i || new mc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Compressor library.
   * For LZ4_FRAME, each compressed buffer must consist of a single frame.
   */
  codec() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt8(this.bb_pos + t) : S0.LZ4_FRAME;
  }
  /**
   * Indicates the way the record batch body was compressed
   */
  method() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt8(this.bb_pos + t) : w0.BUFFER;
  }
  static startBodyCompression(t) {
    t.startObject(2);
  }
  static addCodec(t, i) {
    t.addFieldInt8(0, i, S0.LZ4_FRAME);
  }
  static addMethod(t, i) {
    t.addFieldInt8(1, i, w0.BUFFER);
  }
  static endBodyCompression(t) {
    return t.endObject();
  }
  static createBodyCompression(t, i, r) {
    return mc.startBodyCompression(t), mc.addCodec(t, i), mc.addMethod(t, r), mc.endBodyCompression(t);
  }
}
class R4 {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * The relative offset into the shared memory page where the bytes for this
   * buffer starts
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The absolute length (in bytes) of the memory buffer. The memory is found
   * from offset (inclusive) to offset + length (non-inclusive). When building
   * messages using the encapsulated IPC message, padding bytes may be written
   * after a buffer, but such padding bytes do not need to be accounted for in
   * the size here.
   */
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(t, i, r) {
    return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
}
let M4 = class {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * The number of value slots in the Arrow array at this level of a nested
   * tree
   */
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * The number of observed nulls. Fields with null_count == 0 may choose not
   * to write their physical validity bitmap out as a materialized buffer,
   * instead setting the length of the bitmap buffer to 0.
   */
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(t, i, r) {
    return t.prep(8, 16), t.writeInt64(BigInt(r ?? 0)), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
}, lo = class zb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsRecordBatch(t, i) {
    return (i || new zb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsRecordBatch(t, i) {
    return t.setPosition(t.position() + de), (i || new zb()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * number of records / rows. The arrays in the batch should all have this
   * length
   */
  length() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * Nodes correspond to the pre-ordered flattened logical schema
   */
  nodes(t, i) {
    const r = this.bb.__offset(this.bb_pos, 6);
    return r ? (i || new M4()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
  }
  nodesLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Buffers correspond to the pre-ordered flattened buffer tree
   *
   * The number of buffers appended to this list depends on the schema. For
   * example, most primitive arrays will have 2 buffers, 1 for the validity
   * bitmap and 1 for the values. For struct arrays, there will only be a
   * single buffer for the validity (nulls) bitmap
   */
  buffers(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new R4()).__init(this.bb.__vector(this.bb_pos + r) + t * 16, this.bb) : null;
  }
  buffersLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Optional compression of the message body
   */
  compression(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? (t || new mc()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  static startRecordBatch(t) {
    t.startObject(4);
  }
  static addLength(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addNodes(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static startNodesVector(t, i) {
    t.startVector(16, i, 8);
  }
  static addBuffers(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static startBuffersVector(t, i) {
    t.startVector(16, i, 8);
  }
  static addCompression(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static endRecordBatch(t) {
    return t.endObject();
  }
}, Wd = class Ub {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDictionaryBatch(t, i) {
    return (i || new Ub()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryBatch(t, i) {
    return t.setPosition(t.position() + de), (i || new Ub()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  data(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new lo()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * If isDelta is true the values in the dictionary are to be appended to a
   * dictionary with the indicated id. If isDelta is false this dictionary
   * should replace the existing dictionary.
   */
  isDelta() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startDictionaryBatch(t) {
    t.startObject(3);
  }
  static addId(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addData(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addIsDelta(t, i) {
    t.addFieldInt8(2, +i, 0);
  }
  static endDictionaryBatch(t) {
    return t.endObject();
  }
};
var Hu;
(function(e) {
  e[e.Little = 0] = "Little", e[e.Big = 1] = "Big";
})(Hu || (Hu = {}));
var I0;
(function(e) {
  e[e.DenseArray = 0] = "DenseArray";
})(I0 || (I0 = {}));
class ts {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsInt(t, i) {
    return (i || new ts()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInt(t, i) {
    return t.setPosition(t.position() + de), (i || new ts()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  isSigned() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startInt(t) {
    t.startObject(2);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static addIsSigned(t, i) {
    t.addFieldInt8(1, +i, 0);
  }
  static endInt(t) {
    return t.endObject();
  }
  static createInt(t, i, r) {
    return ts.startInt(t), ts.addBitWidth(t, i), ts.addIsSigned(t, r), ts.endInt(t);
  }
}
class yo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDictionaryEncoding(t, i) {
    return (i || new yo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDictionaryEncoding(t, i) {
    return t.setPosition(t.position() + de), (i || new yo()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * The known dictionary id in the application where this data is used. In
   * the file or streaming formats, the dictionary ids are found in the
   * DictionaryBatch messages
   */
  id() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  /**
   * The dictionary indices are constrained to be non-negative integers. If
   * this field is null, the indices must be signed int32. To maximize
   * cross-language compatibility and performance, implementations are
   * recommended to prefer signed integer types over unsigned integer types
   * and to avoid uint64 indices unless they are required by an application.
   */
  indexType(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new ts()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * By default, dictionaries are not ordered, or the order does not have
   * semantic meaning. In some statistical, applications, dictionary-encoding
   * is used to represent ordered categorical data, and we provide a way to
   * preserve that metadata here
   */
  isOrdered() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  dictionaryKind() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt16(this.bb_pos + t) : I0.DenseArray;
  }
  static startDictionaryEncoding(t) {
    t.startObject(4);
  }
  static addId(t, i) {
    t.addFieldInt64(0, i, BigInt("0"));
  }
  static addIndexType(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addIsOrdered(t, i) {
    t.addFieldInt8(2, +i, 0);
  }
  static addDictionaryKind(t, i) {
    t.addFieldInt16(3, i, I0.DenseArray);
  }
  static endDictionaryEncoding(t) {
    return t.endObject();
  }
}
class Jr {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsKeyValue(t, i) {
    return (i || new Jr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsKeyValue(t, i) {
    return t.setPosition(t.position() + de), (i || new Jr()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  key(t) {
    const i = this.bb.__offset(this.bb_pos, 4);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  value(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  static startKeyValue(t) {
    t.startObject(2);
  }
  static addKey(t, i) {
    t.addFieldOffset(0, i, 0);
  }
  static addValue(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static endKeyValue(t) {
    return t.endObject();
  }
  static createKeyValue(t, i, r) {
    return Jr.startKeyValue(t), Jr.addKey(t, i), Jr.addValue(t, r), Jr.endKeyValue(t);
  }
}
let u3 = class uf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBinary(t, i) {
    return (i || new uf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBinary(t, i) {
    return t.setPosition(t.position() + de), (i || new uf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBinary(t) {
    t.startObject(0);
  }
  static endBinary(t) {
    return t.endObject();
  }
  static createBinary(t) {
    return uf.startBinary(t), uf.endBinary(t);
  }
}, h3 = class hf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsBool(t, i) {
    return (i || new hf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsBool(t, i) {
    return t.setPosition(t.position() + de), (i || new hf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startBool(t) {
    t.startObject(0);
  }
  static endBool(t) {
    return t.endObject();
  }
  static createBool(t) {
    return hf.startBool(t), hf.endBool(t);
  }
}, mg = class Yd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDate(t, i) {
    return (i || new Yd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDate(t, i) {
    return t.setPosition(t.position() + de), (i || new Yd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : ea.MILLISECOND;
  }
  static startDate(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, ea.MILLISECOND);
  }
  static endDate(t) {
    return t.endObject();
  }
  static createDate(t, i) {
    return Yd.startDate(t), Yd.addUnit(t, i), Yd.endDate(t);
  }
}, qd = class uc {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDecimal(t, i) {
    return (i || new uc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDecimal(t, i) {
    return t.setPosition(t.position() + de), (i || new uc()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Total number of decimal digits
   */
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of digits after the decimal point "."
   */
  scale() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  /**
   * Number of bits per value. The only accepted widths are 128 and 256.
   * We use bitWidth for consistency with Int::bitWidth.
   */
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readInt32(this.bb_pos + t) : 128;
  }
  static startDecimal(t) {
    t.startObject(3);
  }
  static addPrecision(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static addScale(t, i) {
    t.addFieldInt32(1, i, 0);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(2, i, 128);
  }
  static endDecimal(t) {
    return t.endObject();
  }
  static createDecimal(t, i, r, n) {
    return uc.startDecimal(t), uc.addPrecision(t, i), uc.addScale(t, r), uc.addBitWidth(t, n), uc.endDecimal(t);
  }
}, gg = class Zd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsDuration(t, i) {
    return (i || new Zd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsDuration(t, i) {
    return t.setPosition(t.position() + de), (i || new Zd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Se.MILLISECOND;
  }
  static startDuration(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Se.MILLISECOND);
  }
  static endDuration(t) {
    return t.endObject();
  }
  static createDuration(t, i) {
    return Zd.startDuration(t), Zd.addUnit(t, i), Zd.endDuration(t);
  }
}, yg = class Xd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFixedSizeBinary(t, i) {
    return (i || new Xd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeBinary(t, i) {
    return t.setPosition(t.position() + de), (i || new Xd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of bytes per value
   */
  byteWidth() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeBinary(t) {
    t.startObject(1);
  }
  static addByteWidth(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static endFixedSizeBinary(t) {
    return t.endObject();
  }
  static createFixedSizeBinary(t, i) {
    return Xd.startFixedSizeBinary(t), Xd.addByteWidth(t, i), Xd.endFixedSizeBinary(t);
  }
}, vg = class Kd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFixedSizeList(t, i) {
    return (i || new Kd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFixedSizeList(t, i) {
    return t.setPosition(t.position() + de), (i || new Kd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Number of list items per value
   */
  listSize() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt32(this.bb_pos + t) : 0;
  }
  static startFixedSizeList(t) {
    t.startObject(1);
  }
  static addListSize(t, i) {
    t.addFieldInt32(0, i, 0);
  }
  static endFixedSizeList(t) {
    return t.endObject();
  }
  static createFixedSizeList(t, i) {
    return Kd.startFixedSizeList(t), Kd.addListSize(t, i), Kd.endFixedSizeList(t);
  }
};
class Ia {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFloatingPoint(t, i) {
    return (i || new Ia()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFloatingPoint(t, i) {
    return t.setPosition(t.position() + de), (i || new Ia()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  precision() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : vn.HALF;
  }
  static startFloatingPoint(t) {
    t.startObject(1);
  }
  static addPrecision(t, i) {
    t.addFieldInt16(0, i, vn.HALF);
  }
  static endFloatingPoint(t) {
    return t.endObject();
  }
  static createFloatingPoint(t, i) {
    return Ia.startFloatingPoint(t), Ia.addPrecision(t, i), Ia.endFloatingPoint(t);
  }
}
class Aa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsInterval(t, i) {
    return (i || new Aa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsInterval(t, i) {
    return t.setPosition(t.position() + de), (i || new Aa()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Pa.YEAR_MONTH;
  }
  static startInterval(t) {
    t.startObject(1);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Pa.YEAR_MONTH);
  }
  static endInterval(t) {
    return t.endObject();
  }
  static createInterval(t, i) {
    return Aa.startInterval(t), Aa.addUnit(t, i), Aa.endInterval(t);
  }
}
let f3 = class ff {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsLargeBinary(t, i) {
    return (i || new ff()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeBinary(t, i) {
    return t.setPosition(t.position() + de), (i || new ff()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeBinary(t) {
    t.startObject(0);
  }
  static endLargeBinary(t) {
    return t.endObject();
  }
  static createLargeBinary(t) {
    return ff.startLargeBinary(t), ff.endLargeBinary(t);
  }
}, p3 = class pf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsLargeUtf8(t, i) {
    return (i || new pf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsLargeUtf8(t, i) {
    return t.setPosition(t.position() + de), (i || new pf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startLargeUtf8(t) {
    t.startObject(0);
  }
  static endLargeUtf8(t) {
    return t.endObject();
  }
  static createLargeUtf8(t) {
    return pf.startLargeUtf8(t), pf.endLargeUtf8(t);
  }
}, m3 = class mf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsList(t, i) {
    return (i || new mf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsList(t, i) {
    return t.setPosition(t.position() + de), (i || new mf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startList(t) {
    t.startObject(0);
  }
  static endList(t) {
    return t.endObject();
  }
  static createList(t) {
    return mf.startList(t), mf.endList(t);
  }
}, _g = class Jd {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsMap(t, i) {
    return (i || new Jd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMap(t, i) {
    return t.setPosition(t.position() + de), (i || new Jd()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * Set to true if the keys within each value are sorted
   */
  keysSorted() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  static startMap(t) {
    t.startObject(1);
  }
  static addKeysSorted(t, i) {
    t.addFieldInt8(0, +i, 0);
  }
  static endMap(t) {
    return t.endObject();
  }
  static createMap(t, i) {
    return Jd.startMap(t), Jd.addKeysSorted(t, i), Jd.endMap(t);
  }
}, g3 = class gf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsNull(t, i) {
    return (i || new gf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsNull(t, i) {
    return t.setPosition(t.position() + de), (i || new gf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startNull(t) {
    t.startObject(0);
  }
  static endNull(t) {
    return t.endObject();
  }
  static createNull(t) {
    return gf.startNull(t), gf.endNull(t);
  }
};
class Nl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsStruct_(t, i) {
    return (i || new Nl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsStruct_(t, i) {
    return t.setPosition(t.position() + de), (i || new Nl()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startStruct_(t) {
    t.startObject(0);
  }
  static endStruct_(t) {
    return t.endObject();
  }
  static createStruct_(t) {
    return Nl.startStruct_(t), Nl.endStruct_(t);
  }
}
class ys {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsTime(t, i) {
    return (i || new ys()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTime(t, i) {
    return t.setPosition(t.position() + de), (i || new ys()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Se.MILLISECOND;
  }
  bitWidth() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readInt32(this.bb_pos + t) : 32;
  }
  static startTime(t) {
    t.startObject(2);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Se.MILLISECOND);
  }
  static addBitWidth(t, i) {
    t.addFieldInt32(1, i, 32);
  }
  static endTime(t) {
    return t.endObject();
  }
  static createTime(t, i, r) {
    return ys.startTime(t), ys.addUnit(t, i), ys.addBitWidth(t, r), ys.endTime(t);
  }
}
class vs {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsTimestamp(t, i) {
    return (i || new vs()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsTimestamp(t, i) {
    return t.setPosition(t.position() + de), (i || new vs()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  unit() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Se.SECOND;
  }
  timezone(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  static startTimestamp(t) {
    t.startObject(2);
  }
  static addUnit(t, i) {
    t.addFieldInt16(0, i, Se.SECOND);
  }
  static addTimezone(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static endTimestamp(t) {
    return t.endObject();
  }
  static createTimestamp(t, i, r) {
    return vs.startTimestamp(t), vs.addUnit(t, i), vs.addTimezone(t, r), vs.endTimestamp(t);
  }
}
class $n {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsUnion(t, i) {
    return (i || new $n()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUnion(t, i) {
    return t.setPosition(t.position() + de), (i || new $n()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  mode() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Hn.Sparse;
  }
  typeIds(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? this.bb.readInt32(this.bb.__vector(this.bb_pos + i) + t * 4) : 0;
  }
  typeIdsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  typeIdsArray() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t), this.bb.__vector_len(this.bb_pos + t)) : null;
  }
  static startUnion(t) {
    t.startObject(2);
  }
  static addMode(t, i) {
    t.addFieldInt16(0, i, Hn.Sparse);
  }
  static addTypeIds(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static createTypeIdsVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addInt32(i[r]);
    return t.endVector();
  }
  static startTypeIdsVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endUnion(t) {
    return t.endObject();
  }
  static createUnion(t, i, r) {
    return $n.startUnion(t), $n.addMode(t, i), $n.addTypeIds(t, r), $n.endUnion(t);
  }
}
let y3 = class yf {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsUtf8(t, i) {
    return (i || new yf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsUtf8(t, i) {
    return t.setPosition(t.position() + de), (i || new yf()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static startUtf8(t) {
    t.startObject(0);
  }
  static endUtf8(t) {
    return t.endObject();
  }
  static createUtf8(t) {
    return yf.startUtf8(t), yf.endUtf8(t);
  }
};
var er;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.FloatingPoint = 3] = "FloatingPoint", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct_ = 13] = "Struct_", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.LargeList = 21] = "LargeList", e[e.RunEndEncoded = 22] = "RunEndEncoded";
})(er || (er = {}));
let hs = class bg {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsField(t, i) {
    return (i || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsField(t, i) {
    return t.setPosition(t.position() + de), (i || new bg()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  name(t) {
    const i = this.bb.__offset(this.bb_pos, 4);
    return i ? this.bb.__string(this.bb_pos + i, t) : null;
  }
  /**
   * Whether or not this field can contain nulls. Should be true in general.
   */
  nullable() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? !!this.bb.readInt8(this.bb_pos + t) : !1;
  }
  typeType() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readUint8(this.bb_pos + t) : er.NONE;
  }
  /**
   * This is the type of the decoded value if the field is dictionary encoded.
   */
  type(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? this.bb.__union(t, this.bb_pos + i) : null;
  }
  /**
   * Present only if the field is dictionary encoded.
   */
  dictionary(t) {
    const i = this.bb.__offset(this.bb_pos, 12);
    return i ? (t || new yo()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  /**
   * children apply only to nested data types like Struct, List and Union. For
   * primitive types children will have length 0.
   */
  children(t, i) {
    const r = this.bb.__offset(this.bb_pos, 14);
    return r ? (i || new bg()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  childrenLength() {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 16);
    return r ? (i || new Jr()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 16);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startField(t) {
    t.startObject(7);
  }
  static addName(t, i) {
    t.addFieldOffset(0, i, 0);
  }
  static addNullable(t, i) {
    t.addFieldInt8(1, +i, 0);
  }
  static addTypeType(t, i) {
    t.addFieldInt8(2, i, er.NONE);
  }
  static addType(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static addDictionary(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static addChildren(t, i) {
    t.addFieldOffset(5, i, 0);
  }
  static createChildrenVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startChildrenVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(6, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endField(t) {
    return t.endObject();
  }
}, _a = class ao {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsSchema(t, i) {
    return (i || new ao()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsSchema(t, i) {
    return t.setPosition(t.position() + de), (i || new ao()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  /**
   * endianness of the buffer
   * it is Little Endian by default
   * if endianness doesn't match the underlying system then the vectors need to be converted
   */
  endianness() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Hu.Little;
  }
  fields(t, i) {
    const r = this.bb.__offset(this.bb_pos, 6);
    return r ? (i || new hs()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  fieldsLength() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new Jr()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * Features used in the stream/file.
   */
  features(t) {
    const i = this.bb.__offset(this.bb_pos, 10);
    return i ? this.bb.readInt64(this.bb.__vector(this.bb_pos + i) + t * 8) : BigInt(0);
  }
  featuresLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startSchema(t) {
    t.startObject(4);
  }
  static addEndianness(t, i) {
    t.addFieldInt16(0, i, Hu.Little);
  }
  static addFields(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static createFieldsVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startFieldsVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static addFeatures(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static createFeaturesVector(t, i) {
    t.startVector(8, i.length, 8);
    for (let r = i.length - 1; r >= 0; r--)
      t.addInt64(i[r]);
    return t.endVector();
  }
  static startFeaturesVector(t, i) {
    t.startVector(8, i, 8);
  }
  static endSchema(t) {
    return t.endObject();
  }
  static finishSchemaBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedSchemaBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
  static createSchema(t, i, r, n, s) {
    return ao.startSchema(t), ao.addEndianness(t, i), ao.addFields(t, r), ao.addCustomMetadata(t, n), ao.addFeatures(t, s), ao.endSchema(t);
  }
};
var Fi;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Schema = 1] = "Schema", e[e.DictionaryBatch = 2] = "DictionaryBatch", e[e.RecordBatch = 3] = "RecordBatch", e[e.Tensor = 4] = "Tensor", e[e.SparseTensor = 5] = "SparseTensor";
})(Fi || (Fi = {}));
var M;
(function(e) {
  e[e.NONE = 0] = "NONE", e[e.Null = 1] = "Null", e[e.Int = 2] = "Int", e[e.Float = 3] = "Float", e[e.Binary = 4] = "Binary", e[e.Utf8 = 5] = "Utf8", e[e.Bool = 6] = "Bool", e[e.Decimal = 7] = "Decimal", e[e.Date = 8] = "Date", e[e.Time = 9] = "Time", e[e.Timestamp = 10] = "Timestamp", e[e.Interval = 11] = "Interval", e[e.List = 12] = "List", e[e.Struct = 13] = "Struct", e[e.Union = 14] = "Union", e[e.FixedSizeBinary = 15] = "FixedSizeBinary", e[e.FixedSizeList = 16] = "FixedSizeList", e[e.Map = 17] = "Map", e[e.Duration = 18] = "Duration", e[e.LargeBinary = 19] = "LargeBinary", e[e.LargeUtf8 = 20] = "LargeUtf8", e[e.Dictionary = -1] = "Dictionary", e[e.Int8 = -2] = "Int8", e[e.Int16 = -3] = "Int16", e[e.Int32 = -4] = "Int32", e[e.Int64 = -5] = "Int64", e[e.Uint8 = -6] = "Uint8", e[e.Uint16 = -7] = "Uint16", e[e.Uint32 = -8] = "Uint32", e[e.Uint64 = -9] = "Uint64", e[e.Float16 = -10] = "Float16", e[e.Float32 = -11] = "Float32", e[e.Float64 = -12] = "Float64", e[e.DateDay = -13] = "DateDay", e[e.DateMillisecond = -14] = "DateMillisecond", e[e.TimestampSecond = -15] = "TimestampSecond", e[e.TimestampMillisecond = -16] = "TimestampMillisecond", e[e.TimestampMicrosecond = -17] = "TimestampMicrosecond", e[e.TimestampNanosecond = -18] = "TimestampNanosecond", e[e.TimeSecond = -19] = "TimeSecond", e[e.TimeMillisecond = -20] = "TimeMillisecond", e[e.TimeMicrosecond = -21] = "TimeMicrosecond", e[e.TimeNanosecond = -22] = "TimeNanosecond", e[e.DenseUnion = -23] = "DenseUnion", e[e.SparseUnion = -24] = "SparseUnion", e[e.IntervalDayTime = -25] = "IntervalDayTime", e[e.IntervalYearMonth = -26] = "IntervalYearMonth", e[e.DurationSecond = -27] = "DurationSecond", e[e.DurationMillisecond = -28] = "DurationMillisecond", e[e.DurationMicrosecond = -29] = "DurationMicrosecond", e[e.DurationNanosecond = -30] = "DurationNanosecond";
})(M || (M = {}));
var uo;
(function(e) {
  e[e.OFFSET = 0] = "OFFSET", e[e.DATA = 1] = "DATA", e[e.VALIDITY = 2] = "VALIDITY", e[e.TYPE = 3] = "TYPE";
})(uo || (uo = {}));
const MZ = void 0;
function Xf(e) {
  if (e === null)
    return "null";
  if (e === MZ)
    return "undefined";
  switch (typeof e) {
    case "number":
      return `${e}`;
    case "bigint":
      return `${e}`;
    case "string":
      return `"${e}"`;
  }
  return typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : ArrayBuffer.isView(e) ? e instanceof BigInt64Array || e instanceof BigUint64Array ? `[${[...e].map((t) => Xf(t))}]` : `[${e}]` : ArrayBuffer.isView(e) ? `[${e}]` : JSON.stringify(e, (t, i) => typeof i == "bigint" ? `${i}` : i);
}
const PZ = Symbol.for("isArrowBigNum");
function aa(e, ...t) {
  return t.length === 0 ? Object.setPrototypeOf($i(this.TypedArray, e), this.constructor.prototype) : Object.setPrototypeOf(new this.TypedArray(e, ...t), this.constructor.prototype);
}
aa.prototype[PZ] = !0;
aa.prototype.toJSON = function() {
  return `"${Jf(this)}"`;
};
aa.prototype.valueOf = function() {
  return P4(this);
};
aa.prototype.toString = function() {
  return Jf(this);
};
aa.prototype[Symbol.toPrimitive] = function(e = "default") {
  switch (e) {
    case "number":
      return P4(this);
    case "string":
      return Jf(this);
    case "default":
      return $Z(this);
  }
  return Jf(this);
};
function vu(...e) {
  return aa.apply(this, e);
}
function _u(...e) {
  return aa.apply(this, e);
}
function Kf(...e) {
  return aa.apply(this, e);
}
Object.setPrototypeOf(vu.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(_u.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(Kf.prototype, Object.create(Uint32Array.prototype));
Object.assign(vu.prototype, aa.prototype, { constructor: vu, signed: !0, TypedArray: Int32Array, BigIntArray: BigInt64Array });
Object.assign(_u.prototype, aa.prototype, { constructor: _u, signed: !1, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
Object.assign(Kf.prototype, aa.prototype, { constructor: Kf, signed: !0, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
function P4(e) {
  const { buffer: t, byteOffset: i, length: r, signed: n } = e, s = new BigUint64Array(t, i, r), a = n && s.at(-1) & BigInt(1) << BigInt(63);
  let o = BigInt(a ? 1 : 0), c = BigInt(0);
  if (a) {
    for (const l of s)
      o += ~l * (BigInt(1) << BigInt(32) * c++);
    o *= BigInt(-1);
  } else
    for (const l of s)
      o += l * (BigInt(1) << BigInt(32) * c++);
  return o;
}
const Jf = (e) => {
  if (e.byteLength === 8)
    return `${new e.BigIntArray(e.buffer, e.byteOffset, 1)[0]}`;
  if (!e.signed)
    return D_(e);
  let t = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  if (new Int16Array([t.at(-1)])[0] >= 0)
    return D_(e);
  t = t.slice();
  let r = 1;
  for (let s = 0; s < t.length; s++) {
    const a = t[s], o = ~a + r;
    t[s] = o, r &= a === 0 ? 1 : 0;
  }
  return `-${D_(t)}`;
}, $Z = (e) => e.byteLength === 8 ? new e.BigIntArray(e.buffer, e.byteOffset, 1)[0] : Jf(e);
function D_(e) {
  let t = "";
  const i = new Uint32Array(2);
  let r = new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2);
  const n = new Uint32Array((r = new Uint16Array(r).reverse()).buffer);
  let s = -1;
  const a = r.length - 1;
  do {
    for (i[0] = r[s = 0]; s < a; )
      r[s++] = i[1] = i[0] / 10, i[0] = (i[0] - i[1] * 10 << 16) + r[s];
    r[s] = i[1] = i[0] / 10, i[0] = i[0] - i[1] * 10, t = `${i[0]}${t}`;
  } while (n[0] || n[1] || n[2] || n[3]);
  return t ?? "0";
}
class uw {
  /** @nocollapse */
  static new(t, i) {
    switch (i) {
      case !0:
        return new vu(t);
      case !1:
        return new _u(t);
    }
    switch (t.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new vu(t);
    }
    return t.byteLength === 16 ? new Kf(t) : new _u(t);
  }
  /** @nocollapse */
  static signed(t) {
    return new vu(t);
  }
  /** @nocollapse */
  static unsigned(t) {
    return new _u(t);
  }
  /** @nocollapse */
  static decimal(t) {
    return new Kf(t);
  }
  constructor(t, i) {
    return uw.new(t, i);
  }
}
function Cn(e) {
  if (typeof e == "bigint" && (e < Number.MIN_SAFE_INTEGER || e > Number.MAX_SAFE_INTEGER))
    throw new TypeError(`${e} is not safe to convert to a number.`);
  return Number(e);
}
var $4, z4, U4, V4, j4, G4, H4, W4, Y4, q4, Z4, X4, K4, J4, Q4, tD, eD, iD, rD, nD, sD, aD;
class ge {
  /** @nocollapse */
  static isNull(t) {
    return (t == null ? void 0 : t.typeId) === M.Null;
  }
  /** @nocollapse */
  static isInt(t) {
    return (t == null ? void 0 : t.typeId) === M.Int;
  }
  /** @nocollapse */
  static isFloat(t) {
    return (t == null ? void 0 : t.typeId) === M.Float;
  }
  /** @nocollapse */
  static isBinary(t) {
    return (t == null ? void 0 : t.typeId) === M.Binary;
  }
  /** @nocollapse */
  static isLargeBinary(t) {
    return (t == null ? void 0 : t.typeId) === M.LargeBinary;
  }
  /** @nocollapse */
  static isUtf8(t) {
    return (t == null ? void 0 : t.typeId) === M.Utf8;
  }
  /** @nocollapse */
  static isLargeUtf8(t) {
    return (t == null ? void 0 : t.typeId) === M.LargeUtf8;
  }
  /** @nocollapse */
  static isBool(t) {
    return (t == null ? void 0 : t.typeId) === M.Bool;
  }
  /** @nocollapse */
  static isDecimal(t) {
    return (t == null ? void 0 : t.typeId) === M.Decimal;
  }
  /** @nocollapse */
  static isDate(t) {
    return (t == null ? void 0 : t.typeId) === M.Date;
  }
  /** @nocollapse */
  static isTime(t) {
    return (t == null ? void 0 : t.typeId) === M.Time;
  }
  /** @nocollapse */
  static isTimestamp(t) {
    return (t == null ? void 0 : t.typeId) === M.Timestamp;
  }
  /** @nocollapse */
  static isInterval(t) {
    return (t == null ? void 0 : t.typeId) === M.Interval;
  }
  /** @nocollapse */
  static isDuration(t) {
    return (t == null ? void 0 : t.typeId) === M.Duration;
  }
  /** @nocollapse */
  static isList(t) {
    return (t == null ? void 0 : t.typeId) === M.List;
  }
  /** @nocollapse */
  static isStruct(t) {
    return (t == null ? void 0 : t.typeId) === M.Struct;
  }
  /** @nocollapse */
  static isUnion(t) {
    return (t == null ? void 0 : t.typeId) === M.Union;
  }
  /** @nocollapse */
  static isFixedSizeBinary(t) {
    return (t == null ? void 0 : t.typeId) === M.FixedSizeBinary;
  }
  /** @nocollapse */
  static isFixedSizeList(t) {
    return (t == null ? void 0 : t.typeId) === M.FixedSizeList;
  }
  /** @nocollapse */
  static isMap(t) {
    return (t == null ? void 0 : t.typeId) === M.Map;
  }
  /** @nocollapse */
  static isDictionary(t) {
    return (t == null ? void 0 : t.typeId) === M.Dictionary;
  }
  /** @nocollapse */
  static isDenseUnion(t) {
    return ge.isUnion(t) && t.mode === Hn.Dense;
  }
  /** @nocollapse */
  static isSparseUnion(t) {
    return ge.isUnion(t) && t.mode === Hn.Sparse;
  }
  constructor(t) {
    this.typeId = t;
  }
}
$4 = Symbol.toStringTag;
ge[$4] = ((e) => (e.children = null, e.ArrayType = Array, e.OffsetArrayType = Int32Array, e[Symbol.toStringTag] = "DataType"))(ge.prototype);
class Lc extends ge {
  constructor() {
    super(M.Null);
  }
  toString() {
    return "Null";
  }
}
z4 = Symbol.toStringTag;
Lc[z4] = ((e) => e[Symbol.toStringTag] = "Null")(Lc.prototype);
class Fc extends ge {
  constructor(t, i) {
    super(M.Int), this.isSigned = t, this.bitWidth = i;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? "I" : "Ui"}nt${this.bitWidth}`;
  }
}
U4 = Symbol.toStringTag;
Fc[U4] = ((e) => (e.isSigned = null, e.bitWidth = null, e[Symbol.toStringTag] = "Int"))(Fc.prototype);
class Qf extends Fc {
  constructor() {
    super(!0, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
}
Object.defineProperty(Qf.prototype, "ArrayType", { value: Int32Array });
class tp extends ge {
  constructor(t) {
    super(M.Float), this.precision = t;
  }
  get ArrayType() {
    switch (this.precision) {
      case vn.HALF:
        return Uint16Array;
      case vn.SINGLE:
        return Float32Array;
      case vn.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
}
V4 = Symbol.toStringTag;
tp[V4] = ((e) => (e.precision = null, e[Symbol.toStringTag] = "Float"))(tp.prototype);
class A0 extends ge {
  constructor() {
    super(M.Binary);
  }
  toString() {
    return "Binary";
  }
}
j4 = Symbol.toStringTag;
A0[j4] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Binary"))(A0.prototype);
class T0 extends ge {
  constructor() {
    super(M.LargeBinary);
  }
  toString() {
    return "LargeBinary";
  }
}
G4 = Symbol.toStringTag;
T0[G4] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeBinary"))(T0.prototype);
class E0 extends ge {
  constructor() {
    super(M.Utf8);
  }
  toString() {
    return "Utf8";
  }
}
H4 = Symbol.toStringTag;
E0[H4] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Utf8"))(E0.prototype);
class k0 extends ge {
  constructor() {
    super(M.LargeUtf8);
  }
  toString() {
    return "LargeUtf8";
  }
}
W4 = Symbol.toStringTag;
k0[W4] = ((e) => (e.ArrayType = Uint8Array, e.OffsetArrayType = BigInt64Array, e[Symbol.toStringTag] = "LargeUtf8"))(k0.prototype);
class C0 extends ge {
  constructor() {
    super(M.Bool);
  }
  toString() {
    return "Bool";
  }
}
Y4 = Symbol.toStringTag;
C0[Y4] = ((e) => (e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "Bool"))(C0.prototype);
class O0 extends ge {
  constructor(t, i, r = 128) {
    super(M.Decimal), this.scale = t, this.precision = i, this.bitWidth = r;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? "+" : ""}${this.scale}]`;
  }
}
q4 = Symbol.toStringTag;
O0[q4] = ((e) => (e.scale = null, e.precision = null, e.ArrayType = Uint32Array, e[Symbol.toStringTag] = "Decimal"))(O0.prototype);
class D0 extends ge {
  constructor(t) {
    super(M.Date), this.unit = t;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${ea[this.unit]}>`;
  }
}
Z4 = Symbol.toStringTag;
D0[Z4] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Date"))(D0.prototype);
class ep extends ge {
  constructor(t, i) {
    super(M.Time), this.unit = t, this.bitWidth = i;
  }
  toString() {
    return `Time${this.bitWidth}<${Se[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
}
X4 = Symbol.toStringTag;
ep[X4] = ((e) => (e.unit = null, e.bitWidth = null, e[Symbol.toStringTag] = "Time"))(ep.prototype);
class N0 extends ge {
  constructor(t, i) {
    super(M.Timestamp), this.unit = t, this.timezone = i;
  }
  toString() {
    return `Timestamp<${Se[this.unit]}${this.timezone ? `, ${this.timezone}` : ""}>`;
  }
}
K4 = Symbol.toStringTag;
N0[K4] = ((e) => (e.unit = null, e.timezone = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Timestamp"))(N0.prototype);
class L0 extends ge {
  constructor(t) {
    super(M.Interval), this.unit = t;
  }
  toString() {
    return `Interval<${Pa[this.unit]}>`;
  }
}
J4 = Symbol.toStringTag;
L0[J4] = ((e) => (e.unit = null, e.ArrayType = Int32Array, e[Symbol.toStringTag] = "Interval"))(L0.prototype);
class F0 extends ge {
  constructor(t) {
    super(M.Duration), this.unit = t;
  }
  toString() {
    return `Duration<${Se[this.unit]}>`;
  }
}
Q4 = Symbol.toStringTag;
F0[Q4] = ((e) => (e.unit = null, e.ArrayType = BigInt64Array, e[Symbol.toStringTag] = "Duration"))(F0.prototype);
class B0 extends ge {
  constructor(t) {
    super(M.List), this.children = [t];
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
}
tD = Symbol.toStringTag;
B0[tD] = ((e) => (e.children = null, e[Symbol.toStringTag] = "List"))(B0.prototype);
class An extends ge {
  constructor(t) {
    super(M.Struct), this.children = t;
  }
  toString() {
    return `Struct<{${this.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
}
eD = Symbol.toStringTag;
An[eD] = ((e) => (e.children = null, e[Symbol.toStringTag] = "Struct"))(An.prototype);
class R0 extends ge {
  constructor(t, i, r) {
    super(M.Union), this.mode = t, this.children = r, this.typeIds = i = Int32Array.from(i), this.typeIdToChildIndex = i.reduce((n, s, a) => (n[s] = a) && n || n, /* @__PURE__ */ Object.create(null));
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((t) => `${t.type}`).join(" | ")}>`;
  }
}
iD = Symbol.toStringTag;
R0[iD] = ((e) => (e.mode = null, e.typeIds = null, e.children = null, e.typeIdToChildIndex = null, e.ArrayType = Int8Array, e[Symbol.toStringTag] = "Union"))(R0.prototype);
class M0 extends ge {
  constructor(t) {
    super(M.FixedSizeBinary), this.byteWidth = t;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
}
rD = Symbol.toStringTag;
M0[rD] = ((e) => (e.byteWidth = null, e.ArrayType = Uint8Array, e[Symbol.toStringTag] = "FixedSizeBinary"))(M0.prototype);
class P0 extends ge {
  constructor(t, i) {
    super(M.FixedSizeList), this.listSize = t, this.children = [i];
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
}
nD = Symbol.toStringTag;
P0[nD] = ((e) => (e.children = null, e.listSize = null, e[Symbol.toStringTag] = "FixedSizeList"))(P0.prototype);
class $0 extends ge {
  constructor(t, i = !1) {
    var r, n, s;
    if (super(M.Map), this.children = [t], this.keysSorted = i, t && (t.name = "entries", !((r = t == null ? void 0 : t.type) === null || r === void 0) && r.children)) {
      const a = (n = t == null ? void 0 : t.type) === null || n === void 0 ? void 0 : n.children[0];
      a && (a.name = "key");
      const o = (s = t == null ? void 0 : t.type) === null || s === void 0 ? void 0 : s.children[1];
      o && (o.name = "value");
    }
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((t) => `${t.name}:${t.type}`).join(", ")}}>`;
  }
}
sD = Symbol.toStringTag;
$0[sD] = ((e) => (e.children = null, e.keysSorted = null, e[Symbol.toStringTag] = "Map_"))($0.prototype);
const zZ = /* @__PURE__ */ ((e) => () => ++e)(-1);
class Wu extends ge {
  constructor(t, i, r, n) {
    super(M.Dictionary), this.indices = i, this.dictionary = t, this.isOrdered = n || !1, this.id = r == null ? zZ() : Cn(r);
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
}
aD = Symbol.toStringTag;
Wu[aD] = ((e) => (e.id = null, e.indices = null, e.isOrdered = null, e.dictionary = null, e[Symbol.toStringTag] = "Dictionary"))(Wu.prototype);
function ho(e) {
  const t = e;
  switch (e.typeId) {
    case M.Decimal:
      return e.bitWidth / 32;
    case M.Timestamp:
      return 2;
    case M.Date:
      return 1 + t.unit;
    case M.Interval:
      return 1 + t.unit;
    case M.FixedSizeList:
      return t.listSize;
    case M.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}
class li {
  visitMany(t, ...i) {
    return t.map((r, n) => this.visit(r, ...i.map((s) => s[n])));
  }
  visit(...t) {
    return this.getVisitFn(t[0], !1).apply(this, t);
  }
  getVisitFn(t, i = !0) {
    return UZ(this, t, i);
  }
  getVisitFnByTypeId(t, i = !0) {
    return Qd(this, t, i);
  }
  visitNull(t, ...i) {
    return null;
  }
  visitBool(t, ...i) {
    return null;
  }
  visitInt(t, ...i) {
    return null;
  }
  visitFloat(t, ...i) {
    return null;
  }
  visitUtf8(t, ...i) {
    return null;
  }
  visitLargeUtf8(t, ...i) {
    return null;
  }
  visitBinary(t, ...i) {
    return null;
  }
  visitLargeBinary(t, ...i) {
    return null;
  }
  visitFixedSizeBinary(t, ...i) {
    return null;
  }
  visitDate(t, ...i) {
    return null;
  }
  visitTimestamp(t, ...i) {
    return null;
  }
  visitTime(t, ...i) {
    return null;
  }
  visitDecimal(t, ...i) {
    return null;
  }
  visitList(t, ...i) {
    return null;
  }
  visitStruct(t, ...i) {
    return null;
  }
  visitUnion(t, ...i) {
    return null;
  }
  visitDictionary(t, ...i) {
    return null;
  }
  visitInterval(t, ...i) {
    return null;
  }
  visitDuration(t, ...i) {
    return null;
  }
  visitFixedSizeList(t, ...i) {
    return null;
  }
  visitMap(t, ...i) {
    return null;
  }
}
function UZ(e, t, i = !0) {
  return typeof t == "number" ? Qd(e, t, i) : typeof t == "string" && t in M ? Qd(e, M[t], i) : t && t instanceof ge ? Qd(e, v3(t), i) : t != null && t.type && t.type instanceof ge ? Qd(e, v3(t.type), i) : Qd(e, M.NONE, i);
}
function Qd(e, t, i = !0) {
  let r = null;
  switch (t) {
    case M.Null:
      r = e.visitNull;
      break;
    case M.Bool:
      r = e.visitBool;
      break;
    case M.Int:
      r = e.visitInt;
      break;
    case M.Int8:
      r = e.visitInt8 || e.visitInt;
      break;
    case M.Int16:
      r = e.visitInt16 || e.visitInt;
      break;
    case M.Int32:
      r = e.visitInt32 || e.visitInt;
      break;
    case M.Int64:
      r = e.visitInt64 || e.visitInt;
      break;
    case M.Uint8:
      r = e.visitUint8 || e.visitInt;
      break;
    case M.Uint16:
      r = e.visitUint16 || e.visitInt;
      break;
    case M.Uint32:
      r = e.visitUint32 || e.visitInt;
      break;
    case M.Uint64:
      r = e.visitUint64 || e.visitInt;
      break;
    case M.Float:
      r = e.visitFloat;
      break;
    case M.Float16:
      r = e.visitFloat16 || e.visitFloat;
      break;
    case M.Float32:
      r = e.visitFloat32 || e.visitFloat;
      break;
    case M.Float64:
      r = e.visitFloat64 || e.visitFloat;
      break;
    case M.Utf8:
      r = e.visitUtf8;
      break;
    case M.LargeUtf8:
      r = e.visitLargeUtf8;
      break;
    case M.Binary:
      r = e.visitBinary;
      break;
    case M.LargeBinary:
      r = e.visitLargeBinary;
      break;
    case M.FixedSizeBinary:
      r = e.visitFixedSizeBinary;
      break;
    case M.Date:
      r = e.visitDate;
      break;
    case M.DateDay:
      r = e.visitDateDay || e.visitDate;
      break;
    case M.DateMillisecond:
      r = e.visitDateMillisecond || e.visitDate;
      break;
    case M.Timestamp:
      r = e.visitTimestamp;
      break;
    case M.TimestampSecond:
      r = e.visitTimestampSecond || e.visitTimestamp;
      break;
    case M.TimestampMillisecond:
      r = e.visitTimestampMillisecond || e.visitTimestamp;
      break;
    case M.TimestampMicrosecond:
      r = e.visitTimestampMicrosecond || e.visitTimestamp;
      break;
    case M.TimestampNanosecond:
      r = e.visitTimestampNanosecond || e.visitTimestamp;
      break;
    case M.Time:
      r = e.visitTime;
      break;
    case M.TimeSecond:
      r = e.visitTimeSecond || e.visitTime;
      break;
    case M.TimeMillisecond:
      r = e.visitTimeMillisecond || e.visitTime;
      break;
    case M.TimeMicrosecond:
      r = e.visitTimeMicrosecond || e.visitTime;
      break;
    case M.TimeNanosecond:
      r = e.visitTimeNanosecond || e.visitTime;
      break;
    case M.Decimal:
      r = e.visitDecimal;
      break;
    case M.List:
      r = e.visitList;
      break;
    case M.Struct:
      r = e.visitStruct;
      break;
    case M.Union:
      r = e.visitUnion;
      break;
    case M.DenseUnion:
      r = e.visitDenseUnion || e.visitUnion;
      break;
    case M.SparseUnion:
      r = e.visitSparseUnion || e.visitUnion;
      break;
    case M.Dictionary:
      r = e.visitDictionary;
      break;
    case M.Interval:
      r = e.visitInterval;
      break;
    case M.IntervalDayTime:
      r = e.visitIntervalDayTime || e.visitInterval;
      break;
    case M.IntervalYearMonth:
      r = e.visitIntervalYearMonth || e.visitInterval;
      break;
    case M.Duration:
      r = e.visitDuration;
      break;
    case M.DurationSecond:
      r = e.visitDurationSecond || e.visitDuration;
      break;
    case M.DurationMillisecond:
      r = e.visitDurationMillisecond || e.visitDuration;
      break;
    case M.DurationMicrosecond:
      r = e.visitDurationMicrosecond || e.visitDuration;
      break;
    case M.DurationNanosecond:
      r = e.visitDurationNanosecond || e.visitDuration;
      break;
    case M.FixedSizeList:
      r = e.visitFixedSizeList;
      break;
    case M.Map:
      r = e.visitMap;
      break;
  }
  if (typeof r == "function")
    return r;
  if (!i)
    return () => null;
  throw new Error(`Unrecognized type '${M[t]}'`);
}
function v3(e) {
  switch (e.typeId) {
    case M.Null:
      return M.Null;
    case M.Int: {
      const { bitWidth: t, isSigned: i } = e;
      switch (t) {
        case 8:
          return i ? M.Int8 : M.Uint8;
        case 16:
          return i ? M.Int16 : M.Uint16;
        case 32:
          return i ? M.Int32 : M.Uint32;
        case 64:
          return i ? M.Int64 : M.Uint64;
      }
      return M.Int;
    }
    case M.Float:
      switch (e.precision) {
        case vn.HALF:
          return M.Float16;
        case vn.SINGLE:
          return M.Float32;
        case vn.DOUBLE:
          return M.Float64;
      }
      return M.Float;
    case M.Binary:
      return M.Binary;
    case M.LargeBinary:
      return M.LargeBinary;
    case M.Utf8:
      return M.Utf8;
    case M.LargeUtf8:
      return M.LargeUtf8;
    case M.Bool:
      return M.Bool;
    case M.Decimal:
      return M.Decimal;
    case M.Time:
      switch (e.unit) {
        case Se.SECOND:
          return M.TimeSecond;
        case Se.MILLISECOND:
          return M.TimeMillisecond;
        case Se.MICROSECOND:
          return M.TimeMicrosecond;
        case Se.NANOSECOND:
          return M.TimeNanosecond;
      }
      return M.Time;
    case M.Timestamp:
      switch (e.unit) {
        case Se.SECOND:
          return M.TimestampSecond;
        case Se.MILLISECOND:
          return M.TimestampMillisecond;
        case Se.MICROSECOND:
          return M.TimestampMicrosecond;
        case Se.NANOSECOND:
          return M.TimestampNanosecond;
      }
      return M.Timestamp;
    case M.Date:
      switch (e.unit) {
        case ea.DAY:
          return M.DateDay;
        case ea.MILLISECOND:
          return M.DateMillisecond;
      }
      return M.Date;
    case M.Interval:
      switch (e.unit) {
        case Pa.DAY_TIME:
          return M.IntervalDayTime;
        case Pa.YEAR_MONTH:
          return M.IntervalYearMonth;
      }
      return M.Interval;
    case M.Duration:
      switch (e.unit) {
        case Se.SECOND:
          return M.DurationSecond;
        case Se.MILLISECOND:
          return M.DurationMillisecond;
        case Se.MICROSECOND:
          return M.DurationMicrosecond;
        case Se.NANOSECOND:
          return M.DurationNanosecond;
      }
      return M.Duration;
    case M.Map:
      return M.Map;
    case M.List:
      return M.List;
    case M.Struct:
      return M.Struct;
    case M.Union:
      switch (e.mode) {
        case Hn.Dense:
          return M.DenseUnion;
        case Hn.Sparse:
          return M.SparseUnion;
      }
      return M.Union;
    case M.FixedSizeBinary:
      return M.FixedSizeBinary;
    case M.FixedSizeList:
      return M.FixedSizeList;
    case M.Dictionary:
      return M.Dictionary;
  }
  throw new Error(`Unrecognized type '${M[e.typeId]}'`);
}
li.prototype.visitInt8 = null;
li.prototype.visitInt16 = null;
li.prototype.visitInt32 = null;
li.prototype.visitInt64 = null;
li.prototype.visitUint8 = null;
li.prototype.visitUint16 = null;
li.prototype.visitUint32 = null;
li.prototype.visitUint64 = null;
li.prototype.visitFloat16 = null;
li.prototype.visitFloat32 = null;
li.prototype.visitFloat64 = null;
li.prototype.visitDateDay = null;
li.prototype.visitDateMillisecond = null;
li.prototype.visitTimestampSecond = null;
li.prototype.visitTimestampMillisecond = null;
li.prototype.visitTimestampMicrosecond = null;
li.prototype.visitTimestampNanosecond = null;
li.prototype.visitTimeSecond = null;
li.prototype.visitTimeMillisecond = null;
li.prototype.visitTimeMicrosecond = null;
li.prototype.visitTimeNanosecond = null;
li.prototype.visitDenseUnion = null;
li.prototype.visitSparseUnion = null;
li.prototype.visitIntervalDayTime = null;
li.prototype.visitIntervalYearMonth = null;
li.prototype.visitDuration = null;
li.prototype.visitDurationSecond = null;
li.prototype.visitDurationMillisecond = null;
li.prototype.visitDurationMicrosecond = null;
li.prototype.visitDurationNanosecond = null;
const oD = new Float64Array(1), Od = new Uint32Array(oD.buffer);
function cD(e) {
  const t = (e & 31744) >> 10, i = (e & 1023) / 1024, r = Math.pow(-1, (e & 32768) >> 15);
  switch (t) {
    case 31:
      return r * (i ? Number.NaN : 1 / 0);
    case 0:
      return r * (i ? 6103515625e-14 * i : 0);
  }
  return r * Math.pow(2, t - 15) * (1 + i);
}
function VZ(e) {
  if (e !== e)
    return 32256;
  oD[0] = e;
  const t = (Od[1] & 2147483648) >> 16 & 65535;
  let i = Od[1] & 2146435072, r = 0;
  return i >= 1089470464 ? Od[0] > 0 ? i = 31744 : (i = (i & 2080374784) >> 16, r = (Od[1] & 1048575) >> 10) : i <= 1056964608 ? (r = 1048576 + (Od[1] & 1048575), r = 1048576 + (r << (i >> 20) - 998) >> 21, i = 0) : (i = i - 1056964608 >> 10, r = (Od[1] & 1048575) + 512 >> 10), t | i | r & 65535;
}
class Ae extends li {
}
function Le(e) {
  return (t, i, r) => {
    if (t.setValid(i, r != null))
      return e(t, i, r);
  };
}
const jZ = (e, t, i) => {
  e[t] = Math.trunc(i / 864e5);
}, hw = (e, t, i) => {
  e[t] = Math.trunc(i % 4294967296), e[t + 1] = Math.trunc(i / 4294967296);
}, GZ = (e, t, i) => {
  e[t] = Math.trunc(i * 1e3 % 4294967296), e[t + 1] = Math.trunc(i * 1e3 / 4294967296);
}, HZ = (e, t, i) => {
  e[t] = Math.trunc(i * 1e6 % 4294967296), e[t + 1] = Math.trunc(i * 1e6 / 4294967296);
}, lD = (e, t, i, r) => {
  if (i + 1 < t.length) {
    const n = Cn(t[i]), s = Cn(t[i + 1]);
    e.set(r.subarray(0, s - n), n);
  }
}, WZ = ({ offset: e, values: t }, i, r) => {
  const n = e + i;
  r ? t[n >> 3] |= 1 << n % 8 : t[n >> 3] &= ~(1 << n % 8);
}, Ho = ({ values: e }, t, i) => {
  e[t] = i;
}, fw = ({ values: e }, t, i) => {
  e[t] = i;
}, dD = ({ values: e }, t, i) => {
  e[t] = VZ(i);
}, YZ = (e, t, i) => {
  switch (e.type.precision) {
    case vn.HALF:
      return dD(e, t, i);
    case vn.SINGLE:
    case vn.DOUBLE:
      return fw(e, t, i);
  }
}, uD = ({ values: e }, t, i) => {
  jZ(e, t, i.valueOf());
}, hD = ({ values: e }, t, i) => {
  hw(e, t * 2, i.valueOf());
}, qZ = ({ stride: e, values: t }, i, r) => {
  t.set(r.subarray(0, e), e * i);
}, fD = ({ values: e, valueOffsets: t }, i, r) => lD(e, t, i, r), pD = ({ values: e, valueOffsets: t }, i, r) => lD(e, t, i, ow(r)), ZZ = (e, t, i) => {
  e.type.unit === ea.DAY ? uD(e, t, i) : hD(e, t, i);
}, mD = ({ values: e }, t, i) => hw(e, t * 2, i / 1e3), gD = ({ values: e }, t, i) => hw(e, t * 2, i), yD = ({ values: e }, t, i) => GZ(e, t * 2, i), vD = ({ values: e }, t, i) => HZ(e, t * 2, i), XZ = (e, t, i) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return mD(e, t, i);
    case Se.MILLISECOND:
      return gD(e, t, i);
    case Se.MICROSECOND:
      return yD(e, t, i);
    case Se.NANOSECOND:
      return vD(e, t, i);
  }
}, _D = ({ values: e }, t, i) => {
  e[t] = i;
}, bD = ({ values: e }, t, i) => {
  e[t] = i;
}, xD = ({ values: e }, t, i) => {
  e[t] = i;
}, wD = ({ values: e }, t, i) => {
  e[t] = i;
}, KZ = (e, t, i) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return _D(e, t, i);
    case Se.MILLISECOND:
      return bD(e, t, i);
    case Se.MICROSECOND:
      return xD(e, t, i);
    case Se.NANOSECOND:
      return wD(e, t, i);
  }
}, JZ = ({ values: e, stride: t }, i, r) => {
  e.set(r.subarray(0, t), t * i);
}, QZ = (e, t, i) => {
  const r = e.children[0], n = e.valueOffsets, s = As.getVisitFn(r);
  if (Array.isArray(i))
    for (let a = -1, o = n[t], c = n[t + 1]; o < c; )
      s(r, o++, i[++a]);
  else
    for (let a = -1, o = n[t], c = n[t + 1]; o < c; )
      s(r, o++, i.get(++a));
}, tX = (e, t, i) => {
  const r = e.children[0], { valueOffsets: n } = e, s = As.getVisitFn(r);
  let { [t]: a, [t + 1]: o } = n;
  const c = i instanceof Map ? i.entries() : Object.entries(i);
  for (const l of c)
    if (s(r, a, l), ++a >= o)
      break;
}, eX = (e, t) => (i, r, n, s) => r && i(r, e, t[s]), iX = (e, t) => (i, r, n, s) => r && i(r, e, t.get(s)), rX = (e, t) => (i, r, n, s) => r && i(r, e, t.get(n.name)), nX = (e, t) => (i, r, n, s) => r && i(r, e, t[n.name]), sX = (e, t, i) => {
  const r = e.type.children.map((s) => As.getVisitFn(s.type)), n = i instanceof Map ? rX(t, i) : i instanceof qi ? iX(t, i) : Array.isArray(i) ? eX(t, i) : nX(t, i);
  e.type.children.forEach((s, a) => n(r[a], e.children[a], s, a));
}, aX = (e, t, i) => {
  e.type.mode === Hn.Dense ? SD(e, t, i) : ID(e, t, i);
}, SD = (e, t, i) => {
  const r = e.type.typeIdToChildIndex[e.typeIds[t]], n = e.children[r];
  As.visit(n, e.valueOffsets[t], i);
}, ID = (e, t, i) => {
  const r = e.type.typeIdToChildIndex[e.typeIds[t]], n = e.children[r];
  As.visit(n, t, i);
}, oX = (e, t, i) => {
  var r;
  (r = e.dictionary) === null || r === void 0 || r.set(e.values[t], i);
}, cX = (e, t, i) => {
  e.type.unit === Pa.DAY_TIME ? AD(e, t, i) : TD(e, t, i);
}, AD = ({ values: e }, t, i) => {
  e.set(i.subarray(0, 2), 2 * t);
}, TD = ({ values: e }, t, i) => {
  e[t] = i[0] * 12 + i[1] % 12;
}, ED = ({ values: e }, t, i) => {
  e[t] = i;
}, kD = ({ values: e }, t, i) => {
  e[t] = i;
}, CD = ({ values: e }, t, i) => {
  e[t] = i;
}, OD = ({ values: e }, t, i) => {
  e[t] = i;
}, lX = (e, t, i) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return ED(e, t, i);
    case Se.MILLISECOND:
      return kD(e, t, i);
    case Se.MICROSECOND:
      return CD(e, t, i);
    case Se.NANOSECOND:
      return OD(e, t, i);
  }
}, dX = (e, t, i) => {
  const { stride: r } = e, n = e.children[0], s = As.getVisitFn(n);
  if (Array.isArray(i))
    for (let a = -1, o = t * r; ++a < r; )
      s(n, o + a, i[a]);
  else
    for (let a = -1, o = t * r; ++a < r; )
      s(n, o + a, i.get(a));
};
Ae.prototype.visitBool = Le(WZ);
Ae.prototype.visitInt = Le(Ho);
Ae.prototype.visitInt8 = Le(Ho);
Ae.prototype.visitInt16 = Le(Ho);
Ae.prototype.visitInt32 = Le(Ho);
Ae.prototype.visitInt64 = Le(Ho);
Ae.prototype.visitUint8 = Le(Ho);
Ae.prototype.visitUint16 = Le(Ho);
Ae.prototype.visitUint32 = Le(Ho);
Ae.prototype.visitUint64 = Le(Ho);
Ae.prototype.visitFloat = Le(YZ);
Ae.prototype.visitFloat16 = Le(dD);
Ae.prototype.visitFloat32 = Le(fw);
Ae.prototype.visitFloat64 = Le(fw);
Ae.prototype.visitUtf8 = Le(pD);
Ae.prototype.visitLargeUtf8 = Le(pD);
Ae.prototype.visitBinary = Le(fD);
Ae.prototype.visitLargeBinary = Le(fD);
Ae.prototype.visitFixedSizeBinary = Le(qZ);
Ae.prototype.visitDate = Le(ZZ);
Ae.prototype.visitDateDay = Le(uD);
Ae.prototype.visitDateMillisecond = Le(hD);
Ae.prototype.visitTimestamp = Le(XZ);
Ae.prototype.visitTimestampSecond = Le(mD);
Ae.prototype.visitTimestampMillisecond = Le(gD);
Ae.prototype.visitTimestampMicrosecond = Le(yD);
Ae.prototype.visitTimestampNanosecond = Le(vD);
Ae.prototype.visitTime = Le(KZ);
Ae.prototype.visitTimeSecond = Le(_D);
Ae.prototype.visitTimeMillisecond = Le(bD);
Ae.prototype.visitTimeMicrosecond = Le(xD);
Ae.prototype.visitTimeNanosecond = Le(wD);
Ae.prototype.visitDecimal = Le(JZ);
Ae.prototype.visitList = Le(QZ);
Ae.prototype.visitStruct = Le(sX);
Ae.prototype.visitUnion = Le(aX);
Ae.prototype.visitDenseUnion = Le(SD);
Ae.prototype.visitSparseUnion = Le(ID);
Ae.prototype.visitDictionary = Le(oX);
Ae.prototype.visitInterval = Le(cX);
Ae.prototype.visitIntervalDayTime = Le(AD);
Ae.prototype.visitIntervalYearMonth = Le(TD);
Ae.prototype.visitDuration = Le(lX);
Ae.prototype.visitDurationSecond = Le(ED);
Ae.prototype.visitDurationMillisecond = Le(kD);
Ae.prototype.visitDurationMicrosecond = Le(CD);
Ae.prototype.visitDurationNanosecond = Le(OD);
Ae.prototype.visitFixedSizeList = Le(dX);
Ae.prototype.visitMap = Le(tX);
const As = new Ae(), Ms = Symbol.for("parent"), bu = Symbol.for("rowIndex");
class pw {
  constructor(t, i) {
    return this[Ms] = t, this[bu] = i, new Proxy(this, new hX());
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[bu], i = this[Ms], r = i.type.children, n = {};
    for (let s = -1, a = r.length; ++s < a; )
      n[r[s].name] = Wn.visit(i.children[s], t);
    return n;
  }
  toString() {
    return `{${[...this].map(([t, i]) => `${Xf(t)}: ${Xf(i)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new uX(this[Ms], this[bu]);
  }
}
class uX {
  constructor(t, i) {
    this.childIndex = 0, this.children = t.children, this.rowIndex = i, this.childFields = t.type.children, this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.childIndex;
    return t < this.numChildren ? (this.childIndex = t + 1, {
      done: !1,
      value: [
        this.childFields[t].name,
        Wn.visit(this.children[t], this.rowIndex)
      ]
    }) : { done: !0, value: null };
  }
}
Object.defineProperties(pw.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [Ms]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [bu]: { writable: !0, enumerable: !1, configurable: !1, value: -1 }
});
class hX {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[Ms].type.children.map((i) => i.name);
  }
  has(t, i) {
    return t[Ms].type.children.findIndex((r) => r.name === i) !== -1;
  }
  getOwnPropertyDescriptor(t, i) {
    if (t[Ms].type.children.findIndex((r) => r.name === i) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, i) {
    if (Reflect.has(t, i))
      return t[i];
    const r = t[Ms].type.children.findIndex((n) => n.name === i);
    if (r !== -1) {
      const n = Wn.visit(t[Ms].children[r], t[bu]);
      return Reflect.set(t, i, n), n;
    }
  }
  set(t, i, r) {
    const n = t[Ms].type.children.findIndex((s) => s.name === i);
    return n !== -1 ? (As.visit(t[Ms].children[n], t[bu], r), Reflect.set(t, i, r)) : Reflect.has(t, i) || typeof i == "symbol" ? Reflect.set(t, i, r) : !1;
  }
}
class ve extends li {
}
function Te(e) {
  return (t, i) => t.getValid(i) ? e(t, i) : null;
}
const fX = (e, t) => 864e5 * e[t], mw = (e, t) => 4294967296 * e[t + 1] + (e[t] >>> 0), pX = (e, t) => 4294967296 * (e[t + 1] / 1e3) + (e[t] >>> 0) / 1e3, mX = (e, t) => 4294967296 * (e[t + 1] / 1e6) + (e[t] >>> 0) / 1e6, DD = (e) => new Date(e), gX = (e, t) => DD(fX(e, t)), yX = (e, t) => DD(mw(e, t)), vX = (e, t) => null, ND = (e, t, i) => {
  if (i + 1 >= t.length)
    return null;
  const r = Cn(t[i]), n = Cn(t[i + 1]);
  return e.subarray(r, n);
}, _X = ({ offset: e, values: t }, i) => {
  const r = e + i;
  return (t[r >> 3] & 1 << r % 8) !== 0;
}, LD = ({ values: e }, t) => gX(e, t), FD = ({ values: e }, t) => yX(e, t * 2), Hc = ({ stride: e, values: t }, i) => t[e * i], bX = ({ stride: e, values: t }, i) => cD(t[e * i]), BD = ({ values: e }, t) => e[t], xX = ({ stride: e, values: t }, i) => t.subarray(e * i, e * (i + 1)), RD = ({ values: e, valueOffsets: t }, i) => ND(e, t, i), MD = ({ values: e, valueOffsets: t }, i) => {
  const r = ND(e, t, i);
  return r !== null ? Mb(r) : null;
}, wX = ({ values: e }, t) => e[t], SX = ({ type: e, values: t }, i) => e.precision !== vn.HALF ? t[i] : cD(t[i]), IX = (e, t) => e.type.unit === ea.DAY ? LD(e, t) : FD(e, t), PD = ({ values: e }, t) => 1e3 * mw(e, t * 2), $D = ({ values: e }, t) => mw(e, t * 2), zD = ({ values: e }, t) => pX(e, t * 2), UD = ({ values: e }, t) => mX(e, t * 2), AX = (e, t) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return PD(e, t);
    case Se.MILLISECOND:
      return $D(e, t);
    case Se.MICROSECOND:
      return zD(e, t);
    case Se.NANOSECOND:
      return UD(e, t);
  }
}, VD = ({ values: e }, t) => e[t], jD = ({ values: e }, t) => e[t], GD = ({ values: e }, t) => e[t], HD = ({ values: e }, t) => e[t], TX = (e, t) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return VD(e, t);
    case Se.MILLISECOND:
      return jD(e, t);
    case Se.MICROSECOND:
      return GD(e, t);
    case Se.NANOSECOND:
      return HD(e, t);
  }
}, EX = ({ values: e, stride: t }, i) => uw.decimal(e.subarray(t * i, t * (i + 1))), kX = (e, t) => {
  const { valueOffsets: i, stride: r, children: n } = e, { [t * r]: s, [t * r + 1]: a } = i, c = n[0].slice(s, a - s);
  return new qi([c]);
}, CX = (e, t) => {
  const { valueOffsets: i, children: r } = e, { [t]: n, [t + 1]: s } = i, a = r[0];
  return new gw(a.slice(n, s - n));
}, OX = (e, t) => new pw(e, t), DX = (e, t) => e.type.mode === Hn.Dense ? WD(e, t) : YD(e, t), WD = (e, t) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  return Wn.visit(r, e.valueOffsets[t]);
}, YD = (e, t) => {
  const i = e.type.typeIdToChildIndex[e.typeIds[t]], r = e.children[i];
  return Wn.visit(r, t);
}, NX = (e, t) => {
  var i;
  return (i = e.dictionary) === null || i === void 0 ? void 0 : i.get(e.values[t]);
}, LX = (e, t) => e.type.unit === Pa.DAY_TIME ? qD(e, t) : ZD(e, t), qD = ({ values: e }, t) => e.subarray(2 * t, 2 * (t + 1)), ZD = ({ values: e }, t) => {
  const i = e[t], r = new Int32Array(2);
  return r[0] = Math.trunc(i / 12), r[1] = Math.trunc(i % 12), r;
}, XD = ({ values: e }, t) => e[t], KD = ({ values: e }, t) => e[t], JD = ({ values: e }, t) => e[t], QD = ({ values: e }, t) => e[t], FX = (e, t) => {
  switch (e.type.unit) {
    case Se.SECOND:
      return XD(e, t);
    case Se.MILLISECOND:
      return KD(e, t);
    case Se.MICROSECOND:
      return JD(e, t);
    case Se.NANOSECOND:
      return QD(e, t);
  }
}, BX = (e, t) => {
  const { stride: i, children: r } = e, s = r[0].slice(t * i, i);
  return new qi([s]);
};
ve.prototype.visitNull = Te(vX);
ve.prototype.visitBool = Te(_X);
ve.prototype.visitInt = Te(wX);
ve.prototype.visitInt8 = Te(Hc);
ve.prototype.visitInt16 = Te(Hc);
ve.prototype.visitInt32 = Te(Hc);
ve.prototype.visitInt64 = Te(BD);
ve.prototype.visitUint8 = Te(Hc);
ve.prototype.visitUint16 = Te(Hc);
ve.prototype.visitUint32 = Te(Hc);
ve.prototype.visitUint64 = Te(BD);
ve.prototype.visitFloat = Te(SX);
ve.prototype.visitFloat16 = Te(bX);
ve.prototype.visitFloat32 = Te(Hc);
ve.prototype.visitFloat64 = Te(Hc);
ve.prototype.visitUtf8 = Te(MD);
ve.prototype.visitLargeUtf8 = Te(MD);
ve.prototype.visitBinary = Te(RD);
ve.prototype.visitLargeBinary = Te(RD);
ve.prototype.visitFixedSizeBinary = Te(xX);
ve.prototype.visitDate = Te(IX);
ve.prototype.visitDateDay = Te(LD);
ve.prototype.visitDateMillisecond = Te(FD);
ve.prototype.visitTimestamp = Te(AX);
ve.prototype.visitTimestampSecond = Te(PD);
ve.prototype.visitTimestampMillisecond = Te($D);
ve.prototype.visitTimestampMicrosecond = Te(zD);
ve.prototype.visitTimestampNanosecond = Te(UD);
ve.prototype.visitTime = Te(TX);
ve.prototype.visitTimeSecond = Te(VD);
ve.prototype.visitTimeMillisecond = Te(jD);
ve.prototype.visitTimeMicrosecond = Te(GD);
ve.prototype.visitTimeNanosecond = Te(HD);
ve.prototype.visitDecimal = Te(EX);
ve.prototype.visitList = Te(kX);
ve.prototype.visitStruct = Te(OX);
ve.prototype.visitUnion = Te(DX);
ve.prototype.visitDenseUnion = Te(WD);
ve.prototype.visitSparseUnion = Te(YD);
ve.prototype.visitDictionary = Te(NX);
ve.prototype.visitInterval = Te(LX);
ve.prototype.visitIntervalDayTime = Te(qD);
ve.prototype.visitIntervalYearMonth = Te(ZD);
ve.prototype.visitDuration = Te(FX);
ve.prototype.visitDurationSecond = Te(XD);
ve.prototype.visitDurationMillisecond = Te(KD);
ve.prototype.visitDurationMicrosecond = Te(JD);
ve.prototype.visitDurationNanosecond = Te(QD);
ve.prototype.visitFixedSizeList = Te(BX);
ve.prototype.visitMap = Te(CX);
const Wn = new ve(), Ta = Symbol.for("keys"), xu = Symbol.for("vals");
class gw {
  constructor(t) {
    return this[Ta] = new qi([t.children[0]]).memoize(), this[xu] = t.children[1], new Proxy(this, new MX());
  }
  [Symbol.iterator]() {
    return new RX(this[Ta], this[xu]);
  }
  get size() {
    return this[Ta].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const t = this[Ta], i = this[xu], r = {};
    for (let n = -1, s = t.length; ++n < s; )
      r[t.get(n)] = Wn.visit(i, n);
    return r;
  }
  toString() {
    return `{${[...this].map(([t, i]) => `${Xf(t)}: ${Xf(i)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}
class RX {
  constructor(t, i) {
    this.keys = t, this.vals = i, this.keyIndex = 0, this.numKeys = t.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const t = this.keyIndex;
    return t === this.numKeys ? { done: !0, value: null } : (this.keyIndex++, {
      done: !1,
      value: [
        this.keys.get(t),
        Wn.visit(this.vals, t)
      ]
    });
  }
}
class MX {
  isExtensible() {
    return !1;
  }
  deleteProperty() {
    return !1;
  }
  preventExtensions() {
    return !0;
  }
  ownKeys(t) {
    return t[Ta].toArray().map(String);
  }
  has(t, i) {
    return t[Ta].includes(i);
  }
  getOwnPropertyDescriptor(t, i) {
    if (t[Ta].indexOf(i) !== -1)
      return { writable: !0, enumerable: !0, configurable: !0 };
  }
  get(t, i) {
    if (Reflect.has(t, i))
      return t[i];
    const r = t[Ta].indexOf(i);
    if (r !== -1) {
      const n = Wn.visit(Reflect.get(t, xu), r);
      return Reflect.set(t, i, n), n;
    }
  }
  set(t, i, r) {
    const n = t[Ta].indexOf(i);
    return n !== -1 ? (As.visit(Reflect.get(t, xu), n, r), Reflect.set(t, i, r)) : Reflect.has(t, i) ? Reflect.set(t, i, r) : !1;
  }
}
Object.defineProperties(gw.prototype, {
  [Symbol.toStringTag]: { enumerable: !1, configurable: !1, value: "Row" },
  [Ta]: { writable: !0, enumerable: !1, configurable: !1, value: null },
  [xu]: { writable: !0, enumerable: !1, configurable: !1, value: null }
});
let _3;
function tN(e, t, i, r) {
  const { length: n = 0 } = e;
  let s = typeof t != "number" ? 0 : t, a = typeof i != "number" ? n : i;
  return s < 0 && (s = (s % n + n) % n), a < 0 && (a = (a % n + n) % n), a < s && (_3 = s, s = a, a = _3), a > n && (a = n), r ? r(e, s, a) : [s, a];
}
const b3 = (e) => e !== e;
function uh(e) {
  if (typeof e !== "object" || e === null)
    return b3(e) ? b3 : (i) => i === e;
  if (e instanceof Date) {
    const i = e.valueOf();
    return (r) => r instanceof Date ? r.valueOf() === i : !1;
  }
  return ArrayBuffer.isView(e) ? (i) => i ? DZ(e, i) : !1 : e instanceof Map ? $X(e) : Array.isArray(e) ? PX(e) : e instanceof qi ? zX(e) : UX(e, !0);
}
function PX(e) {
  const t = [];
  for (let i = -1, r = e.length; ++i < r; )
    t[i] = uh(e[i]);
  return Uy(t);
}
function $X(e) {
  let t = -1;
  const i = [];
  for (const r of e.values())
    i[++t] = uh(r);
  return Uy(i);
}
function zX(e) {
  const t = [];
  for (let i = -1, r = e.length; ++i < r; )
    t[i] = uh(e.get(i));
  return Uy(t);
}
function UX(e, t = !1) {
  const i = Object.keys(e);
  if (!t && i.length === 0)
    return () => !1;
  const r = [];
  for (let n = -1, s = i.length; ++n < s; )
    r[n] = uh(e[i[n]]);
  return Uy(r, i);
}
function Uy(e, t) {
  return (i) => {
    if (!i || typeof i != "object")
      return !1;
    switch (i.constructor) {
      case Array:
        return VX(e, i);
      case Map:
        return x3(e, i, i.keys());
      case gw:
      case pw:
      case Object:
      case void 0:
        return x3(e, i, t || Object.keys(i));
    }
    return i instanceof qi ? jX(e, i) : !1;
  };
}
function VX(e, t) {
  const i = e.length;
  if (t.length !== i)
    return !1;
  for (let r = -1; ++r < i; )
    if (!e[r](t[r]))
      return !1;
  return !0;
}
function jX(e, t) {
  const i = e.length;
  if (t.length !== i)
    return !1;
  for (let r = -1; ++r < i; )
    if (!e[r](t.get(r)))
      return !1;
  return !0;
}
function x3(e, t, i) {
  const r = i[Symbol.iterator](), n = t instanceof Map ? t.keys() : Object.keys(t)[Symbol.iterator](), s = t instanceof Map ? t.values() : Object.values(t)[Symbol.iterator]();
  let a = 0;
  const o = e.length;
  let c = s.next(), l = r.next(), d = n.next();
  for (; a < o && !l.done && !d.done && !c.done && !(l.value !== d.value || !e[a](c.value)); ++a, l = r.next(), d = n.next(), c = s.next())
    ;
  return a === o && l.done && d.done && c.done ? !0 : (r.return && r.return(), n.return && n.return(), s.return && s.return(), !1);
}
function eN(e, t, i, r) {
  return (i & 1 << r) !== 0;
}
function GX(e, t, i, r) {
  return (i & 1 << r) >> r;
}
function w3(e, t, i) {
  const r = i.byteLength + 7 & -8;
  if (e > 0 || i.byteLength < r) {
    const n = new Uint8Array(r);
    return n.set(e % 8 === 0 ? i.subarray(e >> 3) : (
      // Otherwise iterate each bit from the offset and return a new one
      Vb(new yw(i, e, t, null, eN)).subarray(0, r)
    )), n;
  }
  return i;
}
function Vb(e) {
  const t = [];
  let i = 0, r = 0, n = 0;
  for (const a of e)
    a && (n |= 1 << r), ++r === 8 && (t[i++] = n, n = r = 0);
  (i === 0 || r > 0) && (t[i++] = n);
  const s = new Uint8Array(t.length + 7 & -8);
  return s.set(t), s;
}
class yw {
  constructor(t, i, r, n, s) {
    this.bytes = t, this.length = r, this.context = n, this.get = s, this.bit = i % 8, this.byteIndex = i >> 3, this.byte = t[this.byteIndex++], this.index = 0;
  }
  next() {
    return this.index < this.length ? (this.bit === 8 && (this.bit = 0, this.byte = this.bytes[this.byteIndex++]), {
      value: this.get(this.context, this.index++, this.byte, this.bit++)
    }) : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function jb(e, t, i) {
  if (i - t <= 0)
    return 0;
  if (i - t < 8) {
    let s = 0;
    for (const a of new yw(e, t, i - t, e, GX))
      s += a;
    return s;
  }
  const r = i >> 3 << 3, n = t + (t % 8 === 0 ? 0 : 8 - t % 8);
  return (
    // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
    jb(e, t, n) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
    jb(e, r, i) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
    HX(e, n >> 3, r - n >> 3)
  );
}
function HX(e, t, i) {
  let r = 0, n = Math.trunc(t);
  const s = new DataView(e.buffer, e.byteOffset, e.byteLength), a = i === void 0 ? e.byteLength : n + i;
  for (; a - n >= 4; )
    r += N_(s.getUint32(n)), n += 4;
  for (; a - n >= 2; )
    r += N_(s.getUint16(n)), n += 2;
  for (; a - n >= 1; )
    r += N_(s.getUint8(n)), n += 1;
  return r;
}
function N_(e) {
  let t = Math.trunc(e);
  return t = t - (t >>> 1 & 1431655765), t = (t & 858993459) + (t >>> 2 & 858993459), (t + (t >>> 4) & 252645135) * 16843009 >>> 24;
}
const WX = -1;
class Mi {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type: t } = this;
      return ge.isSparseUnion(t) ? this.children.some((i) => i.nullable) : ge.isDenseUnion(t) ? this.children.some((i) => i.nullable) : this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return !0;
  }
  get byteLength() {
    let t = 0;
    const { valueOffsets: i, values: r, nullBitmap: n, typeIds: s } = this;
    return i && (t += i.byteLength), r && (t += r.byteLength), n && (t += n.byteLength), s && (t += s.byteLength), this.children.reduce((a, o) => a + o.byteLength, t);
  }
  get nullCount() {
    if (ge.isUnion(this.type))
      return this.children.reduce((r, n) => r + n.nullCount, 0);
    let t = this._nullCount, i;
    return t <= WX && (i = this.nullBitmap) && (this._nullCount = t = this.length - jb(i, this.offset, this.offset + this.length)), t;
  }
  constructor(t, i, r, n, s, a = [], o) {
    this.type = t, this.children = a, this.dictionary = o, this.offset = Math.floor(Math.max(i || 0, 0)), this.length = Math.floor(Math.max(r || 0, 0)), this._nullCount = Math.floor(Math.max(n || 0, -1));
    let c;
    s instanceof Mi ? (this.stride = s.stride, this.values = s.values, this.typeIds = s.typeIds, this.nullBitmap = s.nullBitmap, this.valueOffsets = s.valueOffsets) : (this.stride = ho(t), s && ((c = s[0]) && (this.valueOffsets = c), (c = s[1]) && (this.values = c), (c = s[2]) && (this.nullBitmap = c), (c = s[3]) && (this.typeIds = c)));
  }
  getValid(t) {
    const { type: i } = this;
    if (ge.isUnion(i)) {
      const r = i, n = this.children[r.typeIdToChildIndex[this.typeIds[t]]], s = r.mode === Hn.Dense ? this.valueOffsets[t] : t;
      return n.getValid(s);
    }
    if (this.nullable && this.nullCount > 0) {
      const r = this.offset + t;
      return (this.nullBitmap[r >> 3] & 1 << r % 8) !== 0;
    }
    return !0;
  }
  setValid(t, i) {
    let r;
    const { type: n } = this;
    if (ge.isUnion(n)) {
      const s = n, a = this.children[s.typeIdToChildIndex[this.typeIds[t]]], o = s.mode === Hn.Dense ? this.valueOffsets[t] : t;
      r = a.getValid(o), a.setValid(o, i);
    } else {
      let { nullBitmap: s } = this;
      const { offset: a, length: o } = this, c = a + t, l = 1 << c % 8, d = c >> 3;
      (!s || s.byteLength <= d) && (s = new Uint8Array((a + o + 63 & -64) >> 3).fill(255), this.nullCount > 0 && s.set(w3(a, o, this.nullBitmap), 0), Object.assign(this, { nullBitmap: s, _nullCount: -1 }));
      const u = s[d];
      r = (u & l) !== 0, i ? s[d] = u | l : s[d] = u & ~l;
    }
    return r !== !!i && (this._nullCount = this.nullCount + (i ? -1 : 1)), i;
  }
  clone(t = this.type, i = this.offset, r = this.length, n = this._nullCount, s = this, a = this.children) {
    return new Mi(t, i, r, n, s, a, this.dictionary);
  }
  slice(t, i) {
    const { stride: r, typeId: n, children: s } = this, a = +(this._nullCount === 0) - 1, o = n === 16 ? r : 1, c = this._sliceBuffers(t, i, r, n);
    return this.clone(
      this.type,
      this.offset + t,
      i,
      a,
      c,
      // Don't slice children if we have value offsets (the variable-width types)
      s.length === 0 || this.valueOffsets ? s : this._sliceChildren(s, o * t, o * i)
    );
  }
  _changeLengthAndBackfillNullBitmap(t) {
    if (this.typeId === M.Null)
      return this.clone(this.type, 0, t, 0);
    const { length: i, nullCount: r } = this, n = new Uint8Array((t + 63 & -64) >> 3).fill(255, 0, i >> 3);
    n[i >> 3] = (1 << i - (i & -8)) - 1, r > 0 && n.set(w3(this.offset, i, this.nullBitmap), 0);
    const s = this.buffers;
    return s[uo.VALIDITY] = n, this.clone(this.type, 0, t, r + (t - i), s);
  }
  _sliceBuffers(t, i, r, n) {
    let s;
    const { buffers: a } = this;
    return (s = a[uo.TYPE]) && (a[uo.TYPE] = s.subarray(t, t + i)), (s = a[uo.OFFSET]) && (a[uo.OFFSET] = s.subarray(t, t + i + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
    (s = a[uo.DATA]) && (a[uo.DATA] = n === 6 ? s : s.subarray(r * t, r * (t + i))), a;
  }
  _sliceChildren(t, i, r) {
    return t.map((n) => n.slice(i, r));
  }
}
Mi.prototype.children = Object.freeze([]);
class Tf extends li {
  visit(t) {
    return this.getVisitFn(t.type).call(this, t);
  }
  visitNull(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["length"]: n = 0 } = t;
    return new Mi(i, r, n, n);
  }
  visitBool(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length >> 3, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitInt(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitFloat(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitUtf8(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.data), s = _i(t.nullBitmap), a = Zh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, n, s]);
  }
  visitLargeUtf8(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.data), s = _i(t.nullBitmap), a = d3(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, n, s]);
  }
  visitBinary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.data), s = _i(t.nullBitmap), a = Zh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, n, s]);
  }
  visitLargeBinary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.data), s = _i(t.nullBitmap), a = d3(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, n, s]);
  }
  visitFixedSizeBinary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitDate(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitTimestamp(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitTime(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitDecimal(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitList(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n } = t, s = _i(t.nullBitmap), a = Zh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, void 0, s], [n]);
  }
  visitStruct(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["children"]: n = [] } = t, s = _i(t.nullBitmap), { length: a = n.reduce((c, { length: l }) => Math.max(c, l), 0), nullCount: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, void 0, s], n);
  }
  visitUnion(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["children"]: n = [] } = t, s = $i(i.ArrayType, t.typeIds), { ["length"]: a = s.length, ["nullCount"]: o = -1 } = t;
    if (ge.isSparseUnion(i))
      return new Mi(i, r, a, o, [void 0, void 0, void 0, s], n);
    const c = Zh(t.valueOffsets);
    return new Mi(i, r, a, o, [c, void 0, void 0, s], n);
  }
  visitDictionary(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.indices.ArrayType, t.data), { ["dictionary"]: a = new qi([new Tf().visit({ type: i.dictionary })]) } = t, { ["length"]: o = s.length, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [void 0, s, n], [], a);
  }
  visitInterval(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitDuration(t) {
    const { ["type"]: i, ["offset"]: r = 0 } = t, n = _i(t.nullBitmap), s = $i(i.ArrayType, t.data), { ["length"]: a = s.length, ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, s, n]);
  }
  visitFixedSizeList(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n = new Tf().visit({ type: i.valueType }) } = t, s = _i(t.nullBitmap), { ["length"]: a = n.length / ho(i), ["nullCount"]: o = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, a, o, [void 0, void 0, s], [n]);
  }
  visitMap(t) {
    const { ["type"]: i, ["offset"]: r = 0, ["child"]: n = new Tf().visit({ type: i.childType }) } = t, s = _i(t.nullBitmap), a = Zh(t.valueOffsets), { ["length"]: o = a.length - 1, ["nullCount"]: c = t.nullBitmap ? -1 : 0 } = t;
    return new Mi(i, r, o, c, [a, void 0, s], [n]);
  }
}
const YX = new Tf();
function ci(e) {
  return YX.visit(e);
}
class S3 {
  constructor(t = 0, i) {
    this.numChunks = t, this.getChunkIterator = i, this.chunkIndex = 0, this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    for (; this.chunkIndex < this.numChunks; ) {
      const t = this.chunkIterator.next();
      if (!t.done)
        return t;
      ++this.chunkIndex < this.numChunks && (this.chunkIterator = this.getChunkIterator(this.chunkIndex));
    }
    return { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function qX(e) {
  return e.some((t) => t.nullable);
}
function iN(e) {
  return e.reduce((t, i) => t + i.nullCount, 0);
}
function rN(e) {
  return e.reduce((t, i, r) => (t[r + 1] = t[r] + i.length, t), new Uint32Array(e.length + 1));
}
function nN(e, t, i, r) {
  const n = [];
  for (let s = -1, a = e.length; ++s < a; ) {
    const o = e[s], c = t[s], { length: l } = o;
    if (c >= r)
      break;
    if (i >= c + l)
      continue;
    if (c >= i && c + l <= r) {
      n.push(o);
      continue;
    }
    const d = Math.max(0, i - c), u = Math.min(r - c, l);
    n.push(o.slice(d, u - d));
  }
  return n.length === 0 && n.push(e[0].slice(0, 0)), n;
}
function vw(e, t, i, r) {
  let n = 0, s = 0, a = t.length - 1;
  do {
    if (n >= a - 1)
      return i < t[a] ? r(e, n, i - t[n]) : null;
    s = n + Math.trunc((a - n) * 0.5), i < t[s] ? a = s : n = s;
  } while (n < a);
}
function _w(e, t) {
  return e.getValid(t);
}
function z0(e) {
  function t(i, r, n) {
    return e(i[r], n);
  }
  return function(i) {
    const r = this.data;
    return vw(r, this._offsets, i, t);
  };
}
function sN(e) {
  let t;
  function i(r, n, s) {
    return e(r[n], s, t);
  }
  return function(r, n) {
    const s = this.data;
    t = n;
    const a = vw(s, this._offsets, r, i);
    return t = void 0, a;
  };
}
function aN(e) {
  let t;
  function i(r, n, s) {
    let a = s, o = 0, c = 0;
    for (let l = n - 1, d = r.length; ++l < d; ) {
      const u = r[l];
      if (~(o = e(u, t, a)))
        return c + o;
      a = 0, c += u.length;
    }
    return -1;
  }
  return function(r, n) {
    t = r;
    const s = this.data, a = typeof n != "number" ? i(s, 0, 0) : vw(s, this._offsets, n, i);
    return t = void 0, a;
  };
}
class _e extends li {
}
function ZX(e, t) {
  return t === null && e.length > 0 ? 0 : -1;
}
function XX(e, t) {
  const { nullBitmap: i } = e;
  if (!i || e.nullCount <= 0)
    return -1;
  let r = 0;
  for (const n of new yw(i, e.offset + (t || 0), e.length, i, eN)) {
    if (!n)
      return r;
    ++r;
  }
  return -1;
}
function ze(e, t, i) {
  if (t === void 0)
    return -1;
  if (t === null)
    switch (e.typeId) {
      case M.Union:
        break;
      case M.Dictionary:
        break;
      default:
        return XX(e, i);
    }
  const r = Wn.getVisitFn(e), n = uh(t);
  for (let s = (i || 0) - 1, a = e.length; ++s < a; )
    if (n(r(e, s)))
      return s;
  return -1;
}
function oN(e, t, i) {
  const r = Wn.getVisitFn(e), n = uh(t);
  for (let s = (i || 0) - 1, a = e.length; ++s < a; )
    if (n(r(e, s)))
      return s;
  return -1;
}
_e.prototype.visitNull = ZX;
_e.prototype.visitBool = ze;
_e.prototype.visitInt = ze;
_e.prototype.visitInt8 = ze;
_e.prototype.visitInt16 = ze;
_e.prototype.visitInt32 = ze;
_e.prototype.visitInt64 = ze;
_e.prototype.visitUint8 = ze;
_e.prototype.visitUint16 = ze;
_e.prototype.visitUint32 = ze;
_e.prototype.visitUint64 = ze;
_e.prototype.visitFloat = ze;
_e.prototype.visitFloat16 = ze;
_e.prototype.visitFloat32 = ze;
_e.prototype.visitFloat64 = ze;
_e.prototype.visitUtf8 = ze;
_e.prototype.visitLargeUtf8 = ze;
_e.prototype.visitBinary = ze;
_e.prototype.visitLargeBinary = ze;
_e.prototype.visitFixedSizeBinary = ze;
_e.prototype.visitDate = ze;
_e.prototype.visitDateDay = ze;
_e.prototype.visitDateMillisecond = ze;
_e.prototype.visitTimestamp = ze;
_e.prototype.visitTimestampSecond = ze;
_e.prototype.visitTimestampMillisecond = ze;
_e.prototype.visitTimestampMicrosecond = ze;
_e.prototype.visitTimestampNanosecond = ze;
_e.prototype.visitTime = ze;
_e.prototype.visitTimeSecond = ze;
_e.prototype.visitTimeMillisecond = ze;
_e.prototype.visitTimeMicrosecond = ze;
_e.prototype.visitTimeNanosecond = ze;
_e.prototype.visitDecimal = ze;
_e.prototype.visitList = ze;
_e.prototype.visitStruct = ze;
_e.prototype.visitUnion = ze;
_e.prototype.visitDenseUnion = oN;
_e.prototype.visitSparseUnion = oN;
_e.prototype.visitDictionary = ze;
_e.prototype.visitInterval = ze;
_e.prototype.visitIntervalDayTime = ze;
_e.prototype.visitIntervalYearMonth = ze;
_e.prototype.visitDuration = ze;
_e.prototype.visitDurationSecond = ze;
_e.prototype.visitDurationMillisecond = ze;
_e.prototype.visitDurationMicrosecond = ze;
_e.prototype.visitDurationNanosecond = ze;
_e.prototype.visitFixedSizeList = ze;
_e.prototype.visitMap = ze;
const U0 = new _e();
class be extends li {
}
function Ee(e) {
  const { type: t } = e;
  if (e.nullCount === 0 && e.stride === 1 && (t.typeId === M.Timestamp || t instanceof Fc && t.bitWidth !== 64 || t instanceof ep && t.bitWidth !== 64 || t instanceof tp && t.precision !== vn.HALF))
    return new S3(e.data.length, (r) => {
      const n = e.data[r];
      return n.values.subarray(0, n.length)[Symbol.iterator]();
    });
  let i = 0;
  return new S3(e.data.length, (r) => {
    const s = e.data[r].length, a = e.slice(i, i + s);
    return i += s, new KX(a);
  });
}
class KX {
  constructor(t) {
    this.vector = t, this.index = 0;
  }
  next() {
    return this.index < this.vector.length ? {
      value: this.vector.get(this.index++)
    } : { done: !0, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
be.prototype.visitNull = Ee;
be.prototype.visitBool = Ee;
be.prototype.visitInt = Ee;
be.prototype.visitInt8 = Ee;
be.prototype.visitInt16 = Ee;
be.prototype.visitInt32 = Ee;
be.prototype.visitInt64 = Ee;
be.prototype.visitUint8 = Ee;
be.prototype.visitUint16 = Ee;
be.prototype.visitUint32 = Ee;
be.prototype.visitUint64 = Ee;
be.prototype.visitFloat = Ee;
be.prototype.visitFloat16 = Ee;
be.prototype.visitFloat32 = Ee;
be.prototype.visitFloat64 = Ee;
be.prototype.visitUtf8 = Ee;
be.prototype.visitLargeUtf8 = Ee;
be.prototype.visitBinary = Ee;
be.prototype.visitLargeBinary = Ee;
be.prototype.visitFixedSizeBinary = Ee;
be.prototype.visitDate = Ee;
be.prototype.visitDateDay = Ee;
be.prototype.visitDateMillisecond = Ee;
be.prototype.visitTimestamp = Ee;
be.prototype.visitTimestampSecond = Ee;
be.prototype.visitTimestampMillisecond = Ee;
be.prototype.visitTimestampMicrosecond = Ee;
be.prototype.visitTimestampNanosecond = Ee;
be.prototype.visitTime = Ee;
be.prototype.visitTimeSecond = Ee;
be.prototype.visitTimeMillisecond = Ee;
be.prototype.visitTimeMicrosecond = Ee;
be.prototype.visitTimeNanosecond = Ee;
be.prototype.visitDecimal = Ee;
be.prototype.visitList = Ee;
be.prototype.visitStruct = Ee;
be.prototype.visitUnion = Ee;
be.prototype.visitDenseUnion = Ee;
be.prototype.visitSparseUnion = Ee;
be.prototype.visitDictionary = Ee;
be.prototype.visitInterval = Ee;
be.prototype.visitIntervalDayTime = Ee;
be.prototype.visitIntervalYearMonth = Ee;
be.prototype.visitDuration = Ee;
be.prototype.visitDurationSecond = Ee;
be.prototype.visitDurationMillisecond = Ee;
be.prototype.visitDurationMicrosecond = Ee;
be.prototype.visitDurationNanosecond = Ee;
be.prototype.visitFixedSizeList = Ee;
be.prototype.visitMap = Ee;
const bw = new be();
var cN;
const lN = {}, dN = {};
class qi {
  constructor(t) {
    var i, r, n;
    const s = t[0] instanceof qi ? t.flatMap((o) => o.data) : t;
    if (s.length === 0 || s.some((o) => !(o instanceof Mi)))
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    const a = (i = s[0]) === null || i === void 0 ? void 0 : i.type;
    switch (s.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: o, set: c, indexOf: l } = lN[a.typeId], d = s[0];
        this.isValid = (u) => _w(d, u), this.get = (u) => o(d, u), this.set = (u, h) => c(d, u, h), this.indexOf = (u) => l(d, u), this._offsets = [0, d.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, dN[a.typeId]), this._offsets = rN(s);
        break;
    }
    this.data = s, this.type = a, this.stride = ho(a), this.numChildren = (n = (r = a.children) === null || r === void 0 ? void 0 : r.length) !== null && n !== void 0 ? n : 0, this.length = this._offsets.at(-1);
  }
  /**
   * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
   */
  get byteLength() {
    return this.data.reduce((t, i) => t + i.byteLength, 0);
  }
  /**
   * Whether this Vector's elements can contain null values.
   */
  get nullable() {
    return qX(this.data);
  }
  /**
   * The number of null elements in this Vector.
   */
  get nullCount() {
    return iN(this.data);
  }
  /**
   * The Array or TypedArray constructor used for the JS representation
   *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
   */
  get ArrayType() {
    return this.type.ArrayType;
  }
  /**
   * The name that should be printed when the Vector is logged in a message.
   */
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  /**
   * The name of this Vector.
   */
  get VectorName() {
    return `${M[this.type.typeId]}Vector`;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, i) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, i) {
    return -1;
  }
  includes(t, i) {
    return this.indexOf(t, i) > -1;
  }
  /**
   * Iterator for the Vector's elements.
   */
  [Symbol.iterator]() {
    return bw.visit(this);
  }
  /**
   * Combines two or more Vectors of the same type.
   * @param others Additional Vectors to add to the end of this Vector.
   */
  concat(...t) {
    return new qi(this.data.concat(t.flatMap((i) => i.data).flat(Number.POSITIVE_INFINITY)));
  }
  /**
   * Return a zero-copy sub-section of this Vector.
   * @param start The beginning of the specified portion of the Vector.
   * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    return new qi(tN(this, t, i, ({ data: r, _offsets: n }, s, a) => nN(r, n, s, a)));
  }
  toJSON() {
    return [...this];
  }
  /**
   * Return a JavaScript Array or TypedArray of the Vector's elements.
   *
   * @note If this Vector contains a single Data chunk and the Vector's type is a
   *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
   *  method returns a zero-copy slice of the underlying TypedArray values. If there's
   *  more than one chunk, the resulting TypedArray will be a copy of the data from each
   *  chunk's underlying TypedArray values.
   *
   * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
   */
  toArray() {
    const { type: t, data: i, length: r, stride: n, ArrayType: s } = this;
    switch (t.typeId) {
      case M.Int:
      case M.Float:
      case M.Decimal:
      case M.Time:
      case M.Timestamp:
        switch (i.length) {
          case 0:
            return new s();
          case 1:
            return i[0].values.subarray(0, r * n);
          default:
            return i.reduce((a, { values: o, length: c }) => (a.array.set(o.subarray(0, c * n), a.offset), a.offset += c * n, a), { array: new s(r * n), offset: 0 }).array;
        }
    }
    return [...this];
  }
  /**
   * Returns a string representation of the Vector.
   *
   * @returns A string representation of the Vector.
   */
  toString() {
    return `[${[...this].join(",")}]`;
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var i;
    return this.getChildAt((i = this.type.children) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.numChildren ? new qi(this.data.map(({ children: i }) => i[t])) : null;
  }
  get isMemoized() {
    return ge.isDictionary(this.type) ? this.data[0].dictionary.isMemoized : !1;
  }
  /**
   * Adds memoization to the Vector's {@link get} method. For dictionary
   * vectors, this method return a vector that memoizes only the dictionary
   * values.
   *
   * Memoization is very useful when decoding a value is expensive such as
   * Utf8. The memoization creates a cache of the size of the Vector and
   * therefore increases memory usage.
   *
   * @returns A new vector that memoizes calls to {@link get}.
   */
  memoize() {
    if (ge.isDictionary(this.type)) {
      const t = new V0(this.data[0].dictionary), i = this.data.map((r) => {
        const n = r.clone();
        return n.dictionary = t, n;
      });
      return new qi(i);
    }
    return new V0(this);
  }
  /**
   * Returns a vector without memoization of the {@link get} method. If this
   * vector is not memoized, this method returns this vector.
   *
   * @returns A new vector without memoization.
   */
  unmemoize() {
    if (ge.isDictionary(this.type) && this.isMemoized) {
      const t = this.data[0].dictionary.unmemoize(), i = this.data.map((r) => {
        const n = r.clone();
        return n.dictionary = t, n;
      });
      return new qi(i);
    }
    return this;
  }
}
cN = Symbol.toStringTag;
qi[cN] = ((e) => {
  e.type = ge.prototype, e.data = [], e.length = 0, e.stride = 1, e.numChildren = 0, e._offsets = new Uint32Array([0]), e[Symbol.isConcatSpreadable] = !0;
  const t = Object.keys(M).map((i) => M[i]).filter((i) => typeof i == "number" && i !== M.NONE);
  for (const i of t) {
    const r = Wn.getVisitFnByTypeId(i), n = As.getVisitFnByTypeId(i), s = U0.getVisitFnByTypeId(i);
    lN[i] = { get: r, set: n, indexOf: s }, dN[i] = Object.create(e, {
      isValid: { value: z0(_w) },
      get: { value: z0(Wn.getVisitFnByTypeId(i)) },
      set: { value: sN(As.getVisitFnByTypeId(i)) },
      indexOf: { value: aN(U0.getVisitFnByTypeId(i)) }
    });
  }
  return "Vector";
})(qi.prototype);
class V0 extends qi {
  constructor(t) {
    super(t.data);
    const i = this.get, r = this.set, n = this.slice, s = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(a) {
        const o = s[a];
        if (o !== void 0)
          return o;
        const c = i.call(this, a);
        return s[a] = c, c;
      }
    }), Object.defineProperty(this, "set", {
      value(a, o) {
        r.call(this, a, o), s[a] = o;
      }
    }), Object.defineProperty(this, "slice", {
      value: (a, o) => new V0(n.call(this, a, o))
    }), Object.defineProperty(this, "isMemoized", { value: !0 }), Object.defineProperty(this, "unmemoize", {
      value: () => new qi(this.data)
    }), Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
}
class Gb {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  /**
   * Index to the start of the RecordBlock (note this is past the Message header)
   */
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  /**
   * Length of the metadata
   */
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  /**
   * Length of the data (this is aligned so there can be a gap between this and
   * the metadata).
   */
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(t, i, r, n) {
    return t.prep(8, 24), t.writeInt64(BigInt(n ?? 0)), t.pad(4), t.writeInt32(r), t.writeInt64(BigInt(i ?? 0)), t.offset();
  }
}
class Qn {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsFooter(t, i) {
    return (i || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsFooter(t, i) {
    return t.setPosition(t.position() + de), (i || new Qn()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Vr.V1;
  }
  schema(t) {
    const i = this.bb.__offset(this.bb_pos, 6);
    return i ? (t || new _a()).__init(this.bb.__indirect(this.bb_pos + i), this.bb) : null;
  }
  dictionaries(t, i) {
    const r = this.bb.__offset(this.bb_pos, 8);
    return r ? (i || new Gb()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
  }
  dictionariesLength() {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  recordBatches(t, i) {
    const r = this.bb.__offset(this.bb_pos, 10);
    return r ? (i || new Gb()).__init(this.bb.__vector(this.bb_pos + r) + t * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  /**
   * User-defined metadata
   */
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 12);
    return r ? (i || new Jr()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startFooter(t) {
    t.startObject(5);
  }
  static addVersion(t, i) {
    t.addFieldInt16(0, i, Vr.V1);
  }
  static addSchema(t, i) {
    t.addFieldOffset(1, i, 0);
  }
  static addDictionaries(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static startDictionariesVector(t, i) {
    t.startVector(24, i, 8);
  }
  static addRecordBatches(t, i) {
    t.addFieldOffset(3, i, 0);
  }
  static startRecordBatchesVector(t, i) {
    t.startVector(24, i, 8);
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endFooter(t) {
    return t.endObject();
  }
  static finishFooterBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedFooterBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
}
class Bi {
  constructor(t = [], i, r, n = Vr.V5) {
    this.fields = t || [], this.metadata = i || /* @__PURE__ */ new Map(), r || (r = Hb(t)), this.dictionaries = r, this.metadataVersion = n;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((t) => t.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((t, i) => `${i}: ${t}`).join(", ")} }>`;
  }
  /**
   * Construct a new Schema containing only specified fields.
   *
   * @param fieldNames Names of fields to keep.
   * @returns A new Schema of fields matching the specified names.
   */
  select(t) {
    const i = new Set(t), r = this.fields.filter((n) => i.has(n.name));
    return new Bi(r, this.metadata);
  }
  /**
   * Construct a new Schema containing only fields at the specified indices.
   *
   * @param fieldIndices Indices of fields to keep.
   * @returns A new Schema of fields at the specified indices.
   */
  selectAt(t) {
    const i = t.map((r) => this.fields[r]).filter(Boolean);
    return new Bi(i, this.metadata);
  }
  assign(...t) {
    const i = t[0] instanceof Bi ? t[0] : Array.isArray(t[0]) ? new Bi(t[0]) : new Bi(t), r = [...this.fields], n = Hm(Hm(/* @__PURE__ */ new Map(), this.metadata), i.metadata), s = i.fields.filter((o) => {
      const c = r.findIndex((l) => l.name === o.name);
      return ~c ? (r[c] = o.clone({
        metadata: Hm(Hm(/* @__PURE__ */ new Map(), r[c].metadata), o.metadata)
      })) && !1 : !0;
    }), a = Hb(s, /* @__PURE__ */ new Map());
    return new Bi([...r, ...s], n, new Map([...this.dictionaries, ...a]));
  }
}
Bi.prototype.fields = null;
Bi.prototype.metadata = null;
Bi.prototype.dictionaries = null;
class ar {
  /** @nocollapse */
  static new(...t) {
    let [i, r, n, s] = t;
    return t[0] && typeof t[0] == "object" && ({ name: i } = t[0], r === void 0 && (r = t[0].type), n === void 0 && (n = t[0].nullable), s === void 0 && (s = t[0].metadata)), new ar(`${i}`, r, n, s);
  }
  constructor(t, i, r = !1, n) {
    this.name = t, this.type = i, this.nullable = r, this.metadata = n || /* @__PURE__ */ new Map();
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...t) {
    let [i, r, n, s] = t;
    return !t[0] || typeof t[0] != "object" ? [i = this.name, r = this.type, n = this.nullable, s = this.metadata] = t : { name: i = this.name, type: r = this.type, nullable: n = this.nullable, metadata: s = this.metadata } = t[0], ar.new(i, r, n, s);
  }
}
ar.prototype.type = null;
ar.prototype.name = null;
ar.prototype.nullable = null;
ar.prototype.metadata = null;
function Hm(e, t) {
  return new Map([...e || /* @__PURE__ */ new Map(), ...t || /* @__PURE__ */ new Map()]);
}
function Hb(e, t = /* @__PURE__ */ new Map()) {
  for (let i = -1, r = e.length; ++i < r; ) {
    const s = e[i].type;
    if (ge.isDictionary(s)) {
      if (!t.has(s.id))
        t.set(s.id, s.dictionary);
      else if (t.get(s.id) !== s.dictionary)
        throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
    }
    s.children && s.children.length > 0 && Hb(s.children, t);
  }
  return t;
}
var JX = Ey, QX = Fa;
class xw {
  /** @nocollapse */
  static decode(t) {
    t = new QX(_i(t));
    const i = Qn.getRootAsFooter(t), r = Bi.decode(i.schema(), /* @__PURE__ */ new Map(), i.version());
    return new tK(r, i);
  }
  /** @nocollapse */
  static encode(t) {
    const i = new JX(), r = Bi.encode(i, t.schema);
    Qn.startRecordBatchesVector(i, t.numRecordBatches);
    for (const a of [...t.recordBatches()].slice().reverse())
      Yu.encode(i, a);
    const n = i.endVector();
    Qn.startDictionariesVector(i, t.numDictionaries);
    for (const a of [...t.dictionaryBatches()].slice().reverse())
      Yu.encode(i, a);
    const s = i.endVector();
    return Qn.startFooter(i), Qn.addSchema(i, r), Qn.addVersion(i, Vr.V5), Qn.addRecordBatches(i, n), Qn.addDictionaries(i, s), Qn.finishFooterBuffer(i, Qn.endFooter(i)), i.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(t, i = Vr.V5, r, n) {
    this.schema = t, this.version = i, r && (this._recordBatches = r), n && (this._dictionaryBatches = n);
  }
  *recordBatches() {
    for (let t, i = -1, r = this.numRecordBatches; ++i < r; )
      (t = this.getRecordBatch(i)) && (yield t);
  }
  *dictionaryBatches() {
    for (let t, i = -1, r = this.numDictionaries; ++i < r; )
      (t = this.getDictionaryBatch(i)) && (yield t);
  }
  getRecordBatch(t) {
    return t >= 0 && t < this.numRecordBatches && this._recordBatches[t] || null;
  }
  getDictionaryBatch(t) {
    return t >= 0 && t < this.numDictionaries && this._dictionaryBatches[t] || null;
  }
}
class tK extends xw {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(t, i) {
    super(t, i.version()), this._footer = i;
  }
  getRecordBatch(t) {
    if (t >= 0 && t < this.numRecordBatches) {
      const i = this._footer.recordBatches(t);
      if (i)
        return Yu.decode(i);
    }
    return null;
  }
  getDictionaryBatch(t) {
    if (t >= 0 && t < this.numDictionaries) {
      const i = this._footer.dictionaries(t);
      if (i)
        return Yu.decode(i);
    }
    return null;
  }
}
class Yu {
  /** @nocollapse */
  static decode(t) {
    return new Yu(t.metaDataLength(), t.bodyLength(), t.offset());
  }
  /** @nocollapse */
  static encode(t, i) {
    const { metaDataLength: r } = i, n = BigInt(i.offset), s = BigInt(i.bodyLength);
    return Gb.createBlock(t, n, r, s);
  }
  constructor(t, i, r) {
    this.metaDataLength = t, this.offset = Cn(r), this.bodyLength = Cn(i);
  }
}
const _r = Object.freeze({ done: !0, value: void 0 });
class I3 {
  constructor(t) {
    this._json = t;
  }
  get schema() {
    return this._json.schema;
  }
  get batches() {
    return this._json.batches || [];
  }
  get dictionaries() {
    return this._json.dictionaries || [];
  }
}
class uN {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(t, i) {
    return this._getNodeStream().pipe(t, i);
  }
  pipeTo(t, i) {
    return this._getDOMStream().pipeTo(t, i);
  }
  pipeThrough(t, i) {
    return this._getDOMStream().pipeThrough(t, i);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
}
class eK extends uN {
  constructor() {
    super(), this._values = [], this.resolvers = [], this._closedPromise = new Promise((t) => this._closedPromiseResolve = t);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  write(t) {
    this._ensureOpen() && (this.resolvers.length <= 0 ? this._values.push(t) : this.resolvers.shift().resolve({ done: !1, value: t }));
  }
  abort(t) {
    this._closedPromiseResolve && (this.resolvers.length <= 0 ? this._error = { error: t } : this.resolvers.shift().reject({ done: !0, value: t }));
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers: t } = this;
      for (; t.length > 0; )
        t.shift().resolve(_r);
      this._closedPromiseResolve(), this._closedPromiseResolve = void 0;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(t) {
    return ms.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  toNodeStream(t) {
    return ms.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, t);
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.abort(t), _r;
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), _r;
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(...t) {
    return this._values.length > 0 ? Promise.resolve({ done: !1, value: this._values.shift() }) : this._error ? Promise.reject({ done: !0, value: this._error.error }) : this._closedPromiseResolve ? new Promise((i, r) => {
      this.resolvers.push({ resolve: i, reject: r });
    }) : Promise.resolve(_r);
  }
  _ensureOpen() {
    if (this._closedPromiseResolve)
      return !0;
    throw new Error("AsyncQueue is closed");
  }
}
class iK extends eK {
  write(t) {
    if ((t = _i(t)).byteLength > 0)
      return super.write(t);
  }
  toString(t = !1) {
    return t ? Mb(this.toUint8Array(!0)) : this.toUint8Array(!1).then(Mb);
  }
  toUint8Array(t = !1) {
    return t ? Ma(this._values)[0] : Dt(this, void 0, void 0, function* () {
      var i, r, n, s;
      const a = [];
      let o = 0;
      try {
        for (var c = !0, l = es(this), d; d = yield l.next(), i = d.done, !i; c = !0) {
          s = d.value, c = !1;
          const u = s;
          a.push(u), o += u.byteLength;
        }
      } catch (u) {
        r = { error: u };
      } finally {
        try {
          !c && !i && (n = l.return) && (yield n.call(l));
        } finally {
          if (r)
            throw r.error;
        }
      }
      return Ma(a, o)[0];
    });
  }
}
class j0 {
  constructor(t) {
    t && (this.source = new rK(ms.fromIterable(t)));
  }
  [Symbol.iterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}
class qu {
  constructor(t) {
    t instanceof qu ? this.source = t.source : t instanceof iK ? this.source = new fl(ms.fromAsyncIterable(t)) : F4(t) ? this.source = new fl(ms.fromNodeStream(t)) : lw(t) ? this.source = new fl(ms.fromDOMStream(t)) : N4(t) ? this.source = new fl(ms.fromDOMStream(t.body)) : zy(t) ? this.source = new fl(ms.fromIterable(t)) : Zf(t) ? this.source = new fl(ms.fromAsyncIterable(t)) : cw(t) && (this.source = new fl(ms.fromAsyncIterable(t)));
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(t) {
    return this.source.next(t);
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(t) {
    return this.source.cancel(t);
  }
  peek(t) {
    return this.source.peek(t);
  }
  read(t) {
    return this.source.read(t);
  }
}
class rK {
  constructor(t) {
    this.source = t;
  }
  cancel(t) {
    this.return(t);
  }
  peek(t) {
    return this.next(t, "peek").value;
  }
  read(t) {
    return this.next(t, "read").value;
  }
  next(t, i = "read") {
    return this.source.next({ cmd: i, size: t });
  }
  throw(t) {
    return Object.create(this.source.throw && this.source.throw(t) || _r);
  }
  return(t) {
    return Object.create(this.source.return && this.source.return(t) || _r);
  }
}
class fl {
  constructor(t) {
    this.source = t, this._closedPromise = new Promise((i) => this._closedPromiseResolve = i);
  }
  cancel(t) {
    return Dt(this, void 0, void 0, function* () {
      yield this.return(t);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "read")).value;
    });
  }
  peek(t) {
    return Dt(this, void 0, void 0, function* () {
      return (yield this.next(t, "peek")).value;
    });
  }
  next(t, i = "read") {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.next({ cmd: i, size: t });
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = this.source.throw && (yield this.source.throw(t)) || _r;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(i);
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = this.source.return && (yield this.source.return(t)) || _r;
      return this._closedPromiseResolve && this._closedPromiseResolve(), this._closedPromiseResolve = void 0, Object.create(i);
    });
  }
}
class A3 extends j0 {
  constructor(t, i) {
    super(), this.position = 0, this.buffer = _i(t), this.size = i === void 0 ? this.buffer.byteLength : i;
  }
  readInt32(t) {
    const { buffer: i, byteOffset: r } = this.readAt(t, 4);
    return new DataView(i, r).getInt32(0, !0);
  }
  seek(t) {
    return this.position = Math.min(t, this.size), t < this.size;
  }
  read(t) {
    const { buffer: i, size: r, position: n } = this;
    return i && n < r ? (typeof t != "number" && (t = Number.POSITIVE_INFINITY), this.position = Math.min(r, n + Math.min(r - n, t)), i.subarray(n, this.position)) : null;
  }
  readAt(t, i) {
    const r = this.buffer, n = Math.min(this.size, t + i);
    return r ? r.subarray(t, n) : new Uint8Array(i);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(t) {
    return this.close(), { done: !0, value: t };
  }
  return(t) {
    return this.close(), { done: !0, value: t };
  }
}
class G0 extends qu {
  constructor(t, i) {
    super(), this.position = 0, this._handle = t, typeof i == "number" ? this.size = i : this._pending = Dt(this, void 0, void 0, function* () {
      this.size = (yield t.stat()).size, delete this._pending;
    });
  }
  readInt32(t) {
    return Dt(this, void 0, void 0, function* () {
      const { buffer: i, byteOffset: r } = yield this.readAt(t, 4);
      return new DataView(i, r).getInt32(0, !0);
    });
  }
  seek(t) {
    return Dt(this, void 0, void 0, function* () {
      return this._pending && (yield this._pending), this.position = Math.min(t, this.size), t < this.size;
    });
  }
  read(t) {
    return Dt(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: i, size: r, position: n } = this;
      if (i && n < r) {
        typeof t != "number" && (t = Number.POSITIVE_INFINITY);
        let s = n, a = 0, o = 0;
        const c = Math.min(r, s + Math.min(r - s, t)), l = new Uint8Array(Math.max(0, (this.position = c) - s));
        for (; (s += o) < c && (a += o) < l.byteLength; )
          ({ bytesRead: o } = yield i.read(l, a, l.byteLength - a, s));
        return l;
      }
      return null;
    });
  }
  readAt(t, i) {
    return Dt(this, void 0, void 0, function* () {
      this._pending && (yield this._pending);
      const { _handle: r, size: n } = this;
      if (r && t + i < n) {
        const s = Math.min(n, t + i), a = new Uint8Array(s - t);
        return (yield r.read(a, 0, i, t)).buffer;
      }
      return new Uint8Array(i);
    });
  }
  close() {
    return Dt(this, void 0, void 0, function* () {
      const t = this._handle;
      this._handle = null, t && (yield t.close());
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.close(), { done: !0, value: t };
    });
  }
}
const nK = 65536;
function ou(e) {
  return e < 0 && (e = 4294967295 + e + 1), `0x${e.toString(16)}`;
}
const Zu = 8, ww = [
  1,
  10,
  100,
  1e3,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];
class hN {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(t) {
    const i = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]), r = new Uint32Array([
      t.buffer[1] >>> 16,
      t.buffer[1] & 65535,
      t.buffer[0] >>> 16,
      t.buffer[0] & 65535
    ]);
    let n = i[3] * r[3];
    this.buffer[0] = n & 65535;
    let s = n >>> 16;
    return n = i[2] * r[3], s += n, n = i[3] * r[2] >>> 0, s += n, this.buffer[0] += s << 16, this.buffer[1] = s >>> 0 < n ? nK : 0, this.buffer[1] += s >>> 16, this.buffer[1] += i[1] * r[3] + i[2] * r[2] + i[3] * r[1], this.buffer[1] += i[0] * r[3] + i[1] * r[2] + i[2] * r[1] + i[3] * r[0] << 16, this;
  }
  _plus(t) {
    const i = this.buffer[0] + t.buffer[0] >>> 0;
    this.buffer[1] += t.buffer[1], i < this.buffer[0] >>> 0 && ++this.buffer[1], this.buffer[0] = i;
  }
  lessThan(t) {
    return this.buffer[1] < t.buffer[1] || this.buffer[1] === t.buffer[1] && this.buffer[0] < t.buffer[0];
  }
  equals(t) {
    return this.buffer[1] === t.buffer[1] && this.buffer[0] == t.buffer[0];
  }
  greaterThan(t) {
    return t.lessThan(this);
  }
  hex() {
    return `${ou(this.buffer[1])} ${ou(this.buffer[0])}`;
  }
}
class Pi extends hN {
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(2)) {
    return Pi.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(2)) {
    return Pi.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(2)) {
    const r = t.length, n = new Pi(i);
    for (let s = 0; s < r; ) {
      const a = Zu < r - s ? Zu : r - s, o = new Pi(new Uint32Array([Number.parseInt(t.slice(s, s + a), 10), 0])), c = new Pi(new Uint32Array([ww[a], 0]));
      n.times(c), n.plus(o), s += a;
    }
    return n;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 2);
    for (let r = -1, n = t.length; ++r < n; )
      Pi.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 2 * r * 4, 2));
    return i;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new Pi(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new Pi(new Uint32Array(t.buffer)).plus(i);
  }
}
class Mn extends hN {
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[0] == 0 && ++this.buffer[1], this;
  }
  times(t) {
    return this._times(t), this;
  }
  plus(t) {
    return this._plus(t), this;
  }
  lessThan(t) {
    const i = this.buffer[1] << 0, r = t.buffer[1] << 0;
    return i < r || i === r && this.buffer[0] < t.buffer[0];
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(2)) {
    return Mn.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(2)) {
    return Mn.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(2)) {
    const r = t.startsWith("-"), n = t.length, s = new Mn(i);
    for (let a = r ? 1 : 0; a < n; ) {
      const o = Zu < n - a ? Zu : n - a, c = new Mn(new Uint32Array([Number.parseInt(t.slice(a, a + o), 10), 0])), l = new Mn(new Uint32Array([ww[o], 0]));
      s.times(l), s.plus(c), a += o;
    }
    return r ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 2);
    for (let r = -1, n = t.length; ++r < n; )
      Mn.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 2 * r * 4, 2));
    return i;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new Mn(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new Mn(new Uint32Array(t.buffer)).plus(i);
  }
}
class ba {
  constructor(t) {
    this.buffer = t;
  }
  high() {
    return new Mn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new Mn(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    return this.buffer[0] = ~this.buffer[0] + 1, this.buffer[1] = ~this.buffer[1], this.buffer[2] = ~this.buffer[2], this.buffer[3] = ~this.buffer[3], this.buffer[0] == 0 && ++this.buffer[1], this.buffer[1] == 0 && ++this.buffer[2], this.buffer[2] == 0 && ++this.buffer[3], this;
  }
  times(t) {
    const i = new Pi(new Uint32Array([this.buffer[3], 0])), r = new Pi(new Uint32Array([this.buffer[2], 0])), n = new Pi(new Uint32Array([this.buffer[1], 0])), s = new Pi(new Uint32Array([this.buffer[0], 0])), a = new Pi(new Uint32Array([t.buffer[3], 0])), o = new Pi(new Uint32Array([t.buffer[2], 0])), c = new Pi(new Uint32Array([t.buffer[1], 0])), l = new Pi(new Uint32Array([t.buffer[0], 0]));
    let d = Pi.multiply(s, l);
    this.buffer[0] = d.low();
    const u = new Pi(new Uint32Array([d.high(), 0]));
    return d = Pi.multiply(n, l), u.plus(d), d = Pi.multiply(s, c), u.plus(d), this.buffer[1] = u.low(), this.buffer[3] = u.lessThan(d) ? 1 : 0, this.buffer[2] = u.high(), new Pi(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2)).plus(Pi.multiply(r, l)).plus(Pi.multiply(n, c)).plus(Pi.multiply(s, o)), this.buffer[3] += Pi.multiply(i, l).plus(Pi.multiply(r, c)).plus(Pi.multiply(n, o)).plus(Pi.multiply(s, a)).low(), this;
  }
  plus(t) {
    const i = new Uint32Array(4);
    return i[3] = this.buffer[3] + t.buffer[3] >>> 0, i[2] = this.buffer[2] + t.buffer[2] >>> 0, i[1] = this.buffer[1] + t.buffer[1] >>> 0, i[0] = this.buffer[0] + t.buffer[0] >>> 0, i[0] < this.buffer[0] >>> 0 && ++i[1], i[1] < this.buffer[1] >>> 0 && ++i[2], i[2] < this.buffer[2] >>> 0 && ++i[3], this.buffer[3] = i[3], this.buffer[2] = i[2], this.buffer[1] = i[1], this.buffer[0] = i[0], this;
  }
  hex() {
    return `${ou(this.buffer[3])} ${ou(this.buffer[2])} ${ou(this.buffer[1])} ${ou(this.buffer[0])}`;
  }
  /** @nocollapse */
  static multiply(t, i) {
    return new ba(new Uint32Array(t.buffer)).times(i);
  }
  /** @nocollapse */
  static add(t, i) {
    return new ba(new Uint32Array(t.buffer)).plus(i);
  }
  /** @nocollapse */
  static from(t, i = new Uint32Array(4)) {
    return ba.fromString(typeof t == "string" ? t : t.toString(), i);
  }
  /** @nocollapse */
  static fromNumber(t, i = new Uint32Array(4)) {
    return ba.fromString(t.toString(), i);
  }
  /** @nocollapse */
  static fromString(t, i = new Uint32Array(4)) {
    const r = t.startsWith("-"), n = t.length, s = new ba(i);
    for (let a = r ? 1 : 0; a < n; ) {
      const o = Zu < n - a ? Zu : n - a, c = new ba(new Uint32Array([Number.parseInt(t.slice(a, a + o), 10), 0, 0, 0])), l = new ba(new Uint32Array([ww[o], 0, 0, 0]));
      s.times(l), s.plus(c), a += o;
    }
    return r ? s.negate() : s;
  }
  /** @nocollapse */
  static convertArray(t) {
    const i = new Uint32Array(t.length * 4);
    for (let r = -1, n = t.length; ++r < n; )
      ba.from(t[r], new Uint32Array(i.buffer, i.byteOffset + 4 * 4 * r, 4));
    return i;
  }
}
class fN extends li {
  constructor(t, i, r, n, s = Vr.V5) {
    super(), this.nodesIndex = -1, this.buffersIndex = -1, this.bytes = t, this.nodes = i, this.buffers = r, this.dictionaries = n, this.metadataVersion = s;
  }
  visit(t) {
    return super.visit(t instanceof ar ? t.type : t);
  }
  visitNull(t, { length: i } = this.nextFieldNode()) {
    return ci({ type: t, length: i });
  }
  visitBool(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitInt(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitFloat(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitUtf8(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeUtf8(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitBinary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitLargeBinary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), data: this.readData(t) });
  }
  visitFixedSizeBinary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDate(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitTimestamp(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitTime(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDecimal(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitList(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  visitStruct(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), children: this.visitMany(t.children) });
  }
  visitUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return this.metadataVersion < Vr.V5 && this.readNullBitmap(t, r), t.mode === Hn.Sparse ? this.visitSparseUnion(t, { length: i, nullCount: r }) : this.visitDenseUnion(t, { length: i, nullCount: r });
  }
  visitDenseUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, typeIds: this.readTypeIds(t), valueOffsets: this.readOffsets(t), children: this.visitMany(t.children) });
  }
  visitSparseUnion(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, typeIds: this.readTypeIds(t), children: this.visitMany(t.children) });
  }
  visitDictionary(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t.indices), dictionary: this.readDictionary(t) });
  }
  visitInterval(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitDuration(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), data: this.readData(t) });
  }
  visitFixedSizeList(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), child: this.visit(t.children[0]) });
  }
  visitMap(t, { length: i, nullCount: r } = this.nextFieldNode()) {
    return ci({ type: t, length: i, nullCount: r, nullBitmap: this.readNullBitmap(t, r), valueOffsets: this.readOffsets(t), child: this.visit(t.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(t, i, r = this.nextBufferRange()) {
    return i > 0 && this.readData(t, r) || new Uint8Array(0);
  }
  readOffsets(t, i) {
    return this.readData(t, i);
  }
  readTypeIds(t, i) {
    return this.readData(t, i);
  }
  readData(t, { length: i, offset: r } = this.nextBufferRange()) {
    return this.bytes.subarray(r, r + i);
  }
  readDictionary(t) {
    return this.dictionaries.get(t.id);
  }
}
class sK extends fN {
  constructor(t, i, r, n, s) {
    super(new Uint8Array(0), i, r, n, s), this.sources = t;
  }
  readNullBitmap(t, i, { offset: r } = this.nextBufferRange()) {
    return i <= 0 ? new Uint8Array(0) : Vb(this.sources[r]);
  }
  readOffsets(t, { offset: i } = this.nextBufferRange()) {
    return $i(Uint8Array, $i(t.OffsetArrayType, this.sources[i]));
  }
  readTypeIds(t, { offset: i } = this.nextBufferRange()) {
    return $i(Uint8Array, $i(t.ArrayType, this.sources[i]));
  }
  readData(t, { offset: i } = this.nextBufferRange()) {
    const { sources: r } = this;
    return ge.isTimestamp(t) || (ge.isInt(t) || ge.isTime(t)) && t.bitWidth === 64 || ge.isDuration(t) || ge.isDate(t) && t.unit === ea.MILLISECOND ? $i(Uint8Array, Mn.convertArray(r[i])) : ge.isDecimal(t) ? $i(Uint8Array, ba.convertArray(r[i])) : ge.isBinary(t) || ge.isLargeBinary(t) || ge.isFixedSizeBinary(t) ? aK(r[i]) : ge.isBool(t) ? Vb(r[i]) : ge.isUtf8(t) || ge.isLargeUtf8(t) ? ow(r[i].join("")) : $i(Uint8Array, $i(t.ArrayType, r[i].map((n) => +n)));
  }
}
function aK(e) {
  const t = e.join(""), i = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    i[r >> 1] = Number.parseInt(t.slice(r, r + 2), 16);
  return i;
}
class xe extends li {
  compareSchemas(t, i) {
    return t === i || i instanceof t.constructor && this.compareManyFields(t.fields, i.fields);
  }
  compareManyFields(t, i) {
    return t === i || Array.isArray(t) && Array.isArray(i) && t.length === i.length && t.every((r, n) => this.compareFields(r, i[n]));
  }
  compareFields(t, i) {
    return t === i || i instanceof t.constructor && t.name === i.name && t.nullable === i.nullable && this.visit(t.type, i.type);
  }
}
function Ln(e, t) {
  return t instanceof e.constructor;
}
function Jl(e, t) {
  return e === t || Ln(e, t);
}
function Wo(e, t) {
  return e === t || Ln(e, t) && e.bitWidth === t.bitWidth && e.isSigned === t.isSigned;
}
function Vy(e, t) {
  return e === t || Ln(e, t) && e.precision === t.precision;
}
function oK(e, t) {
  return e === t || Ln(e, t) && e.byteWidth === t.byteWidth;
}
function Sw(e, t) {
  return e === t || Ln(e, t) && e.unit === t.unit;
}
function Mp(e, t) {
  return e === t || Ln(e, t) && e.unit === t.unit && e.timezone === t.timezone;
}
function Pp(e, t) {
  return e === t || Ln(e, t) && e.unit === t.unit && e.bitWidth === t.bitWidth;
}
function cK(e, t) {
  return e === t || Ln(e, t) && e.children.length === t.children.length && Bc.compareManyFields(e.children, t.children);
}
function lK(e, t) {
  return e === t || Ln(e, t) && e.children.length === t.children.length && Bc.compareManyFields(e.children, t.children);
}
function Iw(e, t) {
  return e === t || Ln(e, t) && e.mode === t.mode && e.typeIds.every((i, r) => i === t.typeIds[r]) && Bc.compareManyFields(e.children, t.children);
}
function dK(e, t) {
  return e === t || Ln(e, t) && e.id === t.id && e.isOrdered === t.isOrdered && Bc.visit(e.indices, t.indices) && Bc.visit(e.dictionary, t.dictionary);
}
function Aw(e, t) {
  return e === t || Ln(e, t) && e.unit === t.unit;
}
function $p(e, t) {
  return e === t || Ln(e, t) && e.unit === t.unit;
}
function uK(e, t) {
  return e === t || Ln(e, t) && e.listSize === t.listSize && e.children.length === t.children.length && Bc.compareManyFields(e.children, t.children);
}
function hK(e, t) {
  return e === t || Ln(e, t) && e.keysSorted === t.keysSorted && e.children.length === t.children.length && Bc.compareManyFields(e.children, t.children);
}
xe.prototype.visitNull = Jl;
xe.prototype.visitBool = Jl;
xe.prototype.visitInt = Wo;
xe.prototype.visitInt8 = Wo;
xe.prototype.visitInt16 = Wo;
xe.prototype.visitInt32 = Wo;
xe.prototype.visitInt64 = Wo;
xe.prototype.visitUint8 = Wo;
xe.prototype.visitUint16 = Wo;
xe.prototype.visitUint32 = Wo;
xe.prototype.visitUint64 = Wo;
xe.prototype.visitFloat = Vy;
xe.prototype.visitFloat16 = Vy;
xe.prototype.visitFloat32 = Vy;
xe.prototype.visitFloat64 = Vy;
xe.prototype.visitUtf8 = Jl;
xe.prototype.visitLargeUtf8 = Jl;
xe.prototype.visitBinary = Jl;
xe.prototype.visitLargeBinary = Jl;
xe.prototype.visitFixedSizeBinary = oK;
xe.prototype.visitDate = Sw;
xe.prototype.visitDateDay = Sw;
xe.prototype.visitDateMillisecond = Sw;
xe.prototype.visitTimestamp = Mp;
xe.prototype.visitTimestampSecond = Mp;
xe.prototype.visitTimestampMillisecond = Mp;
xe.prototype.visitTimestampMicrosecond = Mp;
xe.prototype.visitTimestampNanosecond = Mp;
xe.prototype.visitTime = Pp;
xe.prototype.visitTimeSecond = Pp;
xe.prototype.visitTimeMillisecond = Pp;
xe.prototype.visitTimeMicrosecond = Pp;
xe.prototype.visitTimeNanosecond = Pp;
xe.prototype.visitDecimal = Jl;
xe.prototype.visitList = cK;
xe.prototype.visitStruct = lK;
xe.prototype.visitUnion = Iw;
xe.prototype.visitDenseUnion = Iw;
xe.prototype.visitSparseUnion = Iw;
xe.prototype.visitDictionary = dK;
xe.prototype.visitInterval = Aw;
xe.prototype.visitIntervalDayTime = Aw;
xe.prototype.visitIntervalYearMonth = Aw;
xe.prototype.visitDuration = $p;
xe.prototype.visitDurationSecond = $p;
xe.prototype.visitDurationMillisecond = $p;
xe.prototype.visitDurationMicrosecond = $p;
xe.prototype.visitDurationNanosecond = $p;
xe.prototype.visitFixedSizeList = uK;
xe.prototype.visitMap = hK;
const Bc = new xe();
function fK(e, t) {
  return Bc.compareSchemas(e, t);
}
function L_(e, t) {
  return pK(e, t.map((i) => i.data.concat()));
}
function pK(e, t) {
  const i = [...e.fields], r = [], n = { numBatches: t.reduce((u, h) => Math.max(u, h.length), 0) };
  let s = 0, a = 0, o = -1;
  const c = t.length;
  let l, d = [];
  for (; n.numBatches-- > 0; ) {
    for (a = Number.POSITIVE_INFINITY, o = -1; ++o < c; )
      d[o] = l = t[o].shift(), a = Math.min(a, l ? l.length : a);
    Number.isFinite(a) && (d = mK(i, a, d, t, n), a > 0 && (r[s++] = ci({
      type: new An(i),
      length: a,
      nullCount: 0,
      children: d.slice()
    })));
  }
  return [
    e = e.assign(i),
    r.map((u) => new $s(e, u))
  ];
}
function mK(e, t, i, r, n) {
  var s;
  const a = (t + 63 & -64) >> 3;
  for (let o = -1, c = r.length; ++o < c; ) {
    const l = i[o], d = l == null ? void 0 : l.length;
    if (d >= t)
      d === t ? i[o] = l : (i[o] = l.slice(0, t), n.numBatches = Math.max(n.numBatches, r[o].unshift(l.slice(t, d - t))));
    else {
      const u = e[o];
      e[o] = u.clone({ nullable: !0 }), i[o] = (s = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(t)) !== null && s !== void 0 ? s : ci({
        type: u.type,
        length: t,
        nullCount: t,
        nullBitmap: new Uint8Array(a)
      });
    }
  }
  return i;
}
var pN;
class _s {
  constructor(...t) {
    var i, r;
    if (t.length === 0)
      return this.batches = [], this.schema = new Bi([]), this._offsets = [0], this;
    let n, s;
    t[0] instanceof Bi && (n = t.shift()), t.at(-1) instanceof Uint32Array && (s = t.pop());
    const a = (c) => {
      if (c) {
        if (c instanceof $s)
          return [c];
        if (c instanceof _s)
          return c.batches;
        if (c instanceof Mi) {
          if (c.type instanceof An)
            return [new $s(new Bi(c.type.children), c)];
        } else {
          if (Array.isArray(c))
            return c.flatMap((l) => a(l));
          if (typeof c[Symbol.iterator] == "function")
            return [...c].flatMap((l) => a(l));
          if (typeof c == "object") {
            const l = Object.keys(c), d = l.map((p) => new qi([c[p]])), u = n ?? new Bi(l.map((p, m) => new ar(String(p), d[m].type, d[m].nullable))), [, h] = L_(u, d);
            return h.length === 0 ? [new $s(c)] : h;
          }
        }
      }
      return [];
    }, o = t.flatMap((c) => a(c));
    if (n = (r = n ?? ((i = o[0]) === null || i === void 0 ? void 0 : i.schema)) !== null && r !== void 0 ? r : new Bi([]), !(n instanceof Bi))
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    for (const c of o) {
      if (!(c instanceof $s))
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      if (!fK(n, c.schema))
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
    }
    this.schema = n, this.batches = o, this._offsets = s ?? rN(this.data);
  }
  /**
   * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
   */
  get data() {
    return this.batches.map(({ data: t }) => t);
  }
  /**
   * The number of columns in this Table.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this Table.
   */
  get numRows() {
    return this.data.reduce((t, i) => t + i.length, 0);
  }
  /**
   * The number of null rows in this Table.
   */
  get nullCount() {
    return this._nullCount === -1 && (this._nullCount = iN(this.data)), this._nullCount;
  }
  /**
   * Check whether an element is null.
   *
   * @param index The index at which to read the validity bitmap.
   */
  // @ts-ignore
  isValid(t) {
    return !1;
  }
  /**
   * Get an element value by position.
   *
   * @param index The index of the element to read.
   */
  // @ts-ignore
  get(t) {
    return null;
  }
  /**
   * Set an element value by position.
   *
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  // @ts-ignore
  set(t, i) {
  }
  /**
   * Retrieve the index of the first occurrence of a value in an Vector.
   *
   * @param element The value to locate in the Vector.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  // @ts-ignore
  indexOf(t, i) {
    return -1;
  }
  /**
   * Iterator for rows in this Table.
   */
  [Symbol.iterator]() {
    return this.batches.length > 0 ? bw.visit(new qi(this.data)) : new Array(0)[Symbol.iterator]();
  }
  /**
   * Return a JavaScript Array of the Table rows.
   *
   * @returns An Array of Table rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Returns a string representation of the Table rows.
   *
   * @returns A string representation of the Table rows.
   */
  toString() {
    return `[
  ${this.toArray().join(`,
  `)}
]`;
  }
  /**
   * Combines two or more Tables of the same schema.
   *
   * @param others Additional Tables to add to the end of this Tables.
   */
  concat(...t) {
    const i = this.schema, r = this.data.concat(t.flatMap(({ data: n }) => n));
    return new _s(i, r.map((n) => new $s(i, n)));
  }
  /**
   * Return a zero-copy sub-section of this Table.
   *
   * @param begin The beginning of the specified portion of the Table.
   * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    const r = this.schema;
    [t, i] = tN({ length: this.numRows }, t, i);
    const n = nN(this.data, this._offsets, t, i);
    return new _s(r, n.map((s) => new $s(r, s)));
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   *
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    return this.getChildAt(this.schema.fields.findIndex((i) => i.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   *
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    if (t > -1 && t < this.schema.fields.length) {
      const i = this.data.map((r) => r.children[t]);
      if (i.length === 0) {
        const { type: r } = this.schema.fields[t], n = ci({ type: r, length: 0, nullCount: 0 });
        i.push(n._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new qi(i);
    }
    return null;
  }
  /**
   * Sets a child Vector by name.
   *
   * @param name The name of the child to overwrite.
   * @returns A new Table with the supplied child for the specified name.
   */
  setChild(t, i) {
    var r;
    return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((n) => n.name === t), i);
  }
  setChildAt(t, i) {
    let r = this.schema, n = [...this.batches];
    if (t > -1 && t < this.numCols) {
      i || (i = new qi([ci({ type: new Lc(), length: this.numRows })]));
      const s = r.fields.slice(), a = s[t].clone({ type: i.type }), o = this.schema.fields.map((c, l) => this.getChildAt(l));
      [s[t], o[t]] = [a, i], [r, n] = L_(r, o);
    }
    return new _s(r, n);
  }
  /**
   * Construct a new Table containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new Table of columns matching the specified names.
   */
  select(t) {
    const i = this.schema.fields.reduce((r, n, s) => r.set(n.name, s), /* @__PURE__ */ new Map());
    return this.selectAt(t.map((r) => i.get(r)).filter((r) => r > -1));
  }
  /**
   * Construct a new Table containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new Table of columns at the specified indices.
   */
  selectAt(t) {
    const i = this.schema.selectAt(t), r = this.batches.map((n) => n.selectAt(t));
    return new _s(i, r);
  }
  assign(t) {
    const i = this.schema.fields, [r, n] = t.schema.fields.reduce((o, c, l) => {
      const [d, u] = o, h = i.findIndex((p) => p.name === c.name);
      return ~h ? u[h] = l : d.push(l), o;
    }, [[], []]), s = this.schema.assign(t.schema), a = [
      ...i.map((o, c) => [c, n[c]]).map(([o, c]) => c === void 0 ? this.getChildAt(o) : t.getChildAt(c)),
      ...r.map((o) => t.getChildAt(o))
    ].filter(Boolean);
    return new _s(...L_(s, a));
  }
}
pN = Symbol.toStringTag;
_s[pN] = ((e) => (e.schema = null, e.batches = [], e._offsets = new Uint32Array([0]), e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, e.isValid = z0(_w), e.get = z0(Wn.getVisitFn(M.Struct)), e.set = sN(As.getVisitFn(M.Struct)), e.indexOf = aN(U0.getVisitFn(M.Struct)), "Table"))(_s.prototype);
var mN;
let $s = class vf {
  constructor(...t) {
    switch (t.length) {
      case 2: {
        if ([this.schema] = t, !(this.schema instanceof Bi))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        if ([
          ,
          this.data = ci({
            nullCount: 0,
            type: new An(this.schema.fields),
            children: this.schema.fields.map((i) => ci({ type: i.type, nullCount: 0 }))
          })
        ] = t, !(this.data instanceof Mi))
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        [this.schema, this.data] = T3(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [i] = t, { fields: r, children: n, length: s } = Object.keys(i).reduce((c, l, d) => (c.children[d] = i[l], c.length = Math.max(c.length, i[l].length), c.fields[d] = ar.new({ name: l, type: i[l].type, nullable: !0 }), c), {
          length: 0,
          fields: new Array(),
          children: new Array()
        }), a = new Bi(r), o = ci({ type: new An(r), length: s, children: n, nullCount: 0 });
        [this.schema, this.data] = T3(a, o.children, s);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = gN(this.schema.fields, this.data.children));
  }
  /**
   * The number of columns in this RecordBatch.
   */
  get numCols() {
    return this.schema.fields.length;
  }
  /**
   * The number of rows in this RecordBatch.
   */
  get numRows() {
    return this.data.length;
  }
  /**
   * The number of null rows in this RecordBatch.
   */
  get nullCount() {
    return this.data.nullCount;
  }
  /**
   * Check whether an element is null.
   * @param index The index at which to read the validity bitmap.
   */
  isValid(t) {
    return this.data.getValid(t);
  }
  /**
   * Get a row by position.
   * @param index The index of the element to read.
   */
  get(t) {
    return Wn.visit(this.data, t);
  }
  /**
   * Set a row by position.
   * @param index The index of the element to write.
   * @param value The value to set.
   */
  set(t, i) {
    return As.visit(this.data, t, i);
  }
  /**
   * Retrieve the index of the first occurrence of a row in an RecordBatch.
   * @param element The row to locate in the RecordBatch.
   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
   */
  indexOf(t, i) {
    return U0.visit(this.data, t, i);
  }
  /**
   * Iterator for rows in this RecordBatch.
   */
  [Symbol.iterator]() {
    return bw.visit(new qi([this.data]));
  }
  /**
   * Return a JavaScript Array of the RecordBatch rows.
   * @returns An Array of RecordBatch rows.
   */
  toArray() {
    return [...this];
  }
  /**
   * Combines two or more RecordBatch of the same schema.
   * @param others Additional RecordBatch to add to the end of this RecordBatch.
   */
  concat(...t) {
    return new _s(this.schema, [this, ...t]);
  }
  /**
   * Return a zero-copy sub-section of this RecordBatch.
   * @param start The beginning of the specified portion of the RecordBatch.
   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
   */
  slice(t, i) {
    const [r] = new qi([this.data]).slice(t, i).data;
    return new vf(this.schema, r);
  }
  /**
   * Returns a child Vector by name, or null if this Vector has no child with the given name.
   * @param name The name of the child to retrieve.
   */
  getChild(t) {
    var i;
    return this.getChildAt((i = this.schema.fields) === null || i === void 0 ? void 0 : i.findIndex((r) => r.name === t));
  }
  /**
   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
   * @param index The index of the child to retrieve.
   */
  getChildAt(t) {
    return t > -1 && t < this.schema.fields.length ? new qi([this.data.children[t]]) : null;
  }
  /**
   * Sets a child Vector by name.
   * @param name The name of the child to overwrite.
   * @returns A new RecordBatch with the new child for the specified name.
   */
  setChild(t, i) {
    var r;
    return this.setChildAt((r = this.schema.fields) === null || r === void 0 ? void 0 : r.findIndex((n) => n.name === t), i);
  }
  setChildAt(t, i) {
    let r = this.schema, n = this.data;
    if (t > -1 && t < this.numCols) {
      i || (i = new qi([ci({ type: new Lc(), length: this.numRows })]));
      const s = r.fields.slice(), a = n.children.slice(), o = s[t].clone({ type: i.type });
      [s[t], a[t]] = [o, i.data[0]], r = new Bi(s, new Map(this.schema.metadata)), n = ci({ type: new An(s), children: a });
    }
    return new vf(r, n);
  }
  /**
   * Construct a new RecordBatch containing only specified columns.
   *
   * @param columnNames Names of columns to keep.
   * @returns A new RecordBatch of columns matching the specified names.
   */
  select(t) {
    const i = this.schema.select(t), r = new An(i.fields), n = [];
    for (const s of t) {
      const a = this.schema.fields.findIndex((o) => o.name === s);
      ~a && (n[a] = this.data.children[a]);
    }
    return new vf(i, ci({ type: r, length: this.numRows, children: n }));
  }
  /**
   * Construct a new RecordBatch containing only columns at the specified indices.
   *
   * @param columnIndices Indices of columns to keep.
   * @returns A new RecordBatch of columns matching at the specified indices.
   */
  selectAt(t) {
    const i = this.schema.selectAt(t), r = t.map((s) => this.data.children[s]).filter(Boolean), n = ci({ type: new An(i.fields), length: this.numRows, children: r });
    return new vf(i, n);
  }
};
mN = Symbol.toStringTag;
$s[mN] = ((e) => (e._nullCount = -1, e[Symbol.isConcatSpreadable] = !0, "RecordBatch"))($s.prototype);
function T3(e, t, i = t.reduce((r, n) => Math.max(r, n.length), 0)) {
  var r;
  const n = [...e.fields], s = [...t], a = (i + 63 & -64) >> 3;
  for (const [o, c] of e.fields.entries()) {
    const l = t[o];
    (!l || l.length !== i) && (n[o] = c.clone({ nullable: !0 }), s[o] = (r = l == null ? void 0 : l._changeLengthAndBackfillNullBitmap(i)) !== null && r !== void 0 ? r : ci({
      type: c.type,
      length: i,
      nullCount: i,
      nullBitmap: new Uint8Array(a)
    }));
  }
  return [
    e.assign(n),
    ci({ type: new An(n), length: i, children: s })
  ];
}
function gN(e, t, i = /* @__PURE__ */ new Map()) {
  var r, n;
  if (((r = e == null ? void 0 : e.length) !== null && r !== void 0 ? r : 0) > 0 && (e == null ? void 0 : e.length) === (t == null ? void 0 : t.length))
    for (let s = -1, a = e.length; ++s < a; ) {
      const { type: o } = e[s], c = t[s];
      for (const l of [c, ...((n = c == null ? void 0 : c.dictionary) === null || n === void 0 ? void 0 : n.data) || []])
        gN(o.children, l == null ? void 0 : l.children, i);
      if (ge.isDictionary(o)) {
        const { id: l } = o;
        if (!i.has(l))
          c != null && c.dictionary && i.set(l, c.dictionary);
        else if (i.get(l) !== c.dictionary)
          throw new Error("Cannot create Schema containing two different dictionaries with the same Id");
      }
    }
  return i;
}
class yN extends $s {
  constructor(t) {
    const i = t.fields.map((n) => ci({ type: n.type })), r = ci({ type: new An(t.fields), nullCount: 0, children: i });
    super(t, r);
  }
}
let cc = class ma {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(t, i) {
    return this.bb_pos = t, this.bb = i, this;
  }
  static getRootAsMessage(t, i) {
    return (i || new ma()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  static getSizePrefixedRootAsMessage(t, i) {
    return t.setPosition(t.position() + de), (i || new ma()).__init(t.readInt32(t.position()) + t.position(), t);
  }
  version() {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readInt16(this.bb_pos + t) : Vr.V1;
  }
  headerType() {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb_pos + t) : Fi.NONE;
  }
  header(t) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? this.bb.__union(t, this.bb_pos + i) : null;
  }
  bodyLength() {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readInt64(this.bb_pos + t) : BigInt("0");
  }
  customMetadata(t, i) {
    const r = this.bb.__offset(this.bb_pos, 12);
    return r ? (i || new Jr()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r) + t * 4), this.bb) : null;
  }
  customMetadataLength() {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__vector_len(this.bb_pos + t) : 0;
  }
  static startMessage(t) {
    t.startObject(5);
  }
  static addVersion(t, i) {
    t.addFieldInt16(0, i, Vr.V1);
  }
  static addHeaderType(t, i) {
    t.addFieldInt8(1, i, Fi.NONE);
  }
  static addHeader(t, i) {
    t.addFieldOffset(2, i, 0);
  }
  static addBodyLength(t, i) {
    t.addFieldInt64(3, i, BigInt("0"));
  }
  static addCustomMetadata(t, i) {
    t.addFieldOffset(4, i, 0);
  }
  static createCustomMetadataVector(t, i) {
    t.startVector(4, i.length, 4);
    for (let r = i.length - 1; r >= 0; r--)
      t.addOffset(i[r]);
    return t.endVector();
  }
  static startCustomMetadataVector(t, i) {
    t.startVector(4, i, 4);
  }
  static endMessage(t) {
    return t.endObject();
  }
  static finishMessageBuffer(t, i) {
    t.finish(i);
  }
  static finishSizePrefixedMessageBuffer(t, i) {
    t.finish(i, void 0, !0);
  }
  static createMessage(t, i, r, n, s, a) {
    return ma.startMessage(t), ma.addVersion(t, i), ma.addHeaderType(t, r), ma.addHeader(t, n), ma.addBodyLength(t, s), ma.addCustomMetadata(t, a), ma.endMessage(t);
  }
};
class gK extends li {
  visit(t, i) {
    return t == null || i == null ? void 0 : super.visit(t, i);
  }
  visitNull(t, i) {
    return g3.startNull(i), g3.endNull(i);
  }
  visitInt(t, i) {
    return ts.startInt(i), ts.addBitWidth(i, t.bitWidth), ts.addIsSigned(i, t.isSigned), ts.endInt(i);
  }
  visitFloat(t, i) {
    return Ia.startFloatingPoint(i), Ia.addPrecision(i, t.precision), Ia.endFloatingPoint(i);
  }
  visitBinary(t, i) {
    return u3.startBinary(i), u3.endBinary(i);
  }
  visitLargeBinary(t, i) {
    return f3.startLargeBinary(i), f3.endLargeBinary(i);
  }
  visitBool(t, i) {
    return h3.startBool(i), h3.endBool(i);
  }
  visitUtf8(t, i) {
    return y3.startUtf8(i), y3.endUtf8(i);
  }
  visitLargeUtf8(t, i) {
    return p3.startLargeUtf8(i), p3.endLargeUtf8(i);
  }
  visitDecimal(t, i) {
    return qd.startDecimal(i), qd.addScale(i, t.scale), qd.addPrecision(i, t.precision), qd.addBitWidth(i, t.bitWidth), qd.endDecimal(i);
  }
  visitDate(t, i) {
    return mg.startDate(i), mg.addUnit(i, t.unit), mg.endDate(i);
  }
  visitTime(t, i) {
    return ys.startTime(i), ys.addUnit(i, t.unit), ys.addBitWidth(i, t.bitWidth), ys.endTime(i);
  }
  visitTimestamp(t, i) {
    const r = t.timezone && i.createString(t.timezone) || void 0;
    return vs.startTimestamp(i), vs.addUnit(i, t.unit), r !== void 0 && vs.addTimezone(i, r), vs.endTimestamp(i);
  }
  visitInterval(t, i) {
    return Aa.startInterval(i), Aa.addUnit(i, t.unit), Aa.endInterval(i);
  }
  visitDuration(t, i) {
    return gg.startDuration(i), gg.addUnit(i, t.unit), gg.endDuration(i);
  }
  visitList(t, i) {
    return m3.startList(i), m3.endList(i);
  }
  visitStruct(t, i) {
    return Nl.startStruct_(i), Nl.endStruct_(i);
  }
  visitUnion(t, i) {
    $n.startTypeIdsVector(i, t.typeIds.length);
    const r = $n.createTypeIdsVector(i, t.typeIds);
    return $n.startUnion(i), $n.addMode(i, t.mode), $n.addTypeIds(i, r), $n.endUnion(i);
  }
  visitDictionary(t, i) {
    const r = this.visit(t.indices, i);
    return yo.startDictionaryEncoding(i), yo.addId(i, BigInt(t.id)), yo.addIsOrdered(i, t.isOrdered), r !== void 0 && yo.addIndexType(i, r), yo.endDictionaryEncoding(i);
  }
  visitFixedSizeBinary(t, i) {
    return yg.startFixedSizeBinary(i), yg.addByteWidth(i, t.byteWidth), yg.endFixedSizeBinary(i);
  }
  visitFixedSizeList(t, i) {
    return vg.startFixedSizeList(i), vg.addListSize(i, t.listSize), vg.endFixedSizeList(i);
  }
  visitMap(t, i) {
    return _g.startMap(i), _g.addKeysSorted(i, t.keysSorted), _g.endMap(i);
  }
}
const F_ = new gK();
function yK(e, t = /* @__PURE__ */ new Map()) {
  return new Bi(_K(e, t), xg(e.metadata), t);
}
function vN(e) {
  return new ia(e.count, _N(e.columns), bN(e.columns));
}
function vK(e) {
  return new No(vN(e.data), e.id, e.isDelta);
}
function _K(e, t) {
  return (e.fields || []).filter(Boolean).map((i) => ar.fromJSON(i, t));
}
function E3(e, t) {
  return (e.children || []).filter(Boolean).map((i) => ar.fromJSON(i, t));
}
function _N(e) {
  return (e || []).reduce((t, i) => [
    ...t,
    new hh(i.count, bK(i.VALIDITY)),
    ..._N(i.children)
  ], []);
}
function bN(e, t = []) {
  for (let i = -1, r = (e || []).length; ++i < r; ) {
    const n = e[i];
    n.VALIDITY && t.push(new bo(t.length, n.VALIDITY.length)), n.TYPE_ID && t.push(new bo(t.length, n.TYPE_ID.length)), n.OFFSET && t.push(new bo(t.length, n.OFFSET.length)), n.DATA && t.push(new bo(t.length, n.DATA.length)), t = bN(n.children, t);
  }
  return t;
}
function bK(e) {
  return (e || []).reduce((t, i) => t + +(i === 0), 0);
}
function xK(e, t) {
  let i, r, n, s, a, o;
  return !t || !(s = e.dictionary) ? (a = C3(e, E3(e, t)), n = new ar(e.name, a, e.nullable, xg(e.metadata))) : t.has(i = s.id) ? (r = (r = s.indexType) ? k3(r) : new Qf(), o = new Wu(t.get(i), r, i, s.isOrdered), n = new ar(e.name, o, e.nullable, xg(e.metadata))) : (r = (r = s.indexType) ? k3(r) : new Qf(), t.set(i, a = C3(e, E3(e, t))), o = new Wu(a, r, i, s.isOrdered), n = new ar(e.name, o, e.nullable, xg(e.metadata))), n || null;
}
function xg(e = []) {
  return new Map(e.map(({ key: t, value: i }) => [t, i]));
}
function k3(e) {
  return new Fc(e.isSigned, e.bitWidth);
}
function C3(e, t) {
  const i = e.type.name;
  switch (i) {
    case "NONE":
      return new Lc();
    case "null":
      return new Lc();
    case "binary":
      return new A0();
    case "largebinary":
      return new T0();
    case "utf8":
      return new E0();
    case "largeutf8":
      return new k0();
    case "bool":
      return new C0();
    case "list":
      return new B0((t || [])[0]);
    case "struct":
      return new An(t || []);
    case "struct_":
      return new An(t || []);
  }
  switch (i) {
    case "int": {
      const r = e.type;
      return new Fc(r.isSigned, r.bitWidth);
    }
    case "floatingpoint": {
      const r = e.type;
      return new tp(vn[r.precision]);
    }
    case "decimal": {
      const r = e.type;
      return new O0(r.scale, r.precision, r.bitWidth);
    }
    case "date": {
      const r = e.type;
      return new D0(ea[r.unit]);
    }
    case "time": {
      const r = e.type;
      return new ep(Se[r.unit], r.bitWidth);
    }
    case "timestamp": {
      const r = e.type;
      return new N0(Se[r.unit], r.timezone);
    }
    case "interval": {
      const r = e.type;
      return new L0(Pa[r.unit]);
    }
    case "duration": {
      const r = e.type;
      return new F0(Se[r.unit]);
    }
    case "union": {
      const r = e.type, [n, ...s] = (r.mode + "").toLowerCase(), a = n.toUpperCase() + s.join("");
      return new R0(Hn[a], r.typeIds || [], t || []);
    }
    case "fixedsizebinary": {
      const r = e.type;
      return new M0(r.byteWidth);
    }
    case "fixedsizelist": {
      const r = e.type;
      return new P0(r.listSize, (t || [])[0]);
    }
    case "map": {
      const r = e.type;
      return new $0((t || [])[0], r.keysSorted);
    }
  }
  throw new Error(`Unrecognized type: "${i}"`);
}
var wK = Ey, SK = Fa;
class Vs {
  /** @nocollapse */
  static fromJSON(t, i) {
    const r = new Vs(0, Vr.V5, i);
    return r._createHeader = IK(t, i), r;
  }
  /** @nocollapse */
  static decode(t) {
    t = new SK(_i(t));
    const i = cc.getRootAsMessage(t), r = i.bodyLength(), n = i.version(), s = i.headerType(), a = new Vs(r, n, s);
    return a._createHeader = AK(i, s), a;
  }
  /** @nocollapse */
  static encode(t) {
    const i = new wK();
    let r = -1;
    return t.isSchema() ? r = Bi.encode(i, t.header()) : t.isRecordBatch() ? r = ia.encode(i, t.header()) : t.isDictionaryBatch() && (r = No.encode(i, t.header())), cc.startMessage(i), cc.addVersion(i, Vr.V5), cc.addHeader(i, r), cc.addHeaderType(i, t.headerType), cc.addBodyLength(i, BigInt(t.bodyLength)), cc.finishMessageBuffer(i, cc.endMessage(i)), i.asUint8Array();
  }
  /** @nocollapse */
  static from(t, i = 0) {
    if (t instanceof Bi)
      return new Vs(0, Vr.V5, Fi.Schema, t);
    if (t instanceof ia)
      return new Vs(i, Vr.V5, Fi.RecordBatch, t);
    if (t instanceof No)
      return new Vs(i, Vr.V5, Fi.DictionaryBatch, t);
    throw new Error(`Unrecognized Message header: ${t}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === Fi.Schema;
  }
  isRecordBatch() {
    return this.headerType === Fi.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === Fi.DictionaryBatch;
  }
  constructor(t, i, r, n) {
    this._version = i, this._headerType = r, this.body = new Uint8Array(0), n && (this._createHeader = () => n), this._bodyLength = Cn(t);
  }
}
class ia {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  constructor(t, i, r) {
    this._nodes = i, this._buffers = r, this._length = Cn(t);
  }
}
class No {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(t, i, r = !1) {
    this._data = t, this._isDelta = r, this._id = Cn(i);
  }
}
class bo {
  constructor(t, i) {
    this.offset = Cn(t), this.length = Cn(i);
  }
}
class hh {
  constructor(t, i) {
    this.length = Cn(t), this.nullCount = Cn(i);
  }
}
function IK(e, t) {
  return () => {
    switch (t) {
      case Fi.Schema:
        return Bi.fromJSON(e);
      case Fi.RecordBatch:
        return ia.fromJSON(e);
      case Fi.DictionaryBatch:
        return No.fromJSON(e);
    }
    throw new Error(`Unrecognized Message type: { name: ${Fi[t]}, type: ${t} }`);
  };
}
function AK(e, t) {
  return () => {
    switch (t) {
      case Fi.Schema:
        return Bi.decode(e.header(new _a()), /* @__PURE__ */ new Map(), e.version());
      case Fi.RecordBatch:
        return ia.decode(e.header(new lo()), e.version());
      case Fi.DictionaryBatch:
        return No.decode(e.header(new Wd()), e.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${Fi[t]}, type: ${t} }`);
  };
}
ar.encode = RK;
ar.decode = FK;
ar.fromJSON = xK;
Bi.encode = BK;
Bi.decode = TK;
Bi.fromJSON = yK;
ia.encode = MK;
ia.decode = EK;
ia.fromJSON = vN;
No.encode = PK;
No.decode = kK;
No.fromJSON = vK;
hh.encode = $K;
hh.decode = OK;
bo.encode = zK;
bo.decode = CK;
function TK(e, t = /* @__PURE__ */ new Map(), i = Vr.V5) {
  const r = LK(e, t);
  return new Bi(r, wg(e), t, i);
}
function EK(e, t = Vr.V5) {
  if (e.compression() !== null)
    throw new Error("Record batch compression not implemented");
  return new ia(e.length(), DK(e), NK(e, t));
}
function kK(e, t = Vr.V5) {
  return new No(ia.decode(e.data(), t), e.id(), e.isDelta());
}
function CK(e) {
  return new bo(e.offset(), e.length());
}
function OK(e) {
  return new hh(e.length(), e.nullCount());
}
function DK(e) {
  const t = [];
  for (let i, r = -1, n = -1, s = e.nodesLength(); ++r < s; )
    (i = e.nodes(r)) && (t[++n] = hh.decode(i));
  return t;
}
function NK(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.buffersLength(); ++n < a; )
    (r = e.buffers(n)) && (t < Vr.V4 && (r.bb_pos += 8 * (n + 1)), i[++s] = bo.decode(r));
  return i;
}
function LK(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.fieldsLength(); ++n < a; )
    (r = e.fields(n)) && (i[++s] = ar.decode(r, t));
  return i;
}
function O3(e, t) {
  const i = [];
  for (let r, n = -1, s = -1, a = e.childrenLength(); ++n < a; )
    (r = e.children(n)) && (i[++s] = ar.decode(r, t));
  return i;
}
function FK(e, t) {
  let i, r, n, s, a, o;
  return !t || !(o = e.dictionary()) ? (n = N3(e, O3(e, t)), r = new ar(e.name(), n, e.nullable(), wg(e))) : t.has(i = Cn(o.id())) ? (s = (s = o.indexType()) ? D3(s) : new Qf(), a = new Wu(t.get(i), s, i, o.isOrdered()), r = new ar(e.name(), a, e.nullable(), wg(e))) : (s = (s = o.indexType()) ? D3(s) : new Qf(), t.set(i, n = N3(e, O3(e, t))), a = new Wu(n, s, i, o.isOrdered()), r = new ar(e.name(), a, e.nullable(), wg(e))), r || null;
}
function wg(e) {
  const t = /* @__PURE__ */ new Map();
  if (e)
    for (let i, r, n = -1, s = Math.trunc(e.customMetadataLength()); ++n < s; )
      (i = e.customMetadata(n)) && (r = i.key()) != null && t.set(r, i.value());
  return t;
}
function D3(e) {
  return new Fc(e.isSigned(), e.bitWidth());
}
function N3(e, t) {
  const i = e.typeType();
  switch (i) {
    case er.NONE:
      return new Lc();
    case er.Null:
      return new Lc();
    case er.Binary:
      return new A0();
    case er.LargeBinary:
      return new T0();
    case er.Utf8:
      return new E0();
    case er.LargeUtf8:
      return new k0();
    case er.Bool:
      return new C0();
    case er.List:
      return new B0((t || [])[0]);
    case er.Struct_:
      return new An(t || []);
  }
  switch (i) {
    case er.Int: {
      const r = e.type(new ts());
      return new Fc(r.isSigned(), r.bitWidth());
    }
    case er.FloatingPoint: {
      const r = e.type(new Ia());
      return new tp(r.precision());
    }
    case er.Decimal: {
      const r = e.type(new qd());
      return new O0(r.scale(), r.precision(), r.bitWidth());
    }
    case er.Date: {
      const r = e.type(new mg());
      return new D0(r.unit());
    }
    case er.Time: {
      const r = e.type(new ys());
      return new ep(r.unit(), r.bitWidth());
    }
    case er.Timestamp: {
      const r = e.type(new vs());
      return new N0(r.unit(), r.timezone());
    }
    case er.Interval: {
      const r = e.type(new Aa());
      return new L0(r.unit());
    }
    case er.Duration: {
      const r = e.type(new gg());
      return new F0(r.unit());
    }
    case er.Union: {
      const r = e.type(new $n());
      return new R0(r.mode(), r.typeIdsArray() || [], t || []);
    }
    case er.FixedSizeBinary: {
      const r = e.type(new yg());
      return new M0(r.byteWidth());
    }
    case er.FixedSizeList: {
      const r = e.type(new vg());
      return new P0(r.listSize(), (t || [])[0]);
    }
    case er.Map: {
      const r = e.type(new _g());
      return new $0((t || [])[0], r.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${er[i]}" (${i})`);
}
function BK(e, t) {
  const i = t.fields.map((s) => ar.encode(e, s));
  _a.startFieldsVector(e, i.length);
  const r = _a.createFieldsVector(e, i), n = t.metadata && t.metadata.size > 0 ? _a.createCustomMetadataVector(e, [...t.metadata].map(([s, a]) => {
    const o = e.createString(`${s}`), c = e.createString(`${a}`);
    return Jr.startKeyValue(e), Jr.addKey(e, o), Jr.addValue(e, c), Jr.endKeyValue(e);
  })) : -1;
  return _a.startSchema(e), _a.addFields(e, r), _a.addEndianness(e, UK ? Hu.Little : Hu.Big), n !== -1 && _a.addCustomMetadata(e, n), _a.endSchema(e);
}
function RK(e, t) {
  let i = -1, r = -1, n = -1;
  const s = t.type;
  let a = t.typeId;
  ge.isDictionary(s) ? (a = s.dictionary.typeId, n = F_.visit(s, e), r = F_.visit(s.dictionary, e)) : r = F_.visit(s, e);
  const o = (s.children || []).map((d) => ar.encode(e, d)), c = hs.createChildrenVector(e, o), l = t.metadata && t.metadata.size > 0 ? hs.createCustomMetadataVector(e, [...t.metadata].map(([d, u]) => {
    const h = e.createString(`${d}`), p = e.createString(`${u}`);
    return Jr.startKeyValue(e), Jr.addKey(e, h), Jr.addValue(e, p), Jr.endKeyValue(e);
  })) : -1;
  return t.name && (i = e.createString(t.name)), hs.startField(e), hs.addType(e, r), hs.addTypeType(e, a), hs.addChildren(e, c), hs.addNullable(e, !!t.nullable), i !== -1 && hs.addName(e, i), n !== -1 && hs.addDictionary(e, n), l !== -1 && hs.addCustomMetadata(e, l), hs.endField(e);
}
function MK(e, t) {
  const i = t.nodes || [], r = t.buffers || [];
  lo.startNodesVector(e, i.length);
  for (const a of i.slice().reverse())
    hh.encode(e, a);
  const n = e.endVector();
  lo.startBuffersVector(e, r.length);
  for (const a of r.slice().reverse())
    bo.encode(e, a);
  const s = e.endVector();
  return lo.startRecordBatch(e), lo.addLength(e, BigInt(t.length)), lo.addNodes(e, n), lo.addBuffers(e, s), lo.endRecordBatch(e);
}
function PK(e, t) {
  const i = ia.encode(e, t.data);
  return Wd.startDictionaryBatch(e), Wd.addId(e, BigInt(t.id)), Wd.addIsDelta(e, t.isDelta), Wd.addData(e, i), Wd.endDictionaryBatch(e);
}
function $K(e, t) {
  return M4.createFieldNode(e, BigInt(t.length), BigInt(t.nullCount));
}
function zK(e, t) {
  return R4.createBuffer(e, BigInt(t.offset), BigInt(t.length));
}
const UK = (() => {
  const e = new ArrayBuffer(2);
  return new DataView(e).setInt16(
    0,
    256,
    !0
    /* littleEndian */
  ), new Int16Array(e)[0] === 256;
})(), Tw = (e) => `Expected ${Fi[e]} Message in stream, but was null or length 0.`, Ew = (e) => `Header pointer of flatbuffer-encoded ${Fi[e]} Message is null or length 0.`, xN = (e, t) => `Expected to read ${e} metadata bytes, but only read ${t}.`, wN = (e, t) => `Expected to read ${e} bytes for message body, but only read ${t}.`;
class SN {
  constructor(t) {
    this.source = t instanceof j0 ? t : new j0(t);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let t;
    return (t = this.readMetadataLength()).done || t.value === -1 && (t = this.readMetadataLength()).done || (t = this.readMetadata(t.value)).done ? _r : t;
  }
  throw(t) {
    return this.source.throw(t);
  }
  return(t) {
    return this.source.return(t);
  }
  readMessage(t) {
    let i;
    if ((i = this.next()).done)
      return null;
    if (t != null && i.value.headerType !== t)
      throw new Error(Tw(t));
    return i.value;
  }
  readMessageBody(t) {
    if (t <= 0)
      return new Uint8Array(0);
    const i = _i(this.source.read(t));
    if (i.byteLength < t)
      throw new Error(wN(t, i.byteLength));
    return (
      /* 1. */
      i.byteOffset % 8 === 0 && /* 2. */
      i.byteOffset + i.byteLength <= i.buffer.byteLength ? i : i.slice()
    );
  }
  readSchema(t = !1) {
    const i = Fi.Schema, r = this.readMessage(i), n = r == null ? void 0 : r.header();
    if (t && !n)
      throw new Error(Ew(i));
    return n;
  }
  readMetadataLength() {
    const t = this.source.read(jy), i = t && new Fa(t), r = (i == null ? void 0 : i.readInt32(0)) || 0;
    return { done: r === 0, value: r };
  }
  readMetadata(t) {
    const i = this.source.read(t);
    if (!i)
      return _r;
    if (i.byteLength < t)
      throw new Error(xN(t, i.byteLength));
    return { done: !1, value: Vs.decode(i) };
  }
}
class VK {
  constructor(t, i) {
    this.source = t instanceof qu ? t : D4(t) ? new G0(t, i) : new qu(t);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return Dt(this, void 0, void 0, function* () {
      let t;
      return (t = yield this.readMetadataLength()).done || t.value === -1 && (t = yield this.readMetadataLength()).done || (t = yield this.readMetadata(t.value)).done ? _r : t;
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.throw(t);
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this.source.return(t);
    });
  }
  readMessage(t) {
    return Dt(this, void 0, void 0, function* () {
      let i;
      if ((i = yield this.next()).done)
        return null;
      if (t != null && i.value.headerType !== t)
        throw new Error(Tw(t));
      return i.value;
    });
  }
  readMessageBody(t) {
    return Dt(this, void 0, void 0, function* () {
      if (t <= 0)
        return new Uint8Array(0);
      const i = _i(yield this.source.read(t));
      if (i.byteLength < t)
        throw new Error(wN(t, i.byteLength));
      return (
        /* 1. */
        i.byteOffset % 8 === 0 && /* 2. */
        i.byteOffset + i.byteLength <= i.buffer.byteLength ? i : i.slice()
      );
    });
  }
  readSchema(t = !1) {
    return Dt(this, void 0, void 0, function* () {
      const i = Fi.Schema, r = yield this.readMessage(i), n = r == null ? void 0 : r.header();
      if (t && !n)
        throw new Error(Ew(i));
      return n;
    });
  }
  readMetadataLength() {
    return Dt(this, void 0, void 0, function* () {
      const t = yield this.source.read(jy), i = t && new Fa(t), r = (i == null ? void 0 : i.readInt32(0)) || 0;
      return { done: r === 0, value: r };
    });
  }
  readMetadata(t) {
    return Dt(this, void 0, void 0, function* () {
      const i = yield this.source.read(t);
      if (!i)
        return _r;
      if (i.byteLength < t)
        throw new Error(xN(t, i.byteLength));
      return { done: !1, value: Vs.decode(i) };
    });
  }
}
class jK extends SN {
  constructor(t) {
    super(new Uint8Array(0)), this._schema = !1, this._body = [], this._batchIndex = 0, this._dictionaryIndex = 0, this._json = t instanceof I3 ? t : new I3(t);
  }
  next() {
    const { _json: t } = this;
    if (!this._schema)
      return this._schema = !0, { done: !1, value: Vs.fromJSON(t.schema, Fi.Schema) };
    if (this._dictionaryIndex < t.dictionaries.length) {
      const i = t.dictionaries[this._dictionaryIndex++];
      return this._body = i.data.columns, { done: !1, value: Vs.fromJSON(i, Fi.DictionaryBatch) };
    }
    if (this._batchIndex < t.batches.length) {
      const i = t.batches[this._batchIndex++];
      return this._body = i.columns, { done: !1, value: Vs.fromJSON(i, Fi.RecordBatch) };
    }
    return this._body = [], _r;
  }
  readMessageBody(t) {
    return i(this._body);
    function i(r) {
      return (r || []).reduce((n, s) => [
        ...n,
        ...s.VALIDITY && [s.VALIDITY] || [],
        ...s.TYPE_ID && [s.TYPE_ID] || [],
        ...s.OFFSET && [s.OFFSET] || [],
        ...s.DATA && [s.DATA] || [],
        ...i(s.children)
      ], []);
    }
  }
  readMessage(t) {
    let i;
    if ((i = this.next()).done)
      return null;
    if (t != null && i.value.headerType !== t)
      throw new Error(Tw(t));
    return i.value;
  }
  readSchema() {
    const t = Fi.Schema, i = this.readMessage(t), r = i == null ? void 0 : i.header();
    if (!i || !r)
      throw new Error(Ew(t));
    return r;
  }
}
const jy = 4, Wb = "ARROW1", H0 = new Uint8Array(Wb.length);
for (let e = 0; e < Wb.length; e += 1)
  H0[e] = Wb.codePointAt(e);
function kw(e, t = 0) {
  for (let i = -1, r = H0.length; ++i < r; )
    if (H0[i] !== e[t + i])
      return !1;
  return !0;
}
const zp = H0.length, IN = zp + jy, GK = zp * 2 + jy;
class xo extends uN {
  constructor(t) {
    super(), this._impl = t;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(t) {
    return this._impl.throw(t);
  }
  return(t) {
    return this._impl.return(t);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(t) {
    return this._impl.reset(t), this._DOMStream = void 0, this._nodeStream = void 0, this;
  }
  open(t) {
    const i = this._impl.open(t);
    return Zf(i) ? i.then(() => this) : this;
  }
  readRecordBatch(t) {
    return this._impl.isFile() ? this._impl.readRecordBatch(t) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return ms.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return ms.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: !0 });
  }
  /** @nocollapse */
  // @ts-ignore
  static throughNode(t) {
    throw new Error('"throughNode" not available in this environment');
  }
  /** @nocollapse */
  static throughDOM(t, i) {
    throw new Error('"throughDOM" not available in this environment');
  }
  /** @nocollapse */
  static from(t) {
    return t instanceof xo ? t : Pb(t) ? qK(t) : D4(t) ? KK(t) : Zf(t) ? Dt(this, void 0, void 0, function* () {
      return yield xo.from(yield t);
    }) : N4(t) || lw(t) || F4(t) || cw(t) ? XK(new qu(t)) : ZK(new j0(t));
  }
  /** @nocollapse */
  static readAll(t) {
    return t instanceof xo ? t.isSync() ? L3(t) : F3(t) : Pb(t) || ArrayBuffer.isView(t) || zy(t) || O4(t) ? L3(t) : F3(t);
  }
}
class W0 extends xo {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return jr(this, arguments, function* () {
      yield Vt(yield* xc(es(this[Symbol.iterator]())));
    });
  }
}
class Y0 extends xo {
  constructor(t) {
    super(t), this._impl = t;
  }
  readAll() {
    var t, i, r, n;
    return Dt(this, void 0, void 0, function* () {
      const s = new Array();
      try {
        for (var a = !0, o = es(this), c; c = yield o.next(), t = c.done, !t; a = !0) {
          n = c.value, a = !1;
          const l = n;
          s.push(l);
        }
      } catch (l) {
        i = { error: l };
      } finally {
        try {
          !a && !t && (r = o.return) && (yield r.call(o));
        } finally {
          if (i)
            throw i.error;
        }
      }
      return s;
    });
  }
  [Symbol.iterator]() {
    throw new Error("AsyncRecordBatchStreamReader is not Iterable");
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}
class AN extends W0 {
  constructor(t) {
    super(t), this._impl = t;
  }
}
class HK extends Y0 {
  constructor(t) {
    super(t), this._impl = t;
  }
}
class TN {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(t = /* @__PURE__ */ new Map()) {
    this.closed = !1, this.autoDestroy = !0, this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.dictionaries = t;
  }
  isSync() {
    return !1;
  }
  isAsync() {
    return !1;
  }
  isFile() {
    return !1;
  }
  isStream() {
    return !1;
  }
  reset(t) {
    return this._dictionaryIndex = 0, this._recordBatchIndex = 0, this.schema = t, this.dictionaries = /* @__PURE__ */ new Map(), this;
  }
  _loadRecordBatch(t, i) {
    const r = this._loadVectors(t, i, this.schema.fields), n = ci({ type: new An(this.schema.fields), length: t.length, children: r });
    return new $s(this.schema, n);
  }
  _loadDictionaryBatch(t, i) {
    const { id: r, isDelta: n } = t, { dictionaries: s, schema: a } = this, o = s.get(r);
    if (n || !o) {
      const c = a.dictionaries.get(r), l = this._loadVectors(t.data, i, [c]);
      return (o && n ? o.concat(new qi(l)) : new qi(l)).memoize();
    }
    return o.memoize();
  }
  _loadVectors(t, i, r) {
    return new fN(i, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
  }
}
class q0 extends TN {
  constructor(t, i) {
    super(i), this._reader = Pb(t) ? new jK(this._handle = t) : new SN(this._handle = t);
  }
  isSync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    !this.closed && (this.closed = !0) && (this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
  }
  open(t) {
    return this.closed || (this.autoDestroy = kN(this, t), this.schema || (this.schema = this._reader.readSchema()) || this.cancel()), this;
  }
  throw(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.throw(t) : _r;
  }
  return(t) {
    return !this.closed && this.autoDestroy && (this.closed = !0) ? this.reset()._reader.return(t) : _r;
  }
  next() {
    if (this.closed)
      return _r;
    let t;
    const { _reader: i } = this;
    for (; t = this._readNextMessageAndValidate(); )
      if (t.isSchema())
        this.reset(t.header());
      else if (t.isRecordBatch()) {
        this._recordBatchIndex++;
        const r = t.header(), n = i.readMessageBody(t.bodyLength);
        return { done: !1, value: this._loadRecordBatch(r, n) };
      } else if (t.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const r = t.header(), n = i.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(r, n);
        this.dictionaries.set(r.id, s);
      }
    return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new yN(this.schema) }) : this.return();
  }
  _readNextMessageAndValidate(t) {
    return this._reader.readMessage(t);
  }
}
class Z0 extends TN {
  constructor(t, i) {
    super(i), this._reader = new VK(this._handle = t);
  }
  isAsync() {
    return !0;
  }
  isStream() {
    return !0;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return Dt(this, void 0, void 0, function* () {
      !this.closed && (this.closed = !0) && (yield this.reset()._reader.return(), this._reader = null, this.dictionaries = null);
    });
  }
  open(t) {
    return Dt(this, void 0, void 0, function* () {
      return this.closed || (this.autoDestroy = kN(this, t), this.schema || (this.schema = yield this._reader.readSchema()) || (yield this.cancel())), this;
    });
  }
  throw(t) {
    return Dt(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.throw(t) : _r;
    });
  }
  return(t) {
    return Dt(this, void 0, void 0, function* () {
      return !this.closed && this.autoDestroy && (this.closed = !0) ? yield this.reset()._reader.return(t) : _r;
    });
  }
  next() {
    return Dt(this, void 0, void 0, function* () {
      if (this.closed)
        return _r;
      let t;
      const { _reader: i } = this;
      for (; t = yield this._readNextMessageAndValidate(); )
        if (t.isSchema())
          yield this.reset(t.header());
        else if (t.isRecordBatch()) {
          this._recordBatchIndex++;
          const r = t.header(), n = yield i.readMessageBody(t.bodyLength);
          return { done: !1, value: this._loadRecordBatch(r, n) };
        } else if (t.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const r = t.header(), n = yield i.readMessageBody(t.bodyLength), s = this._loadDictionaryBatch(r, n);
          this.dictionaries.set(r.id, s);
        }
      return this.schema && this._recordBatchIndex === 0 ? (this._recordBatchIndex++, { done: !1, value: new yN(this.schema) }) : yield this.return();
    });
  }
  _readNextMessageAndValidate(t) {
    return Dt(this, void 0, void 0, function* () {
      return yield this._reader.readMessage(t);
    });
  }
}
class EN extends q0 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, i) {
    super(t instanceof A3 ? t : new A3(t), i);
  }
  isSync() {
    return !0;
  }
  isFile() {
    return !0;
  }
  open(t) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const i of this._footer.dictionaryBatches())
        i && this._readDictionaryBatch(this._dictionaryIndex++);
    }
    return super.open(t);
  }
  readRecordBatch(t) {
    var i;
    if (this.closed)
      return null;
    this._footer || this.open();
    const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(t);
    if (r && this._handle.seek(r.offset)) {
      const n = this._reader.readMessage(Fi.RecordBatch);
      if (n != null && n.isRecordBatch()) {
        const s = n.header(), a = this._reader.readMessageBody(n.bodyLength);
        return this._loadRecordBatch(s, a);
      }
    }
    return null;
  }
  _readDictionaryBatch(t) {
    var i;
    const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getDictionaryBatch(t);
    if (r && this._handle.seek(r.offset)) {
      const n = this._reader.readMessage(Fi.DictionaryBatch);
      if (n != null && n.isDictionaryBatch()) {
        const s = n.header(), a = this._reader.readMessageBody(n.bodyLength), o = this._loadDictionaryBatch(s, a);
        this.dictionaries.set(s.id, o);
      }
    }
  }
  _readFooter() {
    const { _handle: t } = this, i = t.size - IN, r = t.readInt32(i), n = t.readAt(i - r, r);
    return xw.decode(n);
  }
  _readNextMessageAndValidate(t) {
    var i;
    if (this._footer || this.open(), this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(this._recordBatchIndex);
      if (r && this._handle.seek(r.offset))
        return this._reader.readMessage(t);
    }
    return null;
  }
}
class WK extends Z0 {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(t, ...i) {
    const r = typeof i[0] != "number" ? i.shift() : void 0, n = i[0] instanceof Map ? i.shift() : void 0;
    super(t instanceof G0 ? t : new G0(t, r), n);
  }
  isFile() {
    return !0;
  }
  isAsync() {
    return !0;
  }
  open(t) {
    const i = Object.create(null, {
      open: { get: () => super.open }
    });
    return Dt(this, void 0, void 0, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const r of this._footer.dictionaryBatches())
          r && (yield this._readDictionaryBatch(this._dictionaryIndex++));
      }
      return yield i.open.call(this, t);
    });
  }
  readRecordBatch(t) {
    var i;
    return Dt(this, void 0, void 0, function* () {
      if (this.closed)
        return null;
      this._footer || (yield this.open());
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getRecordBatch(t);
      if (r && (yield this._handle.seek(r.offset))) {
        const n = yield this._reader.readMessage(Fi.RecordBatch);
        if (n != null && n.isRecordBatch()) {
          const s = n.header(), a = yield this._reader.readMessageBody(n.bodyLength);
          return this._loadRecordBatch(s, a);
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(t) {
    var i;
    return Dt(this, void 0, void 0, function* () {
      const r = (i = this._footer) === null || i === void 0 ? void 0 : i.getDictionaryBatch(t);
      if (r && (yield this._handle.seek(r.offset))) {
        const n = yield this._reader.readMessage(Fi.DictionaryBatch);
        if (n != null && n.isDictionaryBatch()) {
          const s = n.header(), a = yield this._reader.readMessageBody(n.bodyLength), o = this._loadDictionaryBatch(s, a);
          this.dictionaries.set(s.id, o);
        }
      }
    });
  }
  _readFooter() {
    return Dt(this, void 0, void 0, function* () {
      const { _handle: t } = this;
      t._pending && (yield t._pending);
      const i = t.size - IN, r = yield t.readInt32(i), n = yield t.readAt(i - r, r);
      return xw.decode(n);
    });
  }
  _readNextMessageAndValidate(t) {
    return Dt(this, void 0, void 0, function* () {
      if (this._footer || (yield this.open()), this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const i = this._footer.getRecordBatch(this._recordBatchIndex);
        if (i && (yield this._handle.seek(i.offset)))
          return yield this._reader.readMessage(t);
      }
      return null;
    });
  }
}
class YK extends q0 {
  constructor(t, i) {
    super(t, i);
  }
  _loadVectors(t, i, r) {
    return new sK(i, t.nodes, t.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(r);
  }
}
function kN(e, t) {
  return t && typeof t.autoDestroy == "boolean" ? t.autoDestroy : e.autoDestroy;
}
function* L3(e) {
  const t = xo.from(e);
  try {
    if (!t.open({ autoDestroy: !1 }).closed)
      do
        yield t;
      while (!t.reset().open().closed);
  } finally {
    t.cancel();
  }
}
function F3(e) {
  return jr(this, arguments, function* () {
    const i = yield Vt(xo.from(e));
    try {
      if (!(yield Vt(i.open({ autoDestroy: !1 }))).closed)
        do
          yield yield Vt(i);
        while (!(yield Vt(i.reset().open())).closed);
    } finally {
      yield Vt(i.cancel());
    }
  });
}
function qK(e) {
  return new W0(new YK(e));
}
function ZK(e) {
  const t = e.peek(zp + 7 & -8);
  return t && t.byteLength >= 4 ? kw(t) ? new AN(new EN(e.read())) : new W0(new q0(e)) : new W0(new q0(function* () {
  }()));
}
function XK(e) {
  return Dt(this, void 0, void 0, function* () {
    const t = yield e.peek(zp + 7 & -8);
    return t && t.byteLength >= 4 ? kw(t) ? new AN(new EN(yield e.read())) : new Y0(new Z0(e)) : new Y0(new Z0(function() {
      return jr(this, arguments, function* () {
      });
    }()));
  });
}
function KK(e) {
  return Dt(this, void 0, void 0, function* () {
    const { size: t } = yield e.stat(), i = new G0(e, t);
    return t >= GK && kw(yield i.readAt(0, zp + 7 & -8)) ? new HK(new WK(i)) : new Y0(new Z0(i));
  });
}
function CN(e) {
  const t = xo.from(e);
  return Zf(t) ? t.then((i) => CN(i)) : t.isAsync() ? t.readAll().then((i) => new _s(i)) : new _s(t.readAll());
}
function JK(e) {
  return [
    .../* @__PURE__ */ new Set([
      ...e.map((t) => t.source),
      ...e.map((t) => t.target)
    ])
  ].map((t) => ({ id: t }));
}
function B3(e) {
  if (!e)
    return;
  const t = CN(e);
  return YY(t).objects().map((i) => (Object.keys(i).forEach((r) => {
    const n = i[r];
    i[r] = typeof n == "bigint" ? Number(n) : n;
  }), i));
}
var ki;
(function(e) {
  e.assertEqual = (n) => n;
  function t(n) {
  }
  e.assertIs = t;
  function i(n) {
    throw new Error();
  }
  e.assertNever = i, e.arrayToEnum = (n) => {
    const s = {};
    for (const a of n)
      s[a] = a;
    return s;
  }, e.getValidEnumValues = (n) => {
    const s = e.objectKeys(n).filter((o) => typeof n[n[o]] != "number"), a = {};
    for (const o of s)
      a[o] = n[o];
    return e.objectValues(a);
  }, e.objectValues = (n) => e.objectKeys(n).map(function(s) {
    return n[s];
  }), e.objectKeys = typeof Object.keys == "function" ? (n) => Object.keys(n) : (n) => {
    const s = [];
    for (const a in n)
      Object.prototype.hasOwnProperty.call(n, a) && s.push(a);
    return s;
  }, e.find = (n, s) => {
    for (const a of n)
      if (s(a))
        return a;
  }, e.isInteger = typeof Number.isInteger == "function" ? (n) => Number.isInteger(n) : (n) => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
  function r(n, s = " | ") {
    return n.map((a) => typeof a == "string" ? `'${a}'` : a).join(s);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s;
})(ki || (ki = {}));
var Yb;
(function(e) {
  e.mergeShapes = (t, i) => ({
    ...t,
    ...i
    // second overwrites first
  });
})(Yb || (Yb = {}));
const Xt = ki.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), vc = (e) => {
  switch (typeof e) {
    case "undefined":
      return Xt.undefined;
    case "string":
      return Xt.string;
    case "number":
      return isNaN(e) ? Xt.nan : Xt.number;
    case "boolean":
      return Xt.boolean;
    case "function":
      return Xt.function;
    case "bigint":
      return Xt.bigint;
    case "symbol":
      return Xt.symbol;
    case "object":
      return Array.isArray(e) ? Xt.array : e === null ? Xt.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Xt.promise : typeof Map < "u" && e instanceof Map ? Xt.map : typeof Set < "u" && e instanceof Set ? Xt.set : typeof Date < "u" && e instanceof Date ? Xt.date : Xt.object;
    default:
      return Xt.unknown;
  }
}, Rt = ki.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), QK = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ys extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const i = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, i) : this.__proto__ = i, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const i = t || function(s) {
      return s.message;
    }, r = { _errors: [] }, n = (s) => {
      for (const a of s.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(n);
        else if (a.code === "invalid_return_type")
          n(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          n(a.argumentsError);
        else if (a.path.length === 0)
          r._errors.push(i(a));
        else {
          let o = r, c = 0;
          for (; c < a.path.length; ) {
            const l = a.path[c];
            c === a.path.length - 1 ? (o[l] = o[l] || { _errors: [] }, o[l]._errors.push(i(a))) : o[l] = o[l] || { _errors: [] }, o = o[l], c++;
          }
        }
    };
    return n(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, ki.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (i) => i.message) {
    const i = {}, r = [];
    for (const n of this.issues)
      n.path.length > 0 ? (i[n.path[0]] = i[n.path[0]] || [], i[n.path[0]].push(t(n))) : r.push(t(n));
    return { formErrors: r, fieldErrors: i };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ys.create = (e) => new Ys(e);
const ip = (e, t) => {
  let i;
  switch (e.code) {
    case Rt.invalid_type:
      e.received === Xt.undefined ? i = "Required" : i = `Expected ${e.expected}, received ${e.received}`;
      break;
    case Rt.invalid_literal:
      i = `Invalid literal value, expected ${JSON.stringify(e.expected, ki.jsonStringifyReplacer)}`;
      break;
    case Rt.unrecognized_keys:
      i = `Unrecognized key(s) in object: ${ki.joinValues(e.keys, ", ")}`;
      break;
    case Rt.invalid_union:
      i = "Invalid input";
      break;
    case Rt.invalid_union_discriminator:
      i = `Invalid discriminator value. Expected ${ki.joinValues(e.options)}`;
      break;
    case Rt.invalid_enum_value:
      i = `Invalid enum value. Expected ${ki.joinValues(e.options)}, received '${e.received}'`;
      break;
    case Rt.invalid_arguments:
      i = "Invalid function arguments";
      break;
    case Rt.invalid_return_type:
      i = "Invalid function return type";
      break;
    case Rt.invalid_date:
      i = "Invalid date";
      break;
    case Rt.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (i = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (i = `${i} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? i = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? i = `Invalid input: must end with "${e.validation.endsWith}"` : ki.assertNever(e.validation) : e.validation !== "regex" ? i = `Invalid ${e.validation}` : i = "Invalid";
      break;
    case Rt.too_small:
      e.type === "array" ? i = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? i = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? i = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? i = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : i = "Invalid input";
      break;
    case Rt.too_big:
      e.type === "array" ? i = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? i = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? i = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? i = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? i = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : i = "Invalid input";
      break;
    case Rt.custom:
      i = "Invalid input";
      break;
    case Rt.invalid_intersection_types:
      i = "Intersection results could not be merged";
      break;
    case Rt.not_multiple_of:
      i = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case Rt.not_finite:
      i = "Number must be finite";
      break;
    default:
      i = t.defaultError, ki.assertNever(e);
  }
  return { message: i };
};
let ON = ip;
function tJ(e) {
  ON = e;
}
function X0() {
  return ON;
}
const K0 = (e) => {
  const { data: t, path: i, errorMaps: r, issueData: n } = e, s = [...i, ...n.path || []], a = {
    ...n,
    path: s
  };
  let o = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    o = l(a, { data: t, defaultError: o }).message;
  return {
    ...n,
    path: s,
    message: n.message || o
  };
}, eJ = [];
function Qt(e, t) {
  const i = K0({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      X0(),
      ip
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(i);
}
class bn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, i) {
    const r = [];
    for (const n of i) {
      if (n.status === "aborted")
        return qe;
      n.status === "dirty" && t.dirty(), r.push(n.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, i) {
    const r = [];
    for (const n of i)
      r.push({
        key: await n.key,
        value: await n.value
      });
    return bn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, i) {
    const r = {};
    for (const n of i) {
      const { key: s, value: a } = n;
      if (s.status === "aborted" || a.status === "aborted")
        return qe;
      s.status === "dirty" && t.dirty(), a.status === "dirty" && t.dirty(), s.value !== "__proto__" && (typeof a.value < "u" || n.alwaysSet) && (r[s.value] = a.value);
    }
    return { status: t.value, value: r };
  }
}
const qe = Object.freeze({
  status: "aborted"
}), DN = (e) => ({ status: "dirty", value: e }), On = (e) => ({ status: "valid", value: e }), qb = (e) => e.status === "aborted", Zb = (e) => e.status === "dirty", rp = (e) => e.status === "valid", J0 = (e) => typeof Promise < "u" && e instanceof Promise;
var me;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(me || (me = {}));
class $a {
  constructor(t, i, r, n) {
    this._cachedPath = [], this.parent = t, this.data = i, this._path = r, this._key = n;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const R3 = (e, t) => {
  if (rp(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const i = new Ys(e.common.issues);
      return this._error = i, this._error;
    }
  };
};
function Ke(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: i, required_error: r, description: n } = e;
  if (t && (i || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: n } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: r ?? o.defaultError } : { message: i ?? o.defaultError }, description: n };
}
class ni {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return vc(t.data);
  }
  _getOrReturnCtx(t, i) {
    return i || {
      common: t.parent.common,
      data: t.data,
      parsedType: vc(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new bn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: vc(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const i = this._parse(t);
    if (J0(i))
      throw new Error("Synchronous parse encountered promise.");
    return i;
  }
  _parseAsync(t) {
    const i = this._parse(t);
    return Promise.resolve(i);
  }
  parse(t, i) {
    const r = this.safeParse(t, i);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, i) {
    var r;
    const n = {
      common: {
        issues: [],
        async: (r = i == null ? void 0 : i.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: i == null ? void 0 : i.errorMap
      },
      path: (i == null ? void 0 : i.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: vc(t)
    }, s = this._parseSync({ data: t, path: n.path, parent: n });
    return R3(n, s);
  }
  async parseAsync(t, i) {
    const r = await this.safeParseAsync(t, i);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, i) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: i == null ? void 0 : i.errorMap,
        async: !0
      },
      path: (i == null ? void 0 : i.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: vc(t)
    }, n = this._parse({ data: t, path: r.path, parent: r }), s = await (J0(n) ? n : Promise.resolve(n));
    return R3(r, s);
  }
  refine(t, i) {
    const r = (n) => typeof i == "string" || typeof i > "u" ? { message: i } : typeof i == "function" ? i(n) : i;
    return this._refinement((n, s) => {
      const a = t(n), o = () => s.addIssue({
        code: Rt.custom,
        ...r(n)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? !0 : (o(), !1)) : a ? !0 : (o(), !1);
    });
  }
  refinement(t, i) {
    return this._refinement((r, n) => t(r) ? !0 : (n.addIssue(typeof i == "function" ? i(r, n) : i), !1));
  }
  _refinement(t) {
    return new ra({
      schema: this,
      typeName: Ft.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return wo.create(this, this._def);
  }
  nullable() {
    return Gl.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return qs.create(this, this._def);
  }
  promise() {
    return Ku.create(this, this._def);
  }
  or(t) {
    return op.create([this, t], this._def);
  }
  and(t) {
    return cp.create(this, t, this._def);
  }
  transform(t) {
    return new ra({
      ...Ke(this._def),
      schema: this,
      typeName: Ft.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const i = typeof t == "function" ? t : () => t;
    return new fp({
      ...Ke(this._def),
      innerType: this,
      defaultValue: i,
      typeName: Ft.ZodDefault
    });
  }
  brand() {
    return new LN({
      typeName: Ft.ZodBranded,
      type: this,
      ...Ke(this._def)
    });
  }
  catch(t) {
    const i = typeof t == "function" ? t : () => t;
    return new iy({
      ...Ke(this._def),
      innerType: this,
      catchValue: i,
      typeName: Ft.ZodCatch
    });
  }
  describe(t) {
    const i = this.constructor;
    return new i({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Up.create(this, t);
  }
  readonly() {
    return ny.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const iJ = /^c[^\s-]{8,}$/i, rJ = /^[a-z][a-z0-9]*$/, nJ = /^[0-9A-HJKMNP-TV-Z]{26}$/, sJ = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, aJ = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, oJ = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let B_;
const cJ = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, lJ = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, dJ = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function uJ(e, t) {
  return !!((t === "v4" || !t) && cJ.test(e) || (t === "v6" || !t) && lJ.test(e));
}
class Hs extends ni {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Xt.string) {
      const s = this._getOrReturnCtx(t);
      return Qt(
        s,
        {
          code: Rt.invalid_type,
          expected: Xt.string,
          received: s.parsedType
        }
        //
      ), qe;
    }
    const r = new bn();
    let n;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value && (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), r.dirty());
      else if (s.kind === "max")
        t.data.length > s.value && (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: s.message
        }), r.dirty());
      else if (s.kind === "length") {
        const a = t.data.length > s.value, o = t.data.length < s.value;
        (a || o) && (n = this._getOrReturnCtx(t, n), a ? Qt(n, {
          code: Rt.too_big,
          maximum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }) : o && Qt(n, {
          code: Rt.too_small,
          minimum: s.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: s.message
        }), r.dirty());
      } else if (s.kind === "email")
        aJ.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "email",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "emoji")
        B_ || (B_ = new RegExp(oJ, "u")), B_.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "emoji",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "uuid")
        sJ.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "uuid",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "cuid")
        iJ.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "cuid",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "cuid2")
        rJ.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "cuid2",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "ulid")
        nJ.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "ulid",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          n = this._getOrReturnCtx(t, n), Qt(n, {
            validation: "url",
            code: Rt.invalid_string,
            message: s.message
          }), r.dirty();
        }
      else
        s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "regex",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty())) : s.kind === "trim" ? t.data = t.data.trim() : s.kind === "includes" ? t.data.includes(s.value, s.position) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.invalid_string,
          validation: { includes: s.value, position: s.position },
          message: s.message
        }), r.dirty()) : s.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : s.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : s.kind === "startsWith" ? t.data.startsWith(s.value) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.invalid_string,
          validation: { startsWith: s.value },
          message: s.message
        }), r.dirty()) : s.kind === "endsWith" ? t.data.endsWith(s.value) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.invalid_string,
          validation: { endsWith: s.value },
          message: s.message
        }), r.dirty()) : s.kind === "datetime" ? dJ(s).test(t.data) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          code: Rt.invalid_string,
          validation: "datetime",
          message: s.message
        }), r.dirty()) : s.kind === "ip" ? uJ(t.data, s.version) || (n = this._getOrReturnCtx(t, n), Qt(n, {
          validation: "ip",
          code: Rt.invalid_string,
          message: s.message
        }), r.dirty()) : ki.assertNever(s);
    return { status: r.value, value: t.data };
  }
  _regex(t, i, r) {
    return this.refinement((n) => t.test(n), {
      validation: i,
      code: Rt.invalid_string,
      ...me.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Hs({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...me.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...me.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...me.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...me.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...me.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...me.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...me.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...me.errToObj(t) });
  }
  datetime(t) {
    var i;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (i = t == null ? void 0 : t.offset) !== null && i !== void 0 ? i : !1,
      ...me.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, i) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...me.errToObj(i)
    });
  }
  includes(t, i) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: i == null ? void 0 : i.position,
      ...me.errToObj(i == null ? void 0 : i.message)
    });
  }
  startsWith(t, i) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...me.errToObj(i)
    });
  }
  endsWith(t, i) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...me.errToObj(i)
    });
  }
  min(t, i) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...me.errToObj(i)
    });
  }
  max(t, i) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...me.errToObj(i)
    });
  }
  length(t, i) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...me.errToObj(i)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, me.errToObj(t));
  }
  trim() {
    return new Hs({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Hs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Hs({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "min" && (t === null || i.value > t) && (t = i.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    return t;
  }
}
Hs.create = (e) => {
  var t;
  return new Hs({
    checks: [],
    typeName: Ft.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ke(e)
  });
};
function hJ(e, t) {
  const i = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, n = i > r ? i : r, s = parseInt(e.toFixed(n).replace(".", "")), a = parseInt(t.toFixed(n).replace(".", ""));
  return s % a / Math.pow(10, n);
}
class Rc extends ni {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Xt.number) {
      const s = this._getOrReturnCtx(t);
      return Qt(s, {
        code: Rt.invalid_type,
        expected: Xt.number,
        received: s.parsedType
      }), qe;
    }
    let r;
    const n = new bn();
    for (const s of this._def.checks)
      s.kind === "int" ? ki.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.invalid_type,
        expected: "integer",
        received: "float",
        message: s.message
      }), n.dirty()) : s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.too_small,
        minimum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.too_big,
        maximum: s.value,
        type: "number",
        inclusive: s.inclusive,
        exact: !1,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? hJ(t.data, s.value) !== 0 && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : s.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.not_finite,
        message: s.message
      }), n.dirty()) : ki.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, i) {
    return this.setLimit("min", t, !0, me.toString(i));
  }
  gt(t, i) {
    return this.setLimit("min", t, !1, me.toString(i));
  }
  lte(t, i) {
    return this.setLimit("max", t, !0, me.toString(i));
  }
  lt(t, i) {
    return this.setLimit("max", t, !1, me.toString(i));
  }
  setLimit(t, i, r, n) {
    return new Rc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: i,
          inclusive: r,
          message: me.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Rc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: me.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: me.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: me.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: me.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: me.toString(t)
    });
  }
  multipleOf(t, i) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: me.toString(i)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: me.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: me.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: me.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "min" && (t === null || i.value > t) && (t = i.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && ki.isInteger(t.value));
  }
  get isFinite() {
    let t = null, i = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (i === null || r.value > i) && (i = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(i) && Number.isFinite(t);
  }
}
Rc.create = (e) => new Rc({
  checks: [],
  typeName: Ft.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ke(e)
});
class Mc extends ni {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Xt.bigint) {
      const s = this._getOrReturnCtx(t);
      return Qt(s, {
        code: Rt.invalid_type,
        expected: Xt.bigint,
        received: s.parsedType
      }), qe;
    }
    let r;
    const n = new bn();
    for (const s of this._def.checks)
      s.kind === "min" ? (s.inclusive ? t.data < s.value : t.data <= s.value) && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.too_small,
        type: "bigint",
        minimum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "max" ? (s.inclusive ? t.data > s.value : t.data >= s.value) && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.too_big,
        type: "bigint",
        maximum: s.value,
        inclusive: s.inclusive,
        message: s.message
      }), n.dirty()) : s.kind === "multipleOf" ? t.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Qt(r, {
        code: Rt.not_multiple_of,
        multipleOf: s.value,
        message: s.message
      }), n.dirty()) : ki.assertNever(s);
    return { status: n.value, value: t.data };
  }
  gte(t, i) {
    return this.setLimit("min", t, !0, me.toString(i));
  }
  gt(t, i) {
    return this.setLimit("min", t, !1, me.toString(i));
  }
  lte(t, i) {
    return this.setLimit("max", t, !0, me.toString(i));
  }
  lt(t, i) {
    return this.setLimit("max", t, !1, me.toString(i));
  }
  setLimit(t, i, r, n) {
    return new Mc({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: i,
          inclusive: r,
          message: me.toString(n)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Mc({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: me.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: me.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: me.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: me.toString(t)
    });
  }
  multipleOf(t, i) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: me.toString(i)
    });
  }
  get minValue() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "min" && (t === null || i.value > t) && (t = i.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    return t;
  }
}
Mc.create = (e) => {
  var t;
  return new Mc({
    checks: [],
    typeName: Ft.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Ke(e)
  });
};
class np extends ni {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Xt.boolean) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.boolean,
        received: r.parsedType
      }), qe;
    }
    return On(t.data);
  }
}
np.create = (e) => new np({
  typeName: Ft.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Ke(e)
});
class Vl extends ni {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Xt.date) {
      const s = this._getOrReturnCtx(t);
      return Qt(s, {
        code: Rt.invalid_type,
        expected: Xt.date,
        received: s.parsedType
      }), qe;
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return Qt(s, {
        code: Rt.invalid_date
      }), qe;
    }
    const r = new bn();
    let n;
    for (const s of this._def.checks)
      s.kind === "min" ? t.data.getTime() < s.value && (n = this._getOrReturnCtx(t, n), Qt(n, {
        code: Rt.too_small,
        message: s.message,
        inclusive: !0,
        exact: !1,
        minimum: s.value,
        type: "date"
      }), r.dirty()) : s.kind === "max" ? t.data.getTime() > s.value && (n = this._getOrReturnCtx(t, n), Qt(n, {
        code: Rt.too_big,
        message: s.message,
        inclusive: !0,
        exact: !1,
        maximum: s.value,
        type: "date"
      }), r.dirty()) : ki.assertNever(s);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Vl({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, i) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: me.toString(i)
    });
  }
  max(t, i) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: me.toString(i)
    });
  }
  get minDate() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "min" && (t === null || i.value > t) && (t = i.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const i of this._def.checks)
      i.kind === "max" && (t === null || i.value < t) && (t = i.value);
    return t != null ? new Date(t) : null;
  }
}
Vl.create = (e) => new Vl({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Ft.ZodDate,
  ...Ke(e)
});
class Q0 extends ni {
  _parse(t) {
    if (this._getType(t) !== Xt.symbol) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.symbol,
        received: r.parsedType
      }), qe;
    }
    return On(t.data);
  }
}
Q0.create = (e) => new Q0({
  typeName: Ft.ZodSymbol,
  ...Ke(e)
});
class sp extends ni {
  _parse(t) {
    if (this._getType(t) !== Xt.undefined) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.undefined,
        received: r.parsedType
      }), qe;
    }
    return On(t.data);
  }
}
sp.create = (e) => new sp({
  typeName: Ft.ZodUndefined,
  ...Ke(e)
});
class ap extends ni {
  _parse(t) {
    if (this._getType(t) !== Xt.null) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.null,
        received: r.parsedType
      }), qe;
    }
    return On(t.data);
  }
}
ap.create = (e) => new ap({
  typeName: Ft.ZodNull,
  ...Ke(e)
});
class Xu extends ni {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return On(t.data);
  }
}
Xu.create = (e) => new Xu({
  typeName: Ft.ZodAny,
  ...Ke(e)
});
class Bl extends ni {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return On(t.data);
  }
}
Bl.create = (e) => new Bl({
  typeName: Ft.ZodUnknown,
  ...Ke(e)
});
class Lo extends ni {
  _parse(t) {
    const i = this._getOrReturnCtx(t);
    return Qt(i, {
      code: Rt.invalid_type,
      expected: Xt.never,
      received: i.parsedType
    }), qe;
  }
}
Lo.create = (e) => new Lo({
  typeName: Ft.ZodNever,
  ...Ke(e)
});
class ty extends ni {
  _parse(t) {
    if (this._getType(t) !== Xt.undefined) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.void,
        received: r.parsedType
      }), qe;
    }
    return On(t.data);
  }
}
ty.create = (e) => new ty({
  typeName: Ft.ZodVoid,
  ...Ke(e)
});
class qs extends ni {
  _parse(t) {
    const { ctx: i, status: r } = this._processInputParams(t), n = this._def;
    if (i.parsedType !== Xt.array)
      return Qt(i, {
        code: Rt.invalid_type,
        expected: Xt.array,
        received: i.parsedType
      }), qe;
    if (n.exactLength !== null) {
      const a = i.data.length > n.exactLength.value, o = i.data.length < n.exactLength.value;
      (a || o) && (Qt(i, {
        code: a ? Rt.too_big : Rt.too_small,
        minimum: o ? n.exactLength.value : void 0,
        maximum: a ? n.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: n.exactLength.message
      }), r.dirty());
    }
    if (n.minLength !== null && i.data.length < n.minLength.value && (Qt(i, {
      code: Rt.too_small,
      minimum: n.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.minLength.message
    }), r.dirty()), n.maxLength !== null && i.data.length > n.maxLength.value && (Qt(i, {
      code: Rt.too_big,
      maximum: n.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: n.maxLength.message
    }), r.dirty()), i.common.async)
      return Promise.all([...i.data].map((a, o) => n.type._parseAsync(new $a(i, a, i.path, o)))).then((a) => bn.mergeArray(r, a));
    const s = [...i.data].map((a, o) => n.type._parseSync(new $a(i, a, i.path, o)));
    return bn.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, i) {
    return new qs({
      ...this._def,
      minLength: { value: t, message: me.toString(i) }
    });
  }
  max(t, i) {
    return new qs({
      ...this._def,
      maxLength: { value: t, message: me.toString(i) }
    });
  }
  length(t, i) {
    return new qs({
      ...this._def,
      exactLength: { value: t, message: me.toString(i) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
qs.create = (e, t) => new qs({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Ft.ZodArray,
  ...Ke(t)
});
function tu(e) {
  if (e instanceof gr) {
    const t = {};
    for (const i in e.shape) {
      const r = e.shape[i];
      t[i] = wo.create(tu(r));
    }
    return new gr({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof qs ? new qs({
      ...e._def,
      type: tu(e.element)
    }) : e instanceof wo ? wo.create(tu(e.unwrap())) : e instanceof Gl ? Gl.create(tu(e.unwrap())) : e instanceof za ? za.create(e.items.map((t) => tu(t))) : e;
}
class gr extends ni {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), i = ki.objectKeys(t);
    return this._cached = { shape: t, keys: i };
  }
  _parse(t) {
    if (this._getType(t) !== Xt.object) {
      const l = this._getOrReturnCtx(t);
      return Qt(l, {
        code: Rt.invalid_type,
        expected: Xt.object,
        received: l.parsedType
      }), qe;
    }
    const { status: r, ctx: n } = this._processInputParams(t), { shape: s, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof Lo && this._def.unknownKeys === "strip"))
      for (const l in n.data)
        a.includes(l) || o.push(l);
    const c = [];
    for (const l of a) {
      const d = s[l], u = n.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: d._parse(new $a(n, u, n.path, l)),
        alwaysSet: l in n.data
      });
    }
    if (this._def.catchall instanceof Lo) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const d of o)
          c.push({
            key: { status: "valid", value: d },
            value: { status: "valid", value: n.data[d] }
          });
      else if (l === "strict")
        o.length > 0 && (Qt(n, {
          code: Rt.unrecognized_keys,
          keys: o
        }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const d of o) {
        const u = n.data[d];
        c.push({
          key: { status: "valid", value: d },
          value: l._parse(
            new $a(n, u, n.path, d)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: d in n.data
        });
      }
    }
    return n.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const d of c) {
        const u = await d.key;
        l.push({
          key: u,
          value: await d.value,
          alwaysSet: d.alwaysSet
        });
      }
      return l;
    }).then((l) => bn.mergeObjectSync(r, l)) : bn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return me.errToObj, new gr({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (i, r) => {
          var n, s, a, o;
          const c = (a = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, i, r).message) !== null && a !== void 0 ? a : r.defaultError;
          return i.code === "unrecognized_keys" ? {
            message: (o = me.errToObj(t).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new gr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new gr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new gr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new gr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Ft.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, i) {
    return this.augment({ [t]: i });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new gr({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const i = {};
    return ki.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (i[r] = this.shape[r]);
    }), new gr({
      ...this._def,
      shape: () => i
    });
  }
  omit(t) {
    const i = {};
    return ki.objectKeys(this.shape).forEach((r) => {
      t[r] || (i[r] = this.shape[r]);
    }), new gr({
      ...this._def,
      shape: () => i
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return tu(this);
  }
  partial(t) {
    const i = {};
    return ki.objectKeys(this.shape).forEach((r) => {
      const n = this.shape[r];
      t && !t[r] ? i[r] = n : i[r] = n.optional();
    }), new gr({
      ...this._def,
      shape: () => i
    });
  }
  required(t) {
    const i = {};
    return ki.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        i[r] = this.shape[r];
      else {
        let s = this.shape[r];
        for (; s instanceof wo; )
          s = s._def.innerType;
        i[r] = s;
      }
    }), new gr({
      ...this._def,
      shape: () => i
    });
  }
  keyof() {
    return NN(ki.objectKeys(this.shape));
  }
}
gr.create = (e, t) => new gr({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Lo.create(),
  typeName: Ft.ZodObject,
  ...Ke(t)
});
gr.strictCreate = (e, t) => new gr({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Lo.create(),
  typeName: Ft.ZodObject,
  ...Ke(t)
});
gr.lazycreate = (e, t) => new gr({
  shape: e,
  unknownKeys: "strip",
  catchall: Lo.create(),
  typeName: Ft.ZodObject,
  ...Ke(t)
});
class op extends ni {
  _parse(t) {
    const { ctx: i } = this._processInputParams(t), r = this._def.options;
    function n(s) {
      for (const o of s)
        if (o.result.status === "valid")
          return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return i.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new Ys(o.ctx.common.issues));
      return Qt(i, {
        code: Rt.invalid_union,
        unionErrors: a
      }), qe;
    }
    if (i.common.async)
      return Promise.all(r.map(async (s) => {
        const a = {
          ...i,
          common: {
            ...i.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await s._parseAsync({
            data: i.data,
            path: i.path,
            parent: a
          }),
          ctx: a
        };
      })).then(n);
    {
      let s;
      const a = [];
      for (const c of r) {
        const l = {
          ...i,
          common: {
            ...i.common,
            issues: []
          },
          parent: null
        }, d = c._parseSync({
          data: i.data,
          path: i.path,
          parent: l
        });
        if (d.status === "valid")
          return d;
        d.status === "dirty" && !s && (s = { result: d, ctx: l }), l.common.issues.length && a.push(l.common.issues);
      }
      if (s)
        return i.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((c) => new Ys(c));
      return Qt(i, {
        code: Rt.invalid_union,
        unionErrors: o
      }), qe;
    }
  }
  get options() {
    return this._def.options;
  }
}
op.create = (e, t) => new op({
  options: e,
  typeName: Ft.ZodUnion,
  ...Ke(t)
});
const Sg = (e) => e instanceof dp ? Sg(e.schema) : e instanceof ra ? Sg(e.innerType()) : e instanceof up ? [e.value] : e instanceof Pc ? e.options : e instanceof hp ? Object.keys(e.enum) : e instanceof fp ? Sg(e._def.innerType) : e instanceof sp ? [void 0] : e instanceof ap ? [null] : null;
class Gy extends ni {
  _parse(t) {
    const { ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Xt.object)
      return Qt(i, {
        code: Rt.invalid_type,
        expected: Xt.object,
        received: i.parsedType
      }), qe;
    const r = this.discriminator, n = i.data[r], s = this.optionsMap.get(n);
    return s ? i.common.async ? s._parseAsync({
      data: i.data,
      path: i.path,
      parent: i
    }) : s._parseSync({
      data: i.data,
      path: i.path,
      parent: i
    }) : (Qt(i, {
      code: Rt.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), qe);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, i, r) {
    const n = /* @__PURE__ */ new Map();
    for (const s of i) {
      const a = Sg(s.shape[t]);
      if (!a)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (n.has(o))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(o)}`);
        n.set(o, s);
      }
    }
    return new Gy({
      typeName: Ft.ZodDiscriminatedUnion,
      discriminator: t,
      options: i,
      optionsMap: n,
      ...Ke(r)
    });
  }
}
function Xb(e, t) {
  const i = vc(e), r = vc(t);
  if (e === t)
    return { valid: !0, data: e };
  if (i === Xt.object && r === Xt.object) {
    const n = ki.objectKeys(t), s = ki.objectKeys(e).filter((o) => n.indexOf(o) !== -1), a = { ...e, ...t };
    for (const o of s) {
      const c = Xb(e[o], t[o]);
      if (!c.valid)
        return { valid: !1 };
      a[o] = c.data;
    }
    return { valid: !0, data: a };
  } else if (i === Xt.array && r === Xt.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const n = [];
    for (let s = 0; s < e.length; s++) {
      const a = e[s], o = t[s], c = Xb(a, o);
      if (!c.valid)
        return { valid: !1 };
      n.push(c.data);
    }
    return { valid: !0, data: n };
  } else
    return i === Xt.date && r === Xt.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class cp extends ni {
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t), n = (s, a) => {
      if (qb(s) || qb(a))
        return qe;
      const o = Xb(s.value, a.value);
      return o.valid ? ((Zb(s) || Zb(a)) && i.dirty(), { status: i.value, value: o.data }) : (Qt(r, {
        code: Rt.invalid_intersection_types
      }), qe);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([s, a]) => n(s, a)) : n(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
cp.create = (e, t, i) => new cp({
  left: e,
  right: t,
  typeName: Ft.ZodIntersection,
  ...Ke(i)
});
class za extends ni {
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Xt.array)
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.array,
        received: r.parsedType
      }), qe;
    if (r.data.length < this._def.items.length)
      return Qt(r, {
        code: Rt.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), qe;
    !this._def.rest && r.data.length > this._def.items.length && (Qt(r, {
      code: Rt.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), i.dirty());
    const s = [...r.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new $a(r, a, r.path, o)) : null;
    }).filter((a) => !!a);
    return r.common.async ? Promise.all(s).then((a) => bn.mergeArray(i, a)) : bn.mergeArray(i, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new za({
      ...this._def,
      rest: t
    });
  }
}
za.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new za({
    items: e,
    typeName: Ft.ZodTuple,
    rest: null,
    ...Ke(t)
  });
};
class lp extends ni {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Xt.object)
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.object,
        received: r.parsedType
      }), qe;
    const n = [], s = this._def.keyType, a = this._def.valueType;
    for (const o in r.data)
      n.push({
        key: s._parse(new $a(r, o, r.path, o)),
        value: a._parse(new $a(r, r.data[o], r.path, o))
      });
    return r.common.async ? bn.mergeObjectAsync(i, n) : bn.mergeObjectSync(i, n);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, i, r) {
    return i instanceof ni ? new lp({
      keyType: t,
      valueType: i,
      typeName: Ft.ZodRecord,
      ...Ke(r)
    }) : new lp({
      keyType: Hs.create(),
      valueType: t,
      typeName: Ft.ZodRecord,
      ...Ke(i)
    });
  }
}
class ey extends ni {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Xt.map)
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.map,
        received: r.parsedType
      }), qe;
    const n = this._def.keyType, s = this._def.valueType, a = [...r.data.entries()].map(([o, c], l) => ({
      key: n._parse(new $a(r, o, r.path, [l, "key"])),
      value: s._parse(new $a(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const l = await c.key, d = await c.value;
          if (l.status === "aborted" || d.status === "aborted")
            return qe;
          (l.status === "dirty" || d.status === "dirty") && i.dirty(), o.set(l.value, d.value);
        }
        return { status: i.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const l = c.key, d = c.value;
        if (l.status === "aborted" || d.status === "aborted")
          return qe;
        (l.status === "dirty" || d.status === "dirty") && i.dirty(), o.set(l.value, d.value);
      }
      return { status: i.value, value: o };
    }
  }
}
ey.create = (e, t, i) => new ey({
  valueType: t,
  keyType: e,
  typeName: Ft.ZodMap,
  ...Ke(i)
});
class jl extends ni {
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Xt.set)
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.set,
        received: r.parsedType
      }), qe;
    const n = this._def;
    n.minSize !== null && r.data.size < n.minSize.value && (Qt(r, {
      code: Rt.too_small,
      minimum: n.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.minSize.message
    }), i.dirty()), n.maxSize !== null && r.data.size > n.maxSize.value && (Qt(r, {
      code: Rt.too_big,
      maximum: n.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: n.maxSize.message
    }), i.dirty());
    const s = this._def.valueType;
    function a(c) {
      const l = /* @__PURE__ */ new Set();
      for (const d of c) {
        if (d.status === "aborted")
          return qe;
        d.status === "dirty" && i.dirty(), l.add(d.value);
      }
      return { status: i.value, value: l };
    }
    const o = [...r.data.values()].map((c, l) => s._parse(new $a(r, c, r.path, l)));
    return r.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(t, i) {
    return new jl({
      ...this._def,
      minSize: { value: t, message: me.toString(i) }
    });
  }
  max(t, i) {
    return new jl({
      ...this._def,
      maxSize: { value: t, message: me.toString(i) }
    });
  }
  size(t, i) {
    return this.min(t, i).max(t, i);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
jl.create = (e, t) => new jl({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Ft.ZodSet,
  ...Ke(t)
});
class wu extends ni {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Xt.function)
      return Qt(i, {
        code: Rt.invalid_type,
        expected: Xt.function,
        received: i.parsedType
      }), qe;
    function r(o, c) {
      return K0({
        data: o,
        path: i.path,
        errorMaps: [
          i.common.contextualErrorMap,
          i.schemaErrorMap,
          X0(),
          ip
        ].filter((l) => !!l),
        issueData: {
          code: Rt.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function n(o, c) {
      return K0({
        data: o,
        path: i.path,
        errorMaps: [
          i.common.contextualErrorMap,
          i.schemaErrorMap,
          X0(),
          ip
        ].filter((l) => !!l),
        issueData: {
          code: Rt.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const s = { errorMap: i.common.contextualErrorMap }, a = i.data;
    if (this._def.returns instanceof Ku) {
      const o = this;
      return On(async function(...c) {
        const l = new Ys([]), d = await o._def.args.parseAsync(c, s).catch((p) => {
          throw l.addIssue(r(c, p)), l;
        }), u = await Reflect.apply(a, this, d);
        return await o._def.returns._def.type.parseAsync(u, s).catch((p) => {
          throw l.addIssue(n(u, p)), l;
        });
      });
    } else {
      const o = this;
      return On(function(...c) {
        const l = o._def.args.safeParse(c, s);
        if (!l.success)
          throw new Ys([r(c, l.error)]);
        const d = Reflect.apply(a, this, l.data), u = o._def.returns.safeParse(d, s);
        if (!u.success)
          throw new Ys([n(d, u.error)]);
        return u.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new wu({
      ...this._def,
      args: za.create(t).rest(Bl.create())
    });
  }
  returns(t) {
    return new wu({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, i, r) {
    return new wu({
      args: t || za.create([]).rest(Bl.create()),
      returns: i || Bl.create(),
      typeName: Ft.ZodFunction,
      ...Ke(r)
    });
  }
}
class dp extends ni {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: i } = this._processInputParams(t);
    return this._def.getter()._parse({ data: i.data, path: i.path, parent: i });
  }
}
dp.create = (e, t) => new dp({
  getter: e,
  typeName: Ft.ZodLazy,
  ...Ke(t)
});
class up extends ni {
  _parse(t) {
    if (t.data !== this._def.value) {
      const i = this._getOrReturnCtx(t);
      return Qt(i, {
        received: i.data,
        code: Rt.invalid_literal,
        expected: this._def.value
      }), qe;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
up.create = (e, t) => new up({
  value: e,
  typeName: Ft.ZodLiteral,
  ...Ke(t)
});
function NN(e, t) {
  return new Pc({
    values: e,
    typeName: Ft.ZodEnum,
    ...Ke(t)
  });
}
class Pc extends ni {
  _parse(t) {
    if (typeof t.data != "string") {
      const i = this._getOrReturnCtx(t), r = this._def.values;
      return Qt(i, {
        expected: ki.joinValues(r),
        received: i.parsedType,
        code: Rt.invalid_type
      }), qe;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const i = this._getOrReturnCtx(t), r = this._def.values;
      return Qt(i, {
        received: i.data,
        code: Rt.invalid_enum_value,
        options: r
      }), qe;
    }
    return On(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const i of this._def.values)
      t[i] = i;
    return t;
  }
  get Values() {
    const t = {};
    for (const i of this._def.values)
      t[i] = i;
    return t;
  }
  get Enum() {
    const t = {};
    for (const i of this._def.values)
      t[i] = i;
    return t;
  }
  extract(t) {
    return Pc.create(t);
  }
  exclude(t) {
    return Pc.create(this.options.filter((i) => !t.includes(i)));
  }
}
Pc.create = NN;
class hp extends ni {
  _parse(t) {
    const i = ki.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Xt.string && r.parsedType !== Xt.number) {
      const n = ki.objectValues(i);
      return Qt(r, {
        expected: ki.joinValues(n),
        received: r.parsedType,
        code: Rt.invalid_type
      }), qe;
    }
    if (i.indexOf(t.data) === -1) {
      const n = ki.objectValues(i);
      return Qt(r, {
        received: r.data,
        code: Rt.invalid_enum_value,
        options: n
      }), qe;
    }
    return On(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
hp.create = (e, t) => new hp({
  values: e,
  typeName: Ft.ZodNativeEnum,
  ...Ke(t)
});
class Ku extends ni {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: i } = this._processInputParams(t);
    if (i.parsedType !== Xt.promise && i.common.async === !1)
      return Qt(i, {
        code: Rt.invalid_type,
        expected: Xt.promise,
        received: i.parsedType
      }), qe;
    const r = i.parsedType === Xt.promise ? i.data : Promise.resolve(i.data);
    return On(r.then((n) => this._def.type.parseAsync(n, {
      path: i.path,
      errorMap: i.common.contextualErrorMap
    })));
  }
}
Ku.create = (e, t) => new Ku({
  type: e,
  typeName: Ft.ZodPromise,
  ...Ke(t)
});
class ra extends ni {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ft.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t), n = this._def.effect || null, s = {
      addIssue: (a) => {
        Qt(r, a), a.fatal ? i.abort() : i.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (s.addIssue = s.addIssue.bind(s), n.type === "preprocess") {
      const a = n.transform(r.data, s);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: a,
        path: r.path,
        parent: r
      });
    }
    if (n.type === "refinement") {
      const a = (o) => {
        const c = n.refinement(o, s);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return o.status === "aborted" ? qe : (o.status === "dirty" && i.dirty(), a(o.value), { status: i.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => o.status === "aborted" ? qe : (o.status === "dirty" && i.dirty(), a(o.value).then(() => ({ status: i.value, value: o.value }))));
    }
    if (n.type === "transform")
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!rp(a))
          return a;
        const o = n.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: i.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) => rp(a) ? Promise.resolve(n.transform(a.value, s)).then((o) => ({ status: i.value, value: o })) : a);
    ki.assertNever(n);
  }
}
ra.create = (e, t, i) => new ra({
  schema: e,
  typeName: Ft.ZodEffects,
  effect: t,
  ...Ke(i)
});
ra.createWithPreprocess = (e, t, i) => new ra({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Ft.ZodEffects,
  ...Ke(i)
});
class wo extends ni {
  _parse(t) {
    return this._getType(t) === Xt.undefined ? On(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
wo.create = (e, t) => new wo({
  innerType: e,
  typeName: Ft.ZodOptional,
  ...Ke(t)
});
class Gl extends ni {
  _parse(t) {
    return this._getType(t) === Xt.null ? On(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Gl.create = (e, t) => new Gl({
  innerType: e,
  typeName: Ft.ZodNullable,
  ...Ke(t)
});
class fp extends ni {
  _parse(t) {
    const { ctx: i } = this._processInputParams(t);
    let r = i.data;
    return i.parsedType === Xt.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: i.path,
      parent: i
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
fp.create = (e, t) => new fp({
  innerType: e,
  typeName: Ft.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Ke(t)
});
class iy extends ni {
  _parse(t) {
    const { ctx: i } = this._processInputParams(t), r = {
      ...i,
      common: {
        ...i.common,
        issues: []
      }
    }, n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return J0(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Ys(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue({
        get error() {
          return new Ys(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
iy.create = (e, t) => new iy({
  innerType: e,
  typeName: Ft.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Ke(t)
});
class ry extends ni {
  _parse(t) {
    if (this._getType(t) !== Xt.nan) {
      const r = this._getOrReturnCtx(t);
      return Qt(r, {
        code: Rt.invalid_type,
        expected: Xt.nan,
        received: r.parsedType
      }), qe;
    }
    return { status: "valid", value: t.data };
  }
}
ry.create = (e) => new ry({
  typeName: Ft.ZodNaN,
  ...Ke(e)
});
const fJ = Symbol("zod_brand");
class LN extends ni {
  _parse(t) {
    const { ctx: i } = this._processInputParams(t), r = i.data;
    return this._def.type._parse({
      data: r,
      path: i.path,
      parent: i
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Up extends ni {
  _parse(t) {
    const { status: i, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? qe : s.status === "dirty" ? (i.dirty(), DN(s.value)) : this._def.out._parseAsync({
          data: s.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const n = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return n.status === "aborted" ? qe : n.status === "dirty" ? (i.dirty(), {
        status: "dirty",
        value: n.value
      }) : this._def.out._parseSync({
        data: n.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, i) {
    return new Up({
      in: t,
      out: i,
      typeName: Ft.ZodPipeline
    });
  }
}
class ny extends ni {
  _parse(t) {
    const i = this._def.innerType._parse(t);
    return rp(i) && (i.value = Object.freeze(i.value)), i;
  }
}
ny.create = (e, t) => new ny({
  innerType: e,
  typeName: Ft.ZodReadonly,
  ...Ke(t)
});
const FN = (e, t = {}, i) => e ? Xu.create().superRefine((r, n) => {
  var s, a;
  if (!e(r)) {
    const o = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, c = (a = (s = o.fatal) !== null && s !== void 0 ? s : i) !== null && a !== void 0 ? a : !0, l = typeof o == "string" ? { message: o } : o;
    n.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : Xu.create(), pJ = {
  object: gr.lazycreate
};
var Ft;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Ft || (Ft = {}));
const mJ = (e, t = {
  message: `Input not instance of ${e.name}`
}) => FN((i) => i instanceof e, t), BN = Hs.create, RN = Rc.create, gJ = ry.create, yJ = Mc.create, MN = np.create, vJ = Vl.create, _J = Q0.create, bJ = sp.create, xJ = ap.create, wJ = Xu.create, SJ = Bl.create, IJ = Lo.create, AJ = ty.create, TJ = qs.create, EJ = gr.create, kJ = gr.strictCreate, CJ = op.create, OJ = Gy.create, DJ = cp.create, NJ = za.create, LJ = lp.create, FJ = ey.create, BJ = jl.create, RJ = wu.create, MJ = dp.create, PJ = up.create, $J = Pc.create, zJ = hp.create, UJ = Ku.create, M3 = ra.create, VJ = wo.create, jJ = Gl.create, GJ = ra.createWithPreprocess, HJ = Up.create, WJ = () => BN().optional(), YJ = () => RN().optional(), qJ = () => MN().optional(), ZJ = {
  string: (e) => Hs.create({ ...e, coerce: !0 }),
  number: (e) => Rc.create({ ...e, coerce: !0 }),
  boolean: (e) => np.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Mc.create({ ...e, coerce: !0 }),
  date: (e) => Vl.create({ ...e, coerce: !0 })
}, XJ = qe;
var Zt = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ip,
  setErrorMap: tJ,
  getErrorMap: X0,
  makeIssue: K0,
  EMPTY_PATH: eJ,
  addIssueToContext: Qt,
  ParseStatus: bn,
  INVALID: qe,
  DIRTY: DN,
  OK: On,
  isAborted: qb,
  isDirty: Zb,
  isValid: rp,
  isAsync: J0,
  get util() {
    return ki;
  },
  get objectUtil() {
    return Yb;
  },
  ZodParsedType: Xt,
  getParsedType: vc,
  ZodType: ni,
  ZodString: Hs,
  ZodNumber: Rc,
  ZodBigInt: Mc,
  ZodBoolean: np,
  ZodDate: Vl,
  ZodSymbol: Q0,
  ZodUndefined: sp,
  ZodNull: ap,
  ZodAny: Xu,
  ZodUnknown: Bl,
  ZodNever: Lo,
  ZodVoid: ty,
  ZodArray: qs,
  ZodObject: gr,
  ZodUnion: op,
  ZodDiscriminatedUnion: Gy,
  ZodIntersection: cp,
  ZodTuple: za,
  ZodRecord: lp,
  ZodMap: ey,
  ZodSet: jl,
  ZodFunction: wu,
  ZodLazy: dp,
  ZodLiteral: up,
  ZodEnum: Pc,
  ZodNativeEnum: hp,
  ZodPromise: Ku,
  ZodEffects: ra,
  ZodTransformer: ra,
  ZodOptional: wo,
  ZodNullable: Gl,
  ZodDefault: fp,
  ZodCatch: iy,
  ZodNaN: ry,
  BRAND: fJ,
  ZodBranded: LN,
  ZodPipeline: Up,
  ZodReadonly: ny,
  custom: FN,
  Schema: ni,
  ZodSchema: ni,
  late: pJ,
  get ZodFirstPartyTypeKind() {
    return Ft;
  },
  coerce: ZJ,
  any: wJ,
  array: TJ,
  bigint: yJ,
  boolean: MN,
  date: vJ,
  discriminatedUnion: OJ,
  effect: M3,
  enum: $J,
  function: RJ,
  instanceof: mJ,
  intersection: DJ,
  lazy: MJ,
  literal: PJ,
  map: FJ,
  nan: gJ,
  nativeEnum: zJ,
  never: IJ,
  null: xJ,
  nullable: jJ,
  number: RN,
  object: EJ,
  oboolean: qJ,
  onumber: YJ,
  optional: VJ,
  ostring: WJ,
  pipeline: HJ,
  preprocess: GJ,
  promise: UJ,
  record: LJ,
  set: BJ,
  strictObject: kJ,
  string: BN,
  symbol: _J,
  transformer: M3,
  tuple: NJ,
  undefined: bJ,
  union: CJ,
  unknown: SJ,
  void: AJ,
  NEVER: XJ,
  ZodIssueCode: Rt,
  quotelessJson: QK,
  ZodError: Ys
});
function PN(e, t, i, r) {
  r != null && r.errorMessages && i && (e.errorMessage = {
    ...e.errorMessage,
    [t]: i
  });
}
function Yi(e, t, i, r, n) {
  e[t] = i, PN(e, t, r, n);
}
const P3 = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  emailStrategy: "format:email"
}, KJ = (e) => typeof e == "string" ? {
  ...P3,
  name: e
} : {
  ...P3,
  ...e
};
function JJ() {
  return {};
}
function QJ(e, t) {
  var r, n;
  const i = {
    type: "array"
  };
  return ((n = (r = e.type) == null ? void 0 : r._def) == null ? void 0 : n.typeName) !== Ft.ZodAny && (i.items = Ni(e.type._def, {
    ...t,
    currentPath: [...t.currentPath, "items"]
  })), e.minLength && Yi(i, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Yi(i, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Yi(i, "minItems", e.exactLength.value, e.exactLength.message, t), Yi(i, "maxItems", e.exactLength.value, e.exactLength.message, t)), i;
}
function tQ(e, t) {
  const i = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks)
    return i;
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Yi(i, "minimum", r.value, r.message, t) : Yi(i, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (i.exclusiveMinimum = !0), Yi(i, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Yi(i, "maximum", r.value, r.message, t) : Yi(i, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (i.exclusiveMaximum = !0), Yi(i, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Yi(i, "multipleOf", r.value, r.message, t);
        break;
    }
  return i;
}
function eQ() {
  return {
    type: "boolean"
  };
}
function iQ(e, t) {
  return Ni(e.type._def, t);
}
const rQ = (e, t) => Ni(e.innerType._def, t);
function nQ(e, t) {
  return t.dateStrategy == "integer" ? sQ(e, t) : {
    type: "string",
    format: "date-time"
  };
}
const sQ = (e, t) => {
  const i = {
    type: "integer",
    format: "unix-time"
  };
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" && Yi(
          i,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
      case "max":
        t.target === "jsonSchema7" && Yi(
          i,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
    }
  return i;
};
function aQ(e, t) {
  return {
    ...Ni(e.innerType._def, t),
    default: e.defaultValue()
  };
}
function oQ(e, t) {
  return t.effectStrategy === "input" ? Ni(e.schema._def, t) : {};
}
function cQ(e) {
  return {
    type: "string",
    enum: e.values
  };
}
const lQ = (e) => "type" in e && e.type === "string" ? !1 : "allOf" in e;
function dQ(e, t) {
  const i = [
    Ni(e.left._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "0"]
    }),
    Ni(e.right._def, {
      ...t,
      currentPath: [...t.currentPath, "allOf", "1"]
    })
  ].filter((s) => !!s);
  let r = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const n = [];
  return i.forEach((s) => {
    if (lQ(s))
      n.push(...s.allOf), s.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let a = s;
      if ("additionalProperties" in s && s.additionalProperties === !1) {
        const { additionalProperties: o, ...c } = s;
        a = c;
      } else
        r = void 0;
      n.push(a);
    }
  }), n.length ? {
    allOf: n,
    ...r
  } : void 0;
}
function uQ(e, t) {
  const i = typeof e.value;
  return i !== "bigint" && i !== "number" && i !== "boolean" && i !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: i === "bigint" ? "integer" : i,
    enum: [e.value]
  } : {
    type: i === "bigint" ? "integer" : i,
    const: e.value
  };
}
const Xh = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function $N(e, t) {
  const i = {
    type: "string"
  };
  function r(n) {
    return t.patternStrategy === "escape" ? hQ(n) : n;
  }
  if (e.checks)
    for (const n of e.checks)
      switch (n.kind) {
        case "min":
          Yi(i, "minLength", typeof i.minLength == "number" ? Math.max(i.minLength, n.value) : n.value, n.message, t);
          break;
        case "max":
          Yi(i, "maxLength", typeof i.maxLength == "number" ? Math.min(i.maxLength, n.value) : n.value, n.message, t);
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              pl(i, "email", n.message, t);
              break;
            case "format:idn-email":
              pl(i, "idn-email", n.message, t);
              break;
            case "pattern:zod":
              eo(i, Xh.email, n.message, t);
              break;
          }
          break;
        case "url":
          pl(i, "uri", n.message, t);
          break;
        case "uuid":
          pl(i, "uuid", n.message, t);
          break;
        case "regex":
          eo(i, n.regex.source, n.message, t);
          break;
        case "cuid":
          eo(i, Xh.cuid, n.message, t);
          break;
        case "cuid2":
          eo(i, Xh.cuid2, n.message, t);
          break;
        case "startsWith":
          eo(i, "^" + r(n.value), n.message, t);
          break;
        case "endsWith":
          eo(i, r(n.value) + "$", n.message, t);
          break;
        case "datetime":
          pl(i, "date-time", n.message, t);
          break;
        case "length":
          Yi(i, "minLength", typeof i.minLength == "number" ? Math.max(i.minLength, n.value) : n.value, n.message, t), Yi(i, "maxLength", typeof i.maxLength == "number" ? Math.min(i.maxLength, n.value) : n.value, n.message, t);
          break;
        case "includes": {
          eo(i, r(n.value), n.message, t);
          break;
        }
        case "ip": {
          n.version !== "v6" && pl(i, "ipv4", n.message, t), n.version !== "v4" && pl(i, "ipv6", n.message, t);
          break;
        }
        case "emoji":
          eo(i, Xh.emoji, n.message, t);
          break;
        case "ulid": {
          eo(i, Xh.ulid, n.message, t);
          break;
        }
      }
  return i;
}
const hQ = (e) => Array.from(e).map((t) => /[a-zA-Z0-9]/.test(t) ? t : `\\${t}`).join(""), pl = (e, t, i, r) => {
  var n;
  e.format || (n = e.anyOf) != null && n.some((s) => s.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push({
    format: e.format,
    ...e.errorMessage && r.errorMessages && {
      errorMessage: { format: e.errorMessage.format }
    }
  }), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push({
    format: t,
    ...i && r.errorMessages && { errorMessage: { format: i } }
  })) : Yi(e, "format", t, i, r);
}, eo = (e, t, i, r) => {
  var n;
  e.pattern || (n = e.allOf) != null && n.some((s) => s.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push({
    pattern: e.pattern,
    ...e.errorMessage && r.errorMessages && {
      errorMessage: { pattern: e.errorMessage.pattern }
    }
  }), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push({
    pattern: t,
    ...i && r.errorMessages && { errorMessage: { pattern: i } }
  })) : Yi(e, "pattern", t, i, r);
};
function zN(e, t) {
  var r, n, s, a;
  if (t.target === "openApi3" && ((r = e.keyType) == null ? void 0 : r._def.typeName) === Ft.ZodEnum)
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce((o, c) => ({
        ...o,
        [c]: Ni(e.valueType._def, {
          ...t,
          currentPath: [...t.currentPath, "properties", c]
        }) ?? {}
      }), {}),
      additionalProperties: !1
    };
  const i = {
    type: "object",
    additionalProperties: Ni(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? {}
  };
  if (t.target === "openApi3")
    return i;
  if (((n = e.keyType) == null ? void 0 : n._def.typeName) === Ft.ZodString && ((s = e.keyType._def.checks) != null && s.length)) {
    const o = Object.entries($N(e.keyType._def, t)).reduce((c, [l, d]) => l === "type" ? c : { ...c, [l]: d }, {});
    return {
      ...i,
      propertyNames: o
    };
  } else if (((a = e.keyType) == null ? void 0 : a._def.typeName) === Ft.ZodEnum)
    return {
      ...i,
      propertyNames: {
        enum: e.keyType._def.values
      }
    };
  return i;
}
function fQ(e, t) {
  if (t.mapStrategy === "record")
    return zN(e, t);
  const i = Ni(e.keyType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "0"]
  }) || {}, r = Ni(e.valueType._def, {
    ...t,
    currentPath: [...t.currentPath, "items", "items", "1"]
  }) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [i, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
function pQ(e) {
  const t = e.values, r = Object.keys(e.values).filter((s) => typeof t[t[s]] != "number").map((s) => t[s]), n = Array.from(new Set(r.map((s) => typeof s)));
  return {
    type: n.length === 1 ? n[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r
  };
}
function mQ() {
  return {
    not: {}
  };
}
function gQ(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
const sy = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function yQ(e, t) {
  if (t.target === "openApi3")
    return $3(e, t);
  const i = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (i.every((r) => r._def.typeName in sy && (!r._def.checks || !r._def.checks.length))) {
    const r = i.reduce((n, s) => {
      const a = sy[s._def.typeName];
      return a && !n.includes(a) ? [...n, a] : n;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (i.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = i.reduce((n, s) => {
      const a = typeof s._def.value;
      switch (a) {
        case "string":
        case "number":
        case "boolean":
          return [...n, a];
        case "bigint":
          return [...n, "integer"];
        case "object":
          if (s._def.value === null)
            return [...n, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return n;
      }
    }, []);
    if (r.length === i.length) {
      const n = r.filter((s, a, o) => o.indexOf(s) === a);
      return {
        type: n.length > 1 ? n : n[0],
        enum: i.reduce((s, a) => s.includes(a._def.value) ? s : [...s, a._def.value], [])
      };
    }
  } else if (i.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: i.reduce((r, n) => [
        ...r,
        ...n._def.values.filter((s) => !r.includes(s))
      ], [])
    };
  return $3(e, t);
}
const $3 = (e, t) => {
  const i = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map((r, n) => Ni(r._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", `${n}`]
  })).filter((r) => !!r && (!t.strictUnions || typeof r == "object" && Object.keys(r).length > 0));
  return i.length ? { anyOf: i } : void 0;
};
function vQ(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: sy[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [
        sy[e.innerType._def.typeName],
        "null"
      ]
    };
  if (t.target === "openApi3") {
    const r = Ni(e.innerType._def, {
      ...t,
      currentPath: [...t.currentPath]
    });
    return r && "$ref" in r ? { allOf: [r], nullable: !0 } : r && { ...r, nullable: !0 };
  }
  const i = Ni(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "0"]
  });
  return i && { anyOf: [i, { type: "null" }] };
}
function _Q(e, t) {
  const i = {
    type: "number"
  };
  if (!e.checks)
    return i;
  for (const r of e.checks)
    switch (r.kind) {
      case "int":
        i.type = "integer", PN(i, "type", r.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Yi(i, "minimum", r.value, r.message, t) : Yi(i, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (i.exclusiveMinimum = !0), Yi(i, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Yi(i, "maximum", r.value, r.message, t) : Yi(i, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (i.exclusiveMaximum = !0), Yi(i, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Yi(i, "multipleOf", r.value, r.message, t);
        break;
    }
  return i;
}
function bQ(e, t) {
  const i = {
    type: "object",
    ...Object.entries(e.shape()).reduce((r, [n, s]) => {
      if (s === void 0 || s._def === void 0)
        return r;
      const a = Ni(s._def, {
        ...t,
        currentPath: [...t.currentPath, "properties", n],
        propertyPath: [...t.currentPath, "properties", n]
      });
      return a === void 0 ? r : {
        properties: { ...r.properties, [n]: a },
        required: s.isOptional() ? r.required : [...r.required, n]
      };
    }, { properties: {}, required: [] }),
    additionalProperties: e.catchall._def.typeName === "ZodNever" ? e.unknownKeys === "passthrough" : Ni(e.catchall._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalProperties"]
    }) ?? !0
  };
  return i.required.length || delete i.required, i;
}
const xQ = (e, t) => {
  var r;
  if (t.currentPath.toString() === ((r = t.propertyPath) == null ? void 0 : r.toString()))
    return Ni(e.innerType._def, t);
  const i = Ni(e.innerType._def, {
    ...t,
    currentPath: [...t.currentPath, "anyOf", "1"]
  });
  return i ? {
    anyOf: [
      {
        not: {}
      },
      i
    ]
  } : {};
}, wQ = (e, t) => {
  if (t.pipeStrategy === "input")
    return Ni(e.in._def, t);
  if (t.pipeStrategy === "output")
    return Ni(e.out._def, t);
  const i = Ni(e.in._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", "0"]
  }), r = Ni(e.out._def, {
    ...t,
    currentPath: [...t.currentPath, "allOf", i ? "1" : "0"]
  });
  return {
    allOf: [i, r].filter((n) => n !== void 0)
  };
};
function SQ(e, t) {
  return Ni(e.type._def, t);
}
function IQ(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: Ni(e.valueType._def, {
      ...t,
      currentPath: [...t.currentPath, "items"]
    })
  };
  return e.minSize && Yi(r, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Yi(r, "maxItems", e.maxSize.value, e.maxSize.message, t), r;
}
function AQ(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map((i, r) => Ni(i._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${r}`]
    })).reduce((i, r) => r === void 0 ? i : [...i, r], []),
    additionalItems: Ni(e.rest._def, {
      ...t,
      currentPath: [...t.currentPath, "additionalItems"]
    })
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map((i, r) => Ni(i._def, {
      ...t,
      currentPath: [...t.currentPath, "items", `${r}`]
    })).reduce((i, r) => r === void 0 ? i : [...i, r], [])
  };
}
function TQ() {
  return {
    not: {}
  };
}
function EQ() {
  return {};
}
const kQ = (e, t) => Ni(e.innerType._def, t);
function Ni(e, t, i = !1) {
  const r = t.seen.get(e);
  if (r && !i) {
    const a = CQ(r, t);
    if (a !== void 0)
      return a;
  }
  const n = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, n);
  const s = DQ(e, e.typeName, t);
  return s && NQ(e, t, s), n.jsonSchema = s, s;
}
const CQ = (e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: OQ(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((i, r) => t.currentPath[r] === i) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), {}) : t.$refStrategy === "seen" ? {} : void 0;
  }
}, OQ = (e, t) => {
  let i = 0;
  for (; i < e.length && i < t.length && e[i] === t[i]; i++)
    ;
  return [(e.length - i).toString(), ...t.slice(i)].join("/");
}, DQ = (e, t, i) => {
  switch (t) {
    case Ft.ZodString:
      return $N(e, i);
    case Ft.ZodNumber:
      return _Q(e, i);
    case Ft.ZodObject:
      return bQ(e, i);
    case Ft.ZodBigInt:
      return tQ(e, i);
    case Ft.ZodBoolean:
      return eQ();
    case Ft.ZodDate:
      return nQ(e, i);
    case Ft.ZodUndefined:
      return TQ();
    case Ft.ZodNull:
      return gQ(i);
    case Ft.ZodArray:
      return QJ(e, i);
    case Ft.ZodUnion:
    case Ft.ZodDiscriminatedUnion:
      return yQ(e, i);
    case Ft.ZodIntersection:
      return dQ(e, i);
    case Ft.ZodTuple:
      return AQ(e, i);
    case Ft.ZodRecord:
      return zN(e, i);
    case Ft.ZodLiteral:
      return uQ(e, i);
    case Ft.ZodEnum:
      return cQ(e);
    case Ft.ZodNativeEnum:
      return pQ(e);
    case Ft.ZodNullable:
      return vQ(e, i);
    case Ft.ZodOptional:
      return xQ(e, i);
    case Ft.ZodMap:
      return fQ(e, i);
    case Ft.ZodSet:
      return IQ(e, i);
    case Ft.ZodLazy:
      return Ni(e.getter()._def, i);
    case Ft.ZodPromise:
      return SQ(e, i);
    case Ft.ZodNaN:
    case Ft.ZodNever:
      return mQ();
    case Ft.ZodEffects:
      return oQ(e, i);
    case Ft.ZodAny:
      return JJ();
    case Ft.ZodUnknown:
      return EQ();
    case Ft.ZodDefault:
      return aQ(e, i);
    case Ft.ZodBranded:
      return iQ(e, i);
    case Ft.ZodReadonly:
      return kQ(e, i);
    case Ft.ZodCatch:
      return rQ(e, i);
    case Ft.ZodPipeline:
      return wQ(e, i);
    case Ft.ZodFunction:
    case Ft.ZodVoid:
    case Ft.ZodSymbol:
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, NQ = (e, t, i) => (e.description && (i.description = e.description, t.markdownDescription && (i.markdownDescription = e.description)), i), LQ = (e) => {
  const t = KJ(e), i = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return {
    ...t,
    currentPath: i,
    propertyPath: void 0,
    seen: new Map(Object.entries(t.definitions).map(([r, n]) => [
      n._def,
      {
        def: n._def,
        path: [...t.basePath, t.definitionPath, r],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
}, FQ = (e, t) => {
  const i = LQ(t), r = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce((o, [c, l]) => ({
    ...o,
    [c]: Ni(l._def, {
      ...i,
      currentPath: [...i.basePath, i.definitionPath, c]
    }, !0) ?? {}
  }), {}) : void 0, n = typeof t == "string" ? t : t == null ? void 0 : t.name, s = Ni(e._def, n === void 0 ? i : {
    ...i,
    currentPath: [...i.basePath, i.definitionPath, n]
  }, !1) ?? {}, a = n === void 0 ? r ? {
    ...s,
    [i.definitionPath]: r
  } : s : {
    $ref: [
      ...i.$refStrategy === "relative" ? [] : i.basePath,
      i.definitionPath,
      n
    ].join("/"),
    [i.definitionPath]: {
      ...r,
      [n]: s
    }
  };
  return i.target === "jsonSchema7" ? a.$schema = "http://json-schema.org/draft-07/schema#" : i.target === "jsonSchema2019-09" && (a.$schema = "https://json-schema.org/draft/2019-09/schema#"), a;
}, BQ = (e, t) => Object.keys(e).reduce((r, n) => (r[t(n, e[n])] = e[n], r), {}), RQ = (e) => {
  if (!e || e.length === 0)
    return "";
  const t = e.toLowerCase();
  return t.substring(0, 1).toUpperCase() + t.substring(1, t.length);
}, MQ = (e) => {
  var i;
  const t = ((i = e == null ? void 0 : e.replace(/([A-Z])+/g, RQ)) == null ? void 0 : i.split(/(?=[A-Z])|[\.\-\s_]/).map((r) => r.toLowerCase())) ?? [];
  return t.length === 0 ? "" : t.length === 1 ? t[0] : t.reduce((r, n) => `${r}${n.charAt(0).toUpperCase()}${n.slice(1)}`);
}, Kb = Zt.object({
  // From Cosmograph
  disable_simulation: Zt.union([Zt.boolean(), Zt.literal(null)]).default(null),
  show_dynamic_labels: Zt.boolean().default(!0),
  show_top_labels: Zt.boolean().default(!1),
  show_top_labels_limit: Zt.number().default(100),
  show_top_labels_value_key: Zt.string().optional(),
  show_hovered_node_label: Zt.boolean().default(!1),
  node_label_accessor: Zt.string().optional(),
  node_label_class_name: Zt.string().optional(),
  node_label_color: Zt.string().optional(),
  hovered_node_label_class_name: Zt.string().optional(),
  hovered_node_label_color: Zt.string().optional(),
  simulation_decay: Zt.number().default(1e3),
  simulation_gravity: Zt.number().default(0),
  simulation_center: Zt.number().default(0),
  simulation_repulsion: Zt.number().default(0.1),
  simulation_repulsion_theta: Zt.number().default(1.7),
  simulation_repulsion_quadtree_levels: Zt.number().default(12),
  simulation_link_spring: Zt.number().default(1),
  simulation_link_distance: Zt.number().default(2),
  simulation_link_dist_random_variation_range: Zt.tuple([Zt.number(), Zt.number()]).default([1, 1.2]),
  simulation_repulsion_from_mouse: Zt.number().default(2),
  simulation_friction: Zt.number().default(0.85),
  // From Cosmos
  background_color: Zt.string().default("#222222"),
  space_size: Zt.number().default(4096),
  // TODO: How to set the color for each node separately?
  node_color: Zt.string().default("#b3b3b3"),
  node_greyout_opacity: Zt.number().default(0.1),
  // TODO: How to set the size for each node separately?
  node_size: Zt.number().default(4),
  node_size_scale: Zt.number().default(1),
  render_highlighted_node_ring: Zt.boolean().default(!0),
  render_hovered_node_ring: Zt.boolean().default(!0),
  hovered_node_ring_color: Zt.string().default("white"),
  focused_node_ring_color: Zt.string().default("white"),
  render_links: Zt.boolean().default(!0),
  // TODO: How to set the color for each link separately?
  link_color: Zt.string().default("#666666"),
  link_greyout_opacity: Zt.number().default(0.1),
  // TODO: How to set the width for each link separately?
  link_width: Zt.number().default(1),
  link_width_scale: Zt.number().default(1),
  curved_links: Zt.boolean().default(!1),
  curved_link_segments: Zt.number().default(19),
  curved_link_weight: Zt.number().default(0.8),
  curved_link_control_point_distance: Zt.number().default(0.5),
  // TODO: How to set the arrow for each link separately?
  link_arrows: Zt.boolean().default(!0),
  link_arrows_size_scale: Zt.number().default(1),
  link_visibility_distance_range: Zt.tuple([Zt.number(), Zt.number()]).default([50, 150]),
  link_visibility_min_transparency: Zt.number().default(0.25),
  use_quadtree: Zt.boolean().default(!1),
  pixel_ratio: Zt.number().default(2),
  scale_nodes_on_zoom: Zt.boolean().default(!0),
  initial_zoom_level: Zt.number().default(1),
  disable_zoom: Zt.boolean().default(!1),
  fit_view_on_init: Zt.boolean().default(!0),
  fit_view_delay: Zt.number().default(250),
  fit_view_by_nodes_in_rect: Zt.tuple([Zt.tuple([Zt.number(), Zt.number()]), Zt.tuple([Zt.number(), Zt.number()])]).optional(),
  random_seed: Zt.union([Zt.number(), Zt.string()]).optional(),
  node_sampling_distance: Zt.number().default(150)
}).transform((e) => BQ(e, MQ));
function met() {
  return FQ(Kb, "configSchema");
}
function get({ model: e, el: t }) {
  const i = document.createElement("div");
  i.style.width = "100%", i.style.height = "400px", i.style.color = "white";
  const r = document.createElement("div");
  i.appendChild(r);
  const n = Kb.safeParse(e.get("config")), s = n.success ? n.data : Kb.parse({});
  n.success || (e.set("error_message", n.error.toString()), e.save_changes());
  const a = {
    ...s,
    nodeLabelAccessor: s.nodeLabelAccessor ? (l) => l[s.nodeLabelAccessor] : void 0
    // onClick: (clickedNode) => {
    // // Demonstration how to set a value from JS to Python (1)
    // model.set('clicked_node_id', `${clickedNode?.id ?? ''}`)
    // model.save_changes()
    // // Demonstration how to send a message to a Python side (2)
    // const adjacentNodes = clickedNode ? cosmograph.getAdjacentNodes(clickedNode.id) : []
    // model.send({ msg_type: 'adjacent_node_ids', adjacentNodeIds: adjacentNodes?.map(d => d.id) ?? [] })
    // }
  }, o = new GU(r, a);
  function c() {
    var p, m;
    const l = B3((p = e.get("_links_arrow_table_buffer")) == null ? void 0 : p.buffer), d = B3((m = e.get("_nodes_arrow_table_buffer")) == null ? void 0 : m.buffer), u = l ?? [], h = ((d == null ? void 0 : d.length) === 0 && (u == null ? void 0 : u.length) > 0 ? JK(u) : d) ?? [];
    o.setData(h, u);
  }
  c(), e.on("change:_links_arrow_table_buffer", () => {
    c();
  }), e.on("change:_nodes_arrow_table_buffer", () => {
    c();
  }), t.appendChild(i);
}
var PQ = function() {
  throw new Error(
    "ws does not work in the browser. Browser clients must use the native WebSocket object"
  );
};
const $Q = /* @__PURE__ */ o1(PQ), zQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $Q
}, Symbol.toStringTag, { value: "Module" }));
export {
  met as getConfigSchema,
  get as render
};
